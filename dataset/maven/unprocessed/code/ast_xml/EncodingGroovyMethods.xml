<Class>
    <Id>671</Id>
    <Package>org.codehaus.groovy.runtime</Package>
    <ClassName>EncodingGroovyMethods</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EncodingGroovyMethods  /** 
 * This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>T_TABLE</FieldName>
            <FieldType>char[]</FieldType>
        </Field>
        <Field>
            <FieldName>CHUNK_SEPARATOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>encodeBase64</MethodName>
            <MethodComment>/** 
 * Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see &lt;code&gt;RFC 4648&lt;/code&gt;.
 * @param data Byte array to be encoded
 * @param chunked whether or not the Base64 encoded data should be MIME chunked
 * @return object which will write the Base64 encoding of the byte array
 * @since 1.5.1
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>Byte[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>chunked</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encodeBase64</MethodName>
            <MethodComment>/** 
 * Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see &lt;code&gt;RFC 4648&lt;/code&gt;.
 * @param data Byte array to be encoded
 * @return object which will write the Base64 encoding of the byte array
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>Byte[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encodeBase64</MethodName>
            <MethodComment>/** 
 * Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see &lt;code&gt;RFC 4648&lt;/code&gt;.
 * @param data byte array to be encoded
 * @param chunked whether or not the Base64 encoded data should be MIME chunked
 * @return object which will write the Base64 encoding of the byte array
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>byte[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>chunked</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <FieldType>Writer</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [charCount=0]</InnerVar>
                <InnerVar>int [dLimit=(data.length / 3) * 3]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringWriter [buffer=new StringWriter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encodeBase64</MethodName>
            <MethodComment>/** 
 * Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see &lt;code&gt;RFC 4648&lt;/code&gt;.
 * @param data byte array to be encoded
 * @return object which will write the Base64 encoding of the byte array
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>byte[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decodeBase64</MethodName>
            <MethodComment>/** 
 * Decode the String from Base64 into a byte array.
 * @param value the string to be decoded
 * @return the decoded bytes as an array
 * @since 1.0
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteShift=4]</InnerVar>
                <InnerVar>int [tmp=0]</InnerVar>
                <InnerVar>boolean [done=false]</InnerVar>
                <InnerVar>StringBuilder [buffer=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encodeHex</MethodName>
            <MethodComment>/** 
 * Produces a Writable that writes the hex encoding of the Byte[]. Calling toString() on this Writable returns the hex encoding as a String. The hex encoding includes two characters for each byte and all letters are lower case.
 * @param data byte array to be encoded
 * @return object which will write the hex encoding of the byte array
 * @see Integer#toHexString(int)
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>Byte[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encodeHex</MethodName>
            <MethodComment>/** 
 * Produces a Writable that writes the hex encoding of the byte[]. Calling toString() on this Writable returns the hex encoding as a String. The hex encoding includes two characters for each byte and all letters are lower case.
 * @param data byte array to be encoded
 * @return object which will write the hex encoding of the byte array
 * @see Integer#toHexString(int)
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <FieldType>byte[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <FieldType>Writer</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringWriter [buffer=new StringWriter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decodeHex</MethodName>
            <MethodComment>/** 
 * Decodes a hex string to a byte array. The hex string can contain either upper case or lower case letters.
 * @param value string to be decoded
 * @return decoded byte array
 * @throws NumberFormatException If the string contains an odd number of charactersor if the characters are not valid hexadecimal values.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [bytes=new byte[value.length() / 2]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>