<Class>
    <Id>137</Id>
    <Package>groovy.lang</Package>
    <ClassName>Closure</ClassName>
    <SuperClass>GroovyObjectSupport</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Cloneable</SuperInterface>
        <SuperInterface>Runnable</SuperInterface>
        <SuperInterface>GroovyCallable</SuperInterface>
        <SuperInterface>V</SuperInterface>
        <SuperInterface>Serializable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Closure  /** 
 * Represents any closure object in Groovy. &lt;p&gt; Groovy allows instances of Closures to be called in a short form. For example: &lt;pre&gt; def a = 1 def c = { a } assert c() == 1 &lt;/pre&gt; To be able to use a Closure in this way with your own subclass, you need to provide a doCall method with any signature you want to. This ensures that {@link #getMaximumNumberOfParameters()} and{@link #getParameterTypes()} will work too without anyadditional code. If no doCall method is provided a closure must be used in its long form like &lt;pre&gt; def a = 1 def c = {a} assert c.call() == 1 &lt;/pre&gt;
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author &lt;a href="mailto:tug@wilson.co.uk"&gt;John Wilson&lt;/a&gt;
 * @author &lt;a href="mailto:blackdrag@gmx.org"&gt;Jochen Theodorou&lt;/a&gt;
 * @author Graeme Rocher
 * @author Paul King
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>OWNER_FIRST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DELEGATE_FIRST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>OWNER_ONLY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DELEGATE_ONLY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TO_SELF</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DONE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SKIP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_OBJECT_ARRAY</FieldName>
            <FieldType>Object[]</FieldType>
        </Field>
        <Field>
            <FieldName>IDENTITY</FieldName>
            <FieldType>Closure</FieldType>
        </Field>
        <Field>
            <FieldName>delegate</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>owner</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>thisObject</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>resolveStrategy</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>directive</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>parameterTypes</FieldName>
            <FieldType>Class[]</FieldType>
        </Field>
        <Field>
            <FieldName>maximumNumberOfParameters</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>bcw</FieldName>
            <FieldType>BooleanClosureWrapper</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>doCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Closure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisObject</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CachedClosureClass [cachedClass=(CachedClosureClass)ReflectionCache.getCachedClass(getClass())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Closure</MethodName>
            <MethodComment>/** 
 * Constructor used when the "this" object for the Closure is null. This is rarely the case in normal Groovy usage.
 * @param owner the Closure owner
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResolveStrategy</MethodName>
            <MethodComment>/** 
 * Sets the strategy which the closure uses to resolve property references and methods. The default is Closure.OWNER_FIRST
 * @param resolveStrategy The resolve strategy to set
 * @see groovy.lang.Closure#DELEGATE_FIRST
 * @see groovy.lang.Closure#DELEGATE_ONLY
 * @see groovy.lang.Closure#OWNER_FIRST
 * @see groovy.lang.Closure#OWNER_ONLY
 * @see groovy.lang.Closure#TO_SELF
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolveStrategy</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResolveStrategy</MethodName>
            <MethodComment>/** 
 * Gets the strategy which the closure users to resolve methods and properties
 * @return The resolve strategy
 * @see groovy.lang.Closure#DELEGATE_FIRST
 * @see groovy.lang.Closure#DELEGATE_ONLY
 * @see groovy.lang.Closure#OWNER_FIRST
 * @see groovy.lang.Closure#OWNER_ONLY
 * @see groovy.lang.Closure#TO_SELF
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getThisObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyDelegateFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyOwnerFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyTryThese</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>firstTry</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>secondTry</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPropertyDelegateFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPropertyOwnerFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setPropertyTryThese;[property, newValue, this.owner, this.delegate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPropertyTryThese</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>firstTry</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>secondTry</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCase</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>candidate</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Invokes the closure without any parameters, returning any value if applicable.
 * @return the value if applicable or null if there is no return statement in the closure
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object[] [NOARGS=EMPTY_OBJECT_ARRAY]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Invokes the closure, returning any value if applicable.
 * @param arguments could be a single value or a List of values
 * @return the value if applicable or null if there is no return statement in the closure
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwRuntimeException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>throwable</ParamName>
                    <FieldType>Throwable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwner</MethodName>
            <MethodComment>/** 
 * @return the owner Object to which method calls will go which istypically the outer class when the closure is constructed
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDelegate</MethodName>
            <MethodComment>/** 
 * @return the delegate Object to which method calls will go which istypically the outer class when the closure is constructed
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDelegate</MethodName>
            <MethodComment>/** 
 * Allows the delegate to be changed such as when performing markup building
 * @param delegate the new delegate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>delegate</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypes</MethodName>
            <MethodComment>/** 
 * @return the parameter types of the longest doCall methodof this closure
 */
</MethodComment>
            <ReturnType>Class[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumNumberOfParameters</MethodName>
            <MethodComment>/** 
 * @return the maximum number of parameters a doCall methodof this closure can take
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asWritable</MethodName>
            <MethodComment>/** 
 * @return a version of this closure which implements Writable.  Note thatthe returned Writable also overrides  {@link #toString()} in orderto allow rendering the result directly to a String.
 */
</MethodComment>
            <ReturnType>Closure</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;call;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>curry</MethodName>
            <MethodComment>/** 
 * Support for Closure currying. &lt;p&gt; Typical usage: &lt;pre class="groovyTestCase"&gt; def multiply = { a, b -&gt; a * b } def doubler = multiply.curry(2) assert doubler(4) == 8 &lt;/pre&gt; Note: special treatment is given to Closure vararg-style capability. If you curry a vararg parameter, you don't consume the entire vararg array but instead the first parameter of the vararg array as the following example shows: &lt;pre class="groovyTestCase"&gt; def a = { one, two, Object[] others -&gt; one + two + others.sum() } assert a.parameterTypes.name == ['java.lang.Object', 'java.lang.Object', '[Ljava.lang.Object;'] assert a(1,2,3,4) == 10 def b = a.curry(1) assert b.parameterTypes.name == ['java.lang.Object', '[Ljava.lang.Object;'] assert b(2,3,4) == 10 def c = b.curry(2) assert c.parameterTypes.name == ['[Ljava.lang.Object;'] assert c(3,4) == 10 def d = c.curry(3) assert d.parameterTypes.name == ['[Ljava.lang.Object;'] assert d(4) == 10 def e = d.curry(4) assert e.parameterTypes.name == ['[Ljava.lang.Object;'] assert e() == 10 assert e(5) == 15 &lt;/pre&gt;
 * @param arguments the arguments to bind
 * @return the new closure with its arguments bound
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>curry</MethodName>
            <MethodComment>/** 
 * Support for Closure currying.
 * @param argument the argument to bind
 * @return the new closure with the argument bound
 * @see #curry(Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>argument</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rcurry</MethodName>
            <MethodComment>/** 
 * Support for Closure "right" currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage: &lt;pre&gt; def divide = { a, b -&gt; a / b } def halver = divide.rcurry(2) assert halver(8) == 4 &lt;/pre&gt;
 * @param arguments the arguments to bind
 * @return the new closure with its arguments bound
 * @see #curry(Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rcurry</MethodName>
            <MethodComment>/** 
 * Support for Closure "right" currying.
 * @param argument the argument to bind
 * @return the new closure with the argument bound
 * @see #rcurry(Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>argument</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ncurry</MethodName>
            <MethodComment>/** 
 * Support for Closure currying at a given index. Parameters are supplied from index position "n". Typical usage: &lt;pre&gt; def caseInsensitive = { a, b -&gt; a.toLowerCase() &lt;=&gt; b.toLowerCase() } as Comparator def caseSensitive = { a, b -&gt; a &lt;=&gt; b } as Comparator def animals1 = ['ant', 'dog', 'BEE'] def animals2 = animals1 + ['Cat'] // curry middle param of this utility method: // Collections#binarySearch(List list, Object key, Comparator c) def catSearcher = Collections.&amp;binarySearch.ncurry(1, "cat") [[animals1, animals2], [caseInsensitive, caseSensitive]].combinations().each{ a, c -&gt; def idx = catSearcher(a.sort(c), c) print a.sort(c).toString().padRight(22) if (idx &lt; 0) println "Not found but would belong in position ${-idx - 1}" else println "Found at index $idx" } // =&gt; // [ant, BEE, dog]       Not found but would belong in position 2 // [ant, BEE, Cat, dog]  Found at index 2 // [BEE, ant, dog]       Not found but would belong in position 2 // [BEE, Cat, ant, dog]  Not found but would belong in position 3 &lt;/pre&gt;
 * @param n the index from which to bind parameters (may be -ve in which case it will be normalized)
 * @param arguments the arguments to bind
 * @return the new closure with its arguments bound
 * @see #curry(Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ncurry</MethodName>
            <MethodComment>/** 
 * Support for Closure currying at a given index.
 * @param argument the argument to bind
 * @return the new closure with the argument bound
 * @see #ncurry(int,Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>argument</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rightShift</MethodName>
            <MethodComment>/** 
 * Support for Closure forward composition. &lt;p&gt; Typical usage: &lt;pre&gt; def twice = { a -&gt; a * 2 } def thrice = { a -&gt; a * 3 } def times6 = twice &gt;&gt; thrice // equivalent: times6 = { a -&gt; thrice(twice(a)) } assert times6(3) == 18 &lt;/pre&gt;
 * @param other the Closure to compose with the current Closure
 * @return the new composed Closure
 */
</MethodComment>
            <ReturnType>W</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <FieldType>W</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Support for Closure reverse composition. &lt;p&gt; Typical usage: &lt;pre&gt; def twice = { a -&gt; a * 2 } def thrice = { a -&gt; a * 3 } def times6 = thrice &lt;&lt; twice // equivalent: times6 = { a -&gt; thrice(twice(a)) } assert times6(3) == 18 &lt;/pre&gt;
 * @param other the Closure to compose with the current Closure
 * @return the new composed Closure
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>memoize</MethodName>
            <MethodComment>/** 
 * Creates a caching variant of the closure. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant will keep all cached values forever, i.e. till the closure gets garbage-collected. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure.
 * @return A new closure forwarding to the original one while caching the results
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>memoizeAtMost</MethodName>
            <MethodComment>/** 
 * Creates a caching variant of the closure with upper limit on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant will keep all values until the upper size limit is reached. Then the values in the cache start rotating using the LRU (Last Recently Used) strategy. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure.
 * @param maxCacheSize The maximum size the cache can grow to
 * @return A new function forwarding to the original one while caching the results
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maxCacheSize</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>memoizeAtLeast</MethodName>
            <MethodComment>/** 
 * Creates a caching variant of the closure with automatic cache size adjustment and lower limit on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant allows the garbage collector to release entries from the cache and at the same time allows the user to specify how many entries should be protected from the eventual gc-initiated eviction. Cached entries exceeding the specified preservation threshold are made available for eviction based on the LRU (Last Recently Used) strategy. Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the limits set by the user if memory is plentiful. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter might not be respected accurately in such scenarios for some periods of time. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure.
 * @param protectedCacheSize Number of cached return values to protect from garbage collection
 * @return A new function forwarding to the original one while caching the results
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>protectedCacheSize</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>memoizeBetween</MethodName>
            <MethodComment>/** 
 * Creates a caching variant of the closure with automatic cache size adjustment and lower and upper limits on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant allows the garbage collector to release entries from the cache and at the same time allows the user to specify how many entries should be protected from the eventual gc-initiated eviction. Cached entries exceeding the specified preservation threshold are made available for eviction based on the LRU (Last Recently Used) strategy. Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the protected size limits set by the user, if memory is plentiful. Also, this variant will never exceed in size the upper size limit. Once the upper size limit has been reached, the values in the cache start rotating using the LRU (Last Recently Used) strategy. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter might not be respected accurately in such scenarios for some periods of time. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure.
 * @param protectedCacheSize Number of cached return values to protect from garbage collection
 * @param maxCacheSize The maximum size the cache can grow to
 * @return A new function forwarding to the original one while caching the results
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>protectedCacheSize</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>maxCacheSize</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trampoline</MethodName>
            <MethodComment>/** 
 * Builds a trampolined variant of the current closure. To prevent stack overflow due to deep recursion, functions can instead leverage the trampoline mechanism and avoid recursive calls altogether. Under trampoline, the function is supposed to perform one step of the calculation and, instead of a recursive call to itself or another function, it return back a new closure, which will be executed by the trampoline as the next step. Once a non-closure value is returned, the trampoline stops and returns the value as the final result. Here is an example: &lt;pre&gt; def fact fact = { n, total -&gt; n == 0 ? total : fact.trampoline(n - 1, n * total) }.trampoline() def factorial = { n -&gt; fact(n, 1G)} println factorial(20) // =&gt; 2432902008176640000 &lt;/pre&gt;
 * @param args Parameters to the closure, so as the trampoline mechanism can call it
 * @return A closure, which will execute the original closure on a trampoline.
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trampoline</MethodName>
            <MethodComment>/** 
 * Builds a trampolined variant of the current closure. To prevent stack overflow due to deep recursion, functions can instead leverage the trampoline mechanism and avoid recursive calls altogether. Under trampoline, the function is supposed to perform one step of the calculation and, instead of a recursive call to itself or another function, it return back a new closure, which will be executed by the trampoline as the next step. Once a non-closure value is returned, the trampoline stops and returns the value as the final result.
 * @return A closure, which will execute the original closure on a trampoline.
 * @see #trampoline(Object...)
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>WritableClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <FieldType>Writer</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Closure.this;call;[new Object[]{out}]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Closure.this;setProperty;[property, newValue]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDelegate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDelegate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>delegate</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Closure.this;setDelegate;[delegate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Class[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumNumberOfParameters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asWritable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Closure</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Closure.this;run;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg0</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringWriter [writer=new StringWriter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>curry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Closure</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResolveStrategy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolveStrategy</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Closure.this;setResolveStrategy;[resolveStrategy]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResolveStrategy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDirective</MethodName>
            <MethodComment>/** 
 * @return Returns the directive.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDirective</MethodName>
            <MethodComment>/** 
 * @param directive The directive to set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>directive</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dehydrate</MethodName>
            <MethodComment>/** 
 * Returns a copy of this closure where the "owner", "delegate" and "thisObject" fields are null, allowing proper serialization when one of them is not serializable.
 * @return a serializable closure.
 * @since 1.8.5
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Closure&lt;V&gt; [result=(Closure&lt;V&gt;)this.clone()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rehydrate</MethodName>
            <MethodComment>/** 
 * Returns a copy of this closure for which the delegate, owner and thisObject are replaced with the supplied parameters. Use this when you want to rehydrate a closure which has been made serializable thanks to the  {@link #dehydrate()}method.
 * @param delegate the closure delegate
 * @param owner the closure owner
 * @param thisObject the closure "this" object
 * @return a copy of this closure where owner, delegate and thisObject are replaced
 * @since 1.8.5
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>delegate</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisObject</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Closure&lt;V&gt; [result=(Closure&lt;V&gt;)this.clone()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>