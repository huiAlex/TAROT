<Class>
    <Id>426</Id>
    <Package>groovy.lang</Package>
    <ClassName>IntRange</ClassName>
    <SuperClass>AbstractList</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Range</SuperInterface>
        <SuperInterface>Integer</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>IntRange  /** 
 * Represents a list of Integer objects from a specified int up (or down) to and including a given to.&lt;p&gt; &lt;p&gt; This class is a copy of  {@link ObjectRange} optimized for &lt;code&gt;int&lt;/code&gt;. If you make anychanges to this class, you might consider making parallel changes to  {@link ObjectRange}. Instances of this class may be either inclusive aware or non-inclusive aware. See the relevant constructors for creating each type. Inclusive aware IntRange instances are suitable for use with Groovy's range indexing - in particular if the from or to values might be negative. This normally happens underneath the covers but is worth keeping in mind if creating these ranges yourself explicitly.
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>size</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>value</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>from</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>to</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>reverse</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inclusive</FieldName>
            <FieldType>Boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>hasNext</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment>/** 
 * Not supported.
 * @throws java.lang.UnsupportedOperationException always
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IntRange.this;remove;[index]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IntRange</MethodName>
            <MethodComment>/** 
 * Creates a new non-inclusive &lt;code&gt;IntRange&lt;/code&gt;. If &lt;code&gt;from&lt;/code&gt; is greater than &lt;code&gt;to&lt;/code&gt;, a reverse range is created with &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; swapped.
 * @param from the first number in the range.
 * @param to   the last number in the range.
 * @throws IllegalArgumentException if the range would contain more than {@link Integer#MAX_VALUE} values.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Long [size=0L + this.to - this.from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IntRange</MethodName>
            <MethodComment>/** 
 * Creates a new non-inclusive aware &lt;code&gt;IntRange&lt;/code&gt;.
 * @param from    the first value in the range.
 * @param to      the last value in the range.
 * @param reverse &lt;code&gt;true&lt;/code&gt; if the range should count from&lt;code&gt;to&lt;/code&gt; to &lt;code&gt;from&lt;/code&gt;.
 * @throws IllegalArgumentException if &lt;code&gt;from&lt;/code&gt; is greater than &lt;code&gt;to&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>reverse</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Long [size=0L + this.to - this.from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IntRange</MethodName>
            <MethodComment>/** 
 * Creates a new inclusive aware &lt;code&gt;IntRange&lt;/code&gt;.
 * @param from    the first value in the range.
 * @param to      the last value in the range.
 * @param inclusive &lt;code&gt;true&lt;/code&gt; if the to value is included in the range.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inclusive</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>from</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>subListBorders</MethodName>
            <MethodComment>/** 
 * A method for determining from and to information when using this IntRange to index an aggregate object of the specified size. Normally only used internally within Groovy but useful if adding range indexing support for your own aggregates.
 * @param size the size of the aggregate being indexed
 * @return the calculated range information (with 1 added to the to value, ready for providing to subList
 */
</MethodComment>
            <ReturnType>RangeInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [tempFrom=from]</InnerVar>
                <InnerVar>int [tempTo=to]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Determines if this object is equal to another object. Delegates to {@link AbstractList#equals(Object)} if &lt;code&gt;that&lt;/code&gt; is anythingother than an  {@link IntRange}. &lt;p&gt; It is not necessary to override &lt;code&gt;hashCode&lt;/code&gt;, as {@link AbstractList#hashCode()} provides a suitable hash code.&lt;p&gt;&lt;p&gt; Note that equals is generally handled by  {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#equals(List,List)}instead of this method.
 * @param that the object to compare
 * @return &lt;code&gt;true&lt;/code&gt; if the objects are equal
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>that</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Compares an  {@link IntRange} to another {@link IntRange}.
 * @param that the object to compare for equality
 * @return &lt;code&gt;true&lt;/code&gt; if the ranges are equal
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>that</ParamName>
                    <FieldType>IntRange</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFrom</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTo</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInclusive</MethodName>
            <MethodComment>/** 
 * Returns the inclusive flag. Null for non-inclusive aware ranges or non-null for inclusive aware ranges.
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromInt</MethodName>
            <MethodComment>/** 
 * Gets the 'from' value as a primitive integer.
 * @return the 'from' value as a primitive integer.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getToInt</MethodName>
            <MethodComment>/** 
 * Gets the 'to' value as a primitive integer.
 * @return the 'to' value as a primitive integer.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReverse</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsWithinBounds</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>subList</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromIndex</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>toIndex</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inspect</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsAll</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <FieldType>Collection</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>step</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>step</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>step</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>step</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IteratorClosureAdapter&lt;Integer&gt; [adapter=new IteratorClosureAdapter&lt;Integer&gt;(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;step;[step, adapter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>