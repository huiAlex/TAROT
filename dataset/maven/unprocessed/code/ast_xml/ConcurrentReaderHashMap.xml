<Class>
    <Id>250</Id>
    <Package>org.codehaus.groovy.runtime.metaclass</Package>
    <ClassName>ConcurrentReaderHashMap</ClassName>
    <SuperClass>AbstractMap</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Map</SuperInterface>
        <SuperInterface>Cloneable</SuperInterface>
        <SuperInterface>Serializable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ConcurrentReaderHashMap  /** 
 * A hash table that supports mostly-concurrent reading, but exclusive writing.  Because reads are not limited to periods without writes, a concurrent reader policy is weaker than a classic reader/writer policy, but is generally faster and allows more concurrency. This class is a good choice especially for tables that are mainly created by one thread during the start-up phase of a program, and from then on, are mainly read (with perhaps occasional additions or removals) in many threads.  If you also need concurrency among writes, consider instead using ConcurrentHashMap. &lt;p&gt; Successful retrievals using get(key) and containsKey(key) usually run without locking. Unsuccessful ones (i.e., when the key is not present) do involve brief synchronization (locking).  Also, the size and isEmpty methods are always synchronized. &lt;p&gt; Because retrieval operations can ordinarily overlap with writing operations (i.e., put, remove, and their derivatives), retrievals can only be guaranteed to return the results of the most recently &lt;em&gt;completed&lt;/em&gt; operations holding upon their onset. Retrieval operations may or may not return results reflecting in-progress writing operations.  However, the retrieval operations do always return consistent results -- either those holding before any single modification or after it, but never a nonsense result.  For aggregate operations such as putAll and clear, concurrent reads may reflect insertion or removal of only some entries. In those rare contexts in which you use a hash table to synchronize operations across threads (for example, to prevent reads until after clears), you should either encase operations in synchronized blocks, or instead use java.util.Hashtable. &lt;p&gt; This class also supports optional guaranteed exclusive reads, simply by surrounding a call within a synchronized block, as in &lt;br&gt;  &lt;code&gt;ConcurrentReaderHashMap t; ... Object v; &lt;br&gt; synchronized(t) { v = t.get(k); } &lt;/code&gt; &lt;br&gt; But this is not usually necessary in practice. For example, it is generally inefficient to write: &lt;pre&gt; ConcurrentReaderHashMap t; ...            // Inefficient version Object key; ... Object value; ... synchronized(t) {  if (!t.containsKey(key)) t.put(key, value); // other code if not previously present } else { // other code if it was previously present } } &lt;/pre&gt; Instead, if the values are intended to be the same in each case, just take advantage of the fact that put returns null if the key was not previously present: &lt;pre&gt; ConcurrentReaderHashMap t; ...                // Use this instead Object key; ... Object value; ... Object oldValue = t.put(key, value); if (oldValue == null) { // other code if not previously present } else { // other code if it was previously present } &lt;/pre&gt; &lt;p&gt; Iterators and Enumerations (i.e., those returned by keySet().iterator(), entrySet().iterator(), values().iterator(), keys(), and elements()) return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.  They will return at most one instance of each element (via next()/nextElement()), but might or might not reflect puts and removes that have been processed since they were created.  They do &lt;em&gt;not&lt;/em&gt; throw ConcurrentModificationException. However, these iterators are designed to be used by only one thread at a time. Sharing an iterator across multiple threads may lead to unpredictable results if the table is being concurrently modified.  Again, you can ensure interference-free iteration by enclosing the iteration in a synchronized block.  &lt;p&gt; This class may be used as a direct replacement for any use of java.util.Hashtable that does not depend on readers being blocked during updates. Like Hashtable but unlike java.util.HashMap, this class does NOT allow &lt;tt&gt;null&lt;/tt&gt; to be used as a key or value.  This class is also typically faster than ConcurrentHashMap when there is usually only one thread updating the table, but  possibly many retrieving values from it. &lt;p&gt; Implementation note: A slightly faster implementation of this class will be possible once planned Java Memory Model revisions are in place. &lt;p&gt;[&lt;a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"&gt; Introduction to this package. &lt;/a&gt;]
 * @author Adapted from ConcurrentHashMap (Doug Lea)
 * @author adapted by the Groovy community
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>barrierLock</FieldName>
            <FieldType>BarrierLock</FieldType>
        </Field>
        <Field>
            <FieldName>lastWrite</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_INITIAL_CAPACITY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MINIMUM_CAPACITY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAXIMUM_CAPACITY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_LOAD_FACTOR</FieldName>
            <FieldType>float</FieldType>
        </Field>
        <Field>
            <FieldName>table</FieldName>
            <FieldType>Entry[]</FieldType>
        </Field>
        <Field>
            <FieldName>count</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>threshold</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>loadFactor</FieldName>
            <FieldType>float</FieldType>
        </Field>
        <Field>
            <FieldName>keySet</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>entrySet</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>values</FieldName>
            <FieldType>Collection</FieldType>
        </Field>
        <Field>
            <FieldName>hash</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>key</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>next</FieldName>
            <FieldType>Entry</FieldType>
        </Field>
        <Field>
            <FieldName>value</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>tab</FieldName>
            <FieldType>Entry[]</FieldType>
        </Field>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>entry</FieldName>
            <FieldType>Entry</FieldType>
        </Field>
        <Field>
            <FieldName>currentKey</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>currentValue</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>lastReturned</FieldName>
            <FieldType>Entry</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>recordModification</MethodName>
            <MethodComment>/** 
 * Force a memory synchronization that will cause all readers to see table. Call only when already holding main sync lock.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>x</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableForReading</MethodName>
            <MethodComment>/** 
 * Get ref to table; the reference and the cells it accesses will be at least as fresh as from last use of barrierLock
 */
</MethodComment>
            <ReturnType>Entry[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>p2capacity</MethodName>
            <MethodComment>/** 
 * Returns the appropriate capacity (power of two) for the specified  initial capacity argument.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [cap=initialCapacity]</InnerVar>
                <InnerVar>int [result]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hash</MethodName>
            <MethodComment>/** 
 * Return hash code for Object x. Since we are using power-of-two tables, it is worth the effort to improve hashcode via the same multiplicative scheme as used in IdentityHashMap.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>x</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [h=x.hashCode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eq</MethodName>
            <MethodComment>/** 
 * Check for equality of non-null references x and y. 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>x</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>y</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ConcurrentReaderHashMap</MethodName>
            <MethodComment>/** 
 * Constructs a new, empty map with the specified initial  capacity and the specified load factor. 
 * @param initialCapacity the initial capacityThe actual initial capacity is rounded to the nearest power of two.
 * @param loadFactor  the load factor of the ConcurrentReaderHashMap
 * @throws IllegalArgumentException  if the initial maximum number of elements is less than zero, or if the load factor is non-positive.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>loadFactor</ParamName>
                    <FieldType>float</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [cap=p2capacity(initialCapacity)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ConcurrentReaderHashMap</MethodName>
            <MethodComment>/** 
 * Constructs a new, empty map with the specified initial  capacity and default load factor.
 * @param initialCapacity   the initial capacity of the ConcurrentReaderHashMap.
 * @throws IllegalArgumentException if the initial maximum number of elements is less than zero.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ConcurrentReaderHashMap</MethodName>
            <MethodComment>/** 
 * Constructs a new, empty map with a default initial capacity and load factor.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ConcurrentReaderHashMap</MethodName>
            <MethodComment>/** 
 * Constructs a new map with the same mappings as the given map.  The map is created with a capacity of twice the number of mappings in the given map or 16 (whichever is greater), and a default load factor.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <FieldType>Map</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;putAll;[t]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Returns the number of key-value mappings in this map.
 * @return the number of key-value mappings in this map.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
 * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * Returns the value to which the specified key is mapped in this table.
 * @param key   a key in the table.
 * @return  the value to which the key is mapped in this table;&lt;code&gt;null&lt;/code&gt; if the key is not mapped to any value in this table.
 * @exception NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt;.
 * @see #put(Object,Object)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [hash=hash(key)]</InnerVar>
                <InnerVar>Entry[] [tab=table]</InnerVar>
                <InnerVar>int [index=hash &amp; (tab.length - 1)]</InnerVar>
                <InnerVar>Entry [first=tab[index]]</InnerVar>
                <InnerVar>Entry [e=first]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsKey</MethodName>
            <MethodComment>/** 
 * Tests if the specified object is a key in this table.
 * @param key   possible key.
 * @return  &lt;code&gt;true&lt;/code&gt; if and only if the specified object is a key in this table, as determined by the  &lt;tt&gt;equals&lt;/tt&gt; method; &lt;code&gt;false&lt;/code&gt; otherwise.
 * @exception NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt;.
 * @see #contains(Object)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment>/** 
 * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified  &lt;code&gt;value&lt;/code&gt; in this table. Neither the key nor the  value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt; The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method  with a key that is equal to the original key. 
 * @param key     the table key.
 * @param value   the value.
 * @return     the previous value of the specified key in this table,or &lt;code&gt;null&lt;/code&gt; if it did not have one.
 * @exception NullPointerException  if the key or value is &lt;code&gt;null&lt;/code&gt;.
 * @see Object#equals(Object)
 * @see #get(Object)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [hash=hash(key)]</InnerVar>
                <InnerVar>Entry[] [tab=table]</InnerVar>
                <InnerVar>int [index=hash &amp; (tab.length - 1)]</InnerVar>
                <InnerVar>Entry [first=tab[index]]</InnerVar>
                <InnerVar>Entry [e]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sput</MethodName>
            <MethodComment>/** 
 * Continuation of put(), called only when sync lock is held and interference has been detected.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>hash</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Entry[] [tab=table]</InnerVar>
                <InnerVar>int [index=hash &amp; (tab.length - 1)]</InnerVar>
                <InnerVar>Entry [first=tab[index]]</InnerVar>
                <InnerVar>Entry [e=first]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rehash</MethodName>
            <MethodComment>/** 
 * Rehashes the contents of this map into a new table with a larger capacity. This method is called automatically when the number of keys in this map exceeds its capacity and load factor.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Entry[] [oldTable=table]</InnerVar>
                <InnerVar>int [oldCapacity=oldTable.length]</InnerVar>
                <InnerVar>int [newCapacity=oldCapacity &lt;&lt; 1]</InnerVar>
                <InnerVar>int [mask=newCapacity - 1]</InnerVar>
                <InnerVar>Entry[] [newTable=new Entry[newCapacity]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;recordModification;[newTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment>/** 
 * Removes the key (and its corresponding value) from this  table. This method does nothing if the key is not in the table.
 * @param key   the key that needs to be removed.
 * @return  the value to which the key had been mapped in this table,or &lt;code&gt;null&lt;/code&gt; if the key did not have a mapping.
 * @exception NullPointerException  if the key is&lt;code&gt;null&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [hash=hash(key)]</InnerVar>
                <InnerVar>Entry[] [tab=table]</InnerVar>
                <InnerVar>int [index=hash &amp; (tab.length - 1)]</InnerVar>
                <InnerVar>Entry [first=tab[index]]</InnerVar>
                <InnerVar>Entry [e=first]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sremove</MethodName>
            <MethodComment>/** 
 * Continuation of remove(), called only when sync lock is held and interference has been detected.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>hash</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Entry[] [tab=table]</InnerVar>
                <InnerVar>int [index=hash &amp; (tab.length - 1)]</InnerVar>
                <InnerVar>Entry [first=tab[index]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsValue</MethodName>
            <MethodComment>/** 
 * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the specified value. Note: This method requires a full internal traversal of the hash table, and so is much slower than method &lt;tt&gt;containsKey&lt;/tt&gt;.
 * @param value value whose presence in this map is to be tested.
 * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to thespecified value.  
 * @exception NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Entry [tab[]=getTableForReading()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment>/** 
 * Tests if some key maps into the specified value in this table. This operation is more expensive than the &lt;code&gt;containsKey&lt;/code&gt; method.&lt;p&gt; Note that this method is identical in functionality to containsValue, (which is part of the Map interface in the collections framework).
 * @param value   a value to search for.
 * @return     &lt;code&gt;true&lt;/code&gt; if and only if some key maps to the&lt;code&gt;value&lt;/code&gt; argument in this table as  determined by the &lt;tt&gt;equals&lt;/tt&gt; method; &lt;code&gt;false&lt;/code&gt; otherwise.
 * @exception NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;.
 * @see #containsKey(Object)
 * @see #containsValue(Object)
 * @see Map
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAll</MethodName>
            <MethodComment>/** 
 * Copies all of the mappings from the specified map to this one. These mappings replace any mappings that this map had for any of the keys currently in the specified Map.
 * @param t Mappings to be stored in this map.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <FieldType>Map</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [n=t.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Removes all mappings from this map.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Entry [tab[]=table]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;recordModification;[tab]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment>/** 
 * Returns a shallow copy of this  &lt;tt&gt;ConcurrentReaderHashMap&lt;/tt&gt; instance: the keys and values themselves are not cloned.
 * @return a shallow copy of this map.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keySet</MethodName>
            <MethodComment>/** 
 * Returns a set view of the keys contained in this map.  The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.  The set supports element removal, which removes the corresponding mapping from this map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
 * @return a set view of the keys contained in this map.
 */
</MethodComment>
            <ReturnType>Set</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set [ks=keySet]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Iterator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConcurrentReaderHashMap.this;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>values</MethodName>
            <MethodComment>/** 
 * Returns a collection view of the values contained in this map.  The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa.  The collection supports element removal, which removes the corresponding mapping from this map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
 * @return a collection view of the values contained in this map.
 */
</MethodComment>
            <ReturnType>Collection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Collection [vs=values]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Iterator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConcurrentReaderHashMap.this;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entrySet</MethodName>
            <MethodComment>/** 
 * Returns a collection view of the mappings contained in this map.  Each element in the returned collection is a &lt;tt&gt;Map.Entry&lt;/tt&gt;.  The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa.  The collection supports element removal, which removes the corresponding mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
 * @return a collection view of the mappings contained in this map.
 */
</MethodComment>
            <ReturnType>Set</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set [es=entrySet]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Iterator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map.Entry [entry=(Map.Entry)o]</InnerVar>
                <InnerVar>Object [v=ConcurrentReaderHashMap.this.get(entry.getKey())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConcurrentReaderHashMap.this;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection [c=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findAndRemoveEntry</MethodName>
            <MethodComment>/** 
 * Helper method for entrySet.remove
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entry</ParamName>
                    <FieldType>Map.Entry</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [key=entry.getKey()]</InnerVar>
                <InnerVar>Object [v=get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keys</MethodName>
            <MethodComment>/** 
 * Returns an enumeration of the keys in this table.
 * @return  an enumeration of the keys in this table.
 * @see Enumeration
 * @see #elements()
 * @see #keySet()
 * @see Map
 */
</MethodComment>
            <ReturnType>Enumeration</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>elements</MethodName>
            <MethodComment>/** 
 * Returns an enumeration of the values in this table. Use the Enumeration methods on the returned object to fetch the elements sequentially.
 * @return  an enumeration of the values in this table.
 * @see java.util.Enumeration
 * @see #keys()
 * @see #values()
 * @see Map
 */
</MethodComment>
            <ReturnType>Enumeration</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Entry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hash</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>next</ParamName>
                    <FieldType>Entry</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValue</MethodName>
            <MethodComment>/** 
 * Get the value.  Note: In an entrySet or entrySet.iterator, unless the set or iterator is used under synchronization of the table as a whole (or you can otherwise guarantee lack of concurrent modification), &lt;tt&gt;getValue&lt;/tt&gt; &lt;em&gt;might&lt;/em&gt; return null, reflecting the fact that the entry has been concurrently removed. However, there are no assurances that concurrent removals will be reflected using this method.
 * @return     the current value, or null if the entry has been detectably removed.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this entry.  Note: In an entrySet or entrySet.iterator), unless the set or iterator is used under synchronization of the table as a whole (or you can otherwise guarantee lack of concurrent modification), &lt;tt&gt;setValue&lt;/tt&gt; is not strictly guaranteed to actually replace the value field obtained via the &lt;tt&gt;get&lt;/tt&gt; operation of the underlying hash table in multi-threaded applications.  If iterator-wide synchronization is not used, and any other concurrent &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;remove&lt;/tt&gt; operations occur, sometimes even to &lt;em&gt;other&lt;/em&gt; entries, then this change is not guaranteed to be reflected in the hash table. (It might, or it might not. There are no assurances either way.)
 * @param value   the new value.
 * @return     the previous value, or null if entry has been detectablyremoved.
 * @exception NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [oldValue=this.value]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map.Entry [e=(Map.Entry)o]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>HashIterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasMoreElements</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextElement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnValueOfNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [result=returnValueOfNext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConcurrentReaderHashMap.this;remove;[lastReturned.key]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnValueOfNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnValueOfNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeObject</MethodName>
            <MethodComment>/** 
 * Save the state of the &lt;tt&gt;ConcurrentReaderHashMap&lt;/tt&gt;  instance to a stream (i.e., serialize it).
 * @param s the stream
 * @serialData The &lt;i&gt;capacity&lt;/i&gt; of theConcurrentReaderHashMap (the length of the bucket array) is emitted (int), followed  by the &lt;i&gt;size&lt;/i&gt; of the ConcurrentReaderHashMap (the number of key-value mappings), followed by the key (Object) and value (Object) for each key-value mapping represented by the ConcurrentReaderHashMap The key-value mappings are emitted in no particular order.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <FieldType>java.io.ObjectOutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;defaultWriteObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>s;writeInt;[table.length]</InnerMethodInvoke>
                <InnerMethodInvoke>s;writeInt;[count]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readObject</MethodName>
            <MethodComment>/** 
 * Reconstitute the &lt;tt&gt;ConcurrentReaderHashMap&lt;/tt&gt;  instance from a stream (i.e., deserialize it).
 * @param s the stream
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <FieldType>java.io.ObjectInputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numBuckets=s.readInt()]</InnerVar>
                <InnerVar>int [size=s.readInt()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;defaultReadObject;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>capacity</MethodName>
            <MethodComment>/** 
 * @return the number of slots in this table
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadFactor</MethodName>
            <MethodComment>/** 
 * @return the load factor
 */
</MethodComment>
            <ReturnType>float</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>