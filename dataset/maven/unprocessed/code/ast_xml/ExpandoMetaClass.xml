<Class>
    <Id>19</Id>
    <Package>groovy.lang</Package>
    <ClassName>ExpandoMetaClass</ClassName>
    <SuperClass>MetaClassImpl</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>GroovyObject</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ExpandoMetaClass  /** 
 * ExpandoMetaClass is a MetaClass that behaves like an Expando, allowing the addition or replacement of methods, properties and constructors on the fly. &lt;p&gt; Some examples of usage: &lt;pre&gt; // defines or replaces instance method: metaClass.myMethod = { args -&gt; } // defines a new instance method metaClass.myMethod &lt;&lt; { args -&gt; } // creates multiple overloaded methods of the same name metaClass.myMethod &lt;&lt; { String s -&gt; } &lt;&lt; { Integer i -&gt; } // defines or replaces a static method with the 'static' qualifier metaClass.'static'.myMethod = { args -&gt;  } // defines a new static method with the 'static' qualifier metaClass.'static'.myMethod &lt;&lt; { args -&gt;  } // defines a new constructor metaClass.constructor &lt;&lt; { String arg -&gt; } // defines or replaces a constructor metaClass.constructor = { String arg -&gt; } // defines a new property with an initial value of "blah" metaClass.myProperty = "blah" &lt;/pre&gt; &lt;p&gt; ExpandoMetaClass also supports a DSL/builder like notation to combine multiple definitions together. So instead of this: &lt;pre&gt; Number.metaClass.multiply = { Amount amount -&gt; amount.times(delegate) } Number.metaClass.div =      { Amount amount -&gt; amount.inverse().times(delegate) } &lt;/pre&gt; You can also now do this: &lt;pre&gt; Number.metaClass { multiply { Amount amount -&gt; amount.times(delegate) } div      { Amount amount -&gt; amount.inverse().times(delegate) } } &lt;/pre&gt; &lt;p&gt; ExpandoMetaClass also supports runtime mixins. While  {@code @Mixin} allows you to mix in new behaviorto classes you own and are designing, you can not easily mixin anything to types you didn't own, e.g. from third party libraries or from JDK library classes. Runtime mixins let you add a mixin on any type at runtime. &lt;pre&gt; interface Vehicle { String getName() } // Category annotation style {@code @Category}(Vehicle) class FlyingAbility { def fly() { "I'm the ${name} and I fly!" } } // traditional category style class DivingAbility { static dive(Vehicle self) { "I'm the ${self.name} and I dive!" } } // provided by a third-party, so can't augment using Mixin annotation class JamesBondVehicle implements Vehicle { String getName() { "James Bond's vehicle" } } // Can be added via metaClass, e.g.: // JamesBondVehicle.metaClass.mixin DivingAbility, FlyingAbility // Or using shorthand through DGM method on Class JamesBondVehicle.mixin DivingAbility, FlyingAbility assert new JamesBondVehicle().fly() == "I'm the James Bond's vehicle and I fly!" assert new JamesBondVehicle().dive() == "I'm the James Bond's vehicle and I dive!" &lt;/pre&gt; As another example, consider the following class definitions: &lt;pre&gt; class Student { List&lt;String&gt; schedule = [] def addLecture(String lecture) { schedule &lt;&lt; lecture } } class Worker { List&lt;String&gt; schedule = [] def addMeeting(String meeting) { schedule &lt;&lt; meeting } } &lt;/pre&gt; We can mimic a form of multiple inheritance as follows: &lt;pre&gt; class CollegeStudent { static { mixin Student, Worker } } new CollegeStudent().with { addMeeting('Performance review with Boss') addLecture('Learn about Groovy Mixins') println schedule println mixedIn[Student].schedule println mixedIn[Worker].schedule } &lt;/pre&gt; Which outputs these lines when run: &lt;pre&gt; [Performance review with Boss] [Learn about Groovy Mixins] [Performance review with Boss] &lt;/pre&gt; Perhaps some explanation is required here. The methods and properties of Student and Worker are added to CollegeStudent. Worker is added last, so for overlapping methods, its methods will be used, e.g. when calling &lt;code&gt;schedule&lt;/code&gt;, it will be the schedule property (getSchedule method) from Worker that is used. The schedule property from Student will be shadowed but the &lt;code&gt;mixedIn&lt;/code&gt; notation allows us to get to that too if we need as the last two lines show. &lt;p&gt; We can also be a little more dynamic and not require the CollegeStudent class to be defined at all, e.g.: &lt;pre&gt; def cs = new Object() cs.metaClass { mixin Student, Worker getSchedule { mixedIn[Student].schedule + mixedIn[Worker].schedule } } cs.with { addMeeting('Performance review with Boss') addLecture('Learn about Groovy Mixins') println schedule } &lt;/pre&gt; Which outputs this line when run: &lt;pre&gt; [Learn about Groovy Mixins, Performance review with Boss] &lt;/pre&gt; As another example, we can also define a no dup queue by mixing in some Queue and Set functionality as follows: &lt;pre&gt; def ndq = new Object() ndq.metaClass { mixin ArrayDeque mixin HashSet leftShift = { Object o -&gt; if (!mixedIn[Set].contains(o)) { mixedIn[Queue].push(o) mixedIn[Set].add(o) } } } ndq &lt;&lt; 1 ndq &lt;&lt; 2 ndq &lt;&lt; 1 assert ndq.size() == 2 &lt;/pre&gt; As a final example, we sometimes need to pass such mixed in classes or objects into Java methods which require a given static type but the ExpandoMetaClass mixin approach uses a very dynamic approach based on duck typing rather than static interface definitions, so doesn't by default produce objects matching the required static type. Luckily, there is a mixins capability within ExpandoMetaClass which supports the use of Groovy's common 'as StaticType' notation to produce an object having the correct static type so that it can be passed to the Java method call in question. A slightly contrived example illustrating this feature: &lt;pre&gt; class CustomComparator implements Comparator { int compare(Object a, b) { return a.size() - b.size() } } class CustomCloseable implements Closeable { void close() { println 'Lights out - I am closing' } } import static mypackage.IOUtils.closeQuietly import static java.util.Collections.sort def o = new Object() o.metaClass.mixin CustomComparator, CustomCloseable def items = ['a', 'bbb', 'cc'] sort(items, o as Comparator) println items                // =&gt; [a, cc, bbb] closeQuietly(o as Closeable) // =&gt; Lights out - I am closing &lt;/pre&gt; &lt;p&gt; &lt;b&gt;Further details&lt;/b&gt; &lt;p&gt; When using the default implementations of MetaClass, methods are only allowed to be added before initialize() is called. In other words you create a new MetaClass, add some methods and then call initialize(). If you attempt to add new methods after initialize() has been called, an error will be thrown. This is to ensure that the MetaClass can operate appropriately in multi-threaded environments as it forces you to do all method additions at the beginning, before using the MetaClass. &lt;p&gt; ExpandoMetaClass differs here from the default in that it allows you to add methods after initialize has been called. This is done by setting the initialize flag internally to false and then add the methods. Since this is not thread safe it has to be done in a synchronized block. The methods to check for modification and initialization are therefore synchronized as well. Any method call done through this meta class will first check if the it is synchronized. Should this happen during a modification, then the method cannot be selected or called unless the modification is completed. &lt;p&gt;
 * @author Graeme Rocher
 * @since 1.5
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>EMPTY_CLASS_ARRAY</FieldName>
            <FieldType>Class[]</FieldType>
        </Field>
        <Field>
            <FieldName>META_CLASS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CLASS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>META_METHODS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>METHODS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>PROPERTIES</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>STATIC_QUALIFIER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CONSTRUCTOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CLASS_PROPERTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>META_CLASS_PROPERTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>GROOVY_CONSTRUCTOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>myMetaClass</FieldName>
            <FieldType>MetaClass</FieldType>
        </Field>
        <Field>
            <FieldName>initialized</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>modified</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>initCalled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rwl</FieldName>
            <FieldType>ReentrantReadWriteLock</FieldType>
        </Field>
        <Field>
            <FieldName>readLock</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>writeLock</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>allowChangesAfterInit</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inRegistry</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inheritedMetaMethods</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>inheritedMetaMethods</FieldName>
            <FieldType>MetaMethod</FieldType>
        </Field>
        <Field>
            <FieldName>beanPropertyCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>beanPropertyCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>staticBeanPropertyCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>staticBeanPropertyCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>expandoMethods</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>expandoMethods</FieldName>
            <FieldType>MethodKey</FieldType>
        </Field>
        <Field>
            <FieldName>expandoSubclassMethods</FieldName>
            <FieldType>ConcurrentHashMap</FieldType>
        </Field>
        <Field>
            <FieldName>expandoProperties</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>expandoProperties</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>invokeStaticMethodMethod</FieldName>
            <FieldType>ClosureStaticMetaMethod</FieldType>
        </Field>
        <Field>
            <FieldName>mixinClasses</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>mixinClasses</FieldName>
            <FieldType>MixinInMetaClass</FieldType>
        </Field>
        <Field>
            <FieldName>propertyName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>isStatic</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>klazz</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>definition</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>object</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>mixinClasses</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>mixinClasses</FieldName>
            <FieldType>MixinInMetaClass</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getExpandoSubclassMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Collection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>register</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>allowChangesAfterInit</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>add</ParamName>
                    <FieldType>MetaMethod[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>registry</ParamName>
                    <FieldType>MetaClassRegistry</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>register</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>allowChangesAfterInit</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>add</ParamName>
                    <FieldType>MetaMethod[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment>/** 
 * Constructs a new ExpandoMetaClass instance for the given class
 * @param theClass The class that the MetaClass applies to
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>add</ParamName>
                    <FieldType>MetaMethod[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment>/** 
 * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass in the MetaClassRegistry automatically
 * @param theClass The class that the MetaClass applies to
 * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>register</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>register</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>add</ParamName>
                    <FieldType>MetaMethod[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaClass</MethodName>
            <MethodComment>/** 
 * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass in the MetaClassRegistry automatically
 * @param theClass The class that the MetaClass applies to
 * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
 * @param allowChangesAfterInit Should the meta class be modifiable after initialization. Default is false.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>register</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>allowChangesAfterInit</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMixinMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaMethod</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onInvokeMethodFoundInHierarchy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onSuperMethodFoundInHierarchy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addSuperMethodIfNotOverridden;[method]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onSuperPropertyFoundInHierarchy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>MetaBeanProperty</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addMetaBeanProperty;[property]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onSetPropertyFoundInHierarchy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onGetPropertyFoundInHierarchy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isModified</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerSubclassInstanceMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>klazz</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [list=ClosureMetaMethod.createMethodList(name,klazz,closure)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerSubclassInstanceMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaMethod</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [name=metaMethod.getName()]</InnerVar>
                <InnerVar>Object [methodOrList=expandoSubclassMethods.get(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMixinClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mixin</ParamName>
                    <FieldType>MixinInMetaClass</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mixinClasses;add;[mixin]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castToMixedType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>enableGlobally</MethodName>
            <MethodComment>/** 
 * Call to enable global use of global use of ExpandoMetaClass within the registry. This has the advantage that inheritance will function correctly, but has a higher memory usage on the JVM than normal Groovy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DefaultMetaClassInfo;setWithoutCustomMetaclassCreationHandle;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>ExpandoMetaClassCreationHandle;enable;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disableGlobally</MethodName>
            <MethodComment>/** 
 * Call to disable the global use of ExpandoMetaClass
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DefaultMetaClassInfo;setWithoutCustomMetaclassCreationHandle;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>ExpandoMetaClassCreationHandle;disable;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInitialized</MethodName>
            <MethodComment>/** 
 * Checks if the meta class is initialized.
 * @see groovy.lang.MetaClassImpl#isInitialized()
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInitialized</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSuperMethodIfNotOverridden</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaMethodFromSuper</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;performOperationOnMetaClass;[new Callable(){
  public void call(){
    MetaMethod existing=null;
    try {
      existing=pickMethod(metaMethodFromSuper.getName(),metaMethodFromSuper.getNativeParameterTypes());
    }
 catch (    GroovyRuntimeException e) {
    }
    if (existing == null) {
      addMethodWithKey(metaMethodFromSuper);
    }
 else {
      boolean isGroovyMethod=getMetaMethods().contains(existing);
      if (isGroovyMethod) {
        addMethodWithKey(metaMethodFromSuper);
      }
 else       if (inheritedMetaMethods.contains(existing)) {
        inheritedMetaMethods.remove(existing);
        addMethodWithKey(metaMethodFromSuper);
      }
    }
  }
  private void addMethodWithKey(  final MetaMethod metaMethodFromSuper){
    inheritedMetaMethods.add(metaMethodFromSuper);
    if (metaMethodFromSuper instanceof ClosureMetaMethod) {
      ClosureMetaMethod closureMethod=(ClosureMetaMethod)metaMethodFromSuper;
      String name=metaMethodFromSuper.getName();
      final Class declaringClass=metaMethodFromSuper.getDeclaringClass().getTheClass();
      ClosureMetaMethod localMethod=ClosureMetaMethod.copy(closureMethod);
      addMetaMethod(localMethod);
      MethodKey key=new DefaultCachedMethodKey(declaringClass,name,localMethod.getParameterTypes(),false);
      checkIfGroovyObjectMethod(localMethod);
      expandoMethods.put(key,localMethod);
    }
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MetaMethod [existing=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMethodWithKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaMethodFromSuper</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>inheritedMetaMethods;add;[metaMethodFromSuper]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ExpandoMetaProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStatic</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerIfClosure;[arg, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerIfClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerStatic</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callable</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Method [foundMethod=checkIfMethodExists(theClass,propertyName,paramTypes,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerStaticMethod;[propertyName, callable, paramTypes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerInstance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Method [foundMethod=checkIfMethodExists(theClass,propertyName,paramTypes,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerInstanceMethod;[method]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIfMethodExists</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Method</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>staticMethod</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Method [foundMethod=null]</InnerVar>
                <InnerVar>Method[] [methods=methodClass.getMethods()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerIfClosure;[newValue, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeConstructor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class[] [argClasses=MetaClassHelper.convertToTypeArray(arguments)]</InnerVar>
                <InnerVar>MetaMethod [method=pickMethod(GROOVY_CONSTRUCTOR,argClasses)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaClass</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isValidExpandoProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [argsArr=args instanceof Object[] ? (Object[])args : new Object[]{args}]</InnerVar>
                <InnerVar>MetaMethod [metaMethod=myMetaClass.getMetaMethod(name,argsArr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaClass</ParamName>
                    <FieldType>MetaClass</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>define</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExpandoMetaClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DefiningClosure [definer=new DefiningClosure()]</InnerVar>
                <InnerVar>Object [delegate=closure.getDelegate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>closure;setDelegate;[definer]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;setResolveStrategy;[Closure.DELEGATE_ONLY]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;call;[(Object)null]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;setDelegate;[delegate]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;setResolveStrategy;[Closure.DELEGATE_FIRST]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performOperationOnMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <FieldType>Callable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkInitalised</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerBeanProperty</MethodName>
            <MethodComment>/** 
 * Registers a new bean property
 * @param property The property name
 * @param newValue The properties initial value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;performOperationOnMetaClass;[new Callable(){
  public void call(){
    Class type=newValue == null ? Object.class : newValue.getClass();
    MetaBeanProperty mbp=newValue instanceof MetaBeanProperty ? (MetaBeanProperty)newValue : new ThreadManagedMetaBeanProperty(theClass,property,type,newValue);
    final MetaMethod getter=mbp.getGetter();
    final MethodKey getterKey=new DefaultCachedMethodKey(theClass,getter.getName(),CachedClass.EMPTY_ARRAY,false);
    final MetaMethod setter=mbp.getSetter();
    final MethodKey setterKey=new DefaultCachedMethodKey(theClass,setter.getName(),setter.getParameterTypes(),false);
    addMetaMethod(getter);
    addMetaMethod(setter);
    expandoMethods.put(setterKey,setter);
    expandoMethods.put(getterKey,getter);
    expandoProperties.put(mbp.getName(),mbp);
    addMetaBeanProperty(mbp);
    performRegistryCallbacks();
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Class [type=newValue == null ? Object.class : newValue.getClass()]</InnerVar>
                <InnerVar>MetaBeanProperty [mbp=newValue instanceof MetaBeanProperty ? (MetaBeanProperty)newValue : new ThreadManagedMetaBeanProperty(theClass,property,type,newValue)]</InnerVar>
                <InnerVar>MetaMethod [getter=mbp.getGetter()]</InnerVar>
                <InnerVar>MethodKey [getterKey=new DefaultCachedMethodKey(theClass,getter.getName(),CachedClass.EMPTY_ARRAY,false)]</InnerVar>
                <InnerVar>MetaMethod [setter=mbp.getSetter()]</InnerVar>
                <InnerVar>MethodKey [setterKey=new DefaultCachedMethodKey(theClass,setter.getName(),setter.getParameterTypes(),false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addMetaMethod;[getter]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addMetaMethod;[setter]</InnerMethodInvoke>
                <InnerMethodInvoke>expandoMethods;put;[setterKey, setter]</InnerMethodInvoke>
                <InnerMethodInvoke>expandoMethods;put;[getterKey, getter]</InnerMethodInvoke>
                <InnerMethodInvoke>expandoProperties;put;[mbp.getName(), mbp]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addMetaBeanProperty;[mbp]</InnerMethodInvoke>
                <InnerMethodInvoke>null;performRegistryCallbacks;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerInstanceMethod</MethodName>
            <MethodComment>/** 
 * Registers a new instance method for the given method name and closure on this MetaClass
 * @param metaMethod
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaMethod</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [inited=this.initCalled]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;performOperationOnMetaClass;[new Callable(){
  public void call(){
    String methodName=metaMethod.getName();
    checkIfGroovyObjectMethod(metaMethod);
    MethodKey key=new DefaultCachedMethodKey(theClass,methodName,metaMethod.getParameterTypes(),false);
    if (isInitialized()) {
      throw new RuntimeException("Already initialized, cannot add new method: " + metaMethod);
    }
    addMetaMethodToIndex(metaMethod,metaMethodIndex.getHeader(theClass));
    dropMethodCache(methodName);
    expandoMethods.put(key,metaMethod);
    if (inited &amp;&amp; isGetter(methodName,metaMethod.getParameterTypes())) {
      String propertyName=getPropertyForGetter(methodName);
      registerBeanPropertyForMethod(metaMethod,propertyName,true,false);
    }
 else     if (inited &amp;&amp; isSetter(methodName,metaMethod.getParameterTypes())) {
      String propertyName=getPropertyForSetter(methodName);
      registerBeanPropertyForMethod(metaMethod,propertyName,false,false);
    }
    performRegistryCallbacks();
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [methodName=metaMethod.getName()]</InnerVar>
                <InnerVar>MethodKey [key=new DefaultCachedMethodKey(theClass,methodName,metaMethod.getParameterTypes(),false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIfGroovyObjectMethod;[metaMethod]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addMetaMethodToIndex;[metaMethod, metaMethodIndex.getHeader(theClass)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropMethodCache;[methodName]</InnerMethodInvoke>
                <InnerMethodInvoke>expandoMethods;put;[key, metaMethod]</InnerMethodInvoke>
                <InnerMethodInvoke>null;performRegistryCallbacks;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerInstanceMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [list=ClosureMetaMethod.createMethodList(name,theClass,closure)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethods</MethodName>
            <MethodComment>/** 
 * Overrides the behavior of parent getMethods() method to make MetaClass aware of added Expando methods
 * @return A list of MetaMethods
 * @see MetaObjectProtocol#getMethods()
 */
</MethodComment>
            <ReturnType>MetaMethod</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [methodList=new ArrayList&lt;MetaMethod&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodList;addAll;[this.expandoMethods.values()]</InnerMethodInvoke>
                <InnerMethodInvoke>methodList;addAll;[super.getMethods()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaProperty</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;MetaProperty&gt; [propertyList=new ArrayList&lt;MetaProperty&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>propertyList;addAll;[super.getProperties()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performRegistryCallbacks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MetaClassRegistry [registry=GroovySystem.getMetaClassRegistry()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;incVersion;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerBeanPropertyForMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>metaMethod</ParamName>
                    <FieldType>MetaMethod</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>propertyName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>getter</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,MetaProperty&gt; [propertyCache=isStatic ? staticBeanPropertyCache : beanPropertyCache]</InnerVar>
                <InnerVar>MetaBeanProperty [beanProperty=(MetaBeanProperty)propertyCache.get(propertyName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expandoProperties;put;[beanProperty.getName(), beanProperty]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addMetaBeanProperty;[beanProperty]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerStaticMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callable</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerStaticMethod;[name, callable, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerStaticMethod</MethodName>
            <MethodComment>/** 
 * Registers a new static method for the given method name and closure on this MetaClass
 * @param name     The method name
 * @param callable The callable Closure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callable</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;performOperationOnMetaClass;[new Callable(){
  public void call(){
    String methodName;
    if (name.equals(METHOD_MISSING))     methodName=STATIC_METHOD_MISSING;
 else     if (name.equals(PROPERTY_MISSING))     methodName=STATIC_PROPERTY_MISSING;
 else     methodName=name;
    ClosureStaticMetaMethod metaMethod=null;
    if (paramTypes != null) {
      metaMethod=new ClosureStaticMetaMethod(methodName,theClass,callable,paramTypes);
    }
 else {
      metaMethod=new ClosureStaticMetaMethod(methodName,theClass,callable);
    }
    if (methodName.equals(INVOKE_METHOD_METHOD) &amp;&amp; callable.getParameterTypes().length == 2) {
      invokeStaticMethodMethod=metaMethod;
    }
 else {
      if (methodName.equals(METHOD_MISSING)) {
        methodName=STATIC_METHOD_MISSING;
      }
      MethodKey key=new DefaultCachedMethodKey(theClass,methodName,metaMethod.getParameterTypes(),false);
      addMetaMethod(metaMethod);
      dropStaticMethodCache(methodName);
      if (isGetter(methodName,metaMethod.getParameterTypes())) {
        String propertyName=getPropertyForGetter(methodName);
        registerBeanPropertyForMethod(metaMethod,propertyName,true,true);
      }
 else       if (isSetter(methodName,metaMethod.getParameterTypes())) {
        String propertyName=getPropertyForSetter(methodName);
        registerBeanPropertyForMethod(metaMethod,propertyName,false,true);
      }
      performRegistryCallbacks();
      expandoMethods.put(key,metaMethod);
    }
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [methodName]</InnerVar>
                <InnerVar>ClosureStaticMetaMethod [metaMethod=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubclassMetaMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJavaClass</MethodName>
            <MethodComment>/** 
 * @return The Java class enhanced by this MetaClass
 */
</MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>refreshInheritedMethods</MethodName>
            <MethodComment>/** 
 * Called from ExpandoMetaClassCreationHandle in the registry if it exists to set up inheritance handling
 * @param modifiedSuperExpandos A list of modified super ExpandoMetaClass
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>modifiedSuperExpandos</ParamName>
                    <FieldType>Set</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>refreshInheritedMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>superExpando</ParamName>
                    <FieldType>ExpandoMetaClass</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [metaMethods=superExpando.getExpandoMethods()]</InnerVar>
                <InnerVar>Collection&lt;MetaProperty&gt; [metaProperties=superExpando.getExpandoProperties()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExpandoMethods</MethodName>
            <MethodComment>/** 
 * Returns a list of expando MetaMethod instances added to this ExpandoMetaClass
 * @return the expandoMethods
 */
</MethodComment>
            <ReturnType>MetaMethod</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExpandoProperties</MethodName>
            <MethodComment>/** 
 * Returns a list of MetaBeanProperty instances added to this ExpandoMetaClass
 * @return the expandoProperties
 */
</MethodComment>
            <ReturnType>MetaProperty</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment>/** 
 * Overrides default implementation just in case invokeMethod has been overridden by ExpandoMetaClass
 * @see groovy.lang.MetaClassImpl#invokeMethod(Class,Object,String,Object[],boolean,boolean)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>originalArguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isCallToSuper</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>fromInsideClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeStaticMethod</MethodName>
            <MethodComment>/** 
 * Overrides default implementation just in case a static invoke method has been set on ExpandoMetaClass
 * @see MetaClassImpl#invokeStaticMethod(Object,String,Object[])
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment>/** 
 * Overrides default implementation just in case getProperty method has been overridden by ExpandoMetaClass
 * @see MetaClassImpl#getProperty(Class,Object,String,boolean,boolean)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>useSuper</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>fromInsideClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment>/** 
 * Overrides default implementation just in case getProperty method has been overridden by ExpandoMetaClass
 * @see MetaClassImpl#getProperty(Object,String)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasOverrideGetProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment>/** 
 * Overrides default implementation just in case setProperty method has been overridden by ExpandoMetaClass
 * @see MetaClassImpl#setProperty(Class,Object,String,Object,boolean,boolean)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>useSuper</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>fromInsideClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaProperty</MethodName>
            <MethodComment>/** 
 * Looks up an existing MetaProperty by name
 * @param name The name of the MetaProperty
 * @return The MetaProperty or null if it doesn't exist
 */
</MethodComment>
            <ReturnType>MetaProperty</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MetaProperty [mp=(MetaProperty)this.expandoProperties.get(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasMetaProperty</MethodName>
            <MethodComment>/** 
 * Returns true if the MetaClass has the given property
 * @param name The name of the MetaProperty
 * @return True it exists as a MetaProperty
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasMetaMethod</MethodName>
            <MethodComment>/** 
 * Checks whether a MetaMethod for the given name and arguments exists
 * @param name The name of the MetaMethod
 * @param args The arguments to the meta method
 * @return True if the method exists otherwise null
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPropertyName</MethodName>
            <MethodComment>/** 
 * Determine if this method name suffix is a legitimate bean property name. Either the first or second letter must be upperCase for that to be true.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGetter</MethodName>
            <MethodComment>/** 
 * Returns true if the name of the method specified and the number of arguments make it a javabean property
 * @param name True if its a Javabean property
 * @param args The arguments
 * @return True if it is a javabean property method
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>CachedClass[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyForGetter</MethodName>
            <MethodComment>/** 
 * Returns a property name equivalent for the given getter name or null if it is not a getter
 * @param getterName The getter name
 * @return The property name equivalent
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>getterName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyForSetter</MethodName>
            <MethodComment>/** 
 * Returns a property name equivalent for the given setter name or null if it is not a getter
 * @param setterName The setter name
 * @return The property name equivalent
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>setterName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSetter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>CachedClass[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPojoCallSite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CallSite</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>site</ParamName>
                    <FieldType>CallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createStaticSite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CallSite</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>site</ParamName>
                    <FieldType>CallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasCustomStaticInvokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPogoCallSite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CallSite</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>site</ParamName>
                    <FieldType>CallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPogoCallCurrentSite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CallSite</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>site</ParamName>
                    <FieldType>CallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>retrieveConstructor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaMethod</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class[] [params=MetaClassHelper.convertToTypeArray(args)]</InnerVar>
                <InnerVar>MetaMethod [method=pickMethod(GROOVY_CONSTRUCTOR,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConstructorSite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CallSite</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>site</ParamName>
                    <FieldType>CallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class[] [params=MetaClassHelper.convertToTypeArray(args)]</InnerVar>
                <InnerVar>MetaMethod [method=pickMethod(GROOVY_CONSTRUCTOR,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SubClassDefiningClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>klazz</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mixin</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>category</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;mixin;[Collections.singletonList(category)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mixin</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>categories</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DefaultGroovyMethods;mixin;[ExpandoMetaClass.this, categories]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mixin</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>categories</ParamName>
                    <FieldType>Class[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DefaultGroovyMethods;mixin;[ExpandoMetaClass.this, categories]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>define</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>subClass</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SubClassDefiningClosure [definer=new SubClassDefiningClosure(subClass)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>closure;setDelegate;[definer]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;setResolveStrategy;[Closure.DELEGATE_FIRST]</InnerMethodInvoke>
                <InnerMethodInvoke>closure;call;[(Object)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ExpandoMetaClass.this;setProperty;[property, newValue]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>property</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StaticDefiningClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MixedInAccessor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>mixinClasses</ParamName>
                    <FieldType>MixinInMetaClass</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwnerMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwnerMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>