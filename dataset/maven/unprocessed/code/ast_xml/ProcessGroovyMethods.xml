<Class>
    <Id>237</Id>
    <Package>org.codehaus.groovy.runtime</Package>
    <ClassName>ProcessGroovyMethods</ClassName>
    <SuperClass>DefaultGroovyMethodsSupport</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ProcessGroovyMethods  /** 
 * This class defines new groovy methods which appear on normal JDK classes related to process management. &lt;p&gt; Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;. &lt;p&gt; NOTE: While this class contains many 'public' static methods, it is primarily regarded as an internal class (its internal package name suggests this also). We value backwards compatibility of these methods when used within Groovy but value less backwards compatibility at the Java method call level. I.e. future versions of Groovy may remove or move a method call in this file but would normally aim to keep the method available from within Groovy.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>process</FieldName>
            <FieldType>Process</FieldType>
        </Field>
        <Field>
            <FieldName>finished</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>in</FieldName>
            <FieldType>InputStream</FieldType>
        </Field>
        <Field>
            <FieldName>app</FieldName>
            <FieldType>Appendable</FieldType>
        </Field>
        <Field>
            <FieldName>in</FieldName>
            <FieldType>InputStream</FieldType>
        </Field>
        <Field>
            <FieldName>out</FieldName>
            <FieldType>OutputStream</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getIn</MethodName>
            <MethodComment>/** 
 * An alias method so that a process appears similar to System.out, System.in, System.err; you can use process.in, process.out, process.err in a similar fashion.
 * @param self a Process instance
 * @return the InputStream for the process
 * @since 1.0
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the text of the output stream of the Process. Closes all the streams associated with the process after retrieving the text.
 * @param self a Process instance
 * @return the text of the output
 * @throws java.io.IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [text=IOGroovyMethods.getText(new BufferedReader(new InputStreamReader(self.getInputStream())))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeStreams;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getErr</MethodName>
            <MethodComment>/** 
 * An alias method so that a process appears similar to System.out, System.in, System.err; you can use process.in, process.out, process.err in a similar fashion.
 * @param self a Process instance
 * @return the error InputStream for the process
 * @since 1.0
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOut</MethodName>
            <MethodComment>/** 
 * An alias method so that a process appears similar to System.out, System.in, System.err; you can use process.in, process.out, process.err in a similar fashion.
 * @param self a Process instance
 * @return the OutputStream for the process
 * @since 1.0
 */
</MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the left shift operator (&amp;lt;&amp;lt;) to provide an append mechanism to pipe data to a Process.
 * @param self  a Process instance
 * @param value a value to append
 * @return a Writer
 * @throws java.io.IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the left shift operator to provide an append mechanism to pipe into a Process
 * @param self  a Process instance
 * @param value data to append
 * @return an OutputStream
 * @throws java.io.IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <FieldType>byte[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForOrKill</MethodName>
            <MethodComment>/** 
 * Wait for the process to finish during a certain amount of time, otherwise stops the process.
 * @param self           a Process
 * @param numberOfMillis the number of milliseconds to wait before stopping the process
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>numberOfMillis</ParamName>
                    <FieldType>long</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ProcessRunner [runnable=new ProcessRunner(self)]</InnerVar>
                <InnerVar>Thread [thread=new Thread(runnable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>thread;start;[]</InnerMethodInvoke>
                <InnerMethodInvoke>runnable;waitForOrKill;[numberOfMillis]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeStreams</MethodName>
            <MethodComment>/** 
 * Closes all the streams associated with the process (ignoring any IOExceptions).
 * @param self a Process
 * @since 2.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The stream data is thrown away but blocking due to a full output buffer is avoided. Use this method if you don't care about the standard or error output and just want the process to run silently - use carefully however, because since the stream data is thrown away, it might be difficult to track down when something goes wrong. For this, two Threads are started, so this method will return immediately.
 * @param self a Process
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;consumeProcessOutput;[self, (OutputStream)null, (OutputStream)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. For this, two Threads are started, so this method will return immediately. The threads will not be join()ed, even if waitFor() is called. To wait for the output to be fully consumed call waitForProcessOutput().
 * @param self a Process
 * @param output an Appendable to capture the process stdout
 * @param error an Appendable to capture the process stderr
 * @since 1.7.5
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;consumeProcessOutputStream;[self, output]</InnerMethodInvoke>
                <InnerMethodInvoke>null;consumeProcessErrorStream;[self, error]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. For this, two Threads are started, so this method will return immediately. The threads will not be join()ed, even if waitFor() is called. To wait for the output to be fully consumed call waitForProcessOutput().
 * @param self a Process
 * @param output an OutputStream to capture the process stdout
 * @param error an OutputStream to capture the process stderr
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;consumeProcessOutputStream;[self, output]</InnerMethodInvoke>
                <InnerMethodInvoke>null;consumeProcessErrorStream;[self, error]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The stream data is thrown away but blocking due to a full output buffer is avoided. Use this method if you don't care about the standard or error output and just want the process to run silently - use carefully however, because since the stream data is thrown away, it might be difficult to track down when something goes wrong. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the output and error streams are closed.
 * @param self a Process
 * @since 1.6.5
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;waitForProcessOutput;[self, (OutputStream)null, (OutputStream)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the input, output and error streams are closed.
 * @param self a Process
 * @param output an Appendable to capture the process stdout
 * @param error an Appendable to capture the process stderr
 * @since 1.7.5
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [tout=consumeProcessOutputStream(self,output)]</InnerVar>
                <InnerVar>Thread [terr=consumeProcessErrorStream(self,error)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeStreams;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForProcessOutput</MethodName>
            <MethodComment>/** 
 * Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the input, output and error streams are closed.
 * @param self a Process
 * @param output an OutputStream to capture the process stdout
 * @param error an OutputStream to capture the process stderr
 * @since 1.6.5
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [tout=consumeProcessOutputStream(self,output)]</InnerVar>
                <InnerVar>Thread [terr=consumeProcessErrorStream(self,error)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeStreams;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessErrorStream</MethodName>
            <MethodComment>/** 
 * Gets the error stream from a process and reads it to keep the process from blocking due to a full buffer. The processed stream data is appended to the supplied OutputStream. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param err an OutputStream to capture the process stderr
 * @return the Thread
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>Thread</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>err</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [thread=new Thread(new ByteDumper(self.getErrorStream(),err))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>thread;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessErrorStream</MethodName>
            <MethodComment>/** 
 * Gets the error stream from a process and reads it to keep the process from blocking due to a full buffer. The processed stream data is appended to the supplied Appendable. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param error an Appendable to capture the process stderr
 * @return the Thread
 * @since 1.7.5
 */
</MethodComment>
            <ReturnType>Thread</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [thread=new Thread(new TextDumper(self.getErrorStream(),error))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>thread;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessOutputStream</MethodName>
            <MethodComment>/** 
 * Gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param output an Appendable to capture the process stdout
 * @return the Thread
 * @since 1.7.5
 */
</MethodComment>
            <ReturnType>Thread</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [thread=new Thread(new TextDumper(self.getInputStream(),output))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>thread;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consumeProcessOutputStream</MethodName>
            <MethodComment>/** 
 * Gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param output an OutputStream to capture the process stdout
 * @return the Thread
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>Thread</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Thread [thread=new Thread(new ByteDumper(self.getInputStream(),output))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>thread;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Creates a new BufferedWriter as stdin for this process, passes it to the closure, and ensures the stream is flushed and closed after the closure returns. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param closure a closure
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>new Thread(new Runnable(){
  public void run(){
    try {
      IOGroovyMethods.withWriter(new BufferedOutputStream(getOut(self)),closure);
    }
 catch (    IOException e) {
      throw new GroovyRuntimeException("exception while reading process stream",e);
    }
  }
}
);start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withOutputStream</MethodName>
            <MethodComment>/** 
 * Creates a new buffered OutputStream as stdin for this process, passes it to the closure, and ensures the stream is flushed and closed after the closure returns. A new Thread is started, so this method will return immediately.
 * @param self a Process
 * @param closure a closure
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <FieldType>Closure</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>new Thread(new Runnable(){
  public void run(){
    try {
      IOGroovyMethods.withStream(new BufferedOutputStream(getOut(self)),closure);
    }
 catch (    IOException e) {
      throw new GroovyRuntimeException("exception while reading process stream",e);
    }
  }
}
);start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pipeTo</MethodName>
            <MethodComment>/** 
 * Allows one Process to asynchronously pipe data to another Process.
 * @param left  a Process instance
 * @param right a Process to pipe output to
 * @return the second Process to allow chaining
 * @throws java.io.IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>new Thread(new Runnable(){
  public void run(){
    InputStream in=new BufferedInputStream(getIn(left));
    OutputStream out=new BufferedOutputStream(getOut(right));
    byte[] buf=new byte[8192];
    int next;
    try {
      while ((next=in.read(buf)) != -1) {
        out.write(buf,0,next);
      }
    }
 catch (    IOException e) {
      throw new GroovyRuntimeException("exception while reading process stream",e);
    }
 finally {
      closeWithWarning(out);
    }
  }
}
);start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>InputStream [in=new BufferedInputStream(getIn(left))]</InnerVar>
                <InnerVar>OutputStream [out=new BufferedOutputStream(getOut(right))]</InnerVar>
                <InnerVar>byte[] [buf=new byte[8192]]</InnerVar>
                <InnerVar>int [next]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>or</MethodName>
            <MethodComment>/** 
 * Overrides the or operator to allow one Process to asynchronously pipe data to another Process.
 * @param left  a Process instance
 * @param right a Process to pipe output to
 * @return the second Process to allow chaining
 * @throws java.io.IOException if an IOException occurs.
 * @since 1.5.1
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ProcessRunner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>process</ParamName>
                    <FieldType>Process</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doProcessWait</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doProcessWait;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForOrKill</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>millis</ParamName>
                    <FieldType>long</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TextDumper</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <FieldType>InputStream</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>app</ParamName>
                    <FieldType>Appendable</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>InputStreamReader [isr=new InputStreamReader(in)]</InnerVar>
                <InnerVar>BufferedReader [br=new BufferedReader(isr)]</InnerVar>
                <InnerVar>String [next]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ByteDumper</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <FieldType>InputStream</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <FieldType>OutputStream</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [buf=new byte[8192]]</InnerVar>
                <InnerVar>int [next]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by &lt;code&gt;self&lt;/code&gt; as a command-line process. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param self a command line String
 * @return the Process which has just started for this command line representation
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by &lt;code&gt;self&lt;/code&gt; with environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param self a command line String to be executed.
 * @param envp an array of Strings, each element of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by &lt;code&gt;self&lt;/code&gt; with environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param self a command line String to be executed.
 * @param envp a List of Objects (converted to Strings using toString), each member of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the given &lt;code&gt;String&lt;/code&gt; array. The first item in the array is the command; the others are the parameters. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commandArray an array of &lt;code&gt;String&lt;/code&gt; containing the command name andparameters as separate items in the array.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commandArray</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the &lt;code&gt;String&lt;/code&gt; array given in the first parameter, with the environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. The first item in the array is the command; the others are the parameters. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commandArray an array of &lt;code&gt;String&lt;/code&gt; containing the command name andparameters as separate items in the array.
 * @param envp an array of Strings, each member of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commandArray</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the &lt;code&gt;String&lt;/code&gt; array given in the first parameter, with the environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. The first item in the array is the command; the others are the parameters. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commandArray an array of &lt;code&gt;String&lt;/code&gt; containing the command name andparameters as separate items in the array.
 * @param envp a List of Objects (converted to Strings using toString), each member of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commandArray</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the given list. The toString() method is called for each item in the list to convert into a resulting String. The first item in the list is the command the others are the parameters. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commands a list containing the command name andparameters as separate items in the list.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commands</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the given list, with the environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. The first item in the list is the command; the others are the parameters. The toString() method is called on items in the list to convert them to Strings. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commands a List containing the command name andparameters as separate items in the list.
 * @param envp an array of Strings, each member of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commands</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>String[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the command specified by the given list, with the environment defined by &lt;code&gt;envp&lt;/code&gt; and under the working directory &lt;code&gt;dir&lt;/code&gt;. The first item in the list is the command; the others are the parameters. The toString() method is called on items in the list to convert them to Strings. &lt;p&gt;For more control over Process construction you can use &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;.
 * @param commands a List containing the command name andparameters as separate items in the list.
 * @param envp a List of Objects (converted to Strings using toString), each member of whichhas environment variable settings in the format &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or &lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the environment of the current process.
 * @param dir  the working directory of the subprocess, or&lt;tt&gt;null&lt;/tt&gt; if the subprocess should inherit the working directory of the current process.
 * @return the Process which has just started for this command line representation.
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>Process</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commands</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>envp</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <FieldType>File</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringify</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>orig</ParamName>
                    <FieldType>List</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [result=new String[orig.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>