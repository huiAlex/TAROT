<Class>
    <Id>401</Id>
    <Package>org.codehaus.groovy.transform.stc</Package>
    <ClassName>StaticTypeCheckingVisitor</ClassName>
    <SuperClass>ClassCodeVisitorSupport</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StaticTypeCheckingVisitor  /** 
 * The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.
 * @author Cedric Champeau
 * @author Jochen Theodorou
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>DEBUG_GENERATED_CODE</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>UNIQUE_LONG</FieldName>
            <FieldType>AtomicLong</FieldType>
        </Field>
        <Field>
            <FieldName>ERROR_COLLECTOR</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>ITERABLE_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_METHODNODE_LIST</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_METHODNODE_LIST</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>TYPECHECKED_CLASSNODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>TYPECHECKING_ANNOTATIONS</FieldName>
            <FieldType>ClassNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>TYPECHECKING_INFO_NODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>DGM_CLASSNODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>CURRENT_SIGNATURE_PROTOCOL_VERSION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CURRENT_SIGNATURE_PROTOCOL</FieldName>
            <FieldType>Expression</FieldType>
        </Field>
        <Field>
            <FieldName>GET_DELEGATE</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>GET_OWNER</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>GET_THISOBJECT</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>DELEGATES_TO</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>DELEGATES_TO_TARGET</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>LINKEDHASHMAP_CLASSNODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>CLOSUREPARAMS_CLASSNODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>MAP_ENTRY_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>ENUMERATION_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>GENERATED_EMPTY_STATEMENT</FieldName>
            <FieldType>Statement</FieldType>
        </Field>
        <Field>
            <FieldName>CLOSURE_CALL_NO_ARG</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>CLOSURE_CALL_ONE_ARG</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>CLOSURE_CALL_VARGS</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_STRING_ARRAY</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>returnListener</FieldName>
            <FieldType>ReturnAdder.ReturnStatementListener</FieldType>
        </Field>
        <Field>
            <FieldName>returnAdder</FieldName>
            <FieldType>ReturnAdder</FieldType>
        </Field>
        <Field>
            <FieldName>typeCheckingContext</FieldName>
            <FieldType>TypeCheckingContext</FieldType>
        </Field>
        <Field>
            <FieldName>extension</FieldName>
            <FieldType>DefaultTypeCheckingExtension</FieldType>
        </Field>
        <Field>
            <FieldName>varOrigType</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>varOrigType</FieldName>
            <FieldType>VariableExpression</FieldType>
        </Field>
        <Field>
            <FieldName>receiverType</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>name</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>setters</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>setters</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>returnStatementAdded</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnStatement</ParamName>
                    <FieldType>ReturnStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [returnType=checkReturnType(returnStatement)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StaticTypeCheckingVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>SourceUnit</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.typeCheckingContext;pushEnclosingClassNode;[cn]</InnerMethodInvoke>
                <InnerMethodInvoke>this.typeCheckingContext;pushErrorCollector;[source.getErrorCollector()]</InnerMethodInvoke>
                <InnerMethodInvoke>this.typeCheckingContext;pushTemporaryTypeInfo;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDefaultTypeCheckingExtension</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultTypeCheckingExtension</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DefaultTypeCheckingExtension [ext=new DefaultTypeCheckingExtension(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ext;addHandler;[new TraitTypeCheckingExtension(this)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceUnit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SourceUnit</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>extension;setup;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCheckingContext</MethodName>
            <MethodComment>/** 
 * Returns the current type checking context. The context is used internally by the type checker during type checking to store various state data.
 * @return the type checking context
 */
</MethodComment>
            <ReturnType>TypeCheckingContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTypeCheckingExtension</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>extension</ParamName>
                    <FieldType>TypeCheckingExtension</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.extension;addHandler;[extension]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCompilationUnit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cu</ParamName>
                    <FieldType>CompilationUnit</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;setCompilationUnit;[cu]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [type=node.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE)]</InnerVar>
                <InnerVar>Set&lt;MethodNode&gt; [oldVisitedMethod=typeCheckingContext.alreadyVisitedMethods]</InnerVar>
                <InnerVar>Iterator&lt;InnerClassNode&gt; [innerClasses=node.getInnerClasses()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingClassNode;[node]</InnerMethodInvoke>
                <InnerMethodInvoke>node;putNodeMetaData;[StaticTypesMarker.INFERRED_TYPE, node]</InnerMethodInvoke>
                <InnerMethodInvoke>extension;afterVisitClass;[node]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shouldSkipClassNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCheckingAnnotations</MethodName>
            <MethodComment>/** 
 * Returns the list of type checking annotations class nodes. Subclasses may override this method in order to provide additional classes which must be looked up when checking if a method or a class node should be skipped. &lt;p&gt; The default implementation returns  {@link TypeChecked}.
 * @return array of class nodes
 */
</MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSkipMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>AnnotatedNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSkippedInnerClass</MethodName>
            <MethodComment>/** 
 * Test if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.
 * @param node
 * @return true if the inner class node should be skipped
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>AnnotatedNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodNode [enclosingMethod=((InnerClassNode)node).getEnclosingMethod()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitClassExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClassExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [cn=(ClassNode)expression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPrivateFieldOrMethodAccess</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>StaticTypesMarker</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>accessedMember</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;ASTNode&gt; [set=(Set&lt;ASTNode&gt;)cn.getNodeMetaData(type)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>set;add;[accessedMember]</InnerMethodInvoke>
                <InnerMethodInvoke>source;putNodeMetaData;[type, accessedMember]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkOrMarkPrivateAccess</MethodName>
            <MethodComment>/** 
 * Given a field node, checks if we are calling a private field from an inner class.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>fn</ParamName>
                    <FieldType>FieldNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkOrMarkPrivateAccess</MethodName>
            <MethodComment>/** 
 * Given a method node, checks if we are calling a private method from an inner class.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>mn</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [declaringClass=mn.getDeclaringClass()]</InnerVar>
                <InnerVar>ClassNode [enclosingClassNode=typeCheckingContext.getEnclosingClassNode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkSuperCallFromClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>directCallTarget</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeType</MethodName>
            <MethodComment>/** 
 * wrap type in Class&lt;&gt; if usingClass==true
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>usingClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeTypeForThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vexp</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [enclosingClassNode=typeCheckingContext.getEnclosingClassNode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeType;[vexp, makeType(enclosingClassNode,typeCheckingContext.isInStaticContext)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeTypeForSuper</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vexp</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [superClassNode=typeCheckingContext.getEnclosingClassNode().getSuperClass()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeType;[vexp, makeType(superClassNode,typeCheckingContext.isInStaticContext)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitVariableExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vexp</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeCheckingContext.EnclosingClosure [enclosingClosure=typeCheckingContext.getEnclosingClosure()]</InnerVar>
                <InnerVar>DynamicVariable [dyn=(DynamicVariable)vexp.getAccessedVariable()]</InnerVar>
                <InnerVar>String [dynName=dyn.getName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tryVariableExpressionAsProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vexp</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>dynName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>VariableExpression [implicitThis=new VariableExpression("this")]</InnerVar>
                <InnerVar>PropertyExpression [pe=new PropertyExpression(implicitThis,dynName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pe;setImplicitThis;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPropertyExpressionSilent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pe</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>lhsPart</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPropertyExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLHSOfEnclosingAssignment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BinaryExpression [ec=typeCheckingContext.getEnclosingBinaryExpression()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitAttributeExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>AttributeExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitRangeExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>RangeExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [fromType=getWrapper(getType(expression.getFrom()))]</InnerVar>
                <InnerVar>ClassNode [toType=getWrapper(getType(expression.getTo()))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitBinaryExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>BinaryExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BinaryExpression [enclosingBinaryExpression=typeCheckingContext.getEnclosingBinaryExpression()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingBinaryExpression;[expression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureValidSetter</MethodName>
            <MethodComment>/** 
 * Given a binary expression corresponding to an assignment, will check that the type of the RHS matches one of the possible setters and if not, throw a type checking error.
 * @param expression the assignment expression
 * @param leftExpression left expression of the assignment
 * @param rightExpression right expression of the assignment
 * @param setterInfo possible setters
 * @return true if type checking passed
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>setterInfo</ParamName>
                    <FieldType>SetterInfo</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>VariableExpression [ve=new VariableExpression("%",setterInfo.receiverType)]</InnerVar>
                <InnerVar>MethodCallExpression [call=new MethodCallExpression(ve,setterInfo.name,rightExpression)]</InnerVar>
                <InnerVar>MethodNode [directSetterCandidate=call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>call;setImplicitThis;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitMethodCallExpression;[call]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOriginalDeclarationType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lhs</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferDiamondType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cce</ParamName>
                    <FieldType>ConstructorCallExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>lType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [node=cce.getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushInstanceOfTypeInfo</MethodName>
            <MethodComment>/** 
 * Stores information about types when [objectOfInstanceof instanceof typeExpression] is visited
 * @param objectOfInstanceOf the expression which must be checked against instanceof
 * @param typeExpression     the expression which represents the target type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectOfInstanceOf</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>typeExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;Object,List&lt;ClassNode&gt;&gt; [tempo=typeCheckingContext.temporaryIfBranchTypeInformation.peek()]</InnerVar>
                <InnerVar>Object [key=extractTemporaryTypeInfoKey(objectOfInstanceOf)]</InnerVar>
                <InnerVar>List&lt;ClassNode&gt; [potentialTypes=tempo.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>potentialTypes;add;[typeExpression.getType()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMultipleAssignmentAndContinue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TupleExpression [tuple=(TupleExpression)leftExpression]</InnerVar>
                <InnerVar>ListExpression [list=(ListExpression)rightExpression]</InnerVar>
                <InnerVar>List&lt;Expression&gt; [listExpressions=list.getExpressions()]</InnerVar>
                <InnerVar>List&lt;Expression&gt; [tupleExpressions=tuple.getExpressions()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustTypeForSpreading</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inferredRightExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [wrappedRHS=inferredRightExpressionType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addedReadOnlyPropertyError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [name=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Cannot set read-only property: " + name, expr]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPrecisionErrors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftRedirect</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>lhsType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>inferredrhsType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [leftComponentType=lhsType.getComponentType()]</InnerVar>
                <InnerVar>ClassNode [rightRedirect=rightExpression.getType().redirect()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addListAssignmentConstructorErrors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftRedirect</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>inferredRightExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>assignmentExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMapAssignmentConstructorErrors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftRedirect</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkTypeGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>wrappedRHS</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType [gt=GenericsUtils.buildWildcardType(leftExpressionType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Incompatible generic argument types. Cannot assign " + wrappedRHS.toString(false) + " to: "+ leftExpressionType.toString(false), rightExpression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasGStringStringError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>wrappedRHS</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckAssignment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>assignmentExpression</ParamName>
                    <FieldType>BinaryExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>leftExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>inferredRightExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [leftRedirect=leftExpressionType.redirect()]</InnerVar>
                <InnerVar>ClassNode [wrappedRHS=adjustTypeForSpreading(inferredRightExpressionType,leftExpression)]</InnerVar>
                <InnerVar>boolean [compatible=checkCompatibleAssignmentTypes(leftRedirect,wrappedRHS,rightExpression)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkGroovyConstructorMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiverType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>mapExpression</ParamName>
                    <FieldType>MapExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingBinaryExpression;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;popEnclosingBinaryExpression;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasRHSIncompleteGenericTypeInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inferredRightExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [replaceType=false]</InnerVar>
                <InnerVar>GenericsType[] [genericsTypes=inferredRightExpressionType.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkGroovyStyleConstructor</MethodName>
            <MethodComment>/** 
 * Checks that a constructor style expression is valid regarding the number of arguments and the argument types.
 * @param node      the class node for which we will try to find a matching constructor
 * @param arguments the constructor arguments
 * @deprecated use {@link #checkGroovyStyleConstructor(org.codehaus.groovy.ast.ClassNode,org.codehaus.groovy.ast.ClassNode[],org.codehaus.groovy.ast.ASTNode)} )}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkGroovyStyleConstructor;[node, arguments, typeCheckingContext.getEnclosingClassNode()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkGroovyStyleConstructor</MethodName>
            <MethodComment>/** 
 * Checks that a constructor style expression is valid regarding the number of arguments and the argument types.
 * @param node      the class node for which we will try to find a matching constructor
 * @param arguments the constructor arguments
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ConstructorNode&gt; [constructors=node.getDeclaredConstructors()]</InnerVar>
                <InnerVar>List&lt;MethodNode&gt; [constructorList=findMethod(node,"&lt;init&gt;",arguments)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractTemporaryTypeInfoKey</MethodName>
            <MethodComment>/** 
 * When instanceof checks are found in the code, we store temporary type information data in the  {@link TypeCheckingContext#temporaryIfBranchTypeInformation} table. This method computes the key which must be used to store this typeinfo.
 * @param expression the expression for which to compute the key
 * @return a key to be used for {@link TypeCheckingContext#temporaryIfBranchTypeInformation}
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findCurrentInstanceOfClass</MethodName>
            <MethodComment>/** 
 * A helper method which determines which receiver class should be used in error messages when a field or attribute is not found. The returned type class depends on whether we have temporary type information availble (due to instanceof checks) and whether there is a single candidate in that case.
 * @param expr the expression for which an unknown field has been found
 * @param type the type of the expression (used as fallback type)
 * @return if temporary information is available and there's only one type, returns the temporary type classotherwise falls back to the provided type class.
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>checkForReadOnly</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsProperty</MethodName>
            <MethodComment>/** 
 * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the temporary type information table)
 * @param pexp             a property expression
 * @param readMode         if true, look for property read, else for property set
 * @param visitor          if not null, when the property node is found, visit it with the provided visitor
 * @return true if the property is defined in any of the possible receiver classes
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>readMode</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>visitor</ParamName>
                    <FieldType>ClassCodeVisitorSupport</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [propertyName=pexp.getPropertyAsString()]</InnerVar>
                <InnerVar>Expression [objectExpression=pexp.getObjectExpression()]</InnerVar>
                <InnerVar>ClassNode [objectExpressionType=getType(objectExpression)]</InnerVar>
                <InnerVar>boolean [staticOnlyAccess=isClassClassNodeWrappingConcreteType(objectExpressionType)]</InnerVar>
                <InnerVar>boolean [foundGetterOrSetter=false]</InnerVar>
                <InnerVar>List&lt;Receiver&lt;String&gt;&gt; [receivers=new LinkedList&lt;Receiver&lt;String&gt;&gt;()]</InnerVar>
                <InnerVar>List&lt;Receiver&lt;String&gt;&gt; [owners=makeOwnerList(objectExpression)]</InnerVar>
                <InnerVar>String [capName=MetaClassHelper.capitalize(propertyName)]</InnerVar>
                <InnerVar>boolean [isAttributeExpression=pexp instanceof AttributeExpression]</InnerVar>
                <InnerVar>HashSet&lt;ClassNode&gt; [handledNodes=new HashSet&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addReceivers;[receivers, owners, pexp.isImplicitThis()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeForSpreadExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>testClass</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>objectExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodCallExpression [mce=new MethodCallExpression(new VariableExpression("_",testClass),"iterator",ArgumentListExpression.EMPTY_ARGUMENTS)]</InnerVar>
                <InnerVar>ClassNode [callType=getType(mce)]</InnerVar>
                <InnerVar>GenericsType[] [types=callType.getGenericsTypes()]</InnerVar>
                <InnerVar>ClassNode [contentType=OBJECT_TYPE]</InnerVar>
                <InnerVar>PropertyExpression [subExp=new PropertyExpression(new VariableExpression("{}",contentType),pexp.getPropertyAsString())]</InnerVar>
                <InnerVar>AtomicReference&lt;ClassNode&gt; [result=new AtomicReference&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mce;visit;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeForListPropertyExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>testClass</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>objectExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [intf=GenericsUtils.parameterizeType(objectExpressionType,LIST_TYPE.getPlainNodeReference())]</InnerVar>
                <InnerVar>GenericsType[] [types=intf.getGenericsTypes()]</InnerVar>
                <InnerVar>PropertyExpression [subExp=new PropertyExpression(new VariableExpression("{}",types[0].getType()),pexp.getPropertyAsString())]</InnerVar>
                <InnerVar>AtomicReference&lt;ClassNode&gt; [result=new AtomicReference&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeForMapPropertyExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>testClass</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>objectExpressionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [intf]</InnerVar>
                <InnerVar>GenericsType[] [types=intf.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allowStaticAccessToMember</MethodName>
            <MethodComment>/** 
 * This method is used to filter search results in which null means "no match", to filter out illegal access to instance members from a static context. Return null if the given member is not static, but we want to access in a static way (staticOnly=true). If we want to access in a non-static way we always return the member, since then access to static members and non-static members is allowed.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>member</ParamName>
                    <FieldType>T</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>staticOnly</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isStatic=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeWithResolve</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeToResolve</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expressionToStoreOn</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [type=typeToResolve]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeInferredTypeForPropertyExpression;[expressionToStoreOn, type]</InnerMethodInvoke>
                <InnerMethodInvoke>null;storeType;[expressionToStoreOn, type]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeField</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>field</ParamName>
                    <FieldType>FieldNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>returnTrueIfFieldExists</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expressionToStoreOn</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>visitor</ParamName>
                    <FieldType>ClassCodeVisitorSupport</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>delegationData</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeWithResolve;[field.getOriginType(), receiver, field.getDeclaringClass(), field.isStatic(), expressionToStoreOn]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkOrMarkPrivateAccess;[expressionToStoreOn, field]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>propertyNode</ParamName>
                    <FieldType>PropertyNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expressionToStoreOn</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>visitor</ParamName>
                    <FieldType>ClassCodeVisitorSupport</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>delegationData</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeWithResolve;[propertyNode.getOriginType(), receiver, propertyNode.getDeclaringClass(), propertyNode.isStatic(), expressionToStoreOn]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeInferredTypeForPropertyExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>flatInferredType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasSetter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SetterInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pexp</ParamName>
                    <FieldType>PropertyExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [propertyName=pexp.getPropertyAsString()]</InnerVar>
                <InnerVar>Expression [objectExpression=pexp.getObjectExpression()]</InnerVar>
                <InnerVar>List&lt;Receiver&lt;String&gt;&gt; [receivers=new LinkedList&lt;Receiver&lt;String&gt;&gt;()]</InnerVar>
                <InnerVar>List&lt;Receiver&lt;String&gt;&gt; [owners=makeOwnerList(objectExpression)]</InnerVar>
                <InnerVar>String [capName=MetaClassHelper.capitalize(propertyName)]</InnerVar>
                <InnerVar>boolean [isAttributeExpression=pexp instanceof AttributeExpression]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addReceivers;[receivers, owners, pexp.isImplicitThis()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>PropertyNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [osc=typeCheckingContext.isInStaticContext]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitField</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>FieldNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [osc=typeCheckingContext.isInStaticContext]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitForLoop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forLoop</ParamName>
                    <FieldType>ForStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,ClassNode&gt; [varOrigType=new HashMap&lt;VariableExpression,ClassNode&gt;()]</InnerVar>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
                <InnerVar>Expression [collectionExpression=forLoop.getCollectionExpression()]</InnerVar>
                <InnerVar>boolean [typeChanged=isSecondPassNeededForControlStructure(varOrigType,oldTracker)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>forLoop.getLoopBlock();visit;[new VariableExpressionTypeMemoizer(varOrigType)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferLoopElementType</MethodName>
            <MethodComment>/** 
 * Given a loop collection type, returns the inferred type of the loop element. Used, for example, to infer the element type of a (for e in list) loop.
 * @param collectionType the type of the collection
 * @return the inferred component type
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collectionType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [componentType=collectionType.getComponentType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSecondPassNeededForControlStructure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>varOrigType</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>oldTracker</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,ClassNode&gt; [assignedVars=popAssignmentTracking(oldTracker)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitWhileLoop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loop</ParamName>
                    <FieldType>WhileStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;popAssignmentTracking;[oldTracker]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitBitwiseNegationExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>BitwiseNegationExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [type=getType(expression)]</InnerVar>
                <InnerVar>ClassNode [typeRe=type.redirect()]</InnerVar>
                <InnerVar>ClassNode [resultType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeType;[expression, resultType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitUnaryPlusExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>UnaryPlusExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;negativeOrPositiveUnary;[expression, "positive"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitUnaryMinusExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>UnaryMinusExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;negativeOrPositiveUnary;[expression, "negative"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPostfixExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>PostfixExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Expression [inner=expression.getExpression()]</InnerVar>
                <InnerVar>int [op=expression.getOperation().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitPrefixOrPostifExpression;[expression, inner, op]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPrefixExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>PrefixExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Expression [inner=expression.getExpression()]</InnerVar>
                <InnerVar>int [type=expression.getOperation().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitPrefixOrPostifExpression;[expression, inner, type]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMathWideningClassNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPrefixOrPostifExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>origin</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>innerExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>operationType</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isPostfix=origin instanceof PostfixExpression]</InnerVar>
                <InnerVar>ClassNode [exprType=getType(innerExpression)]</InnerVar>
                <InnerVar>String [name=operationType == PLUS_PLUS ? "next" : operationType == MINUS_MINUS ? "previous" : null]</InnerVar>
                <InnerVar>MethodNode [node=findMethodOrFail(innerExpression,exprType,name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>negativeOrPositiveUnary</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [type=getType(expression)]</InnerVar>
                <InnerVar>ClassNode [typeRe=type.redirect()]</InnerVar>
                <InnerVar>ClassNode [resultType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeType;[expression, resultType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitConstructorOrMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstructor</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingMethod;[node]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;popEnclosingMethod;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitReturnStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <FieldType>ReturnStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>returnListener;returnStatementAdded;[statement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkReturnType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <FieldType>ReturnStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Expression [expression=statement.getExpression()]</InnerVar>
                <InnerVar>ClassNode [type=getType(expression)]</InnerVar>
                <InnerVar>MethodNode [enclosingMethod=typeCheckingContext.getEnclosingMethod()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addClosureReturnType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext.getEnclosingClosure();addReturnType;[returnType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitConstructorCallExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>ConstructorCallExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [receiver=call.isThisCall() ? typeCheckingContext.getEnclosingClassNode() : call.isSuperCall() ? typeCheckingContext.getEnclosingClassNode().getSuperClass() : call.getType()]</InnerVar>
                <InnerVar>Expression [arguments=call.getArguments()]</InnerVar>
                <InnerVar>ArgumentListExpression [argumentList=InvocationWriter.makeArgumentList(arguments)]</InnerVar>
                <InnerVar>ClassNode[] [args=getArgumentTypes(argumentList)]</InnerVar>
                <InnerVar>MethodNode [node=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkForbiddenSpreadArgument;[argumentList]</InnerMethodInvoke>
                <InnerMethodInvoke>extension;afterMethodCall;[call]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMapConstructor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>ConstructorCallExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodNode [node=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getArgumentTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ArgumentListExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Expression&gt; [arglist=args.getExpressions()]</InnerVar>
                <InnerVar>ClassNode[] [ret=new ClassNode[arglist.size()]]</InnerVar>
                <InnerVar>int [i=0]</InnerVar>
                <InnerVar>Map&lt;Object,List&lt;ClassNode&gt;&gt; [info=typeCheckingContext.temporaryIfBranchTypeInformation.empty() ? null : typeCheckingContext.temporaryIfBranchTypeInformation.peek()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitClosureExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [oldStaticContext=typeCheckingContext.isInStaticContext]</InnerVar>
                <InnerVar>Map&lt;VariableExpression,ClassNode&gt; [varOrigType=new HashMap&lt;VariableExpression,ClassNode&gt;()]</InnerVar>
                <InnerVar>Statement [code=expression.getCode()]</InnerVar>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
                <InnerVar>SharedVariableCollector [collector=new SharedVariableCollector(getSourceUnit())]</InnerVar>
                <InnerVar>Set&lt;VariableExpression&gt; [closureSharedExpressions=collector.getClosureSharedExpressions()]</InnerVar>
                <InnerVar>Map&lt;VariableExpression,ListHashMap&gt; [typesBeforeVisit=null]</InnerVar>
                <InnerVar>DelegationMetadata [dmd=getDelegationMetadata(expression)]</InnerVar>
                <InnerVar>MethodNode [node=new MethodNode("dummy",0,ClassHelper.OBJECT_TYPE,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,code)]</InnerVar>
                <InnerVar>TypeCheckingContext.EnclosingClosure [enclosingClosure=typeCheckingContext.getEnclosingClosure()]</InnerVar>
                <InnerVar>boolean [typeChanged=isSecondPassNeededForControlStructure(varOrigType,oldTracker)]</InnerVar>
                <InnerVar>Parameter[] [parameters=expression.getParameters()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>code;visit;[new VariableExpressionTypeMemoizer(varOrigType)]</InnerMethodInvoke>
                <InnerMethodInvoke>collector;visitClosureExpression;[expression]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingClosureExpression;[expression]</InnerMethodInvoke>
                <InnerMethodInvoke>returnAdder;visitMethod;[node]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;popEnclosingClosure;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;restoreVariableExpressionMetadata;[typesBeforeVisit]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wrapClosureType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [inferredType=CLOSURE_TYPE.getPlainNodeReference()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>inferredType;setGenericsTypes;[new GenericsType[]{new GenericsType(wrapTypeIfNecessary(returnType))}]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDelegationMetadata</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DelegationMetadata</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreVariableExpressionMetadata</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typesBeforeVisit</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>saveVariableExpressionMetadata</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closureSharedExpressions</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>typesBeforeVisit</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shouldSkipMethodNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [type=node.getNodeMetaData(StaticTypeCheckingVisitor.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>extension;afterVisitMethod;[node]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitConstructor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ConstructorNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startMethodInference</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>collector</ParamName>
                    <FieldType>ErrorCollector</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [osc=typeCheckingContext.isInStaticContext]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext.alreadyVisitedMethods;add;[node]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;pushErrorCollector;[collector]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;popErrorCollector;[]</InnerMethodInvoke>
                <InnerMethodInvoke>node;putNodeMetaData;[ERROR_COLLECTOR, collector]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTypeCheckingInfoAnnotation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [rtype=getInferredReturnType(node)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitStaticMethodCallExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>StaticMethodCallExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [name=call.getMethod()]</InnerVar>
                <InnerVar>ClassNode [rememberLastItType=typeCheckingContext.lastImplicitItType]</InnerVar>
                <InnerVar>Expression [callArguments=call.getArguments()]</InnerVar>
                <InnerVar>ArgumentListExpression [argumentList=InvocationWriter.makeArgumentList(callArguments)]</InnerVar>
                <InnerVar>ClassNode [receiver=call.getOwnerType()]</InnerVar>
                <InnerVar>ClassNode[] [args=getArgumentTypes(argumentList)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkForbiddenSpreadArgument;[argumentList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitMethodCallArguments;[receiver, argumentList, false, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkClosureParameters</MethodName>
            <MethodComment>/** 
 * @deprecated this method is unused, replaced with {@link DelegatesTo} inference.
 * @param callArguments
 * @param receiver
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callArguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>silentlyVisitMethodNode</MethodName>
            <MethodComment>/** 
 * visit a method call target, to infer the type. Don't report errors right away, that will be done by a later visitMethod call
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>directMethodCallCandidate</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ErrorCollector [collector=new ErrorCollector(typeCheckingContext.getErrorCollector().getConfiguration())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;startMethodInference;[directMethodCallCandidate, collector]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMethodCallArguments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>ArgumentListExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>visitClosures</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>selectedMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parameter[] [params=selectedMethod != null ? selectedMethod.getParameters() : Parameter.EMPTY_ARRAY]</InnerVar>
                <InnerVar>List&lt;Expression&gt; [expressions=new LinkedList&lt;Expression&gt;(arguments.getExpressions())]</InnerVar>
                <InnerVar>ArgumentListExpression [newArgs=new ArgumentListExpression(expressions)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferClosureParameterTypes</MethodName>
            <MethodComment>/** 
 * This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;. In this case, the type checker tries to find if the &lt;code&gt;collect&lt;/code&gt; method has its  {@link Closure} argumentannotated with  {@link groovy.transform.stc.ClosureParams}. If yes, then additional type inference can be performed and the type of &lt;code&gt;it&lt;/code&gt; may be inferred.
 * @param receiver
 * @param arguments
 * @param expression a closure expression for which the argument types should be inferred
 * @param param the parameter where to look for a {@link groovy.transform.stc.ClosureParams} annotation.
 * @param selectedMethod the method accepting a closure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>param</ParamName>
                    <FieldType>Parameter</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>selectedMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;AnnotationNode&gt; [annotations=param.getAnnotations(CLOSUREPARAMS_CLASSNODE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferSAMType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>param</ParamName>
                    <FieldType>Parameter</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodWithSAMParameter</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>originalMethodCallArguments</ParamName>
                    <FieldType>ArgumentListExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>openBlock</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [targetMethodDeclarationClassConnections=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
                <InnerVar>Parameter[] [parametersOfMethodContainingSAM=methodWithSAMParameter.getParameters()]</InnerVar>
                <InnerVar>ClassNode [paramTypeWithReceiverInformation=applyGenericsContext(targetMethodDeclarationClassConnections,param.getOriginType())]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [SAMTypeConnections=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
                <InnerVar>ClassNode [classForSAM=paramTypeWithReceiverInformation.redirect()]</InnerVar>
                <InnerVar>MethodNode [methodForSAM=findSAM(classForSAM)]</InnerVar>
                <InnerVar>ClassNode[] [parameterTypesForSAM=extractTypesFromParameters(methodForSAM.getParameters())]</InnerVar>
                <InnerVar>ClassNode[] [blockParameterTypes=(ClassNode[])openBlock.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;extractGenericsConnections;[targetMethodDeclarationClassConnections, receiver, receiver.redirect()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;extractGenericsConnections;[SAMTypeConnections, paramTypeWithReceiverInformation, classForSAM]</InnerMethodInvoke>
                <InnerMethodInvoke>openBlock;putNodeMetaData;[StaticTypesMarker.CLOSURE_ARGUMENTS, blockParameterTypes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSignaturesFromHint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>selectedMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>hintClass</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ClassNode[]&gt; [closureSignatures=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransformLoader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CompilationUnit [compilationUnit=typeCheckingContext.getCompilationUnit()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doInferClosureParameterTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>selectedMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>hintClass</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ClassNode[]&gt; [closureSignatures=getSignaturesFromHint(expression,selectedMethod,hintClass,options)]</InnerVar>
                <InnerVar>List&lt;ClassNode[]&gt; [candidates=new LinkedList&lt;ClassNode[]&gt;()]</InnerVar>
                <InnerVar>Parameter[] [closureParams=expression.getParameters()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveGenericsFromTypeHint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>selectedMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>signature</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [dummyResultNode=new ClassNode("ClForInference$" + UNIQUE_LONG.incrementAndGet(),0,OBJECT_TYPE).getPlainNodeReference()]</InnerVar>
                <InnerVar>GenericsType[] [genericTypes=new GenericsType[signature.length]]</InnerVar>
                <InnerVar>MethodNode [dummyMN=selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode)selectedMethod).getExtensionMethodNode() : selectedMethod]</InnerVar>
                <InnerVar>ClassNode [classNode=inferReturnTypeGenerics(receiver,dummyMN,arguments)]</InnerVar>
                <InnerVar>ClassNode[] [inferred=new ClassNode[classNode.getGenericsTypes().length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dummyResultNode;setGenericsTypes;[genericTypes]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyMN;setDeclaringClass;[selectedMethod.getDeclaringClass()]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyMN;setGenericsTypes;[selectedMethod.getGenericsTypes()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createUsableClassNodeFromGenericsType</MethodName>
            <MethodComment>/** 
 * Given a GenericsType instance, returns a ClassNode which can be used as an inferred type.
 * @param genericsType a {@link org.codehaus.groovy.ast.GenericsType} representing either a type, a placeholder or a wildcard
 * @return a class node usable as an inferred type
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>genericsType</ParamName>
                    <FieldType>GenericsType</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [value=genericsType.getType()]</InnerVar>
                <InnerVar>ClassNode [lowerBound=genericsType.getLowerBound()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertToStringArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>options</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkClosureWithDelegatesTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>mn</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>ArgumentListExpression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <FieldType>Parameter[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>param</ParamName>
                    <FieldType>Parameter</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;AnnotationNode&gt; [annotations=param.getAnnotations(DELEGATES_TO)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addReceivers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receivers</ParamName>
                    <FieldType>Receiver&lt;String&gt;</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>owners</ParamName>
                    <FieldType>Receiver&lt;String&gt;</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>implicitThis</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DelegationMetadata [dmd=typeCheckingContext.delegationMetadata]</InnerVar>
                <InnerVar>StringBuilder [path=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMethodCallExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>MethodCallExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [name=call.getMethodAsString()]</InnerVar>
                <InnerVar>Expression [objectExpression=call.getObjectExpression()]</InnerVar>
                <InnerVar>ClassNode [rememberLastItType=typeCheckingContext.lastImplicitItType]</InnerVar>
                <InnerVar>Expression [callArguments=call.getArguments()]</InnerVar>
                <InnerVar>ArgumentListExpression [argumentList=InvocationWriter.makeArgumentList(callArguments)]</InnerVar>
                <InnerVar>ClassNode [receiver=getType(objectExpression)]</InnerVar>
                <InnerVar>ClassNode[] [args=getArgumentTypes(argumentList)]</InnerVar>
                <InnerVar>boolean [isCallOnClosure=isClosureCall(name,objectExpression,callArguments)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushEnclosingMethodCall;[call]</InnerMethodInvoke>
                <InnerMethodInvoke>objectExpression;visit;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>call.getMethod();visit;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkForbiddenSpreadArgument;[argumentList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitMethodCallArguments;[receiver, argumentList, false, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustWithTraits</MethodName>
            <MethodComment>/** 
 * A special method handling the "withTrait" call for which the type checker knows more than what the type signature is able to tell. If "withTrait" is detected, then a new class node is created representing the list of trait interfaces.
 * @param directMethodCallCandidate a method selected by the type checker
 * @param receiver the receiver of the method call
 * @param args the arguments of the method call
 * @param returnType the original return type, as inferred by the type checker   @return fixed return type if the selected method is {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#withTraits(Object,Class[]) withTraits}
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>directMethodCallCandidate</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addArrayMethods</MethodName>
            <MethodComment>/** 
 * add various getAt and setAt methods for primitive arrays
 * @param receiver the receiver class
 * @param name  the name of the method
 * @param args the argument classes
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInferredReturnTypeFromWithClosureArgument</MethodName>
            <MethodComment>/** 
 * In the case of a &lt;em&gt;Object.with { ... }&lt;/em&gt; call, this method is supposed to retrieve the inferred closure return type.
 * @param callArguments the argument list from the &lt;em&gt;Object#with(Closure)&lt;/em&gt; call, ie. a single closure expression
 * @return the inferred closure return type or &lt;em&gt;null&lt;/em&gt;
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callArguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArgumentListExpression [argList=(ArgumentListExpression)callArguments]</InnerVar>
                <InnerVar>ClosureExpression [closure=(ClosureExpression)argList.getExpression(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitClosureExpression;[closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeOwnerList</MethodName>
            <MethodComment>/** 
 * Given an object expression (a receiver expression), generate the list of potential receiver types.
 * @param objectExpression the receiver expression
 * @return the list of types the receiver may be
 */
</MethodComment>
            <ReturnType>Receiver&lt;String&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [receiver=getType(objectExpression)]</InnerVar>
                <InnerVar>List&lt;Receiver&lt;String&gt;&gt; [owners=new LinkedList&lt;Receiver&lt;String&gt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owners;add;[Receiver.&lt;String&gt;make(receiver)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSelfTypes;[receiver, owners]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSelfTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>owners</ParamName>
                    <FieldType>Receiver&lt;String&gt;</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LinkedHashSet&lt;ClassNode&gt; [selfTypes=new LinkedHashSet&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkForbiddenSpreadArgument</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>argumentList</ParamName>
                    <FieldType>ArgumentListExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTemporaryTypesForExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ClassNode&gt; [classNodes=null]</InnerVar>
                <InnerVar>int [depth=typeCheckingContext.temporaryIfBranchTypeInformation.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeTargetMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>directMethodCallCandidate</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>call;putNodeMetaData;[StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directMethodCallCandidate]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkOrMarkPrivateAccess;[call, directMethodCallCandidate]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkSuperCallFromClosure;[call, directMethodCallCandidate]</InnerMethodInvoke>
                <InnerMethodInvoke>extension;onMethodSelection;[call, directMethodCallCandidate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosureCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>objectExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckClosureCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callArguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <FieldType>Parameter[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitIfElse</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ifElse</ParamName>
                    <FieldType>IfStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitSwitch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <FieldType>SwitchStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCaseStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <FieldType>CaseStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;restoreTypeBeforeConditional;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreTypeBeforeConditional</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;Map.Entry&lt;VariableExpression,List&lt;ClassNode&gt;&gt;&gt; [entries=typeCheckingContext.ifElseForWhileAssignmentTracker.entrySet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popAssignmentTracking</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>VariableExpression</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldTracker</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,ClassNode&gt; [assignments=new HashMap&lt;VariableExpression,ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushAssignmentTracking</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>VariableExpression</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=typeCheckingContext.ifElseForWhileAssignmentTracker]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCastExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>CastExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeType;[expression, expression.getType()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDelegateOrOwnerInClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCast</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [sourceIsNull=isNullConstant(source)]</InnerVar>
                <InnerVar>ClassNode [expressionType=getType(source)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitTernaryExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>TernaryExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;VariableExpression,List&lt;ClassNode&gt;&gt; [oldTracker=pushAssignmentTracking()]</InnerVar>
                <InnerVar>Expression [trueExpression=expression.getTrueExpression()]</InnerVar>
                <InnerVar>Expression [falseExpression=expression.getFalseExpression()]</InnerVar>
                <InnerVar>ClassNode [resultType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeCheckingContext;pushTemporaryTypeInfo;[]</InnerMethodInvoke>
                <InnerMethodInvoke>expression.getBooleanExpression();visit;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>trueExpression;visit;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>typeCheckingContext;popTemporaryTypeInfo;[]</InnerMethodInvoke>
                <InnerMethodInvoke>falseExpression;visit;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;storeType;[expression, resultType]</InnerMethodInvoke>
                <InnerMethodInvoke>null;popAssignmentTracking;[oldTracker]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitTryCatchFinally</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <FieldType>TryCatchStatement</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;CatchStatement&gt; [catchStatements=statement.getCatchStatements()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [oldValue=(ClassNode)exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE,cn)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>op</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>BinaryExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [leftRedirect=left.redirect()]</InnerVar>
                <InnerVar>ClassNode [rightRedirect=right.redirect()]</InnerVar>
                <InnerVar>Expression [leftExpression=expr.getLeftExpression()]</InnerVar>
                <InnerVar>Expression [rightExpression=expr.getRightExpression()]</InnerVar>
                <InnerVar>String [operationName=getOperationName(op)]</InnerVar>
                <InnerVar>MethodNode [method=findMethodOrFail(expr,left,operationName,right)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferSAMTypeGenericsInAssignment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>samUsage</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sam</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closureType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closureExpression</ParamName>
                    <FieldType>ClosureExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [samGt=samUsage.getGenericsTypes()]</InnerVar>
                <InnerVar>GenericsType[] [closureGt=closureType.getGenericsTypes()]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [connections=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
                <InnerVar>Parameter[] [closureParams=closureExpression.getParameters()]</InnerVar>
                <InnerVar>Parameter[] [methodParams=sam.getParameters()]</InnerVar>
                <InnerVar>ClassNode [result=applyGenericsContext(connections,samUsage.redirect())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;extractGenericsConnections;[connections, closureType, sam.getReturnType()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGroupOperationResultType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>b</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferComponentType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>indexType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [componentType=containerType.getComponentType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMethodOrFail</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [methods=findMethod(receiver,name,args)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disambiguateMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>argTypes</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prettyPrintMethodList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nodes</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder("[")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["]"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>areCategoryMethodCalls</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>foundMethods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [category=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMethodsWithGenerated</MethodName>
            <MethodComment>/** 
 * This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add "non existing" methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet.
 * @param receiver the receiver where to find methods
 * @param name the name of the methods to return
 * @return the methods that are defined on the receiver completed with stubs for future methods
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [methods=receiver.getMethods(name)]</InnerVar>
                <InnerVar>List&lt;MethodNode&gt; [result=addGeneratedMethods(receiver,methods)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addGeneratedMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [result=new LinkedList&lt;MethodNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [methods]</InnerVar>
                <InnerVar>List&lt;MethodNode&gt; [chosen=chooseBestMethod(receiver,methods,args)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findDGMMethodsByNameAndArguments;[getTransformLoader(), receiver, name, args, methods]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractPropertyNameFromMethodName</MethodName>
            <MethodComment>/** 
 * Given a method name and a prefix, returns the name of the property that should be looked up, following the java beans rules. For example, "getName" would return "name", while "getFullName" would return "fullName". If the prefix is not found, returns null.
 * @param prefix the method name prefix ("get", "is", "set", ...)
 * @param methodName the method name
 * @return a property name if the prefix is found and the method matches the java beans rules, null otherwise
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAllInterfaceMethodsByName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode[] [interfaces=receiver.getInterfaces()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [cn=exp.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsResolvedTypeOfFieldOrProperty</MethodName>
            <MethodComment>/** 
 * resolves a Field or Property node generics by using the current class and the declaring class to extract the right meaning of the generics symbols
 * @param an a FieldNode or PropertyNode
 * @param type the origin type
 * @return the new ClassNode with corrected generics
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>an</ParamName>
                    <FieldType>AnnotatedNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [connections=new HashMap()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;extractGenericsConnections;[connections, typeCheckingContext.getEnclosingClassNode(), an.getDeclaringClass()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeSuper</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ClassNode [ret=typeCheckingContext.getEnclosingClassNode().getSuperClass()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ClassNode [ret=typeCheckingContext.getEnclosingClassNode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeSelf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>trait</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [ret=trait]</InnerVar>
                <InnerVar>LinkedHashSet&lt;ClassNode&gt; [selfTypes=new LinkedHashSet&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Traits;collectSelfTypes;[ret, selfTypes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeInferredReturnType</MethodName>
            <MethodComment>/** 
 * Stores the inferred return type of a closure or a method. We are using a separate key to store inferred return type because the inferred type of a closure is  {@link Closure}, which is different from the inferred type of the code of the closure.
 * @param node a {@link ClosureExpression} or a {@link MethodNode}
 * @param type the inferred return type of the code
 * @return the old value of the inferred type
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInferredReturnType</MethodName>
            <MethodComment>/** 
 * Returns the inferred return type of a closure or a method, if stored on the AST node. This method doesn't perform any type inference by itself.
 * @param exp a {@link ClosureExpression} or {@link MethodNode}
 * @return the inferred type, as stored on node metadata.
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferListExpressionType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>list</ParamName>
                    <FieldType>ListExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Expression&gt; [expressions=list.getExpressions()]</InnerVar>
                <InnerVar>ClassNode [listType=list.getType()]</InnerVar>
                <InnerVar>GenericsType[] [genericsTypes=listType.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNullConstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferMapExpressionType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <FieldType>MapExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [mapType=LINKEDHASHMAP_CLASSNODE.getPlainNodeReference()]</InnerVar>
                <InnerVar>List&lt;MapEntryExpression&gt; [entryExpressions=map.getMapEntryExpressions()]</InnerVar>
                <InnerVar>GenericsType[] [genericsTypes=mapType.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferReturnTypeGenerics</MethodName>
            <MethodComment>/** 
 * If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters. For example, the method Arrays.asList(T...) is generified with type T which can be deduced from actual type arguments.
 * @param method    the method node
 * @param arguments the method call arguments
 * @return parameterized, infered, class node
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferReturnTypeGenerics</MethodName>
            <MethodComment>/** 
 * If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters. For example, the method Arrays.asList(T...) is generified with type T which can be deduced from actual type arguments.
 * @param method    the method node
 * @param arguments the method call arguments
 * @param explicitTypeHints explicit type hints as found for example in Collections.&amp;lt;String&amp;gt;emptyList()
 * @return parameterized, infered, class node
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>explicitTypeHints</ParamName>
                    <FieldType>GenericsType[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [returnType=method.getReturnType()]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [resolvedPlaceholders=resolvePlaceHoldersFromDeclaration(receiver,getDeclaringClass(method,arguments),method,method.isStatic())]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [placeholdersFromContext=extractGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod())]</InnerVar>
                <InnerVar>Parameter[] [parameters=method.getParameters()]</InnerVar>
                <InnerVar>boolean [isVargs=isVargs(parameters)]</InnerVar>
                <InnerVar>ArgumentListExpression [argList=InvocationWriter.makeArgumentList(arguments)]</InnerVar>
                <InnerVar>List&lt;Expression&gt; [expressions=argList.getExpressions()]</InnerVar>
                <InnerVar>int [paramLength=parameters.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resolvePlaceholdersFromExplicitTypeHints;[method, explicitTypeHints, resolvedPlaceholders]</InnerMethodInvoke>
                <InnerMethodInvoke>null;applyGenericsConnections;[placeholdersFromContext, resolvedPlaceholders]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolvePlaceholdersFromExplicitTypeHints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>explicitTypeHints</ParamName>
                    <FieldType>GenericsType[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractGenericsConnectionsForSuperClassAndInterfaces</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertClosureTypeToSAMType</MethodName>
            <MethodComment>/** 
 * This method will convert a closure type to the appropriate SAM type, which will be used to infer return type generics.
 * @param closureType the inferred type of a closure (Closure&amp;lt;ClosureReturnType&amp;gt;)
 * @param samType the type into which the closure is coerced into
 * @return same SAM type, but completed with information from the closure node
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>closureType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>samType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholders</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodNode [sam=findSAM(samType)]</InnerVar>
                <InnerVar>ClassNode [result=applyGenericsContext(placeholders,samType.redirect())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveGenericsWithContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>currentType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [placeholdersFromContext=extractGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeclaringClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [declaringClass=method.getDeclaringClass()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolvePlaceHoldersFromDeclaration</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>declaration</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>isStaticTarget</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [resolvedPlaceholders]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGenericsPlaceHolderOrArrayOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractPlaceHolders</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [resolvedPlaceholders=null]</InnerVar>
                <InnerVar>List&lt;ClassNode&gt; [queue]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMethodsWithGenericsOrFail</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>candidateMethod</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>location</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toMethodGenericTypesString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [genericsTypes=node.getGenericsTypes()]</InnerVar>
                <InnerVar>StringBuilder [sb=new StringBuilder("&lt;")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["&gt; "]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatArgumentList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nodes</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder(24 * nodes.length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["["]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putSetterInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>info</ParamName>
                    <FieldType>SetterInfo</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exp;putNodeMetaData;[SetterInfo.class, info]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeSetterInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SetterInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [nodeMetaData=exp.getNodeMetaData(SetterInfo.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Long [err=((long)expr.getLineNumber()) &lt;&lt; 16 + expr.getColumnNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addStaticTypeError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>ASTNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNoMatchingMethodError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Cannot find matching method " + receiver.getText() + "#"+ toMethodParametersString(name,args)+ ". Please check if the declared type is right and if the method exists.", call]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addAmbiguousErrorMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>foundMethods</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>ClassNode[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Reference to method is ambiguous. Cannot choose between " + prettyPrintMethodList(foundMethods), expr]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addCategoryMethodCallError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>call</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Due to their dynamic nature, usage of categories is not possible with static type checking active", call]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addAssignmentError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>rightType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>assignmentExpression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addStaticTypeError;["Cannot assign value of type " + rightType.toString(false) + " to variable of type "+ leftType.toString(false), assignmentExpression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUnsupportedPreOrPostfixExpressionError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>Expression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMethodsToBeVisited</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodsToBeVisited</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performSecondPass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>extension;finish;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractTypesFromParameters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <FieldType>Parameter[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode[] [params=new ClassNode[parameters.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wrapTypeIfNecessary</MethodName>
            <MethodComment>/** 
 * Returns a wrapped type if, and only if, the provided class node is a primitive type. This method differs from  {@link ClassHelper#getWrapper(org.codehaus.groovy.ast.ClassNode)} as it willreturn the same instance if the provided type is not a generic type.
 * @param type
 * @return the wrapped type
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClassInnerClassOrEqualTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toBeChecked</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>VariableExpressionTypeMemoizer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>varOrigType</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceUnit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SourceUnit</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitVariableExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <FieldType>VariableExpression</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Variable [var=findTargetVariable(expression)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCodec</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SignatureCodec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>version</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <FieldType>ClassLoader</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SetterInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverType</ParamName>
                    <FieldType>ClassNode</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>setters</ParamName>
                    <FieldType>MethodNode</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>