<Class>
    <Id>535</Id>
    <Package>org.codehaus.groovy.tools</Package>
    <ClassName>RootLoader</ClassName>
    <SuperClass>URLClassLoader</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>RootLoader  /** 
 * This ClassLoader should be used as root of class loaders. Any RootLoader does have it's own classpath. When searching for a class or resource this classpath will be used. Parent Classloaders are ignored first. If a class or resource can't be found in the classpath of the RootLoader, then parent is checked. &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; this is very against the normal behavior of classloaders. Normal is to first check parent and then look in the resources you gave this classloader. &lt;p&gt; It's possible to add urls to the classpath at runtime through {@link &lt;a href="#addURL(URL)"&gt;addURL(URL)&lt;/a&gt;}&lt;p&gt; &lt;b&gt;Why using RootLoader?&lt;/b&gt; If you have to load classes with multiple classloaders and a classloader does know a class which depends on a class only a child of this loader does know, then you won't be able to load the class. To load the class the child is not allowed to redirect it's search for the class to the parent first. That way the child can load the class. If the child does not have all classes to do this, this fails of course. &lt;p&gt; For example: &lt;p&gt; &lt;pre&gt; parentLoader   (has classpath: a.jar;c.jar) | | childLoader    (has classpath: a.jar;b.jar;c.jar) &lt;/pre&gt; class C (from c.jar) extends B (from b.jar) childLoader.find("C") --&gt; parentLoader does know C.class, try to load it --&gt; to load C.class it has to load B.class --&gt; parentLoader is unable to find B.class in a.jar or c.jar --&gt; NoClassDefFoundException! if childLoader had tried to load the class by itself, there would be no problem. Changing childLoader to be a RootLoader instance will solve that problem.
 * @author Jochen Theodorou
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>EMPTY_URL_ARRAY</FieldName>
            <FieldType>URL[]</FieldType>
        </Field>
        <Field>
            <FieldName>customClasses</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>customClasses</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>RootLoader</MethodName>
            <MethodComment>/** 
 * constructs a new RootLoader without classpath
 * @param parent the parent Loader
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <FieldType>ClassLoader</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RootLoader</MethodName>
            <MethodComment>/** 
 * constructs a new RootLoader with a parent loader and an array of URLs as classpath
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>urls</ParamName>
                    <FieldType>URL[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <FieldType>ClassLoader</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseParent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ClassLoader [cl=RootLoader.class.getClassLoader()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RootLoader</MethodName>
            <MethodComment>/** 
 * constructs a new RootLoader with a  {@link LoaderConfiguration}object which holds the classpath
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lc</ParamName>
                    <FieldType>LoaderConfiguration</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URL[] [urls=lc.getClassPathUrls()]</InnerVar>
                <InnerVar>String [groovyHome=System.getProperty("groovy.home")]</InnerVar>
                <InnerVar>List&lt;String&gt; [grabUrls=lc.getGrabUrls()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Thread.currentThread();setContextClassLoader;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadClass</MethodName>
            <MethodComment>/** 
 * loads a class using the name of the class
 */
</MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>resolve</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [c=this.findLoadedClass(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResource</MethodName>
            <MethodComment>/** 
 * returns the URL of a resource, or null if it is not found
 */
</MethodComment>
            <ReturnType>URL</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URL [url=findResource(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addURL</MethodName>
            <MethodComment>/** 
 * adds an url to the classpath of this classloader
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <FieldType>URL</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>oldFindClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>