<Class>
    <Id>516</Id>
    <Package>org.codehaus.groovy.vmplugin.v7</Package>
    <ClassName>Selector</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>args</FieldName>
            <FieldType>Object[]</FieldType>
        </Field>
        <Field>
            <FieldName>originalArguments</FieldName>
            <FieldType>Object[]</FieldType>
        </Field>
        <Field>
            <FieldName>method</FieldName>
            <FieldType>MetaMethod</FieldType>
        </Field>
        <Field>
            <FieldName>targetType</FieldName>
            <FieldType>MethodType</FieldType>
        </Field>
        <Field>
            <FieldName>currentType</FieldName>
            <FieldType>MethodType</FieldType>
        </Field>
        <Field>
            <FieldName>name</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>handle</FieldName>
            <FieldType>MethodHandle</FieldType>
        </Field>
        <Field>
            <FieldName>useMetaClass</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>callSite</FieldName>
            <FieldType>MutableCallSite</FieldType>
        </Field>
        <Field>
            <FieldName>sender</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>isVargs</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>safeNavigation</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>safeNavigationOrig</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>spread</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>skipSpreadCollector</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>thisCall</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>selectionBase</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>catchException</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>callType</FieldName>
            <FieldType>CALL_TYPES</FieldType>
        </Field>
        <Field>
            <FieldName>staticSourceType</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>staticSourceType</FieldName>
            <FieldType>?</FieldType>
        </Field>
        <Field>
            <FieldName>staticTargetType</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>staticTargetType</FieldName>
            <FieldType>?</FieldType>
        </Field>
        <Field>
            <FieldName>insertName</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>beanConstructor</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>mc</FieldName>
            <FieldType>MetaClass</FieldType>
        </Field>
        <Field>
            <FieldName>isCategoryMethod</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getSelector</MethodName>
            <MethodComment>/** 
 * Returns the Selector
 */
</MethodComment>
            <ReturnType>Selector</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callSite</ParamName>
                    <FieldType>MutableCallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callID</ParamName>
                    <FieldType>int</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>safeNavigation</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>spreadCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CALL_TYPES [callType=CALL_TYPES.values()[callID]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCallSiteTarget</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spread</MethodName>
            <MethodComment>/** 
 * Helper method to transform the given arguments, consisting of the receiver  and the actual arguments in an Object[], into a new Object[] consisting of the receiver and the arguments directly. Before the size of args was  always 2, the returned Object[] will have a size of 1+n, where n is the number arguments.
 */
</MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>spreadCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [normalArguments=(Object[])args[1]]</InnerVar>
                <InnerVar>Object[] [ret=new Object[normalArguments.length + 1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[normalArguments, 0, ret, 1, ret.length - 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CastSelector</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callSite</ParamName>
                    <FieldType>MutableCallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCallSiteTarget</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;handleBoolean;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;handleNullWithoutBoolean;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;handleInstanceCase;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;handleCollections;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;handleSAM;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;castToTypeFallBack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castAndSetGuards</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setGuards;[args[0]]</InnerMethodInvoke>
                <InnerMethodInvoke>null;doCallSiteTargetSet;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleNullWithoutBoolean</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleInstanceCase</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAbstractClassOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toTest</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>givenOnCallSite</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleCollections</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleSAM</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Method [m=CachedSAMClass.getSAMMethod(staticTargetType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castToTypeFallBack</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleBoolean</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [primitive=staticTargetType == boolean.class]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PropertySelector</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callSite</ParamName>
                    <FieldType>MutableCallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callType</ParamName>
                    <FieldType>CALL_TYPES</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>safeNavigation</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>spreadCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterceptor</MethodName>
            <MethodComment>/** 
 * We never got the interceptor path with a property get
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseMeta</MethodName>
            <MethodComment>/** 
 * this method chooses a property from the meta class.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mci</ParamName>
                    <FieldType>MetaClassImpl</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [receiver=getCorrectedReceiver()]</InnerVar>
                <InnerVar>Class [chosenSender=this.sender]</InnerVar>
                <InnerVar>MetaProperty [res=mci.getEffectiveGetMetaProperty(chosenSender,receiver,name,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHandleForMetaMethod</MethodName>
            <MethodComment>/** 
 * Additionally to the normal  {@link MethodSelector#setHandleForMetaMethod()}task we have to also take care of generic getter methods, that depend one the name.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClassCallHandleIfNedded</MethodName>
            <MethodComment>/** 
 * The MOP requires all get property operations to go through  {@link GroovyObject#getProperty(String)}. We do this in case  no property was found before.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>standardMetaClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InitSelector</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callSite</ParamName>
                    <FieldType>MutableCallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callType</ParamName>
                    <FieldType>CALL_TYPES</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>safeNavigation</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>spreadCall</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterceptor</MethodName>
            <MethodComment>/** 
 * Constructor calls are not intercepted, thus always returns false.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClass</MethodName>
            <MethodComment>/** 
 * For a constructor call we always use the static meta class from the registry
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [receiver=args[0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseMeta</MethodName>
            <MethodComment>/** 
 * This method chooses a constructor from the meta class.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mci</ParamName>
                    <FieldType>MetaClassImpl</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [newArgs=removeRealReceiver(args)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHandleForMetaMethod</MethodName>
            <MethodComment>/** 
 * Adds  {@link MetaConstructor} handling.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctParameterLength</MethodName>
            <MethodComment>/** 
 * In case of a bean constructor we don't do any varags or implicit null argument  transformations. Otherwise we do the same as for  {@link MethodSelector#correctParameterLength()}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctCoerce</MethodName>
            <MethodComment>/** 
 * In case of a bean constructor we don't do any coercion, otherwise we do the same as for  {@link MethodSelector#correctCoerce()}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClassCallHandleIfNedded</MethodName>
            <MethodComment>/** 
 * Set MOP based constructor invocation path.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>standardMetaClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MethodSelector</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>callSite</ParamName>
                    <FieldType>MutableCallSite</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <FieldType>Class</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <FieldType>String</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>callType</ParamName>
                    <FieldType>CALL_TYPES</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>safeNavigation</ParamName>
                    <FieldType>Boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>thisCall</ParamName>
                    <FieldType>Boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>spreadCall</ParamName>
                    <FieldType>Boolean</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNullForSafeNavigation</MethodName>
            <MethodComment>/** 
 * Sets the null constant for safe navigation. In case of foo?.bar() and foo being null, we don't call the method, instead we simply return null. This produces a handle, which will  return the constant.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClass</MethodName>
            <MethodComment>/** 
 * Gives the meta class to an Object.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [receiver=args[0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mc;initialize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseMeta</MethodName>
            <MethodComment>/** 
 * Uses the meta class to get a meta method for a method call. There will be no meta method selected, if the meta class is no MetaClassImpl or the meta class is an AdaptingMetaClass.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mci</ParamName>
                    <FieldType>MetaClassImpl</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [receiver=getCorrectedReceiver()]</InnerVar>
                <InnerVar>Object[] [newArgs=removeRealReceiver(args)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHandleForMetaMethod</MethodName>
            <MethodComment>/** 
 * Creates a MethodHandle using a before selected MetaMethod. If the MetaMethod has reflective information available, then we will use that information to create the target MethodHandle.  If that is not the case we will produce a handle, which will use the MetaMethod itself for invocation.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MetaMethod [metaMethod=method]</InnerVar>
                <InnerVar>boolean [isCategoryTypeMethod=metaMethod instanceof NewInstanceMetaMethod]</InnerVar>
                <InnerVar>boolean [isStaticCategoryTypeMethod=metaMethod instanceof NewStaticMetaMethod]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctClassForNameAndUnReflectOtherwise</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>m</ParamName>
                    <FieldType>Method</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IllegalAccessException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeWrapper</MethodName>
            <MethodComment>/** 
 * Helper method to manipulate the given type to replace Wrapper with Object.
 */
</MethodComment>
            <ReturnType>MethodType</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <FieldType>MethodType</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class[] [types=targetType.parameterArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClassCallHandleIfNedded</MethodName>
            <MethodComment>/** 
 * Creates a MethodHandle, which will use the meta class path. This method is called only if no handle has been created before. This is usually the case if the method selection failed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>standardMetaClass</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [receiver=getCorrectedReceiver()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctWrapping</MethodName>
            <MethodComment>/** 
 * Corrects method argument wrapping. In cases in which we want to force a certain method selection we use Wrapper classes to transport the static type information. This method will be used to undo the wrapping.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Class[] [pt=handle.type().parameterArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctParameterLength</MethodName>
            <MethodComment>/** 
 * Handles cases in which we have to correct the length of arguments using the parameters. This might be needed for vargs and for one  parameter calls without arguments (null is used then).  
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Class[] [params=handle.type().parameterArray()]</InnerVar>
                <InnerVar>Class [lastParam=params[params.length - 1]]</InnerVar>
                <InnerVar>Object [lastArg=unwrapIfWrapped(args[args.length - 1])]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctCoerce</MethodName>
            <MethodComment>/** 
 * There are some conversions we have to do explicitly. These are GString to String, Number to Byte and Number to BigInteger conversions.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Class[] [parameters=handle.type().parameterArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctNullReceiver</MethodName>
            <MethodComment>/** 
 * Gives a replacement receiver for null. In case of the receiver being null we want to do the method invocation on NullObject instead.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correctSpreading</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addExceptionHandler</MethodName>
            <MethodComment>/** 
 * Adds the standard exception handler.  
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Class [returnType=handle.type().returnType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setGuards</MethodName>
            <MethodComment>/** 
 * Sets all argument and receiver guards.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodHandle [fallback=makeFallBack(callSite,sender,name,callType.ordinal(),targetType,safeNavigationOrig,thisCall,spread)]</InnerVar>
                <InnerVar>Class[] [pt=handle.type().parameterArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCallSiteTargetSet</MethodName>
            <MethodComment>/** 
 * do the actual call site target set, if the call is supposed to be cached
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSelectionBase</MethodName>
            <MethodComment>/** 
 * Sets the selection base.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterceptor</MethodName>
            <MethodComment>/** 
 * Sets a handle to call  {@link GroovyInterceptable#invokeMethod(String,Object)}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCallSiteTarget</MethodName>
            <MethodComment>/** 
 * setting a call site target consists of the following steps: # get the meta class # select a method/constructor/property from it, if it is a MetaClassImpl # make a handle out of the selection # if nothing could be selected select a path through the given MetaClass or the GroovyObject # apply transformations for vargs, implicit null argument, coercion, wrapping, null receiver and spreading
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setGuards;[args[0]]</InnerMethodInvoke>
                <InnerMethodInvoke>null;doCallSiteTargetSet;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unwrapIfWrapped</MethodName>
            <MethodComment>/** 
 * Unwraps the given object from a  {@link Wrapper}. If not wrapped, the given object is returned.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <FieldType>Object</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrectedReceiver</MethodName>
            <MethodComment>/** 
 * Returns  {@link NullObject#getNullObject()} if the receiver(args[0]) is null. If it is not null, the recevier itself is returned.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [receiver=args[0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStatic</MethodName>
            <MethodComment>/** 
 * Returns if a method is static
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>m</ParamName>
                    <FieldType>Method</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [mods=m.getModifiers()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClassImpl</MethodName>
            <MethodComment>/** 
 * Returns the MetaClassImpl if the given MetaClass is one of MetaClassImpl, AdaptingMetaClass or ClosureMetaClass. If none of these cases matches, this method returns null.
 */
</MethodComment>
            <ReturnType>MetaClassImpl</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mc</ParamName>
                    <FieldType>MetaClass</FieldType>
                </Parameter>
                <Parameter>
                    <ParamName>includeEMC</ParamName>
                    <FieldType>boolean</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [mcc=mc.getClass()]</InnerVar>
                <InnerVar>boolean [valid=mcc == MetaClassImpl.class || mcc == AdaptingMetaClass.class || mcc == ClosureMetaClass.class || (includeEMC &amp;&amp; mcc == ExpandoMetaClass.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeRealReceiver</MethodName>
            <MethodComment>/** 
 * Helper method to remove the receiver from the argument array by producing a new array.
 */
</MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <FieldType>Object[]</FieldType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [ar=new Object[args.length - 1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[args, 1, ar, 0, args.length - 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>