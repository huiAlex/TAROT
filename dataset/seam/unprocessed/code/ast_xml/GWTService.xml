<Class>
    <Id>500</Id>
    <Package>org.jboss.seam.remoting.gwt</Package>
    <ClassName>GWTService</ClassName>
    <SuperClass>AbstractResource</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>SerializationPolicyProvider</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>GWTService  /** 
 * Abstract base class for GWT 1.5 integration.
 * @author Shane Bryzak
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>LogProvider</FieldType>
        </Field>
        <Field>
            <FieldName>TYPE_NAMES</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>TYPE_NAMES</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>serializationPolicyCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>serializationPolicyCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>perThreadRequest</FieldName>
            <FieldType>ThreadLocal</FieldType>
        </Field>
        <Field>
            <FieldName>perThreadRequest</FieldName>
            <FieldType>HttpServletRequest</FieldType>
        </Field>
        <Field>
            <FieldName>perThreadResponse</FieldName>
            <FieldType>ThreadLocal</FieldType>
        </Field>
        <Field>
            <FieldName>perThreadResponse</FieldName>
            <FieldType>HttpServletResponse</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getResourcePath</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStreamReader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ServerSerializationStreamReader</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStreamWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ServerSerializationStreamWriter</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createResponse</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>ServerSerializationStreamWriter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>responseType</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>responseObj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isException</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResource</MethodName>
            <MethodComment>/** 
 * This is called internally.
 * @see RemoteServiceServlet#doPost
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>request</ParamName>
                    <ParamType>HttpServletRequest</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>HttpServletResponse</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ServletException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>process</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreConversationId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConversationPropagation.instance();setConversationId;[GWTService.this.perThreadRequest.get().getParameter("conversationId")]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleConversationPropagation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processCall</MethodName>
            <MethodComment>/** 
 * This is public so that it can be unit tested easily without HTTP.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>payload</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SerializationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getThreadLocalRequest</MethodName>
            <MethodComment>/** 
 * Gets the &lt;code&gt;HttpServletRequest&lt;/code&gt; object for the current call. It is stored thread-locally so that simultaneous invocations can have different request objects.
 */
</MethodComment>
            <ReturnType>HttpServletRequest</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getThreadLocalResponse</MethodName>
            <MethodComment>/** 
 * Gets the &lt;code&gt;HttpServletResponse&lt;/code&gt; object for the current call. It is stored thread-locally so that simultaneous invocations can have different response objects.
 */
</MethodComment>
            <ReturnType>HttpServletResponse</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RPC_decodeRequest</MethodName>
            <MethodComment>/** 
 * Returns an  {@link RPCRequest} that is built by decoding the contents of anencoded RPC request and optionally validating that type can handle the request. If the type parameter is not &lt;code&gt;null&lt;/code&gt;, the implementation checks that the type is assignable to the {@link com.google.gwt.user.client.rpc.RemoteService} interface requestedin the encoded request string. &lt;p&gt; If the serializationPolicyProvider parameter is not &lt;code&gt;null&lt;/code&gt;, it is asked for a  {@link SerializationPolicy} to use to restrict the set oftypes that can be decoded from the request. If this parameter is &lt;code&gt;null&lt;/code&gt;, then only subtypes of {@link com.google.gwt.user.client.rpc.IsSerializable IsSerializable} ortypes which have custom field serializers can be decoded. &lt;/p&gt; &lt;p&gt; Invoking this method with &lt;code&gt;null&lt;/code&gt; for the type parameter, &lt;code&gt;decodeRequest(encodedRequest, null)&lt;/code&gt;, is equivalent to calling &lt;code&gt;decodeRequest(encodedRequest)&lt;/code&gt;. &lt;/p&gt;
 * @param encodedRequest a string that encodes the {@link com.google.gwt.user.client.rpc.RemoteService} interface,the service method, and the arguments to pass to the service method
 * @param type if not &lt;code&gt;null&lt;/code&gt;, the implementation checks that the type is assignable to the {@link com.google.gwt.user.client.rpc.RemoteService} interfaceencoded in the encoded request string.
 * @param serializationPolicyProvider if not &lt;code&gt;null&lt;/code&gt;, the implementation asks this provider for a  {@link SerializationPolicy} which will be used to restrictthe set of types that can be decoded from this request
 * @return an {@link RPCRequest} instance
 * @throws NullPointerException if the encodedRequest is &lt;code&gt;null&lt;/code&gt;
 * @throws IllegalArgumentException if the encodedRequest is an empty string
 * @throws IncompatibleRemoteServiceException if any of the following conditions apply: &lt;ul&gt; &lt;li&gt;if the types in the encoded request cannot be deserialized&lt;/li&gt; &lt;li&gt;if the  {@link ClassLoader} acquired from&lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt; cannot load the service interface or any of the types specified in the encodedRequest&lt;/li&gt; &lt;li&gt;the requested interface is not assignable to {@link com.google.gwt.user.client.rpc.RemoteService}&lt;/li&gt; &lt;li&gt;the service method requested in the encodedRequest is not a member of the requested service interface&lt;/li&gt; &lt;li&gt;the type parameter is not &lt;code&gt;null&lt;/code&gt; and is not assignable to the requested {@link com.google.gwt.user.client.rpc.RemoteService} interface&lt;/ul&gt;
 */
</MethodComment>
            <ReturnType>SeamRPCRequest</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>encodedRequest</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializationPolicyProvider</ParamName>
                    <ParamType>SerializationPolicyProvider</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassLoader [classLoader=Thread.currentThread().getContextClassLoader()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RPC_getClassFromSerializedName</MethodName>
            <MethodComment>/** 
 * Returns the  {@link Class} instance for the named class or primitive type.
 * @param serializedName the serialized name of a class or primitive type
 * @param classLoader the classLoader used to load  {@link Class}es
 * @return Class instance for the given type name
 * @throws ClassNotFoundException if the named type was not found
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serializedName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [value=TYPE_NAMES.get(serializedName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RPC_invokeAndEncodeResponse</MethodName>
            <MethodComment>/** 
 * Returns a string that encodes the result of calling a service method, which could be the value returned by the method or an exception thrown by it. &lt;p&gt; If the serializationPolicy parameter is not &lt;code&gt;null&lt;/code&gt;, it is used to determine what types can be encoded as part of this response. If this parameter is &lt;code&gt;null&lt;/code&gt;, then only subtypes of {@link com.google.gwt.user.client.rpc.IsSerializable IsSerializable} ortypes which have custom field serializers may be encoded. &lt;/p&gt; &lt;p&gt; This method does no security checking; security checking must be done on the method prior to this invocation. &lt;/p&gt;
 * @param target instance on which to invoke the serviceMethod
 * @param serviceMethod the method to invoke
 * @param args arguments used for the method invocation
 * @param serializationPolicy determines the serialization policy to be used
 * @return a string which encodes either the method's return or a checkedexception thrown by the method
 * @throws NullPointerException if the serviceMethod or the serializationPolicy are &lt;code&gt;null&lt;/code&gt;
 * @throws SecurityException if the method cannot be accessed or if the number or type of actual and formal arguments differ
 * @throws SerializationException if an object could not be serialized by the stream
 * @throws UnexpectedException if the serviceMethod throws a checked exception that is not declared in its signature
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceMethod</ParamName>
                    <ParamType>Method</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializationPolicy</ParamName>
                    <ParamType>SerializationPolicy</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [responsePayload]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SerializationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemoteServiceServlet_onAfterResponseSerialized</MethodName>
            <MethodComment>/** 
 * Override this method to examine the serialized response that will be returned to the client. The default implementation does nothing and need not be called by subclasses.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serializedResponse</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemoteServiceServlet_onBeforeRequestDeserialized</MethodName>
            <MethodComment>/** 
 * Override this method to examine the serialized version of the request payload before it is deserialized into objects. The default implementation does nothing and need not be called by subclasses.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serializedRequest</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemoteServiceServlet_readContent</MethodName>
            <MethodComment>/** 
 * Override this method in order to control the parsing of the incoming request. For example, you may want to bypass the check of the Content-Type and character encoding headers in the request, as some proxies re-write the request headers. Note that bypassing these checks may expose the servlet to some cross-site vulnerabilities.
 * @param request the incoming request
 * @return the content of the incoming request encoded as a string.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>request</ParamName>
                    <ParamType>HttpServletRequest</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ServletException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSerializationPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SerializationPolicy</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>moduleBaseURL</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>strongName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SerializationPolicy [serializationPolicy=getCachedSerializationPolicy(moduleBaseURL,strongName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;putCachedSerializationPolicy;[moduleBaseURL, strongName, serializationPolicy]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCachedSerializationPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SerializationPolicy</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>moduleBaseURL</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>strongName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putCachedSerializationPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>moduleBaseURL</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>strongName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializationPolicy</ParamName>
                    <ParamType>SerializationPolicy</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetSerializationPolicy</MethodName>
            <MethodComment>/** 
 * Gets the  {@link SerializationPolicy} for given module base URL and strongname if there is one. Override this method to provide a  {@link SerializationPolicy} using analternative approach.
 * @param request the HTTP request being serviced
 * @param moduleBaseURL as specified in the incoming payload
 * @param strongName a strong name that uniquely identifies a serialization policy file
 * @return a {@link SerializationPolicy} for the given module base URL andstrong name, or &lt;code&gt;null&lt;/code&gt; if there is none
 */
</MethodComment>
            <ReturnType>SerializationPolicy</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>request</ParamName>
                    <ParamType>HttpServletRequest</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>moduleBaseURL</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>strongName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [contextPath=request.getContextPath()]</InnerVar>
                <InnerVar>String [modulePath=null]</InnerVar>
                <InnerVar>SerializationPolicy [serializationPolicy=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemoteServiceServlet_writeResponse</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>request</ParamName>
                    <ParamType>HttpServletRequest</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>HttpServletResponse</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>responsePayload</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [gzipEncode=RPCServletUtils.acceptsGzipEncoding(request) &amp;&amp; shouldCompressResponse(request,response,responsePayload)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>RPCServletUtils;writeResponse;[getServletContext(), response, responsePayload, gzipEncode]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemoteServiceServlet_doUnexpectedFailure</MethodName>
            <MethodComment>/** 
 * Override this method to control what should happen when an exception escapes the  {@link #processCall(String)} method. The defaultimplementation will log the failure and send a generic failure response to the client. &lt;p/&gt; An "expected failure" is an exception thrown by a service method that is declared in the signature of the service method. These exceptions are serialized back to the client, and are not passed to this method. This method is called only for exceptions or errors that are not part of the service method's signature, or that result from SecurityExceptions, SerializationExceptions, or other failures within the RPC framework. &lt;p/&gt; Note that if the desired behavior is to both send the GENERIC_FAILURE_MSG response AND to rethrow the exception, then this method should first send the GENERIC_FAILURE_MSG response itself (using getThreadLocalResponse), and then rethrow the exception. Rethrowing the exception will cause it to escape into the servlet container.
 * @param e the exception which was thrown
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ServletContext [servletContext=getServletContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>RPCServletUtils;writeResponseForUnexpectedFailure;[servletContext, getThreadLocalResponse(), e]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shouldCompressResponse</MethodName>
            <MethodComment>/** 
 * Determines whether the response to a given servlet request should or should not be GZIP compressed. This method is only called in cases where the requester accepts GZIP encoding. &lt;p&gt; This implementation currently returns &lt;code&gt;true&lt;/code&gt; if the response string's estimated byte length is longer than 256 bytes. Subclasses can override this logic. &lt;/p&gt;
 * @param request the request being served
 * @param response the response that will be written into
 * @param responsePayload the payload that is about to be sent to the client
 * @return &lt;code&gt;true&lt;/code&gt; if responsePayload should be GZIP compressed,otherwise &lt;code&gt;false&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>request</ParamName>
                    <ParamType>HttpServletRequest</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>HttpServletResponse</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>responsePayload</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatMethodNotFoundErrorMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceIntf</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceMethodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterTypes</ParamName>
                    <ParamType>Class&lt;?&gt;[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["Could not locate requested method '"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[serviceMethodName]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["("]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[")'"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[" in interface '"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[printTypeName(serviceIntf)]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["'"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatIllegalAccessErrorMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceMethod</ParamName>
                    <ParamType>Method</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["Blocked attempt to access inaccessible method '"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[getSourceRepresentation(serviceMethod)]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["'"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["; this is either misconfiguration or a hack attempt"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatIllegalArgumentErrorMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceMethod</ParamName>
                    <ParamType>Method</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["Blocked attempt to invoke method '"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[getSourceRepresentation(serviceMethod)]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["'"]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[" with invalid arguments"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceRepresentation</MethodName>
            <MethodComment>/** 
 * Returns the source representation for a method signature.
 * @param method method to get the source signature for
 * @return source representation for a method signature
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>Method</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printTypeName</MethodName>
            <MethodComment>/** 
 * Straight copy from {@link com.google.gwt.dev.util.TypeInfo#getSourceRepresentation(Class)} toavoid runtime dependency on gwt-dev.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>