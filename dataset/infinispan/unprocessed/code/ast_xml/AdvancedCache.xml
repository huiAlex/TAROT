<Class>
    <Id>2190</Id>
    <Package>org.infinispan</Package>
    <ClassName>AdvancedCache</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Cache</SuperInterface>
        <SuperInterface>K</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AdvancedCache  /** 
 * An advanced interface that exposes additional methods not available on  {@link Cache}.
 * @author Manik Surtani
 * @author Galder Zamarre√±o
 * @author Tristan Tarrant
 * @since 4.0
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>withFlags</MethodName>
            <MethodComment>/** 
 * A method that adds flags to any API call.  For example, consider the following code snippet: &lt;pre&gt; cache.withFlags(Flag.FORCE_WRITE_LOCK).get(key); &lt;/pre&gt; will invoke a cache.get() with a write lock forced. &lt;p /&gt; &lt;b&gt;Note&lt;/b&gt; that for the flag to take effect, the cache operation &lt;b&gt;must&lt;/b&gt; be invoked on the instance returned by this method. &lt;p /&gt; As an alternative to setting this on every invocation, users could also consider using the  {@link DecoratedCache} wrapper, as this allows for more readablecode.  E.g.: &lt;pre&gt; Cache forceWriteLockCache = new DecoratedCache(cache, Flag.FORCE_WRITE_LOCK); forceWriteLockCache.get(key1); forceWriteLockCache.get(key2); forceWriteLockCache.get(key3); &lt;/pre&gt;
 * @param flags a set of flags to apply.  See the {@link Flag} documentation.
 * @return an {@link AdvancedCache} instance on which a real operation is to be invoked, if the flags areto be applied.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withSubject</MethodName>
            <MethodComment>/** 
 * Performs any cache operations using the specified  {@link Subject}. Only applies to caches with authorization enabled (see  {@link ConfigurationBuilder#security()}).
 * @param subject
 * @return an {@link AdvancedCache} instance on which a real operation is to be invoked, using the specified subject
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>subject</ParamName>
                    <ParamType>Subject</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInterceptor</MethodName>
            <MethodComment>/** 
 * Adds a custom interceptor to the interceptor chain, at specified position, where the first interceptor in the chain is at position 0 and the last one at NUM_INTERCEPTORS - 1.
 * @param i        the interceptor to add
 * @param position the position to add the interceptor
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>CommandInterceptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInterceptorAfter</MethodName>
            <MethodComment>/** 
 * Adds a custom interceptor to the interceptor chain, after an instance of the specified interceptor type. Throws a cache exception if it cannot find an interceptor of the specified type.
 * @param i                interceptor to add
 * @param afterInterceptor interceptor type after which to place custom interceptor
 * @return true if successful, false otherwise.
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>CommandInterceptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>afterInterceptor</ParamName>
                    <ParamType>? extends CommandInterceptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInterceptorBefore</MethodName>
            <MethodComment>/** 
 * Adds a custom interceptor to the interceptor chain, before an instance of the specified interceptor type. Throws a cache exception if it cannot find an interceptor of the specified type.
 * @param i                 interceptor to add
 * @param beforeInterceptor interceptor type before which to place custom interceptor
 * @return true if successful, false otherwise.
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>CommandInterceptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>beforeInterceptor</ParamName>
                    <ParamType>? extends CommandInterceptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeInterceptor</MethodName>
            <MethodComment>/** 
 * Removes the interceptor at a specified position, where the first interceptor in the chain is at position 0 and the last one at getInterceptorChain().size() - 1.
 * @param position the position at which to remove an interceptor
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeInterceptor</MethodName>
            <MethodComment>/** 
 * Removes the interceptor of specified type.
 * @param interceptorType type of interceptor to remove
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>interceptorType</ParamName>
                    <ParamType>? extends CommandInterceptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInterceptorChain</MethodName>
            <MethodComment>/** 
 * @deprecated Since 9.0, use {@link #getAsyncInterceptorChain()} instead.
 */
</MethodComment>
            <ReturnType>CommandInterceptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAsyncInterceptorChain</MethodName>
            <MethodComment>/** 
 * Allows the modification of the interceptor chain. Experimental: The ability to modify the interceptors at runtime may be removed in future versions.
 * @since 9.0
 */
</MethodComment>
            <ReturnType>AsyncInterceptorChain</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvictionManager</MethodName>
            <MethodComment>/** 
 * @return the eviction manager - if one is configured - for this cache instance
 */
</MethodComment>
            <ReturnType>EvictionManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExpirationManager</MethodName>
            <MethodComment>/** 
 * @return the expiration manager - if one is configured - for this cache instance
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponentRegistry</MethodName>
            <MethodComment>/** 
 * @return the component registry for this cache instance
 */
</MethodComment>
            <ReturnType>ComponentRegistry</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDistributionManager</MethodName>
            <MethodComment>/** 
 * Retrieves a reference to the  {@link org.infinispan.distribution.DistributionManager} if the cache is configuredto use Distribution.  Otherwise, returns a null.
 * @return a DistributionManager, or null.
 */
</MethodComment>
            <ReturnType>DistributionManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuthorizationManager</MethodName>
            <MethodComment>/** 
 * Retrieves the  {@link AuthorizationManager} if the cache has security enabled. Otherwise returns null
 * @return an AuthorizationManager or null
 */
</MethodComment>
            <ReturnType>AuthorizationManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockAs</MethodName>
            <MethodComment>/** 
 * Whenever this cache acquires a lock it will do so using the given Object as the owner of said lock. &lt;p&gt; This can be useful when a lock may have been manually acquired and you wish to reuse that lock across invocations. &lt;p&gt; Great care should be taken with this command as misuse can very easily lead to deadlocks.
 * @param lockOwner the lock owner to lock any keys as
 * @return an {@link AdvancedCache} instance on which when an operation is invoked it will use lock ownerobject to acquire any locks
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lock</MethodName>
            <MethodComment>/** 
 * Locks a given key or keys eagerly across cache nodes in a cluster. &lt;p&gt; Keys can be locked eagerly in the context of a transaction only.
 * @param keys the keys to lock
 * @return true if the lock acquisition attempt was successful for &lt;i&gt;all&lt;/i&gt; keys;false will only be returned if the lock acquisition timed out and the operation has been called with  {@link Flag#FAIL_SILENTLY}.
 * @throws org.infinispan.util.concurrent.TimeoutException if the lockcannot be acquired within the configured lock acquisition time.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lock</MethodName>
            <MethodComment>/** 
 * Locks collections of keys eagerly across cache nodes in a cluster. &lt;p&gt; Collections of keys can be locked eagerly in the context of a transaction only.
 * @param keys collection of keys to lock
 * @return true if the lock acquisition attempt was successful for &lt;i&gt;all&lt;/i&gt; keys;false will only be returned if the lock acquisition timed out and the operation has been called with  {@link Flag#FAIL_SILENTLY}.
 * @throws org.infinispan.util.concurrent.TimeoutException if the lockcannot be acquired within the configured lock acquisition time.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyDelta</MethodName>
            <MethodComment>/** 
 * Applies the given Delta to the DeltaAware object stored under deltaAwareValueKey if and only if all locksToAcquire locks are successfully obtained
 * @param deltaAwareValueKey the key for DeltaAware object
 * @param delta the delta to be applied to DeltaAware object
 * @param locksToAcquire keys to be locked in DeltaAware scope. Must contain only single key equal to &lt;code&gt;deltaAwareValueKey&lt;/code&gt;
 * @deprecated since 9.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>deltaAwareValueKey</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delta</ParamName>
                    <ParamType>Delta</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locksToAcquire</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRpcManager</MethodName>
            <MethodComment>/** 
 * Returns the component in charge of communication with other caches in the cluster.  If the cache's  {@link org.infinispan.configuration.cache.ClusteringConfiguration#cacheMode()}is  {@link org.infinispan.configuration.cache.CacheMode#LOCAL}, this method will return null.
 * @return the RPC manager component associated with this cache instance or null
 */
</MethodComment>
            <ReturnType>RpcManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBatchContainer</MethodName>
            <MethodComment>/** 
 * Returns the component in charge of batching cache operations.
 * @return the batching component associated with this cache instance
 */
</MethodComment>
            <ReturnType>BatchContainer</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInvocationContextContainer</MethodName>
            <MethodComment>/** 
 * Returns the component in charge of managing the interactions between the cache operations and the context information associated with them.
 * @return the invocation context container component
 * @deprecated No longer in use, implementations might return null.
 */
</MethodComment>
            <ReturnType>InvocationContextContainer</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataContainer</MethodName>
            <MethodComment>/** 
 * Returns the container where data is stored in the cache. Users should interact with this component with care because direct calls on it bypass the internal interceptors and other infrastructure in place to guarantee the consistency of data.
 * @return the data container associated with this cache instance
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionManager</MethodName>
            <MethodComment>/** 
 * Returns the transaction manager configured for this cache. If no transaction manager was configured, this method returns null.
 * @return the transaction manager associated with this cache instance or null
 */
</MethodComment>
            <ReturnType>TransactionManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockManager</MethodName>
            <MethodComment>/** 
 * Returns the component that deals with all aspects of acquiring and releasing locks for cache entries.
 * @return retrieves the lock manager associated with this cache instance
 */
</MethodComment>
            <ReturnType>LockManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStats</MethodName>
            <MethodComment>/** 
 * Returns a  {@link Stats} object that allows several statistics associatedwith this cache at runtime.
 * @return this cache's {@link Stats} object
 */
</MethodComment>
            <ReturnType>Stats</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXAResource</MethodName>
            <MethodComment>/** 
 * Returns the  {@link XAResource} associated with this cache which can beused to do transactional recovery.
 * @return an instance of {@link XAResource}
 */
</MethodComment>
            <ReturnType>XAResource</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassLoader</MethodName>
            <MethodComment>/** 
 * Returns the cache loader associated associated with this cache.  As an alternative to setting this on every invocation, users could also consider using the  {@link DecoratedCache} wrapper.
 * @return this cache's cache loader
 */
</MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>with</MethodName>
            <MethodComment>/** 
 * Using this operation, users can call any  {@link AdvancedCache} operationwith a given  {@link ClassLoader}. This means that any  {@link ClassLoader} happeningas a result of the cache operation will be done using the  {@link ClassLoader}given. For example: &lt;p /&gt; When users store POJO instances in caches configured with  {@link org.infinispan.configuration.cache.StoreAsBinaryConfiguration}, these instances are transformed into byte arrays. When these entries are read from the cache, a lazy unmarshalling process happens where these byte arrays are transformed back into POJO instances. Using  {@link AdvancedCache#with(ClassLoader)}when reading that enables users to provide the class loader that should be used when trying to locate the classes that are constructed as a result of the unmarshalling process. &lt;pre&gt; cache.with(classLoader).get(key); &lt;/pre&gt; &lt;b&gt;Note&lt;/b&gt; that for the flag to take effect, the cache operation &lt;b&gt;must&lt;/b&gt; be invoked on the instance returned by this method. &lt;p /&gt; As an alternative to setting this on every invocation, users could also consider using the  {@link DecoratedCache} wrapper, as this allows for more readablecode.  E.g.: &lt;pre&gt; Cache classLoaderSpecificCache = new DecoratedCache(cache, classLoader); classLoaderSpecificCache.get(key1); classLoaderSpecificCache.get(key2); classLoaderSpecificCache.get(key3); &lt;/pre&gt;
 * @return an {@link AdvancedCache} instance upon which operations can be calledwith a particular  {@link ClassLoader}.
 * @deprecated A cache manager, and all caches within it, can only haveone classloader associated to it, so it's no longer possible to read cached data with a different classloader.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #put(K,V)}, which takes in an instance of {@link org.infinispan.metadata.Metadata} which can be used to provide metadata information forthe entry being stored, such as lifespan, version of value...etc.
 * @param key key to use
 * @param value value to store
 * @param metadata information to store alongside the value
 * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or&lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
 * @since 5.3
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAll</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #putAll(Map)}, which takes in an instance of {@link org.infinispan.metadata.Metadata} which can be used to provide metadata information forthe entries being stored, such as lifespan, version of value...etc.
 * @param map the values to store
 * @param metadata information to store alongside the value(s)
 * @since 7.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #replace(K,V)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is associated
 * @param value value to be associated with the specified key
 * @param metadata information to store alongside the new value
 * @return the previous value associated with the specified key, or&lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.
 * @since 5.3
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #replace(K,V,V)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is associated
 * @param oldValue value expected to be associated with the specified key
 * @param newValue value to be associated with the specified key
 * @param metadata information to store alongside the new value
 * @return &lt;tt&gt;true&lt;/tt&gt; if the value was replaced
 * @since 5.3
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putIfAbsent</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #putIfAbsent(K,V)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @param metadata information to store alongside the new value
 * @return the previous value associated with the specified key, or&lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.
 * @since 5.3
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putForExternalRead</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #putForExternalRead(K,V)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @param metadata information to store alongside the new value
 * @since 7.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compute</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #compute(K,BiFunction)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc.
 * @param key key with which the specified value is associated
 * @param remappingFunction function to be applied to the specified key/value
 * @param metadata information to store alongside the new value
 * @return the previous value associated with the specified key, or&lt;tt&gt;null&lt;/tt&gt; if remapping function is gives null.
 * @since 9.1
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compute</MethodName>
            <MethodComment>/** 
 * Overloaded  {@link #compute(Object,BiFunction,Metadata)} with {@link SerializableBiFunction}
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeIfPresent</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #computeIfPresent(K,BiFunction)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is associated
 * @param remappingFunction function to be applied to the specified key/value
 * @param metadata information to store alongside the new value
 * @return the previous value associated with the specified key, or&lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.
 * @since 9.1
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeIfPresent</MethodName>
            <MethodComment>/** 
 * Overloaded  {@link #computeIfPresent(Object,BiFunction,Metadata)} with {@link SerializableBiFunction}
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeIfAbsent</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #computeIfAbsent(K,Function)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key key with which the specified value is associated
 * @param mappingFunction function to be applied to the specified key
 * @param metadata information to store alongside the new value
 * @return the value created with the mapping function associated with the specified key, orthe previous value associated with the specified key if the key is not absent.
 * @since 9.1
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeIfAbsent</MethodName>
            <MethodComment>/** 
 * Overloaded  {@link #computeIfAbsent(Object,Function,Metadata)} with {@link SerializableFunction}
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mappingFunction</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * An overloaded form of  {@link #merge(Object,Object,BiFunction)}, which takes in an instance of  {@link Metadata} which can be used to provide metadatainformation for the entry being stored, such as lifespan, version of value...etc. The  {@link Metadata} is only stored if the call issuccessful.
 * @param key, key with which the resulting value is to be associated
 * @param value, the non-null value to be merged with the existing valueassociated with the key or, if no existing value or a null value is associated with the key, to be associated with the key
 * @param remappingFunction, the function to recompute a value if present
 * @param metadata, information to store alongside the new value
 * @return the new value associated with the specified key, or null if novalue is associated with the key
 * @since 9.2
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * Overloaded  {@link #merge(Object,Object,BiFunction,Metadata)} with {@link SerializableBiFunction}
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remappingFunction</ParamName>
                    <ParamType>? super V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAsync</MethodName>
            <MethodComment>/** 
 * Asynchronous version of  {@link #put(Object,Object,Metadata)} which storesmetadata alongside the value.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #put(Object,Object,Metadata)} if used in LOCAL mode.&lt;p/&gt;
 * @param key   key to use
 * @param value value to store
 * @param metadata information to store alongside the new value
 * @return a future containing the old value replaced.
 * @since 5.3
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAll</MethodName>
            <MethodComment>/** 
 * Gets a collection of entries, returning them as  {@link Map} of the valuesassociated with the set of keys requested. &lt;p&gt; If the cache is configured read-through, and a get for a key would return null because an entry is missing from the cache, the Cache's {@link CacheLoader} is called in an attempt to load the entry. If anentry cannot be loaded for a given key, the returned Map will contain null for value of the key. &lt;p&gt; Unlike other bulk methods if this invoked in an existing transaction all entries will be stored in the current transactional context &lt;p&gt; The returned  {@link Map} will be a copy and updates to the map will not be reflectedin the Cache and vice versa.  The keys and values themselves however may not be copies depending on if storeAsBinary is enabled and the value was retrieved from the local node.
 * @param keys The keys whose associated values are to be returned.
 * @return A map of entries that were found for the given keys. If an entry is notfound for a given key, it will not be in the returned map.
 * @throws NullPointerException  if keys is null or if keys contains a null
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCacheEntry</MethodName>
            <MethodComment>/** 
 * Retrieves a CacheEntry corresponding to a specific key.
 * @param key the key whose associated cache entry is to be returned
 * @return the cache entry to which the specified key is mapped, or{@code null} if this map contains no mapping for the key
 * @since 5.3
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllCacheEntries</MethodName>
            <MethodComment>/** 
 * Gets a collection of entries from the  {@link AdvancedCache}, returning them as {@link Map} of the cache entries associated with the set of keys requested.&lt;p&gt; If the cache is configured read-through, and a get for a key would return null because an entry is missing from the cache, the Cache's {@link CacheLoader} is called in an attempt to load the entry. If anentry cannot be loaded for a given key, the returned Map will contain null for value of the key. &lt;p&gt; Unlike other bulk methods if this invoked in an existing transaction all entries will be stored in the current transactional context &lt;p&gt; The returned  {@link Map} will be a copy and updates to the map will not be reflectedin the Cache and vice versa.  The keys and values themselves however may not be copies depending on if storeAsBinary is enabled and the value was retrieved from the local node.
 * @param keys The keys whose associated values are to be returned.
 * @return A map of entries that were found for the given keys. Keys not foundin the cache are present in the map with null values.
 * @throws NullPointerException  if keys is null or if keys contains a null
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAndPutAll</MethodName>
            <MethodComment>/** 
 * Executes an equivalent of  {@link Map#putAll(Map)}, returning previous values of the modified entries.
 * @param map mappings to be stored in this map
 * @return A map of previous values for the given keys. If the previous mappingdoes not exist it will not be in the returned map.
 * @since 9.1
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;K,V&gt; [result=new HashMap&lt;&gt;(map.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGroup</MethodName>
            <MethodComment>/** 
 * It fetches all the keys which belong to the group. &lt;p/&gt; Semantically, it iterates over all the keys in memory and persistence, and performs a read operation in the keys found. Multiple invocations inside a transaction ensures that all the keys previous read are returned and it may return newly added keys to the group from other committed transactions (also known as phantom reads). &lt;p/&gt; The  {@code map} returned is immutable and represents the group at the time of the invocation. If you want to addor remove keys from a group use  {@link #put(Object,Object)} and {@link #remove(Object)}. To remove all the keys in the group use  {@link #removeGroup(String)}. &lt;p/&gt; To improve performance you may use the  {@code flag} {@link org.infinispan.context.Flag#SKIP_CACHE_LOAD} to avoidfetching the key/value from persistence. However, you will get an inconsistent snapshot of the group.
 * @param groupName the group name.
 * @return an immutable {@link java.util.Map} with the key/value pairs.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>groupName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeGroup</MethodName>
            <MethodComment>/** 
 * It removes all the key which belongs to a group. &lt;p/&gt; Semantically, it fetches the most recent group keys/values and removes them. &lt;p/&gt; Note that, concurrent addition perform by other transactions/threads to the group may not be removed.
 * @param groupName the group name.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>groupName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAvailability</MethodName>
            <MethodComment>/** 
 * Returns the cache's availability. In local mode this method will always return  {@link AvailabilityMode#AVAILABLE}. In clustered mode, the  {@link PartitionHandlingManager} is queried to obtain the availability mode.
 */
</MethodComment>
            <ReturnType>AvailabilityMode</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAvailability</MethodName>
            <MethodComment>/** 
 * Manually change the availability of the cache. Doesn't change anything if the cache is not clustered or  {@link PartitionHandlingConfiguration#whenSplit() is set to}{ {@link org.infinispan.partitionhandling.PartitionHandling#ALLOW_READ_WRITES }
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>availabilityMode</ParamName>
                    <ParamType>AvailabilityMode</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cacheEntrySet</MethodName>
            <MethodComment>/** 
 * Identical to  {@link Cache#entrySet()} but is typed to return CacheEntries instead of Entries.  Please seethe other method for a description of its behaviors. &lt;p&gt; This method is needed since nested generics do not support covariance
 * @see Cache#entrySet()
 * @return the entry set containing all of the CacheEntries
 */
</MethodComment>
            <ReturnType>CacheEntry&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockedStream</MethodName>
            <MethodComment>/** 
 * Returns a sequential stream using this Cache as the source. This stream is very similar to using the {@link CacheStream} returned from the {@link CacheSet#stream()} method of the collectionreturned via  {@link AdvancedCache#cacheEntrySet()}. The use of this locked stream is that when an entry is being processed by the user the entry is locked for the invocation preventing a different thread from modifying it. &lt;p&gt; Note that this stream is not supported when using a optimistic transactional or simple cache. Both non transactional and pessimistic transactional caches are supported. &lt;p&gt; The stream will not share any ongoing transaction the user may have. Code executed by the stream should be treated as completely independent. That is any operation performed via the stream will require the user to start their own transaction or will be done intrinsically on the invocation. Note that if there is an ongoing transaction that has a lock on a key from the cache, that it will cause a deadlock. &lt;p&gt; Currently simple cache,  {@link org.infinispan.configuration.cache.ConfigurationBuilder#simpleCache(boolean)}was set to true, and optimistic caches, {@link org.infinispan.configuration.cache.TransactionConfigurationBuilder#lockingMode(LockingMode)} was set to{@link LockingMode#OPTIMISTIC}, do not support this method. In this case it will throw an {@link UnsupportedOperationException}. This restriction may be removed in a future version. Also this method cannot be used on a cache that has a lock owner already specified via {@link AdvancedCache#lockAs(Object)} as this could lead to a deadlock or the release of locks early and willthrow an  {@link IllegalStateException}.
 * @return the locked stream
 * @throws UnsupportedOperationException this is thrown if invoked from a cache that doesn't support this
 * @throws IllegalStateException if this cache has already explicitly set a lock owner
 * @since 9.1
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeExpired</MethodName>
            <MethodComment>/** 
 * Attempts to remove the entry if it is expired.  Due to expired entries not being consistent across nodes, this will still attempt to remove the value if it is not present.  Note that this will raise an expired event even if the entry is not present.  Normally this method should never be invoked except by the {@link ExpirationManager}. &lt;p&gt; This command will only remove the value if the value and lifespan also match if provided. &lt;p&gt; NOTE: This method may be removed at any point including in a minor release and is not supported for external usage.
 * @param key the key that is expiring
 * @param value the value that mapped to the given.  Null means it will match any value
 * @param lifespan the lifespan that should match.  If null is provided it will match any lifespan value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lifespan</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withEncoding</MethodName>
            <MethodComment>/** 
 * Performs any cache operations using the specified pair of  {@link Encoder}.
 * @param keyEncoder   {@link Encoder} for the keys.
 * @param valueEncoder {@link Encoder} for the values.
 * @return an instance of {@link AdvancedCache} where all operations will use the supplied encoders.
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keyEncoder</ParamName>
                    <ParamType>? extends Encoder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueEncoder</ParamName>
                    <ParamType>? extends Encoder</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWrapping</MethodName>
            <MethodComment>/** 
 * Performs any cache operations using the specified pair of  {@link Wrapper}.
 * @param keyWrapper   {@link Wrapper} for the keys.
 * @param valueWrapper {@link Wrapper} for the values.
 * @return {@link AdvancedCache} where all operations will use the supplied wrappers.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keyWrapper</ParamName>
                    <ParamType>? extends Wrapper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueWrapper</ParamName>
                    <ParamType>? extends Wrapper</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withEncoding</MethodName>
            <MethodComment>/** 
 * Performs any cache operations using the specified  {@link Encoder}.
 * @param encoder {@link Encoder} used for both keys and values.
 * @return an instance of {@link AdvancedCache} where all operations will use the supplied encoder.
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>encoder</ParamName>
                    <ParamType>? extends Encoder</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWrapping</MethodName>
            <MethodComment>/** 
 * Performs any cache operations using the specified  {@link Wrapper}.
 * @param wrapper {@link Wrapper} for the keys and values.
 * @return an instance of {@link AdvancedCache} where all operations will use the supplied wrapper.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>wrapper</ParamName>
                    <ParamType>? extends Wrapper</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKeyEncoder</MethodName>
            <MethodComment>/** 
 * @return The associated {@link Encoder} for the keys.
 * @deprecated Use {@link #getKeyDataConversion()} and then {@link DataConversion#getEncoder()}
 */
</MethodComment>
            <ReturnType>Encoder</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValueEncoder</MethodName>
            <MethodComment>/** 
 * @return The associated {@link Encoder} for the cache's values.
 * @deprecated Use {@link #getValueDataConversion()} ()} and then {@link DataConversion#getEncoder()}
 */
</MethodComment>
            <ReturnType>Encoder</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKeyWrapper</MethodName>
            <MethodComment>/** 
 * @return The associated {@link Wrapper} for the cache's keys.
 * @deprecated Use {@link #getKeyDataConversion()} and then {@link DataConversion#getWrapper()}
 */
</MethodComment>
            <ReturnType>Wrapper</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValueWrapper</MethodName>
            <MethodComment>/** 
 * @return The associated {@link Wrapper} for the cache's values.
 * @deprecated Use {@link #getValueDataConversion()} ()} and then {@link DataConversion#getWrapper()}
 */
</MethodComment>
            <ReturnType>Wrapper</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKeyDataConversion</MethodName>
            <MethodComment>/** 
 * @return The associated {@link DataConversion} for the keys.
 */
</MethodComment>
            <ReturnType>DataConversion</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValueDataConversion</MethodName>
            <MethodComment>/** 
 * @return The associated {@link DataConversion} for the cache's values.
 */
</MethodComment>
            <ReturnType>DataConversion</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>