<Class>
    <Id>3279</Id>
    <Package>org.infinispan.interceptors.locking</Package>
    <ClassName>AbstractTxLockingInterceptor</ClassName>
    <SuperClass>AbstractLockingInterceptor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AbstractTxLockingInterceptor  /** 
 * Base class for transaction based locking interceptors.
 * @author Mircea.Markus@jboss.com
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rpcManager</FieldName>
            <FieldType>RpcManager</FieldType>
        </Field>
        <Field>
            <FieldName>partitionHandlingManager</FieldName>
            <FieldType>PartitionHandlingManager</FieldType>
        </Field>
        <Field>
            <FieldName>pendingLockManager</FieldName>
            <FieldType>PendingLockManager</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>setDependencies</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rpcManager</ParamName>
                    <ParamType>RpcManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>partitionHandlingManager</ParamName>
                    <ParamType>PartitionHandlingManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pendingLockManager</ParamName>
                    <ParamType>PendingLockManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitRollbackCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>TxInvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>RollbackCommand</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleReadManyCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>FlagAffectedCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCommitCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>TxInvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>CommitCommand</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockOrRegisterBackupLock</MethodName>
            <MethodComment>/** 
 * The backup (non-primary) owners keep a "backup lock" for each key they received in a lock/prepare command. Normally there can be many transactions holding the backup lock at the same time, but when the secondary owner becomes a primary owner a new transaction trying to obtain the "real" lock will have to wait for all backup locks to be released. The backup lock will be released either by a commit/rollback/unlock command or by the originator leaving the cluster (if recovery is disabled).
 * @return {@code true} if the key was really locked.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockTimeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockAllOrRegisterBackupLock</MethodName>
            <MethodComment>/** 
 * Same as  {@link #lockOrRegisterBackupLock(TxInvocationContext,Object,long)}
 * @return a collection with the keys locked.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockTimeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Log [log=getLog()]</InnerVar>
                <InnerVar>Collection&lt;Object&gt; [keysToLock=new ArrayList&lt;&gt;(keys.size())]</InnerVar>
                <InnerVar>LocalizedCacheTopology [cacheTopology=cdl.getCacheTopology()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkPendingAndLockAllKeys;[ctx, keysToLock, lockTimeout]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkPendingAndLockKey</MethodName>
            <MethodComment>/** 
 * Besides acquiring a lock, this method also handles the following situation: 1. consistentHash("k") == {A, B}, tx1 prepared on A and B. Then node A crashed (A  == single lock owner) 2. at this point tx2 which also writes "k" tries to prepare on B. 3. tx2 has to determine that "k" is already locked by another tx (i.e. tx1) and it has to wait for that tx to finish before acquiring the lock. The algorithm used at step 3 is: - the transaction table(TT) associates the current topology id with every remote and local transaction it creates - TT also keeps track of the minimal value of all the topology ids of all the transactions still present in the cache (minTopologyId) - when a tx wants to acquire lock "k": - if tx.topologyId &gt; TT.minTopologyId then "k" might be a key whose owner crashed. If so: - obtain the list LT of transactions that started in a previous topology (txTable.getTransactionsPreparedBefore) - for each t in LT: - if t wants to write "k" then block until t finishes (CacheTransaction.waitForTransactionsToFinishIfItWritesToKey) - only then try to acquire lock on "k" - if tx.topologyId == TT.minTopologyId try to acquire lock straight away. Note: The algorithm described below only when nodes leave the cluster, so it doesn't add a performance burden when the cluster is stable.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockTimeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [remaining=pendingLockManager.awaitPendingTransactionsForKey((TxInvocationContext&lt;?&gt;)ctx,key,lockTimeout,TimeUnit.MILLISECONDS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;lockAndRecord;[ctx, key, remaining]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkPendingAndLockAllKeys</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockTimeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [remaining=pendingLockManager.awaitPendingTransactionsForAllKeys((TxInvocationContext&lt;?&gt;)ctx,keys,lockTimeout,TimeUnit.MILLISECONDS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;lockAllAndRecord;[ctx, keys, remaining]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseLockOnTxCompletion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>TxInvocationContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [shouldReleaseLocks=ctx.isOriginLocal() &amp;&amp; !partitionHandlingManager.isTransactionPartiallyCommitted(ctx.getGlobalTransaction())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>