<Class>
    <Id>3296</Id>
    <Package>org.infinispan.conflict.impl</Package>
    <ClassName>DefaultConflictManager</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>InternalConflictManager</SuperInterface>
        <SuperInterface>K</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DefaultConflictManager  /** 
 * @author Ryan Emerson
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>localFlags</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>userMergeFlags</FieldName>
            <FieldType>Flag[]</FieldType>
        </Field>
        <Field>
            <FieldName>autoMergeFlags</FieldName>
            <FieldType>Flag[]</FieldType>
        </Field>
        <Field>
            <FieldName>interceptorChain</FieldName>
            <FieldType>AsyncInterceptorChain</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>AdvancedCache</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>commandsFactory</FieldName>
            <FieldType>CommandsFactory</FieldType>
        </Field>
        <Field>
            <FieldName>distributionManager</FieldName>
            <FieldType>DistributionManager</FieldType>
        </Field>
        <Field>
            <FieldName>entryMergePolicy</FieldName>
            <FieldType>EntryMergePolicy</FieldType>
        </Field>
        <Field>
            <FieldName>entryMergePolicy</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferExecutor</FieldName>
            <FieldType>ExecutorService</FieldType>
        </Field>
        <Field>
            <FieldName>invocationContextFactory</FieldName>
            <FieldType>InvocationContextFactory</FieldType>
        </Field>
        <Field>
            <FieldName>rpcManager</FieldName>
            <FieldType>RpcManager</FieldType>
        </Field>
        <Field>
            <FieldName>stateConsumer</FieldName>
            <FieldType>StateConsumer</FieldType>
        </Field>
        <Field>
            <FieldName>stateReceiver</FieldName>
            <FieldType>StateReceiver</FieldType>
        </Field>
        <Field>
            <FieldName>stateReceiver</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>cacheName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>localAddress</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>rpcOptions</FieldName>
            <FieldType>RpcOptions</FieldType>
        </Field>
        <Field>
            <FieldName>streamInProgress</FieldName>
            <FieldType>AtomicBoolean</FieldType>
        </Field>
        <Field>
            <FieldName>versionRequestMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>versionRequestMap</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>retryQueue</FieldName>
            <FieldType>Queue</FieldType>
        </Field>
        <Field>
            <FieldName>retryQueue</FieldName>
            <FieldType>VersionRequest</FieldType>
        </Field>
        <Field>
            <FieldName>installedTopology</FieldName>
            <FieldType>LocalizedCacheTopology</FieldType>
        </Field>
        <Field>
            <FieldName>running</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>key</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>postpone</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>completableFuture</FieldName>
            <FieldType>CompletableFuture</FieldType>
        </Field>
        <Field>
            <FieldName>completableFuture</FieldName>
            <FieldType>Map&lt;Address,InternalCacheValue&lt;V&gt;&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>rpcFuture</FieldName>
            <FieldType>CompletableFuture</FieldType>
        </Field>
        <Field>
            <FieldName>rpcFuture</FieldName>
            <FieldType>Map&lt;Address,Response&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>keyOwners</FieldName>
            <FieldType>Collection</FieldType>
        </Field>
        <Field>
            <FieldName>keyOwners</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>topology</FieldName>
            <FieldType>LocalizedCacheTopology</FieldType>
        </Field>
        <Field>
            <FieldName>totalSegments</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextSegment</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>iterator</FieldName>
            <FieldType>Iterator</FieldType>
        </Field>
        <Field>
            <FieldName>iterator</FieldName>
            <FieldType>Map&lt;Address,CacheEntry&lt;K,V&gt;&gt;</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>interceptorChain</ParamName>
                    <ParamType>AsyncInterceptorChain</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commandsFactory</ParamName>
                    <ParamType>CommandsFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distributionManager</ParamName>
                    <ParamType>DistributionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateTransferExecutor</ParamName>
                    <ParamType>ExecutorService</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>invocationContextFactory</ParamName>
                    <ParamType>InvocationContextFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rpcManager</ParamName>
                    <ParamType>RpcManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateConsumer</ParamName>
                    <ParamType>StateConsumer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateReceiver</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initRpcOptions;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cache.getCacheConfiguration().clustering().attributes().attribute(ClusteringConfiguration.REMOTE_TIMEOUT);addListener;[((a,o) -&gt; initRpcOptions())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initRpcOptions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onTopologyUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheTopology</ParamName>
                    <ParamType>LocalizedCacheTopology</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cancelVersionRequests</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restartVersionRequests</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>VersionRequest [request]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllVersions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Address</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>VersionRequest [request]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIsRunning;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Map&lt;Address,CacheEntry&lt;K,V&gt;&gt;</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIsRunning;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Map&lt;Address,CacheEntry&lt;K,V&gt;&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topology</ParamName>
                    <ParamType>LocalizedCacheTopology</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConflictResolutionInProgress</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resolveConflicts;[entryMergePolicy]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergePolicy</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIsRunning;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;doResolveConflicts;[installedTopology, mergePolicy, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topology</ParamName>
                    <ParamType>CacheTopology</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LocalizedCacheTopology [localizedTopology]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doResolveConflicts;[localizedTopology, entryMergePolicy, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doResolveConflicts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topology</ParamName>
                    <ParamType>LocalizedCacheTopology</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergePolicy</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userCall</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Address&gt; [preferredPartition=new HashSet&lt;&gt;(topology.getCurrentCH().getMembers())]</InnerVar>
                <InnerVar>AdvancedCache&lt;K,V&gt; [cache=this.cache.withFlags(userCall ? userMergeFlags : autoMergeFlags)]</InnerVar>
                <InnerVar>Phaser [phaser=new Phaser(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getConflicts(topology);forEach;[conflictMap -&gt; {
  phaser.register();
  stateTransferExecutor.execute(() -&gt; {
    if (trace)     log.tracef("Conflict detected %s",conflictMap);
    Collection&lt;CacheEntry&lt;K,V&gt;&gt; entries=conflictMap.values();
    Optional&lt;K&gt; optionalEntry=entries.stream().filter(entry -&gt; !(entry instanceof NullCacheEntry)).map(CacheEntry::getKey).findAny();
    final K key=optionalEntry.orElseThrow(() -&gt; new CacheException("All returned conflicts are NullCacheEntries. This should not happen!"));
    Address primaryReplica=topology.getDistribution(key).primary();
    List&lt;Address&gt; preferredEntries=conflictMap.entrySet().stream().map(Map.Entry::getKey).filter(preferredPartition::contains).collect(Collectors.toList());
    CacheEntry&lt;K,V&gt; preferredEntry;
    if (preferredEntries.size() == 1) {
      preferredEntry=conflictMap.remove(preferredEntries.get(0));
    }
 else {
      preferredEntry=conflictMap.remove(primaryReplica);
    }
    if (trace)     log.tracef("Applying EntryMergePolicy %s to PreferredEntry %s, otherEntries %s",mergePolicy.getClass().getName(),preferredEntry,entries);
    CacheEntry&lt;K,V&gt; entry=preferredEntry instanceof NullCacheEntry ? null : preferredEntry;
    List&lt;CacheEntry&lt;K,V&gt;&gt; otherEntries=entries.stream().filter(e -&gt; !(e instanceof NullCacheEntry)).collect(Collectors.toList());
    CacheEntry&lt;K,V&gt; mergedEntry=mergePolicy.merge(entry,otherEntries);
    CompletableFuture&lt;V&gt; future;
    if (mergedEntry == null) {
      if (trace)       log.tracef("Executing remove on conflict: key %s",key);
      future=cache.removeAsync(key);
    }
 else {
      if (trace)       log.tracef("Executing update on conflict: key %s with value %s",key,mergedEntry.getValue());
      future=cache.putAsync(key,mergedEntry.getValue(),mergedEntry.getMetadata());
    }
    future.whenComplete((responseMap,exception) -&gt; {
      if (trace)       log.tracef("ResolveConflicts future complete for key %s: ResponseMap=%s, Exception=%s",key,responseMap,exception);
      phaser.arriveAndDeregister();
      if (exception != null)       log.exceptionDuringConflictResolution(key,exception);
    }
);
  }
);
}
]</InnerMethodInvoke>
                <InnerMethodInvoke>phaser;arriveAndAwaitAdvance;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStateTransferInProgress</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIsRunning</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>VersionRequest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>postpone</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cancelRequestIfOutdated</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Collection&lt;Address&gt; [latestOwners=installedTopology.getWriteOwners(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LocalizedCacheTopology [topology=installedTopology]</InnerVar>
                <InnerVar>Map&lt;Address,InternalCacheValue&lt;V&gt;&gt; [versionsMap=new HashMap&lt;&gt;()]</InnerVar>
                <InnerVar>ClusteredGetCommand [cmd=commandsFactory.buildClusteredGetCommand(key,FlagBitSets.SKIP_OWNERSHIP_CHECK)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cmd;setTopologyId;[topology.getTopologyId()]</InnerMethodInvoke>
                <InnerMethodInvoke>rpcFuture;whenComplete;[(responseMap,exception) -&gt; {
  if (trace)   log.tracef("%s received responseMap %s, exception %s",this,responseMap,exception);
  if (exception != null) {
    String msg=String.format("%s encountered when attempting '%s' on cache '%s'",exception.getCause(),this,cacheName);
    completableFuture.completeExceptionally(new CacheException(msg,exception.getCause()));
    return;
  }
  for (  Map.Entry&lt;Address,Response&gt; entry : responseMap.entrySet()) {
    if (trace)     log.tracef("%s received response %s from %s",this,entry.getValue(),entry.getKey());
    Response rsp=entry.getValue();
    if (rsp instanceof SuccessfulResponse) {
      SuccessfulResponse response=(SuccessfulResponse)rsp;
      Object rspVal=response.getResponseValue();
synchronized (versionsMap) {
        versionsMap.put(entry.getKey(),(InternalCacheValue&lt;V&gt;)rspVal);
      }
    }
 else     if (rsp instanceof UnsureResponse) {
      log.debugf("Received UnsureResponse, restarting request %s",this);
      this.start();
      return;
    }
 else     if (rsp instanceof CacheNotFoundResponse) {
      if (trace)       log.tracef("Ignoring CacheNotFoundResponse: %s",rsp);
    }
 else {
      completableFuture.completeExceptionally(new CacheException(String.format("Unable to retrieve key %s from %s: %s",key,entry.getKey(),entry.getValue())));
      return;
    }
  }
  completableFuture.complete(versionsMap);
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterConsistentEntries</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>? super Map&lt;Address,CacheEntry&lt;K,V&gt;&gt;</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ReplicaSpliterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topology</ParamName>
                    <ParamType>LocalizedCacheTopology</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tryAdvance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>? super Map&lt;Address,CacheEntry&lt;K,V&gt;&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>action;accept;[iterator.next()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>