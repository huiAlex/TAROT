<Class>
    <Id>494</Id>
    <Package>org.infinispan.tree</Package>
    <ClassName>Node</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Node  /** 
 * A Node is a  {@link Fqn named} logical grouping of data in the {@link TreeCache} API of JBoss {@link Cache}. A node should be used to contain data for a single data record, for example information about a particular person or account. &lt;p/&gt; One purpose of grouping cache data into separate nodes is to minimize transaction locking interference, and increase concurrency.  So for example, when multiple threads or possibly distributed caches are accessing different accounts simultaneously. &lt;p/&gt; A node has references to its children, parent (each node except the root - defined by  {@link Fqn#ROOT} - has a singleparent) and data contained within the node (as key/value pairs).  The data access methods are similar to the collections  {@link Map} interface, but some are read-only or return copies of the underlying data.&lt;p/&gt;
 * @author &lt;a href="mailto:manik AT jboss DOT org"&gt;Manik Surtani (manik AT jboss DOT org)&lt;/a&gt;
 * @see TreeCache
 * @since 4.0
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>getParent</MethodName>
            <MethodComment>/** 
 * Returns the parent node. If this is the root node, this method returns &lt;code&gt;this&lt;/code&gt;.
 * @return the parent node, or self if this is the root node
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChildren</MethodName>
            <MethodComment>/** 
 * Returns an immutable set of children nodes.
 * @return an immutable {@link Set} of child nodes.  Empty {@link Set} if there aren't any children.
 */
</MethodComment>
            <ReturnType>Node&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Node&lt;K,V&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChildrenNames</MethodName>
            <MethodComment>/** 
 * Returns an immutable set of children node names.
 * @return an immutable {@link Set} of child node names.  Empty {@link Set} if there aren't any children.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChildrenNames</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getData</MethodName>
            <MethodComment>/** 
 * Returns a map containing the data in this  {@link Node}.
 * @return a {@link Map} containing the data in this {@link Node}.  If there is no data, an empty  {@link Map} isreturned.  The  {@link Map} returned is always immutable.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKeys</MethodName>
            <MethodComment>/** 
 * Returns a  {@link Set} containing the data in this {@link Node}.
 * @return a {@link Set} containing the data in this {@link Node}.  If there is no data, an empty  {@link Set} isreturned.  The  {@link Set} returned is always immutable.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKeys</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFqn</MethodName>
            <MethodComment>/** 
 * Returns the  {@link Fqn} which represents the location of this {@link Node} in the cache structure.  The {@link Fqn} returned is absolute.
 * @return The {@link Fqn} which represents the location of this {@link Node} in the cache structure.  The {@link Fqn} returned is absolute.
 */
</MethodComment>
            <ReturnType>Fqn</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addChild</MethodName>
            <MethodComment>/** 
 * Adds a child node with the given  {@link Fqn} under the current node.  Returns the newly created node.&lt;p/&gt; If the child exists returns the child node anyway.  Guaranteed to return a non-null node. &lt;p/&gt; The  {@link Fqn} passed in is relative to the current node.  The new child node will have an absolute fqncalculated as follows: &lt;pre&gt;new Fqn(getFqn(), f)&lt;/pre&gt;.  See  {@link Fqn} for the operation of this constructor.
 * @param f {@link Fqn} of the child node, relative to the current node.
 * @return the newly created node, or the existing node if one already exists.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChild</MethodName>
            <MethodComment>/** 
 * Removes a child node specified by the given relative  {@link Fqn}. &lt;p/&gt; If you wish to remove children based on absolute  {@link Fqn}s, use the  {@link TreeCache} interface instead.
 * @param f {@link Fqn} of the child node, relative to the current node.
 * @return true if the node was found and removed, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChild</MethodName>
            <MethodComment>/** 
 * Removes a child node specified by the given name.
 * @param childName name of the child node, directly under the current node.
 * @return true if the node was found and removed, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>childName</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>childName</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChild</MethodName>
            <MethodComment>/** 
 * Returns the child node
 * @param f {@link Fqn} of the child node
 * @return null if the child does not exist.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChild</MethodName>
            <MethodComment>/** 
 * @param name name of the child
 * @return a direct child of the current node.
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment>/** 
 * Associates the specified value with the specified key for this node. If this node previously contained a mapping for this key, the old value is replaced by the specified value.
 * @param key   key with which the specified value is to be associated.
 * @param value value to be associated with the specified key.
 * @return Returns the old value contained under this key.  Null if key doesn't exist.
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putIfAbsent</MethodName>
            <MethodComment>/** 
 * If the specified key is not already associated with a value, associate it with the given value, and returns the Object (if any) that occupied the space, or null. &lt;p/&gt; Equivalent to calling &lt;pre&gt; if (!node.getKeys().contains(key)) return node.put(key, value); else return node.get(key); &lt;/pre&gt; &lt;p/&gt; except that this is atomic.
 * @param key   key with which the specified value is to be associated.
 * @param value value to be associated with the specified key.
 * @return previous value associated with specified key, or null if there was no mapping for key.
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putIfAbsent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * Replace entry for key only if currently mapped to some value. Acts as &lt;pre&gt; if ((node.getKeys().contains(key)) { return node.put(key, value); } else return null; &lt;/pre&gt; &lt;p/&gt; except that this is atomic.
 * @param key   key with which the specified value is associated.
 * @param value value to be associated with the specified key.
 * @return previous value associated with specified key, or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for key.
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * Replace entry for key only if currently mapped to given value. Acts as &lt;pre&gt; if (node.get(key).equals(oldValue)) { node.put(key, newValue); return true; } else return false; &lt;/pre&gt; &lt;p/&gt; except that this is atomic.
 * @param key      key with which the specified value is associated.
 * @param oldValue value expected to be associated with the specified key.
 * @param newValue value to be associated with the specified key.
 * @return true if the value was replaced
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAll</MethodName>
            <MethodComment>/** 
 * Copies all of the mappings from the specified map to this node's map. If any data exists, existing keys are overwritten with the keys in the new map. The behavior is equivalent to: &lt;pre&gt; Node node; for (Map.Entry me : map.entrySet()) node.put(me.getKey(), me.getValue()); &lt;/pre&gt;
 * @param map map to copy from
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAll</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceAll</MethodName>
            <MethodComment>/** 
 * Similar to  {@link #putAll(java.util.Map)} except that it removes any entries that exists in the data map first.Note that this happens atomically, under a single lock.  This is the analogous to doing a  {@link #clearData()}followed by a  {@link #putAll(java.util.Map)} in the same transaction.
 * @param map map to copy from
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceAll</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * Returns the value to which this node maps the specified key. Returns &lt;code&gt;null&lt;/code&gt; if the node contains no mapping for this key.
 * @param key key of the data to return
 * @return the value to which this node maps the specified key, or &lt;code&gt;null&lt;/code&gt; if the map contains no mappingfor this key
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment>/** 
 * Removes the mapping for this key from this node if it is present. Returns the value to which the node previously associated the key, or &lt;code&gt;null&lt;/code&gt; if the node contained no mapping for this key
 * @param key key whose mapping is to be removed
 * @return previous value associated with specified key, or &lt;code&gt;null&lt;/code&gt; if there was no mapping for key
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearData</MethodName>
            <MethodComment>/** 
 * Removes all mappings from the node's data map.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataSize</MethodName>
            <MethodComment>/** 
 * @return the number of elements (key/value pairs) in the node's data map.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasChild</MethodName>
            <MethodComment>/** 
 * Returns true if the child node denoted by the relative  {@link Fqn} passed in exists.
 * @param f {@link Fqn} relative to the current node of the child you are testing the existence of.
 * @return true if the child node denoted by the relative {@link Fqn} passed in exists.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>Fqn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasChild</MethodName>
            <MethodComment>/** 
 * Returns true if the child node denoted by the Object name passed in exists.
 * @param o name of the child, relative to the current node
 * @return true if the child node denoted by the name passed in exists.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasChild</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isValid</MethodName>
            <MethodComment>/** 
 * Tests if a node reference is still valid.  A node reference may become invalid if it has been removed, invalidated or moved, either locally or remotely.  If a node is invalid, it should be fetched again from the cache or a valid parent node.  Operations on invalid nodes will throw a  {@link org.infinispan.tree.NodeNotValidException}.
 * @return true if the node is valid.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flags</ParamName>
                    <ParamType>Flag</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>