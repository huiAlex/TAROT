<Class>
    <Id>3426</Id>
    <Package>org.infinispan.stream.impl.termop.object</Package>
    <ClassName>NoMapIteratorOperation</ClassName>
    <SuperClass>MapIteratorOperation</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>NoMapIteratorOperation  /** 
 * Terminal rehash aware operation that handles an iterator when no flat map or map intermediate operation was performed on the stream.  This is important due to the fact that we can just return the entries as is and the client can sort out what is the key and what isn't.
 * @param &lt; K &gt; key type
 * @param &lt; V &gt; resulting value type
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>NoMapIteratorOperation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>intermediateOperations</ParamName>
                    <ParamType>IntermediateOperation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>supplier</ParamName>
                    <ParamType>Stream&lt;CacheEntry&gt;</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>batchSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lostSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stopIfLost</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performOperation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>Collection&lt;V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseStream&lt;?,?&gt; [stream=supplier.get()]</InnerVar>
                <InnerVar>Stream&lt;V&gt; [convertedStream=((Stream&lt;V&gt;)stream)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>actualPerformOperation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>R</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>Collection&lt;R&gt;</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>R</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BiConsumer&lt;List&lt;R&gt;,R&gt; [accumulator=(l,e) -&gt; {
  l.add(e);
  if (l.size() &gt;= batchSize) {
    response.sendDataResonse(l);
    l.clear();
  }
}
]</InnerVar>
                <InnerVar>List&lt;R&gt; [list=stream.collect(ArrayList::new,accumulator,(l1,l2) -&gt; {
  l2.forEach(e -&gt; accumulator.accept(l1,e));
}
)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performOperationRehashAware</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CacheEntry&lt;K,V&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>response</ParamName>
                    <ParamType>Collection&lt;CacheEntry&lt;K,V&gt;&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseStream&lt;?,?&gt; [stream=supplier.get().sequential()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>