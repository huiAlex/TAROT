<Class>
    <Id>1268</Id>
    <Package>org.infinispan.hibernate.cache.access</Package>
    <ClassName>PutFromLoadValidator</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>PutFromLoadValidator  /** 
 * Encapsulates logic to allow a  {@link InvalidationCacheAccessDelegate} to determinewhether a  {@link InvalidationCacheAccessDelegate#putFromLoad(org.hibernate.engine.spi.SessionImplementor,Object,Object,long,Object,boolean)}call should be allowed to update the cache. A &lt;code&gt;putFromLoad&lt;/code&gt; has the potential to store stale data, since the data may have been removed from the database and the cache between the time when the data was read from the database and the actual call to &lt;code&gt;putFromLoad&lt;/code&gt;. &lt;p&gt; The expected usage of this class by a thread that read the cache and did not find data is: &lt;p/&gt; &lt;ol&gt; &lt;li&gt; Call  {@link #registerPendingPut(SessionImplementor,Object,long)}&lt;/li&gt; &lt;li&gt; Read the database&lt;/li&gt; &lt;li&gt; Call  {@link #acquirePutFromLoadLock(SessionImplementor,Object,long)}&lt;li&gt; if above returns &lt;code&gt;null&lt;/code&gt;, the thread should not cache the data; only if above returns instance of &lt;code&gt;AcquiredLock&lt;/code&gt;, put data in the cache and...&lt;/li&gt; &lt;li&gt; then call  {@link #releasePutFromLoadLock(Object,Lock)}&lt;/li&gt; &lt;/ol&gt; &lt;/p&gt; &lt;p/&gt; &lt;p&gt; The expected usage by a thread that is taking an action such that any pending &lt;code&gt;putFromLoad&lt;/code&gt; may have stale data and should not cache it is to either call &lt;p/&gt; &lt;ul&gt; &lt;li&gt;  {@link #beginInvalidatingKey(Object,Object)} (for a single key invalidation)&lt;/li&gt;&lt;li&gt;or  {@link #beginInvalidatingRegion()} followed by {@link #endInvalidatingRegion()}(for a general invalidation all pending puts)&lt;/li&gt; &lt;/ul&gt; After transaction commit (when the DB is updated)  {@link #endInvalidatingKey(Object,Object)} shouldbe called in order to allow further attempts to cache entry. &lt;/p&gt; &lt;p/&gt; &lt;p&gt; This class also supports the concept of "naked puts", which are calls to {@link #acquirePutFromLoadLock(SessionImplementor,Object,long)} without a preceding {@link #registerPendingPut(SessionImplementor,Object,long)}. Besides not acquiring lock in  {@link #registerPendingPut(SessionImplementor,Object,long)} this can happen when collectionelements are loaded after the collection has not been found in the cache, where the elements don't have their own table but can be listed as 'select ... from Element where collection_id = ...'. Naked puts are handled according to txTimestamp obtained by calling  {@link RegionFactory#nextTimestamp()}before the transaction is started. The timestamp is compared with timestamp of last invalidation end time and the write to the cache is denied if it is lower or equal. &lt;/p&gt;
 * @author Brian Stansberry
 * @version $Revision: $
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>InfinispanMessageLogger</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>expirationPeriod</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>pendingPuts</FieldName>
            <FieldType>Cache</FieldType>
        </Field>
        <Field>
            <FieldName>pendingPuts</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>AdvancedCache</FieldType>
        </Field>
        <Field>
            <FieldName>regionFactory</FieldName>
            <FieldType>InfinispanRegionFactory</FieldType>
        </Field>
        <Field>
            <FieldName>nonTxPutFromLoadInterceptor</FieldName>
            <FieldType>NonTxPutFromLoadInterceptor</FieldType>
        </Field>
        <Field>
            <FieldName>regionInvalidationTimestamp</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>regionInvalidations</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentSession</FieldName>
            <FieldType>ThreadLocal</FieldType>
        </Field>
        <Field>
            <FieldName>currentSession</FieldName>
            <FieldType>SessionImplementor</FieldType>
        </Field>
        <Field>
            <FieldName>GC_THRESHOLD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>singlePendingPut</FieldName>
            <FieldType>PendingPut</FieldType>
        </Field>
        <Field>
            <FieldName>fullMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>fullMap</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>lock</FieldName>
            <FieldType>java.util.concurrent.locks.Lock</FieldType>
        </Field>
        <Field>
            <FieldName>singleInvalidator</FieldName>
            <FieldType>Invalidator</FieldType>
        </Field>
        <Field>
            <FieldName>invalidators</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>invalidators</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>lastInvalidationEnd</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>removed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>owner</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>completed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>registeredTimestamp</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>owner</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>registeredTimestamp</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>valueForPFER</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>PutFromLoadValidator</MethodName>
            <MethodComment>/** 
 * Creates a new put from load validator instance.
 * @param cache Cache instance on which to store pending put information.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>AdvancedCache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regionFactory</ParamName>
                    <ParamType>InfinispanRegionFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PutFromLoadValidator</MethodName>
            <MethodComment>/** 
 * Creates a new put from load validator instance.
 * @param cache Cache instance on which to store pending put information.
 * @param regionFactory
 * @param cacheManager where to find a cache to store pending put information
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>AdvancedCache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regionFactory</ParamName>
                    <ParamType>InfinispanRegionFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cacheManager</ParamName>
                    <ParamType>EmbeddedCacheManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Configuration [cacheConfiguration=cache.getCacheConfiguration()]</InnerVar>
                <InnerVar>Configuration [pendingPutsConfiguration=regionFactory.getPendingPutsCacheConfiguration()]</InnerVar>
                <InnerVar>ConfigurationBuilder [configurationBuilder=new ConfigurationBuilder()]</InnerVar>
                <InnerVar>String [pendingPutsName=getPendingPutsName(cache)]</InnerVar>
                <InnerVar>CacheMode [cacheMode=cache.getCacheConfiguration().clustering().cacheMode()]</InnerVar>
                <InnerVar>NonTxPutFromLoadInterceptor [nonTxPutFromLoadInterceptor=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>configurationBuilder;read;[pendingPutsConfiguration]</InnerMethodInvoke>
                <InnerMethodInvoke>configurationBuilder.dataContainer();keyEquivalence;[cacheConfiguration.dataContainer().keyEquivalence()]</InnerMethodInvoke>
                <InnerMethodInvoke>cacheManager;defineConfiguration;[pendingPutsName, configurationBuilder.build()]</InnerMethodInvoke>
                <InnerMethodInvoke>this.pendingPuts;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPendingPutsName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>AdvancedCache</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addToCache</MethodName>
            <MethodComment>/** 
 * Besides the call from constructor, this should be called only from tests when mocking the validator.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>AdvancedCache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validator</ParamName>
                    <ParamType>PutFromLoadValidator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AsyncInterceptorChain [chain=cache.getAsyncInterceptorChain()]</InnerVar>
                <InnerVar>List&lt;AsyncInterceptor&gt; [interceptors=chain.getInterceptors()]</InnerVar>
                <InnerVar>int [position=0]</InnerVar>
                <InnerVar>int [invalidationPosition=0]</InnerVar>
                <InnerVar>int [entryWrappingPosition=0]</InnerVar>
                <InnerVar>boolean [transactional=cache.getCacheConfiguration().transaction().transactionMode().isTransactional()]</InnerVar>
                <InnerVar>CacheCommandInitializer [cacheCommandInitializer=cache.getComponentRegistry().getComponent(CacheCommandInitializer.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["Interceptor chain was: ", interceptors]</InnerMethodInvoke>
                <InnerMethodInvoke>log;debugf;["New interceptor chain is: ", cache.getAsyncInterceptorChain()]</InnerMethodInvoke>
                <InnerMethodInvoke>cacheCommandInitializer;addPutFromLoadValidator;[cache.getName(), validator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFromCache</MethodName>
            <MethodComment>/** 
 * This methods should be called only from tests; it removes existing validator from the cache structures in order to replace it with new one.
 * @param cache
 */
</MethodComment>
            <ReturnType>PutFromLoadValidator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>AdvancedCache</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AsyncInterceptorChain [chain=cache.getAsyncInterceptorChain()]</InnerVar>
                <InnerVar>CacheCommandInitializer [cci=cache.getComponentRegistry().getComponent(CacheCommandInitializer.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cache;removeInterceptor;[TxPutFromLoadInterceptor.class]</InnerMethodInvoke>
                <InnerMethodInvoke>cache;removeInterceptor;[NonTxPutFromLoadInterceptor.class]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentSession</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>session</ParamName>
                    <ParamType>SessionImplementor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentSession;set;[session]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetCurrentSession</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentSession;remove;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>destroy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pendingPuts;stop;[]</InnerMethodInvoke>
                <InnerMethodInvoke>pendingPuts.getCacheManager();undefineConfiguration;[pendingPuts.getName()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Lock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acquirePutFromLoadLock</MethodName>
            <MethodComment>/** 
 * Acquire a lock giving the calling thread the right to put data in the cache for the given key. &lt;p&gt; &lt;strong&gt;NOTE:&lt;/strong&gt; A call to this method that returns &lt;code&gt;true&lt;/code&gt; should always be matched with a call to  {@link #releasePutFromLoadLock(Object,Lock)}. &lt;/p&gt;
 * @param session
 * @param key the key
 * @param txTimestamp
 * @return &lt;code&gt;AcquiredLock&lt;/code&gt; if the lock is acquired and the cache putcan proceed; &lt;code&gt;null&lt;/code&gt; if the data should not be cached
 */
</MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>session</ParamName>
                    <ParamType>SessionImplementor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>txTimestamp</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [locked=false]</InnerVar>
                <InnerVar>PendingPutMap [pending=pendingPuts.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releasePutFromLoadLock</MethodName>
            <MethodComment>/** 
 * Releases the lock previously obtained by a call to {@link #acquirePutFromLoadLock(SessionImplementor,Object,long)}.
 * @param key the key
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PendingPutMap [pending=(PendingPutMap)lock]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginInvalidatingRegion</MethodName>
            <MethodComment>/** 
 * Invalidates all  {@link #registerPendingPut(SessionImplementor,Object,long) previously registered pending puts} ensuring a subsequent call to{@link #acquirePutFromLoadLock(SessionImplementor,Object,long)} will return &lt;code&gt;false&lt;/code&gt;. &lt;p&gt; This method will block until anyconcurrent thread that has  {@link #acquirePutFromLoadLock(SessionImplementor,Object,long) acquired the putFromLoad lock} for the any key hasreleased the lock. This allows the caller to be certain the putFromLoad will not execute after this method returns, possibly caching stale data. &lt;/p&gt;
 * @return &lt;code&gt;true&lt;/code&gt; if the invalidation was successful; &lt;code&gt;false&lt;/code&gt; if a problem occurred (which thecaller should treat as an exception condition)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [ok=true]</InnerVar>
                <InnerVar>long [now=regionFactory.nextTimestamp()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endInvalidatingRegion</MethodName>
            <MethodComment>/** 
 * Called when the region invalidation is finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerPendingPut</MethodName>
            <MethodComment>/** 
 * Notifies this validator that it is expected that a database read followed by a subsequent  {@link #acquirePutFromLoadLock(SessionImplementor,Object,long)} call will occur. The intent is this method would be called following a cache misswherein it is expected that a database read plus cache put will occur. Calling this method allows the validator to treat the subsequent &lt;code&gt;acquirePutFromLoadLock&lt;/code&gt; as if the database read occurred when this method was invoked. This allows the validator to compare the timestamp of this call against the timestamp of subsequent removal notifications.
 * @param session
 * @param key key that will be used for subsequent cache put
 * @param txTimestamp
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>session</ParamName>
                    <ParamType>SessionImplementor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>txTimestamp</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [invalidationTimestamp=this.regionInvalidationTimestamp]</InnerVar>
                <InnerVar>PendingPut [pendingPut=new PendingPut(session)]</InnerVar>
                <InnerVar>PendingPutMap [pendingForKey=new PendingPutMap(pendingPut)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginInvalidatingKey</MethodName>
            <MethodComment>/** 
 * Invalidates any  {@link #registerPendingPut(SessionImplementor,Object,long) previously registered pending puts}and disables further registrations ensuring a subsequent call to  {@link #acquirePutFromLoadLock(SessionImplementor,Object,long)}will return &lt;code&gt;false&lt;/code&gt;. &lt;p&gt; This method will block until any concurrent thread that has {@link #acquirePutFromLoadLock(SessionImplementor,Object,long) acquired the putFromLoad lock} for the given keyhas released the lock. This allows the caller to be certain the putFromLoad will not execute after this method returns, possibly caching stale data. &lt;/p&gt; After this transaction completes,  {@link #endInvalidatingKey(Object,Object)} needs to be called }
 * @param key key identifying data whose pending puts should be invalidated
 * @return &lt;code&gt;true&lt;/code&gt; if the invalidation was successful; &lt;code&gt;false&lt;/code&gt; if a problem occurred (which thecaller should treat as an exception condition)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginInvalidatingWithPFER</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueForPFER</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endInvalidatingKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endInvalidatingKey</MethodName>
            <MethodComment>/** 
 * Called after the transaction completes, allowing caching of entries. It is possible that this method is called without previous invocation of  {@link #beginInvalidatingKey(Object,Object)}, then it should be a no-op.
 * @param lockOwner owner of the invalidation - transaction or thread
 * @param key
 * @return
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doPFER</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PendingPutMap [pending=pendingPuts.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerRemoteInvalidation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SessionImplementor [session=currentSession.get()]</InnerVar>
                <InnerVar>TransactionCoordinator [transactionCoordinator=session == null ? null : session.getTransactionCoordinator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockOwnerToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockOwner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removePendingPutsCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [pendingPutsName=getPendingPutsName(cache)]</InnerVar>
                <InnerVar>EmbeddedCacheManager [cm=cache.getCacheManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cm;removeCache;[pendingPutsName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PendingPutMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>singleItem</ParamName>
                    <ParamType>PendingPut</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pendingPut</ParamName>
                    <ParamType>PendingPut</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PendingPut</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ownerForPut</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PendingPut [removed=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acquireLock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>time</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unit</ParamName>
                    <ParamType>TimeUnit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseLock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lock;unlock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>gc</MethodName>
            <MethodComment>/** 
 * Running  {@link #gc()} is important when the key is regularly queried but it is notpresent in DB. In such case, the putFromLoad would not be called at all and we would leak pending puts. Cache expiration should handle the case when the pending puts are not accessed frequently; when these are accessed, we have to do the housekeeping internally to prevent unlimited growth of the map. The pending puts will get their timestamps when the map reaches  {@link #GC_THRESHOLD}entries; after expiration period these will be removed completely either through invalidation or when we try to register next pending put.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long [now=regionFactory.nextTimestamp()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;tracef;["Contains %d, doing GC at %d, expiration %d", size(), now, expirationPeriod]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInvalidator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueForPFER</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasInvalidator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInvalidators</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Invalidator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeInvalidator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doPFER</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pferValueIfNeeded</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueForPFER</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doPFER</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canRemove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRemoved</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRemoved</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PendingPut</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expirationPeriod</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>gc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expirationPeriod</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Invalidator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>registeredTimestamp</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueForPFER</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder("{")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb.append("Owner=");append;[lockOwnerToString(owner)]</InnerMethodInvoke>
                <InnerMethodInvoke>sb.append(", Timestamp=");append;[registeredTimestamp]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;['}']</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>