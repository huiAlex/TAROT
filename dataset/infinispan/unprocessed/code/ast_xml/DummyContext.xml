<Class>
    <Id>3730</Id>
    <Package>org.infinispan.test.jndi</Package>
    <ClassName>DummyContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Context</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>bindings</FieldName>
            <FieldType>ConcurrentHashMap</FieldType>
        </Field>
        <Field>
            <FieldName>bindings</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>serializing</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bytes</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DummyContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DummyContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serializing</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookup</MethodName>
            <MethodComment>/** 
 * Retrieves the named object. If &lt;tt&gt;name&lt;/tt&gt; is empty, returns a new instance of this context (which represents the same naming context as this context, but its environment may be modified independently and it may be accessed concurrently).
 * @param name the name of the object to look up
 * @return the object bound to &lt;tt&gt;name&lt;/tt&gt;
 * @throws NamingException if a naming exception is encountered
 * @see #lookup(String)
 * @see #lookupLink(Name)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookup</MethodName>
            <MethodComment>/** 
 * Retrieves the named object. See  {@link #lookup(Name)} for details.
 * @param name the name of the object to look up
 * @return the object bound to &lt;tt&gt;name&lt;/tt&gt;
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bind</MethodName>
            <MethodComment>/** 
 * Binds a name to an object. All intermediate contexts and the target context (that named by all but terminal atomic component of the name) must already exist.
 * @param name the name to bind; may not be empty
 * @param obj  the object to bind; possibly null
 * @throws javax.naming.NameAlreadyBoundException if name is already bound
 * @throws javax.naming.directory.InvalidAttributesException if object did not supply all mandatory attributes
 * @throws NamingException if a naming exception is encountered
 * @see #bind(String,Object)
 * @see #rebind(Name,Object)
 * @see javax.naming.directory.DirContext#bind(Name,Object,javax.naming.directory.Attributes)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bind;["NAME: " + name.toString(), obj]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bind</MethodName>
            <MethodComment>/** 
 * Binds a name to an object. See  {@link #bind(Name,Object)} for details.
 * @param name the name to bind; may not be empty
 * @param obj  the object to bind; possibly null
 * @throws javax.naming.NameAlreadyBoundException if name is already bound
 * @throws javax.naming.directory.InvalidAttributesException if object did not supply all mandatory attributes
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rebind</MethodName>
            <MethodComment>/** 
 * Binds a name to an object, overwriting any existing binding. All intermediate contexts and the target context (that named by all but terminal atomic component of the name) must already exist. &lt;p/&gt; &lt;p&gt; If the object is a &lt;tt&gt;DirContext&lt;/tt&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.
 * @param name the name to bind; may not be empty
 * @param obj  the object to bind; possibly null
 * @throws javax.naming.directory.InvalidAttributesException if object did not supply all mandatory attributes
 * @throws NamingException if a naming exception is encountered
 * @see #rebind(String,Object)
 * @see #bind(Name,Object)
 * @see javax.naming.directory.DirContext#rebind(Name,Object,javax.naming.directory.Attributes)
 * @see javax.naming.directory.DirContext
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bind;[name, obj]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rebind</MethodName>
            <MethodComment>/** 
 * Binds a name to an object, overwriting any existing binding. See  {@link #rebind(Name,Object)} for details.
 * @param name the name to bind; may not be empty
 * @param obj  the object to bind; possibly null
 * @throws javax.naming.directory.InvalidAttributesException if object did not supply all mandatory attributes
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bind;[name, obj]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unbind</MethodName>
            <MethodComment>/** 
 * Unbinds the named object. Removes the terminal atomic name in &lt;code&gt;name&lt;/code&gt; from the target context--that named by all but the terminal atomic part of &lt;code&gt;name&lt;/code&gt;. &lt;p/&gt; &lt;p&gt; This method is idempotent. It succeeds even if the terminal atomic name is not bound in the target context, but throws &lt;tt&gt;NameNotFoundException&lt;/tt&gt; if any of the intermediate contexts do not exist. &lt;p/&gt; &lt;p&gt; Any attributes associated with the name are removed. Intermediate contexts are not changed.
 * @param name the name to unbind; may not be empty
 * @throws javax.naming.NameNotFoundException if an intermediate context does not exist
 * @throws NamingException if a naming exception is encountered
 * @see #unbind(String)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;unbind;["NAME: " + name.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unbind</MethodName>
            <MethodComment>/** 
 * Unbinds the named object. See  {@link #unbind(Name)} for details.
 * @param name the name to unbind; may not be empty
 * @throws javax.naming.NameNotFoundException if an intermediate context does not exist
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rename</MethodName>
            <MethodComment>/** 
 * Binds a new name to the object bound to an old name, and unbinds the old name.  Both names are relative to this context. Any attributes associated with the old name become associated with the new name. Intermediate contexts of the old name are not changed.
 * @param oldName the name of the existing binding; may not be empty
 * @param newName the name of the new binding; may not be empty
 * @throws javax.naming.NameAlreadyBoundException if &lt;tt&gt;newName&lt;/tt&gt; is already bound
 * @throws NamingException if a naming exception is encountered
 * @see #rename(String,String)
 * @see #bind(Name,Object)
 * @see #rebind(Name,Object)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldName</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newName</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rename</MethodName>
            <MethodComment>/** 
 * Binds a new name to the object bound to an old name, and unbinds the old name. See  {@link #rename(Name,Name)} fordetails.
 * @param oldName the name of the existing binding; may not be empty
 * @param newName the name of the new binding; may not be empty
 * @throws javax.naming.NameAlreadyBoundException if &lt;tt&gt;newName&lt;/tt&gt; is already bound
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>list</MethodName>
            <MethodComment>/** 
 * Enumerates the names bound in the named context, along with the class names of objects bound to them. The contents of any subcontexts are not included. &lt;p/&gt; &lt;p&gt; If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.
 * @param name the name of the context to list
 * @return an enumeration of the names and class names of the bindings in this context.  Each element of theenumeration is of type &lt;tt&gt;NameClassPair&lt;/tt&gt;.
 * @throws NamingException if a naming exception is encountered
 * @see #list(String)
 * @see #listBindings(Name)
 * @see javax.naming.NameClassPair
 */
</MethodComment>
            <ReturnType>NameClassPair</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>list</MethodName>
            <MethodComment>/** 
 * Enumerates the names bound in the named context, along with the class names of objects bound to them. See  {@link #list(Name)} for details.
 * @param name the name of the context to list
 * @return an enumeration of the names and class names of the bindings in this context.  Each element of theenumeration is of type &lt;tt&gt;NameClassPair&lt;/tt&gt;.
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>NameClassPair</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>listBindings</MethodName>
            <MethodComment>/** 
 * Enumerates the names bound in the named context, along with the objects bound to them. The contents of any subcontexts are not included. &lt;p/&gt; &lt;p&gt; If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.
 * @param name the name of the context to list
 * @return an enumeration of the bindings in this context. Each element of the enumeration is of type&lt;tt&gt;Binding&lt;/tt&gt;.
 * @throws NamingException if a naming exception is encountered
 * @see #listBindings(String)
 * @see #list(Name)
 * @see javax.naming.Binding
 */
</MethodComment>
            <ReturnType>Binding</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>listBindings</MethodName>
            <MethodComment>/** 
 * Enumerates the names bound in the named context, along with the objects bound to them. See  {@link #listBindings(Name)} for details.
 * @param name the name of the context to list
 * @return an enumeration of the bindings in this context. Each element of the enumeration is of type&lt;tt&gt;Binding&lt;/tt&gt;.
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>Binding</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>destroySubcontext</MethodName>
            <MethodComment>/** 
 * Destroys the named context and removes it from the namespace. Any attributes associated with the name are also removed. Intermediate contexts are not destroyed. &lt;p/&gt; &lt;p&gt; This method is idempotent. It succeeds even if the terminal atomic name is not bound in the target context, but throws &lt;tt&gt;NameNotFoundException&lt;/tt&gt; if any of the intermediate contexts do not exist. &lt;p/&gt; &lt;p&gt; In a federated naming system, a context from one naming system may be bound to a name in another.  One can subsequently look up and perform operations on the foreign context using a composite name.  However, an attempt destroy the context using this composite name will fail with &lt;tt&gt;NotContextException&lt;/tt&gt;, because the foreign context is not a "subcontext" of the context in which it is bound. Instead, use &lt;tt&gt;unbind()&lt;/tt&gt; to remove the binding of the foreign context.  Destroying the foreign context requires that the &lt;tt&gt;destroySubcontext()&lt;/tt&gt; be performed on a context from the foreign context's "native" naming system.
 * @param name the name of the context to be destroyed; may not be empty
 * @throws javax.naming.NameNotFoundException if an intermediate context does not exist
 * @throws javax.naming.NotContextException if the name is bound but does not name a context, or does not name a context of the appropriate type
 * @throws javax.naming.ContextNotEmptyException if the named context is not empty
 * @throws NamingException if a naming exception is encountered
 * @see #destroySubcontext(String)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>destroySubcontext</MethodName>
            <MethodComment>/** 
 * Destroys the named context and removes it from the namespace. See  {@link #destroySubcontext(Name)} for details.
 * @param name the name of the context to be destroyed; may not be empty
 * @throws javax.naming.NameNotFoundException if an intermediate context does not exist
 * @throws javax.naming.NotContextException if the name is bound but does not name a context, or does not name a context of the appropriate type
 * @throws javax.naming.ContextNotEmptyException if the named context is not empty
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSubcontext</MethodName>
            <MethodComment>/** 
 * Creates and binds a new context. Creates a new context with the given name and binds it in the target context (that named by all but terminal atomic component of the name).  All intermediate contexts and the target context must already exist.
 * @param name the name of the context to create; may not be empty
 * @return the newly created context
 * @throws javax.naming.NameAlreadyBoundException if name is already bound
 * @throws javax.naming.directory.InvalidAttributesException if creation of the subcontext requires specification of mandatory attributes
 * @throws NamingException if a naming exception is encountered
 * @see #createSubcontext(String)
 * @see javax.naming.directory.DirContext#createSubcontext
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSubcontext</MethodName>
            <MethodComment>/** 
 * Creates and binds a new context. See  {@link #createSubcontext(Name)} for details.
 * @param name the name of the context to create; may not be empty
 * @return the newly created context
 * @throws javax.naming.NameAlreadyBoundException if name is already bound
 * @throws javax.naming.directory.InvalidAttributesException if creation of the subcontext requires specification of mandatory attributes
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupLink</MethodName>
            <MethodComment>/** 
 * Retrieves the named object, following links except for the terminal atomic component of the name. If the object bound to &lt;tt&gt;name&lt;/tt&gt; is not a link, returns the object itself.
 * @param name the name of the object to look up
 * @return the object bound to &lt;tt&gt;name&lt;/tt&gt;, not following the terminal link (if any).
 * @throws NamingException if a naming exception is encountered
 * @see #lookupLink(String)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupLink</MethodName>
            <MethodComment>/** 
 * Retrieves the named object, following links except for the terminal atomic component of the name. See  {@link #lookupLink(Name)} for details.
 * @param name the name of the object to look up
 * @return the object bound to &lt;tt&gt;name&lt;/tt&gt;, not following the terminal link (if any)
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNameParser</MethodName>
            <MethodComment>/** 
 * Retrieves the parser associated with the named context. In a federation of namespaces, different naming systems will parse names differently.  This method allows an application to get a parser for parsing names into their atomic components using the naming convention of a particular naming system. Within any single naming system, &lt;tt&gt;NameParser&lt;/tt&gt; objects returned by this method must be equal (using the &lt;tt&gt;equals()&lt;/tt&gt; test).
 * @param name the name of the context from which to get the parser
 * @return a name parser that can parse compound names into their atomic components
 * @throws NamingException if a naming exception is encountered
 * @see #getNameParser(String)
 * @see javax.naming.CompoundName
 */
</MethodComment>
            <ReturnType>NameParser</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNameParser</MethodName>
            <MethodComment>/** 
 * Retrieves the parser associated with the named context. See  {@link #getNameParser(Name)} for details.
 * @param name the name of the context from which to get the parser
 * @return a name parser that can parse compound names into their atomic components
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>NameParser</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>composeName</MethodName>
            <MethodComment>/** 
 * Composes the name of this context with a name relative to this context. Given a name (&lt;code&gt;name&lt;/code&gt;) relative to this context, and the name (&lt;code&gt;prefix&lt;/code&gt;) of this context relative to one of its ancestors, this method returns the composition of the two names using the syntax appropriate for the naming system(s) involved.  That is, if &lt;code&gt;name&lt;/code&gt; names an object relative to this context, the result is the name of the same object, but relative to the ancestor context.  None of the names may be null. &lt;p/&gt; For example, if this context is named "wiz.com" relative to the initial context, then &lt;pre&gt; composeName("east", "wiz.com")   &lt;/pre&gt; might return &lt;code&gt;"east.wiz.com"&lt;/code&gt;. If instead this context is named "org/research", then &lt;pre&gt; composeName("user/jane", "org/research")  &lt;/pre&gt; might return &lt;code&gt;"org/research/user/jane"&lt;/code&gt; while &lt;pre&gt; composeName("user/jane", "research")   &lt;/pre&gt; returns &lt;code&gt;"research/user/jane"&lt;/code&gt;.
 * @param name   a name relative to this context
 * @param prefix the name of this context relative to one of its ancestors
 * @return the composition of &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;
 * @throws NamingException if a naming exception is encountered
 * @see #composeName(String,String)
 */
</MethodComment>
            <ReturnType>Name</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>Name</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>composeName</MethodName>
            <MethodComment>/** 
 * Composes the name of this context with a name relative to this context. See  {@link #composeName(Name,Name)} fordetails.
 * @param name   a name relative to this context
 * @param prefix the name of this context relative to one of its ancestors
 * @return the composition of &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addToEnvironment</MethodName>
            <MethodComment>/** 
 * Adds a new environment property to the environment of this context.  If the property already exists, its value is overwritten. See class description for more details on environment properties.
 * @param propName the name of the environment property to add; may not be null
 * @param propVal  the value of the property to add; may not be null
 * @return the previous value of the property, or null if the property was not in the environment before
 * @throws NamingException if a naming exception is encountered
 * @see #getEnvironment()
 * @see #removeFromEnvironment(String)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>propName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>propVal</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFromEnvironment</MethodName>
            <MethodComment>/** 
 * Removes an environment property from the environment of this context.  See class description for more details on environment properties.
 * @param propName the name of the environment property to remove; may not be null
 * @return the previous value of the property, or null if the property was not in the environment
 * @throws NamingException if a naming exception is encountered
 * @see #getEnvironment()
 * @see #addToEnvironment(String,Object)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>propName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEnvironment</MethodName>
            <MethodComment>/** 
 * Retrieves the environment in effect for this context. See class description for more details on environment properties. &lt;p/&gt; &lt;p&gt; The caller should not make any changes to the object returned: their effect on the context is undefined. The environment of this context may be changed using &lt;tt&gt;addToEnvironment()&lt;/tt&gt; and &lt;tt&gt;removeFromEnvironment()&lt;/tt&gt;.
 * @return the environment of this context; never null
 * @throws NamingException if a naming exception is encountered
 * @see #addToEnvironment(String,Object)
 * @see #removeFromEnvironment(String)
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Closes this context. This method releases this context's resources immediately, instead of waiting for them to be released automatically by the garbage collector. &lt;p/&gt; &lt;p&gt; This method is idempotent:  invoking it on a context that has already been closed has no effect.  Invoking any other method on a closed context is not allowed, and results in undefined behaviour.
 * @throws NamingException if a naming exception is encountered
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNameInNamespace</MethodName>
            <MethodComment>/** 
 * Retrieves the full name of this context within its own namespace. &lt;p/&gt; &lt;p&gt; Many naming services have a notion of a "full name" for objects in their respective namespaces.  For example, an LDAP entry has a distinguished name, and a DNS record has a fully qualified name. This method allows the client application to retrieve this name. The string returned by this method is not a JNDI composite name and should not be passed directly to context methods. In naming systems for which the notion of full name does not make sense, &lt;tt&gt;OperationNotSupportedException&lt;/tt&gt; is thrown.
 * @return this context's name in its own namespace; never null
 * @throws javax.naming.OperationNotSupportedException if the naming system does not have the notion of a full name
 * @throws NamingException if a naming exception is encountered
 * @since 1.3
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NamingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>serialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deserialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>