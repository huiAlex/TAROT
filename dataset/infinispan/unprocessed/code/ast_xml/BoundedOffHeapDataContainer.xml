<Class>
    <Id>1236</Id>
    <Package>org.infinispan.container.offheap</Package>
    <ClassName>BoundedOffHeapDataContainer</ClassName>
    <SuperClass>OffHeapDataContainer</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BoundedOffHeapDataContainer  /** 
 * Data Container implementation that stores entries in native memory (off-heap) that is also bounded.  This implementation uses a simple LRU doubly linked list off-heap guarded by a single lock. &lt;p&gt; The link list is represented by firstAddress as the had of the list and lastAddress as the tail of the list. Each entry in the list consists of 28 bytes (3 longs and 1 int), the first long is the actual entry address, the second is a pointer to the previous element in the list, the third is the next pointer and lastly the int is the hashCode of the key to retrieve the lock. The hashCode is required to know which lock to use when trying to read the entry.
 * @author wburns
 * @since 9.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>maxSize</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lruLock</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>sizeCalculator</FieldName>
            <FieldType>LongUnaryOperator</FieldType>
        </Field>
        <Field>
            <FieldName>currentSize</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>firstAddress</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lastAddress</FieldName>
            <FieldType>long</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BoundedOffHeapDataContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>desiredSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxSize</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>EvictionType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureSize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>WrappedBytes</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InternalCacheEntry&lt;WrappedBytes,WrappedBytes&gt; [result=super.compute(key,action)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entryReplaced</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [oldSize=sizeCalculator.applyAsLong(oldAddress)]</InnerVar>
                <InnerVar>long [newSize=sizeCalculator.applyAsLong(newAddress)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entryCreated</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [hashCode=offHeapEntryFactory.getHashCode(newAddress)]</InnerVar>
                <InnerVar>long [newSize=sizeCalculator.applyAsLong(newAddress)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entryRemoved</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [removedSize=sizeCalculator.applyAsLong(removedAddress)]</InnerVar>
                <InnerVar>long [lruNode=offHeapEntryFactory.getLruNode(removedAddress)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entryRetrieved</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entryAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performClear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureSize</MethodName>
            <MethodComment>/** 
 * This method repeatedly removes the head of the LRU list until there the current size is less than or equal to `maxSize`. &lt;p&gt; We need to hold the LRU lock in order to check the current size and to read the head entry, and then we need to hold the head entry's write lock in order to remove it. The problem is that the correct acquisition order is entry write lock first, LRU lock second, and we need to hold the LRU lock so that we know which entry write lock to acquire. &lt;p&gt; To work around it, we first try to acquire the entry write lock without blocking. If that fails, we release the LRU lock and we acquire the locks in the correct order, hoping that the LRU head doesn't change while we wait. Because the entry write locks are striped, we actually tolerate a LRU head change as long as the new head entry is in the same lock stripe. If the LRU list head changes, we release both locks and try again.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addEntryAddressToEnd</MethodName>
            <MethodComment>/** 
 * Method to be invoked when adding a new entry address to the end of the lru nodes.  This occurs for newly created entries. This method should only be invoked after acquiring the lruLock
 * @param entryAddress the new entry address pointer *NOT* the lru node
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entryAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hashCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [nodeAddress=allocator.allocate(OffHeapLruNode.getSize())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>OffHeapLruNode;setEntry;[nodeAddress, entryAddress]</InnerMethodInvoke>
                <InnerMethodInvoke>offHeapEntryFactory;setLruNode;[entryAddress, nodeAddress]</InnerMethodInvoke>
                <InnerMethodInvoke>OffHeapLruNode;setNext;[nodeAddress, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>OffHeapLruNode;setHashCode;[nodeAddress, hashCode]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>moveToEnd</MethodName>
            <MethodComment>/** 
 * Method to be invoked when moving an existing lru node to the end.  This occurs when the entry is accessed for this node. This method should only be invoked after acquiring the lruLock.
 * @param lruNode the node to move to the end
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lruNode</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugLruList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lruLock;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>