<Class>
    <Id>323</Id>
    <Package>org.infinispan.interceptors.impl</Package>
    <ClassName>QueueAsyncInvocationStage</ClassName>
    <SuperClass>SimpleAsyncInvocationStage</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>BiConsumer</SuperInterface>
        <SuperInterface>Object</SuperInterface>
        <SuperInterface>InvocationCallback</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>QueueAsyncInvocationStage  /** 
 * Invocation stage representing a computation that may or may not be done yet. &lt;p&gt;It stores handler objects in a queue instead of creating a new instance every time a handler is added. The queue may be frozen based on internal conditions, like executing the last handler or reaching the capacity of the queue, and adding a handler will create a new instance. The queue will also be frozen when  {@link #toCompletableFuture()} is invoked, to make that future behave likea regular  {@link CompletableFuture}. &lt;/p&gt; &lt;p&gt;When the queue is not frozen, adding a handler will change the result of the current stage. When the queue is frozen, adding a handler may actually execute the handler synchronously.&lt;/p&gt;
 * @author Dan Berindei
 * @since 9.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>ctx</FieldName>
            <FieldType>InvocationContext</FieldType>
        </Field>
        <Field>
            <FieldName>command</FieldName>
            <FieldType>VisitableCommand</FieldType>
        </Field>
        <Field>
            <FieldName>QUEUE_INITIAL_CAPACITY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>elements</FieldName>
            <FieldType>InvocationCallback[]</FieldType>
        </Field>
        <Field>
            <FieldName>mask</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>head</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>tail</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>frozen</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>QueueAsyncInvocationStage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueFuture</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationCallback</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;queueAdd;[function]</InnerMethodInvoke>
                <InnerMethodInvoke>valueFuture;whenComplete;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addCallback</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationCallback</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeDirectly</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationCallback</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [rv]</InnerVar>
                <InnerVar>Throwable [throwable]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>accept</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rv</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>throwable</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invokeQueuedHandlers;[rv, throwable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rCtx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rCommand</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rv</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>throwable</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invokeQueuedHandlers;[rv, throwable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeQueuedHandlers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rv</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>throwable</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>queueAdd</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>InvocationCallback</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>queuePoll</MethodName>
            <MethodComment>/** 
 * Remove one handler from the deque, or freeze the deque if there are no more elements.
 * @return The next handler, or {@code null} if the deque is empty.
 */
</MethodComment>
            <ReturnType>InvocationCallback</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>InvocationCallback [element]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>queueSize</MethodName>
            <MethodComment>/** 
 * @return The current number of elements in the deque, only useful for debugging.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>queueExpand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>InvocationCallback[] [oldElements=elements]</InnerVar>
                <InnerVar>int [oldCapacity=oldElements.length]</InnerVar>
                <InnerVar>int [oldMask=mask]</InnerVar>
                <InnerVar>int [oldHead=head]</InnerVar>
                <InnerVar>int [oldTail=tail]</InnerVar>
                <InnerVar>int [maskedHead=oldHead &amp; oldMask]</InnerVar>
                <InnerVar>int [maskedTail=oldTail &amp; oldMask]</InnerVar>
                <InnerVar>int [oldSize=tail - head]</InnerVar>
                <InnerVar>int [newSize=oldCapacity * 2]</InnerVar>
                <InnerVar>int [newMask=newSize - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>