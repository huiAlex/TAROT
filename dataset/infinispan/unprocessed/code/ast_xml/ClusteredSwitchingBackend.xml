<Class>
    <Id>2237</Id>
    <Package>org.infinispan.query.indexmanager</Package>
    <ClassName>ClusteredSwitchingBackend</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>LazyInitializableBackend</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ClusteredSwitchingBackend  /** 
 * Manages the current state of being a "master" node or a node delegating index update operations to other nodes. In a static cluster this would have been a boolean state, but a state machine is modelled here to cope with transitions between: Initialization of a node - still not having enough information on the cluster Becoming a master because of previous master failure / shutdown Forfaiting the master role (useful for cluster merges) The transition to become a master goes via different phases, and at each state the process is reversible. So for example if operations have been put on hold while the node is being upgraded, but then the master election is moved to a different node quickly (cluster startup scenario), the buffered operations will be forwarded to the last backend. A node being forwarded update operations but not being the master anymore, will re-forward the payload to the new master: stability by induction. The solution is rather poor at managing cluster Merge operations, but we need to build on upcoming functionality from Infinispan core for that; for example the index content wouldn't be consistent either so one would likely need to wipe the index and rebuild it. Also we're dealing with the inherent limitation of a "cluster wide lock" concept not being compatible with sub-groups of nodes in which a new lead might be elected and a lock per group might have been created. A lock cleanup is not too aggressive: in case a stale lock is detected, scheduled work is postponed. This implies that in such situations in which a stale lock needs to be cleaned up, index operations might not be visible to the transaction committer. I've chosen for this option as the lesser evil vs. blocking incoming RPCs, although if the buffer for postponed operations gets filled too quickly, we'll both speed up the lock acquisition and apply backpressure to the clients.
 * @author Sanne Grinovero &lt;sanne@hibernate.org&gt; (C) 2014 Red Hat Inc.
 * @since 7.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_LOCK_ACQUISITION_ATTEMPTS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>localAddress</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>rpcManager</FieldName>
            <FieldType>RpcManager</FieldType>
        </Field>
        <Field>
            <FieldName>factory</FieldName>
            <FieldType>LocalBackendFactory</FieldType>
        </Field>
        <Field>
            <FieldName>indexlock</FieldName>
            <FieldType>IndexLockController</FieldType>
        </Field>
        <Field>
            <FieldName>async</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cacheName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>lastSeenViewId</FieldName>
            <FieldType>AtomicInteger</FieldType>
        </Field>
        <Field>
            <FieldName>currentMaster</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>currentBackend</FieldName>
            <FieldType>IndexingBackend</FieldType>
        </Field>
        <Field>
            <FieldName>initialized</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>masterLockAcquisitionAttempts</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ClusteredSwitchingBackend</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>componentsRegistry</ParamName>
                    <ParamType>ComponentRegistry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factory</ParamName>
                    <ParamType>LocalBackendFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexlock</ParamName>
                    <ParamType>IndexLockController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>viewChanged</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>ViewChangedEvent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [currentViewId=lastSeenViewId.get()]</InnerVar>
                <InnerVar>int [viewId=e.getViewId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lazyInitialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;Address&gt; [members=rpcManager.getMembers()]</InnerVar>
                <InnerVar>Address [initialMaster=members.get(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lastSeenViewId;set;[rpcManager.getTransport().getViewId()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyViewChangedEvent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>ViewChangedEvent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Address&gt; [newMembers=e.getNewMembers()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;handleTopologyChange;[newMembers]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleTopologyChange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newMembers</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Address [newmaster=newMembers.get(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>thisIsNewMaster</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newmaster</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>thisIsMaster</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>masterDidChange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newmaster</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateRoutingToNewRemote</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newMaster</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexingBackend [newBackend=new RemoteIndexingBackend(cacheName,rpcManager,indexName,newMaster,async)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;swapNewBackendIn;[newBackend, newMaster]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acquireControlStart</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>IndexingBackend [backend=new LockAcquiringBackend(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;swapNewBackendIn;[backend, localAddress]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forfeitControl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newMasterAddress</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexingBackend [newBackend=new RemoteIndexingBackend(cacheName,rpcManager,indexName,newMasterAddress,async)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;swapNewBackendIn;[newBackend, newMasterAddress]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>swapNewBackendIn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newBackend</ParamName>
                    <ParamType>IndexingBackend</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newMasterAddress</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexingBackend [oldBackend=currentBackend]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugv;["Swapping from backend {0} to {1}'", oldBackend, newBackend]</InnerMethodInvoke>
                <InnerMethodInvoke>null;closeBackend;[oldBackend, currentBackend]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shutdown</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeBackend;[currentBackend, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentIndexingBackend</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexingBackend</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>refresh</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;handleTopologyChange;[rpcManager.getMembers()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeBackend</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldOne</ParamName>
                    <ParamType>IndexingBackend</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacement</ParamName>
                    <ParamType>IndexingBackend</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>attemptUpgrade</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expectedBackend</ParamName>
                    <ParamType>IndexingBackend</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;trace;["owning lock for attemptUpgrade(IndexingBackend)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>