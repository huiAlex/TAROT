<Class>
    <Id>2865</Id>
    <Package>org.infinispan</Package>
    <ClassName>LockedStream</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>BaseCacheStream</SuperInterface>
        <SuperInterface>CacheEntry&lt;K,V&gt;</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LockedStream  /** 
 * Stream that allows for operation upon data solely with side effects by using  {@link LockedStream#forEach(BiConsumer)}where the &lt;b&gt;BiConsumer&lt;/b&gt; is invoked while guaranteeing that the entry being passed is properly locked for the entire duration of the invocation. &lt;p&gt; An attempt is made to acquire the lock for an entry using the default {@link LockingConfiguration#lockAcquisitionTimeout()} before invoking any operations on it.&lt;/p&gt;
 * @author wburns
 * @since 9.1
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>filter</MethodName>
            <MethodComment>/** 
 * Returns a locked stream consisting of the elements of this stream that match the given predicate. &lt;p&gt; This filter is after the lock is acquired for the given key. This way the filter will see the same value as the consumer is given.
 * @param predicate predicate
 * @return a LockedStream with the filter applied
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>? super CacheEntry&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filter</MethodName>
            <MethodComment>/** 
 * Same as  {@link LockedStream#filter(Predicate)} except that the Predicate must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param predicate the predicate to filter out unwanted entries
 * @return a LockedStream with the filter applied
 */
</MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>? super CacheEntry&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEach</MethodName>
            <MethodComment>/** 
 * Performs an action for each element of this stream on the primary owner of the given key. &lt;p&gt; This method is performed while holding exclusive lock over the given entry and will be released only after the consumer has completed. If the entry is directly modified via the {@link java.util.Map.Entry#setValue(Object)} method this will be the same as if{@link java.util.Map#put(Object,Object)} was invoked.&lt;p&gt; If using a pessimistic transaction this lock is not held using a transaction and thus the user can start a transaction in this consumer which also must be completed before returning. A transaction can be started in the consumer and if done it will share the same lock used to obtain the key. &lt;p&gt; Remember that if you are using an explicit transaction or an async method that these must be completed before the consumer returns to guarantee that they are operating within the scope of the lock for the given key. Failure to do so will lead into possible inconsistency as they will be performing operations without the proper locking. &lt;p&gt; Some methods on the provided cache may not work as expected. These include {@link AdvancedCache#putForExternalRead(Object,Object)},  {@link AdvancedCache#lock(Object[])}, {@link AdvancedCache#lock(Collection)}, and  {@link AdvancedCache#removeGroup(String)}. If these methods are used inside of the Consumer on the cache it will throw a  {@link IllegalStateException}. This is due to possible interactions with transactions while using these commands.
 * @param biConsumer the biConsumer to run for each entry under their lock
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>biConsumer</ParamName>
                    <ParamType>Cache&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEach</MethodName>
            <MethodComment>/** 
 * Same as  {@link LockedStream#forEach(BiConsumer)}  except that the BiConsumer must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param biConsumer the biConsumer to run for each entry under their lock
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>biConsumer</ParamName>
                    <ParamType>Cache&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forEach;[(BiConsumer&lt;Cache&lt;K,V&gt;,? super CacheEntry&lt;K,V&gt;&gt;)biConsumer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>timeout</MethodName>
            <MethodComment>/** 
 * Sets the timeout for the acquisition of the lock for each entry.
 * @param time the maximum time to wait
 * @param unit the time unit of the timeout argument
 * @return a LockedStream with the timeout applied
 */
</MethodComment>
            <ReturnType>LockedStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>time</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unit</ParamName>
                    <ParamType>TimeUnit</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>segmentCompletionListener</MethodName>
            <MethodComment>/** 
 * This method is not supported when using a  {@link LockedStream}
 */
</MethodComment>
            <ReturnType>LockedStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>SegmentCompletionListener</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedOperationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * This method is not supported when using a  {@link LockedStream}
 */
</MethodComment>
            <ReturnType>CacheEntry&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedOperationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spliterator</MethodName>
            <MethodComment>/** 
 * This method is not supported when using a  {@link LockedStream}
 */
</MethodComment>
            <ReturnType>CacheEntry&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedOperationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>