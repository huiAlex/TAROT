<Class>
    <Id>4063</Id>
    <Package>org.infinispan.interceptors</Package>
    <ClassName>BaseAsyncInterceptor</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>AsyncInterceptor</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BaseAsyncInterceptor  /** 
 * Base class for an interceptor in the new asynchronous invocation chain.
 * @author Dan Berindei
 * @since 9.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>invokeNextFunction</FieldName>
            <FieldType>InvocationSuccessFunction</FieldType>
        </Field>
        <Field>
            <FieldName>cacheConfiguration</FieldName>
            <FieldType>Configuration</FieldType>
        </Field>
        <Field>
            <FieldName>nextInterceptor</FieldName>
            <FieldType>AsyncInterceptor</FieldType>
        </Field>
        <Field>
            <FieldName>nextDDInterceptor</FieldName>
            <FieldType>DDAsyncInterceptor</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>inject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheConfiguration</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNextInterceptor</MethodName>
            <MethodComment>/** 
 * Used internally to set up the interceptor.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextInterceptor</ParamName>
                    <ParamType>AsyncInterceptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNext</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command. &lt;p&gt;Use  {@link #invokeNextThenApply(InvocationContext,VisitableCommand,InvocationSuccessFunction)}or  {@link #invokeNextThenAccept(InvocationContext,VisitableCommand,InvocationSuccessAction)} insteadif you need to process the return value of the next interceptor.&lt;/p&gt; &lt;p&gt;Note:  {@code invokeNext(ctx, command)} does not throw exceptions. In order to handle exceptions from thenext interceptors, you &lt;em&gt;must&lt;/em&gt; use {@link #invokeNextAndHandle(InvocationContext,VisitableCommand,InvocationFinallyFunction)}, {@link #invokeNextAndFinally(InvocationContext,VisitableCommand,InvocationFinallyAction)}, or  {@link #invokeNextAndExceptionally(InvocationContext,VisitableCommand,InvocationExceptionFunction)}.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNextThenApply</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command, and execute an  {@link InvocationCallback}after all the interceptors have finished successfully. &lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationSuccessFunction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNextThenAccept</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command, and execute an  {@link InvocationCallback}after all the interceptors have finished successfully. &lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>InvocationSuccessAction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNextAndExceptionally</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command, and execute an  {@link InvocationCallback}after all the interceptors have finished with an exception. &lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationExceptionFunction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNextAndFinally</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command, and execute an  {@link InvocationCallback}after all the interceptors have finished, with or without an exception. &lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>InvocationFinallyAction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeNextAndHandle</MethodName>
            <MethodComment>/** 
 * Invoke the next interceptor, possibly with a new command, and execute an  {@link InvocationCallback}after all the interceptors have finished, with or without an exception. &lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>InvocationFinallyFunction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asyncValue</MethodName>
            <MethodComment>/** 
 * Suspend the invocation until  {@code valueFuture} completes, then return its result without runningthe remaining interceptors. &lt;p&gt;The caller can add a callback that will run when  {@code valueFuture} completes, e.g.{@code asyncValue(v).thenApply(ctx, command, (rCtx, rCommand, rv, t) -&gt; invokeNext(rCtx, rCommand))}. For this particular scenario, however, it's simpler to use {@link #asyncInvokeNext(InvocationContext,VisitableCommand,CompletableFuture)}.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>InvocationStage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>valueFuture</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asyncInvokeNext</MethodName>
            <MethodComment>/** 
 * Suspend the invocation until  {@code delay} completes, then if successful invoke the next interceptor.&lt;p&gt;If  {@code delay} completes exceptionally, skip the next interceptor and continue with the exception.&lt;/p&gt;&lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delay</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asyncInvokeNext</MethodName>
            <MethodComment>/** 
 * Suspend invocation until all  {@code delays} complete, then if successful invoke the next interceptor.If the list is empty or null, invoke the next interceptor immediately. &lt;p&gt;If any of  {@code delays} completes exceptionally, skip the next interceptor and continue with the exception.&lt;/p&gt;&lt;p&gt;You need to wrap the result with  {@link #makeStage(Object)} if you need to add another handler.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>VisitableCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delays</ParamName>
                    <ParamType>CompletableFuture&lt;?&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>valueOrException</MethodName>
            <MethodComment>/** 
 * Return the value if  {@code throwable != null}, throw the exception otherwise.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rv</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>throwable</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeStage</MethodName>
            <MethodComment>/** 
 * Encode the result of an  {@link #invokeNext(InvocationContext,VisitableCommand)} in an {@link InvocationStage}. &lt;p&gt;May not create a new instance, if the result is already an  {@code InvocationStage}.
 */
</MethodComment>
            <ReturnType>InvocationStage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rv</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSuccessfullyDone</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maybeStage</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>