<Class>
    <Id>1508</Id>
    <Package>org.infinispan.lucene</Package>
    <ClassName>DirectoryIntegrityCheck</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DirectoryIntegrityCheck  /** 
 * DirectoryIntegrityCheck contains helpers to assert assumptions we make on the structure of an index as stored in an Infinispan cache.
 * @author Sanne Grinovero
 * @since 4.1
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>DirectoryIntegrityCheck</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyDirectoryStructure</MethodName>
            <MethodComment>/** 
 * Verifies that no garbage elements are left over in the cache and that for each type of object the expected value is stored. Also asserts for proper size metadata comparing to actual bytes used in chunks. It's assumed that only one index is stored in the inspected cache, and that the index is not being used by IndexReaders or IndexWriters.
 * @param cache The cache to inspect
 * @param indexName The name of the unique index stored in the cache
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyDirectoryStructure;[cache, indexName, false, Collections.emptySet(), -1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyDirectoryStructure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyDirectoryStructure;[cache, indexName, false, ignoreFiles, -1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyDirectoryStructure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wasAStressTest</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyDirectoryStructure;[cache, indexName, wasAStressTest, Collections.emptySet(), affinitySegmentId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyDirectoryStructure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wasAStressTest</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileListCacheValue [fileList=(FileListCacheValue)cache.get(new FileListCacheKey(indexName,affinitySegmentId))]</InnerVar>
                <InnerVar>int [fileListCacheKeyInstances=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertNotNull;[fileList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyReadlockExists</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileReadLockKey [readLockKey=new FileReadLockKey(indexName,filename,affinitySegmentId)]</InnerVar>
                <InnerVar>Object [readLockValue=cache.get(readLockKey)]</InnerVar>
                <InnerVar>int [v=((Integer)readLockValue).intValue()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertNotNull;[readLockValue]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertTrue;[readLockValue instanceof Integer]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertTrue;["readlock exists for unregistered file of unexpected value: " + v + " for file: "+ filename, v &gt; 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deepCountFileSize</MethodName>
            <MethodComment>/** 
 * For a given FileCacheKey return the total size of all chunks related to the file.
 * @param fileCacheKey the key to the file to inspect
 * @param cache the cache storing the chunks
 * @return the total size adding all found chunks up
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileCacheKey</ParamName>
                    <ParamType>FileCacheKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [indexName=fileCacheKey.getIndexName()]</InnerVar>
                <InnerVar>String [fileName=fileCacheKey.getFileName()]</InnerVar>
                <InnerVar>long [accumulator=0]</InnerVar>
                <InnerVar>FileMetadata [metadata=(FileMetadata)cache.get(fileCacheKey)]</InnerVar>
                <InnerVar>int [bufferSize=metadata.getBufferSize()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assertFileNotExists</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWaitForCondition</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileListCacheValue [fileList=(FileListCacheValue)cache.get(new FileListCacheKey(indexName,affinitySegmentId))]</InnerVar>
                <InnerVar>boolean [allok=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>AssertJUnit;assertNotNull;[fileList]</InnerMethodInvoke>
                <InnerMethodInvoke>AssertJUnit;assertFalse;[fileList.contains(fileName)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertTrue;[allok]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assertFileExistsHavingRLCount</MethodName>
            <MethodComment>/** 
 * Verified the file exists and has a specified value for readLock; Consider that null should be interpreted as value 1;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expectedReadcount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunkSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expectRegisteredInFat</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileListCacheValue [fileList=(FileListCacheValue)cache.get(new FileListCacheKey(indexName,affinitySegmentId))]</InnerVar>
                <InnerVar>FileMetadata [metadata=(FileMetadata)cache.get(new FileCacheKey(indexName,fileName,affinitySegmentId))]</InnerVar>
                <InnerVar>long [totalFileSize=metadata.getSize()]</InnerVar>
                <InnerVar>int [chunkNumbers=(int)(totalFileSize / chunkSize)]</InnerVar>
                <InnerVar>FileReadLockKey [readLockKey=new FileReadLockKey(indexName,fileName,affinitySegmentId)]</InnerVar>
                <InnerVar>Object [value=cache.get(readLockKey)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertNotNull;[fileList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertTrue;[fileList.contains(fileName) == expectRegisteredInFat]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertNotNull;[metadata]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>