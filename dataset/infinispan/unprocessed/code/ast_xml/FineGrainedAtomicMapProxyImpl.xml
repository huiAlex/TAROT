<Class>
    <Id>1467</Id>
    <Package>org.infinispan.atomic.impl</Package>
    <ClassName>FineGrainedAtomicMapProxyImpl</ClassName>
    <SuperClass>AbstractMap</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>FineGrainedAtomicMap</SuperInterface>
        <SuperInterface>K</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FineGrainedAtomicMapProxyImpl  /** 
 * Implementation of  {@link FineGrainedAtomicMap} that uses {@link org.infinispan.distribution.group Grouping API}to co-locate subkeys on the same node. Therefore the entries in this map are held as regular cache entries, but in order to prevent the need for iterating all data in the owning node we also keep a set of keys under the map's key. &lt;p&gt; The implementation requires to be executed on a transactional cache with grouping API enabled. Neither null keys nor null values are supported. &lt;p&gt; This cached set implemented by  {@link AtomicKeySetImpl} is accessed using functional API and can be modified withoutacquiring its lock as long as we modify the same keys in that transaction. &lt;p&gt; Once the map is created or fully read ( {@link} #size(), {@link #keySet()},  {@link #values()} or {@link #entrySet()}), the whole map (both keys and values) is loaded into context to guarantee repeatable reads semantics.  {@link #clear()}removes only those keys that are known - if the map is read, and another transaction adds a key afterwards, such key may not be removed from the map. &lt;p&gt; The map cannot be safely removed (using  {@link org.infinispan.atomic.AtomicMapLookup#removeAtomicMap(Cache,Object)}concurrently to another modifications - such operation may result in leaked entries, map being cleared but not removed, failures during commit phase or other undefined behaviour.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>Cache</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>ro</FieldName>
            <FieldType>FunctionalMap.ReadOnlyMap</FieldType>
        </Field>
        <Field>
            <FieldName>ro</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>rw</FieldName>
            <FieldType>FunctionalMap.ReadWriteMap</FieldType>
        </Field>
        <Field>
            <FieldName>rw</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>group</FieldName>
            <FieldType>MK</FieldType>
        </Field>
        <Field>
            <FieldName>icf</FieldName>
            <FieldType>InvocationContextFactory</FieldType>
        </Field>
        <Field>
            <FieldName>entryFactory</FieldName>
            <FieldType>EntryFactory</FieldType>
        </Field>
        <Field>
            <FieldName>txHelper</FieldName>
            <FieldType>TransactionHelper</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FineGrainedAtomicMapProxyImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ro</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rw</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>group</ParamName>
                    <ParamType>MK</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>icf</ParamName>
                    <ParamType>InvocationContextFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>entryFactory</ParamName>
                    <ParamType>EntryFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>group</ParamName>
                    <ParamType>MK</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createIfAbsent</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FunctionalMapImpl&lt;Object,Object&gt; [fmap=FunctionalMapImpl.create(cache.getAdvancedCache())]</InnerVar>
                <InnerVar>FunctionalMap.ReadOnlyMap&lt;Object,Object&gt; [ro=ReadOnlyMapImpl.create(fmap)]</InnerVar>
                <InnerVar>FunctionalMap.ReadWriteMap&lt;Object,Object&gt; [rw=ReadWriteMapImpl.create(fmap).withParams(Param.LockingMode.SKIP)]</InnerVar>
                <InnerVar>InvocationContextFactory [icf=cache.getAdvancedCache().getComponentRegistry().getComponent(InvocationContextFactory.class)]</InnerVar>
                <InnerVar>EntryFactory [entryFactory=cache.getAdvancedCache().getComponentRegistry().getComponent(EntryFactory.class)]</InnerVar>
                <InnerVar>Set&lt;K&gt; [keys=wait(ro.eval(group,AtomicKeySetImpl.ReadAll.&lt;K&gt;instance()))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeMap</MethodName>
            <MethodComment>/** 
 * Warning: with pessimistic locking/optimistic locking without WSC, when the map is removed and a new key is added before the removal transaction commit, the map may be removed but the key left dangling.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>group</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FunctionalMapImpl&lt;Object,Object&gt; [fmap=FunctionalMapImpl.create(cache.getAdvancedCache())]</InnerVar>
                <InnerVar>FunctionalMap.ReadWriteMap&lt;Object,Object&gt; [rw=ReadWriteMapImpl.create(fmap).withParams(Param.LockingMode.SKIP)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>new TransactionHelper(cache.getAdvancedCache());run;[() -&gt; {
  Set&lt;Object&gt; keys=wait(rw.eval(group,AtomicKeySetImpl.RemoveMap.instance()));
  if (keys != null) {
    removeAll(cache,group,keys);
  }
  return null;
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wait</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>? extends T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeAll</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>group</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;CompletableFuture&lt;?&gt;&gt; [cfs=new ArrayList&lt;&gt;(keys.size())]</InnerVar>
                <InnerVar>Cache&lt;Object,Object&gt; [noReturn=cache.getAdvancedCache().withFlags(Flag.IGNORE_RETURN_VALUES)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;wait;[CompletableFuture.allOf(cfs.toArray(new CompletableFuture[cfs.size()]))]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keys</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keys=wait(ro.eval(group,AtomicKeySetImpl.ReadAll.instance()))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>atomicKeys</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AtomicKeySetImpl.Key&lt;MK,K&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>put</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAll</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>m</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>txHelper;run;[() -&gt; {
  cache.putAll(m.entrySet().stream().collect(Collectors.toMap(e -&gt; new AtomicKeySetImpl.Key&lt;&gt;(group,e.getKey()),Map.Entry::getValue)));
  wait(rw.eval(group,new AtomicKeySetImpl.AddAll&lt;&gt;(m.keySet())));
  return null;
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>txHelper;run;[() -&gt; {
  Set&lt;K&gt; keys=wait(rw.eval(group,AtomicKeySetImpl.RemoveAll.&lt;K&gt;instance()));
  removeAll(cache,group,keys);
  return null;
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keySet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keys=keys()]</InnerVar>
                <InnerVar>Stream&lt;Entry&lt;Object,Object&gt;&gt; [entryStream=cache.getAdvancedCache().getAll(atomicKeys(keys)).entrySet().stream()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>values</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keys=keys()]</InnerVar>
                <InnerVar>Stream&lt;Object&gt; [valuesStream=cache.getAdvancedCache().getAll(atomicKeys(keys)).values().stream().filter(Objects::nonNull)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entrySet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Entry&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keys=keys()]</InnerVar>
                <InnerVar>Stream&lt;Entry&lt;Object,Object&gt;&gt; [entryStream=cache.getAdvancedCache().getAll(atomicKeys(keys)).entrySet().stream().filter(e -&gt; e.getValue() != null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>