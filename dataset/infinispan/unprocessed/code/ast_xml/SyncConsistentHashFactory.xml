<Class>
    <Id>4004</Id>
    <Package>org.infinispan.distribution.ch.impl</Package>
    <ClassName>SyncConsistentHashFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ConsistentHashFactory</SuperInterface>
        <SuperInterface>DefaultConsistentHash</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SyncConsistentHashFactory  /** 
 * One of the assumptions people made on consistent hashing involves thinking that given a particular key and same topology, it would produce the same consistent hash value no matter which cache it was stored in. However, that's not exactly the case in Infinispan. In order to the optimise the number of segments moved on join/leave, Infinispan uses a consistent hash that depends on the previous consistent hash. Given two caches, even if they contain exactly the same keyset, it's very easy for the consistent hash history to differ, e.g. if 2 nodes join you might see two separate topology change in one cache and a single topology change in the other. The reason for that each node has to send a {@link org.infinispan.topology.CacheTopologyControlCommand} for each cacheit wants to join and Infinispan can and does batch cache topology changes. For example, if a rebalance is in progress, joins are queued and send in one go when the rebalance has finished. This  {@link org.infinispan.distribution.ch.ConsistentHashFactory} implementation avoids any of the issuesmentioned and guarantees that multiple caches with the same members will have the same consistent hash. It has a drawback compared to  {@link org.infinispan.distribution.ch.impl.DefaultConsistentHashFactory} though:it can potentially move a lot more segments during a rebalance than strictly necessary because it's not taking advantage of the optimisation mentioned above.
 * @author Dan Berindei
 * @since 5.2
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>OWNED_SEGMENTS_ALLOWED_VARIATION</FieldName>
            <FieldType>float</FieldType>
        </Field>
        <Field>
            <FieldName>PRIMARY_SEGMENTS_ALLOWED_VARIATION</FieldName>
            <FieldType>float</FieldType>
        </Field>
        <Field>
            <FieldName>hashFunction</FieldName>
            <FieldType>Hash</FieldType>
        </Field>
        <Field>
            <FieldName>numOwners</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>capacityFactors</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>capacityFactors</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>actualNumOwners</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numSegments</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sortedMembers</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>sortedMembers</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>segmentSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>segmentOwners</FieldName>
            <FieldType>List&lt;Address&gt;[]</FieldType>
        </Field>
        <Field>
            <FieldName>stats</FieldName>
            <FieldType>OwnershipStatistics</FieldType>
        </Field>
        <Field>
            <FieldName>ignoreMaxSegments</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>create</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultConsistentHash</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashFunction</ParamName>
                    <ParamType>Hash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numOwners</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numSegments</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>members</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Builder [builder=createBuilder(hashFunction,numOwners,numSegments,members,capacityFactors)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkCapacityFactors;[members, capacityFactors]</InnerMethodInvoke>
                <InnerMethodInvoke>builder;populateOwners;[numSegments]</InnerMethodInvoke>
                <InnerMethodInvoke>builder;copyOwners;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromPersistentState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultConsistentHash</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>state</ParamName>
                    <ParamType>ScopedPersistentState</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [consistentHashClass=state.getProperty("consistentHash")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createBuilder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Builder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashFunction</ParamName>
                    <ParamType>Hash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numOwners</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numSegments</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>members</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCapacityFactors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>members</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateMembers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultConsistentHash</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseCH</ParamName>
                    <ParamType>DefaultConsistentHash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newMembers</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actualCapacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [sameCapacityFactors=actualCapacityFactors == null ? baseCH.getCapacityFactors() == null : actualCapacityFactors.equals(baseCH.getCapacityFactors())]</InnerVar>
                <InnerVar>int [numSegments=baseCH.getNumSegments()]</InnerVar>
                <InnerVar>int [numOwners=baseCH.getNumOwners()]</InnerVar>
                <InnerVar>HashSet&lt;Address&gt; [leavers=new HashSet&lt;Address&gt;(baseCH.getMembers())]</InnerVar>
                <InnerVar>DefaultConsistentHash [rebalancedCH=null]</InnerVar>
                <InnerVar>List&lt;Address&gt;[] [newSegmentOwners=new List[numSegments]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkCapacityFactors;[newMembers, actualCapacityFactors]</InnerMethodInvoke>
                <InnerMethodInvoke>leavers;removeAll;[newMembers]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rebalance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultConsistentHash</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseCH</ParamName>
                    <ParamType>DefaultConsistentHash</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DefaultConsistentHash [rebalancedCH=create(baseCH.getHashFunction(),baseCH.getNumOwners(),baseCH.getNumSegments(),baseCH.getMembers(),baseCH.getCapacityFactors())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>union</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DefaultConsistentHash</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ch1</ParamName>
                    <ParamType>DefaultConsistentHash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch2</ParamName>
                    <ParamType>DefaultConsistentHash</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Builder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashFunction</ParamName>
                    <ParamType>Hash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numOwners</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numSegments</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>members</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>populateCapacityFactors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Address</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sortedMembers</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;Address,Float&gt; [realCapacityFactors=new HashMap&lt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOwnerNoCheck</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>segmentOwners[segment];add;[owner]</InnerMethodInvoke>
                <InnerMethodInvoke>stats;incOwned;[owner]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeTotalCapacity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>float</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>float [totalCapacity=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sort</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Address</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>members</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>capacityFactors</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Address&gt; [result=new ArrayList&lt;Address&gt;(members)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Collections;sort;[result, new Comparator&lt;Address&gt;(){
  @Override public int compare(  Address o1,  Address o2){
    int capacityComparison=capacityFactors != null ? capacityFactors.get(o1).compareTo(capacityFactors.get(o2)) : 0;
    return capacityComparison != 0 ? -capacityComparison : o1.compareTo(o2);
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [capacityComparison=capacityFactors != null ? capacityFactors.get(o1).compareTo(capacityFactors.get(o2)) : 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyOwners</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doCopyOwners;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;doCopyOwners;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCopyOwners</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canAddOwners</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owners</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>populateOwners</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numSegments</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [virtualNode=0]</InnerVar>
                <InnerVar>boolean [membersWithZeroSegments=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>member</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>virtualNode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [virtualNodeHash=normalizedHash(hashFunction,member.hashCode())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeExpectedSegmentsForNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numCopies</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Float [nodeCapacityFactor=capacityFactors.get(node)]</InnerVar>
                <InnerVar>double [remainingCapacity=computeTotalCapacity()]</InnerVar>
                <InnerVar>double [remainingCopies=numCopies * numSegments]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPrimaryOwner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>candidate</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Address&gt; [owners=segmentOwners[segment]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addBackupOwner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>candidate</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Address&gt; [owners=segmentOwners[segment]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalizedHash</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashFunction</ParamName>
                    <ParamType>Hash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hashcode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>output</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chf</ParamName>
                    <ParamType>SyncConsistentHashFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SyncConsistentHashFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>unmarshaller</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeClasses</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Class&lt;? extends SyncConsistentHashFactory&gt;</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>