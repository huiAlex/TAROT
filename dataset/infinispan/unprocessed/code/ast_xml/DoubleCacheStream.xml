<Class>
    <Id>3013</Id>
    <Package>org.infinispan</Package>
    <ClassName>DoubleCacheStream</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DoubleStream</SuperInterface>
        <SuperInterface>BaseCacheStream</SuperInterface>
        <SuperInterface>Double</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DoubleCacheStream  /** 
 * A  {@link DoubleStream} that has additional methods to allow for Serializable instances.  Please see{@link CacheStream} for additional details about various methods.
 * @author wburns
 * @since 9.0
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>sequentialDistribution</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with parallel distribution disabled.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parallelDistribution</MethodName>
            <MethodComment>/** 
 * @inheritDoc
 * @return a stream with parallel distribution enabled.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterKeySegments</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with the segments filtered.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterKeys</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with the keys filtered.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>distributedBatchSize</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with the batch size updated
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>batchSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>segmentCompletionListener</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with the listener registered.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>SegmentCompletionListener</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disableRehashAware</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with rehash awareness disabled.
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>timeout</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a stream with the timeout set
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unit</ParamName>
                    <ParamType>TimeUnit</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filter</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>DoublePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filter</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#filter(DoublePredicate)} except that the DoublePredicate must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param predicate a non-interfering, statelesspredicate to apply to each element to determine if it should be included
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>SerializableDoublePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>map</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>DoubleUnaryOperator</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>map</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#map(DoubleUnaryOperator)} except that the DoubleUnaryOperator must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param mapper a non-interfering, statelessfunction to apply to each element
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>SerializableDoubleUnaryOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToObj</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache stream
 */
</MethodComment>
            <ReturnType>U</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>? extends U</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToObj</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#mapToObj(DoubleFunction)} except that the DoubleFunction must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param &lt; U &gt; the element type of the new stream
 * @param mapper a non-interfering, statelessfunction to apply to each element
 * @return the new cache stream
 */
</MethodComment>
            <ReturnType>U</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>? extends U</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToInt</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache int stream
 */
</MethodComment>
            <ReturnType>IntCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>DoubleToIntFunction</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToInt</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#mapToInt(DoubleToIntFunction)} except that the DoubleToIntFunction must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param mapper a non-interfering, statelessfunction to apply to each element
 * @return the new cache int stream
 */
</MethodComment>
            <ReturnType>IntCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>SerializableDoubleToIntFunction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToLong</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache long stream
 */
</MethodComment>
            <ReturnType>LongCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>DoubleToLongFunction</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToLong</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#mapToLong(DoubleToLongFunction)} except that the DoubleToLongFunction must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param mapper a non-interfering, statelessfunction to apply to each element
 * @return the new cache long stream
 */
</MethodComment>
            <ReturnType>LongCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>SerializableDoubleToLongFunction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flatMap</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>? extends DoubleStream</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flatMap</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#flatMap(DoubleFunction)} except that the DoubleFunction must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param mapper a non-interfering, statelessfunction to apply to each element which produces a {@code DoubleStream} of new values
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mapper</ParamName>
                    <ParamType>? extends DoubleStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>distinct</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sorted</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peek</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>DoubleConsumer</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peek</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#flatMap(DoubleFunction)} except that the DoubleFunction must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param action a non-interfering action to perform on the elements asthey are consumed from the stream
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>SerializableDoubleConsumer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>limit</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maxSize</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skip</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEach</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#forEach(DoubleConsumer)} except that the DoubleConsumer must alsoimplement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param action a non-interfering action to perform on the elements
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>SerializableDoubleConsumer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forEach;[(DoubleConsumer)action]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEach</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#forEach(DoubleConsumer)} except that it takes an {@link ObjDoubleConsumer} thatprovides access to the underlying  {@link Cache} that is backing this stream.&lt;p&gt; Note that the &lt;code&gt;CacheAware&lt;/code&gt; interface is not supported for injection using this method as the cache is provided in the consumer directly.
 * @param action consumer to be ran for each element in the stream
 * @param &lt; K &gt; key type of the cache
 * @param &lt; V &gt; value type of the cache
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>Cache&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEach</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#forEach(ObjDoubleConsumer)} except that the &lt;code&gt;BiConsumer&lt;/code&gt; must also implement&lt;code&gt;Serializable&lt;/code&gt;
 * @param action consumer to be ran for each element in the stream
 * @param &lt; K &gt; key type of the cache
 * @param &lt; V &gt; value type of the cache
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>Cache&lt;K,V&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forEach;[(ObjDoubleConsumer&lt;Cache&lt;K,V&gt;&gt;)action]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reduce</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#reduce(double,DoubleBinaryOperator)} except that the DoubleBinaryOperator mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param identity the identity value for the accumulating function
 * @param op an associative, non-interfering, statelessfunction for combining two values
 * @return the result of the reduction
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>SerializableDoubleBinaryOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reduce</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#reduce(DoubleBinaryOperator)} except that the DoubleBinaryOperator mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param op an associative, non-interfering, statelessfunction for combining two values
 * @return the result of the reduction
 */
</MethodComment>
            <ReturnType>OptionalDouble</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>SerializableDoubleBinaryOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collect</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#collect(Supplier,ObjDoubleConsumer,BiConsumer)} except that the arguments mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param &lt; R &gt; type of the result
 * @param supplier a function that creates a new result container. For aparallel execution, this function may be called multiple times and must return a fresh value each time.
 * @param accumulator an associative, non-interfering, statelessfunction for incorporating an additional element into a result
 * @param combiner an associative, non-interfering, statelessfunction for combining two values, which must be compatible with the accumulator function
 * @return the result of the reduction
 */
</MethodComment>
            <ReturnType>R</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>supplier</ParamName>
                    <ParamType>R</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulator</ParamName>
                    <ParamType>R</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>combiner</ParamName>
                    <ParamType>R</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>anyMatch</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#anyMatch(DoublePredicate)} except that the DoublePredicate mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param predicate a non-interfering, statelesspredicate to apply to elements of this stream
 * @return {@code true} if any elements of the stream match the providedpredicate, otherwise  {@code false}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>SerializableDoublePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allMatch</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#allMatch(DoublePredicate)} except that the DoublePredicate mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param predicate a non-interfering, statelesspredicate to apply to elements of this stream
 * @return {@code true} if either all elements of the stream match theprovided predicate or the stream is empty, otherwise  {@code false}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>SerializableDoublePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noneMatch</MethodName>
            <MethodComment>/** 
 * Same as  {@link DoubleCacheStream#noneMatch(DoublePredicate)} except that the DoublePredicate mustalso implement &lt;code&gt;Serializable&lt;/code&gt; &lt;p&gt; The compiler will pick this overload for lambda parameters, making them &lt;code&gt;Serializable&lt;/code&gt;
 * @param predicate a non-interfering, statelesspredicate to apply to elements of this stream
 * @return {@code true} if either no elements of the stream match theprovided predicate or the stream is empty, otherwise  {@code false}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>SerializableDoublePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boxed</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return the new cache stream containing doubles
 */
</MethodComment>
            <ReturnType>Double</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sequential</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a sequential cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parallel</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a parallel cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unordered</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return an unordered cache double stream
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onClose</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 * @return a cache double stream with the handler applied
 */
</MethodComment>
            <ReturnType>DoubleCacheStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closeHandler</ParamName>
                    <ParamType>Runnable</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>