<Class>
    <Id>2345</Id>
    <Package>org.infinispan.lucene.readlocks</Package>
    <ClassName>DistributedSegmentReadLocker</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>SegmentReadLocker</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DistributedSegmentReadLocker  /** 
 * &lt;p&gt;DistributedSegmentReadLocker stores reference counters in the cache to keep track of the number of clients still needing to be able to read a segment. It makes extensive usage of Infinispan's atomic operations.&lt;/p&gt; &lt;p&gt;Locks stored this way are not optimally performing as it might spin on remote invocations, and might fail to cleanup some garbage in case a node is disconnected without having released the readlock.&lt;/p&gt;
 * @author Sanne Grinovero
 * @since 4.1
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>locksCache</FieldName>
            <FieldType>AdvancedCache</FieldType>
        </Field>
        <Field>
            <FieldName>locksCache</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>chunksCache</FieldName>
            <FieldType>AdvancedCache</FieldType>
        </Field>
        <Field>
            <FieldName>chunksCache</FieldName>
            <FieldType>?</FieldType>
        </Field>
        <Field>
            <FieldName>metadataCache</FieldName>
            <FieldType>AdvancedCache</FieldType>
        </Field>
        <Field>
            <FieldName>metadataCache</FieldName>
            <FieldType>FileCacheKey</FieldType>
        </Field>
        <Field>
            <FieldName>indexName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>forceSynchronousDeletes</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>affinitySegmentId</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DistributedSegmentReadLocker</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>locksCache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunksCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadataCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DistributedSegmentReadLocker</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>locksCache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunksCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadataCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forceSynchronousDeletes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyCacheHasNoEviction;[this.locksCache]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DistributedSegmentReadLocker</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteOrReleaseReadLock</MethodName>
            <MethodComment>/** 
 * Deletes or releases a read-lock for the specified filename, so that if it was marked as deleted and no other  {@link org.infinispan.lucene.impl.InfinispanIndexInput} instances are reading from it, then it willbe effectively deleted.
 * @see #acquireReadLock(String)
 * @see org.apache.lucene.store.Directory#deleteFile(String)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isMultiChunked</MethodName>
            <MethodComment>/** 
 * Evaluates if the file is potentially being stored as fragmented into multiple chunks; when it's a single chunk we don't need to apply readlocks.
 * @param filename
 * @return true if it is definitely fragmented, or if it's possibly fragmented.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileCacheKey [fileCacheKey=new FileCacheKey(indexName,filename,affinitySegmentId)]</InnerVar>
                <InnerVar>FileMetadata [fileMetadata=metadataCache.get(fileCacheKey)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acquireReadLock</MethodName>
            <MethodComment>/** 
 * Acquires a readlock on all chunks for this file, to make sure chunks are not deleted while iterating on the group. This is needed to avoid an eager lock on all elements. If no value is found in the cache, a disambiguation procedure is needed: not value might mean both "existing, no readlocks, no deletions in progress", but also "not existent file". The first possibility is coded as no value to avoid storing readlocks in a permanent store, which would unnecessarily slow down and provide unwanted long term storage of the lock; so the value is treated as one if not found, but obviously it's also not found for non-existent or concurrently deleted files.
 * @param filename the name of the "file" for which a readlock is requested
 * @see #deleteOrReleaseReadLock(String)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileReadLockKey [readLockKey=new FileReadLockKey(indexName,filename,affinitySegmentId)]</InnerVar>
                <InnerVar>Integer [lockValue=locksCache.get(readLockKey)]</InnerVar>
                <InnerVar>boolean [done=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>realFileDelete</MethodName>
            <MethodComment>/** 
 * The  {@link org.apache.lucene.store.Directory#deleteFile(String)} is not deleting the elements from the cachebut instead flagging the file as deletable. This method will really remove the elements from the cache; should be invoked only by  {@link #deleteOrReleaseReadLock(String)} after having verified that thereare no users left in need to read these chunks.
 * @param indexName the index name to delete the file from
 * @param fileName the name of the file to delete
 * @param locksCache the cache containing the locks
 * @param chunksCache the cache containing the chunks to be deleted
 * @param metadataCache the cache containing the metadata of elements to be deleted
 * @param forceSynchronousDeletes when false deletion of chunk data is performed asynchronously
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locksCache</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunksCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadataCache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forceSynchronousDeletes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affinitySegmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [trace=log.isTraceEnabled()]</InnerVar>
                <InnerVar>FileCacheKey [key=new FileCacheKey(indexName,fileName,affinitySegmentId)]</InnerVar>
                <InnerVar>FileMetadata [file=(FileMetadata)metadataCache.remove(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyCacheHasNoEviction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>