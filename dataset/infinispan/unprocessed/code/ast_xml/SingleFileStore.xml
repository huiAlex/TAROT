<Class>
    <Id>1360</Id>
    <Package>org.infinispan.persistence.file</Package>
    <ClassName>SingleFileStore</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>AdvancedLoadWriteStore</SuperInterface>
        <SuperInterface>K</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SingleFileStore  /** 
 * A filesystem-based implementation of a  {@link org.infinispan.persistence.spi.AdvancedLoadWriteStore}. This file store stores cache values in a single file &lt;tt&gt;&amp;lt;location&amp;gt;/&amp;lt;cache name&amp;gt;.dat&lt;/tt&gt;, keys and file positions are kept in memory. &lt;p/&gt; Note: this CacheStore implementation keeps keys and file positions in memory! The current implementation needs about 100 bytes per cache entry, plus the memory for the key objects. &lt;p/&gt; So, the space taken by this cache store is both the space in the file itself plus the in-memory index with the keys and their file positions. With this in mind and to avoid the cache store leading to OutOfMemoryExceptions, you can optionally configure the maximum number of entries to maintain in this cache store, which affects both the size of the file and the size of the in-memory index. However, setting this maximum limit results in older entries in the cache store to be eliminated, and hence, it only makes sense configuring a maximum limit if Infinispan is used as a cache where loss of data in the cache store does not lead to data loss, and data can be recomputed or re-queried from the original data source. &lt;p/&gt; This class is fully thread safe, yet allows for concurrent load / store of individual cache entries.
 * @author Karsten Blees
 * @author Mircea Markus
 * @since 6.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>MAGIC</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>ZERO_INT</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>KEYLEN_POS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>KEY_POS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLEST_ENTRY_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>configuration</FieldName>
            <FieldType>SingleFileStoreConfiguration</FieldType>
        </Field>
        <Field>
            <FieldName>ctx</FieldName>
            <FieldType>InitializationContext</FieldType>
        </Field>
        <Field>
            <FieldName>channel</FieldName>
            <FieldType>FileChannel</FieldType>
        </Field>
        <Field>
            <FieldName>entries</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>entries</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>freeList</FieldName>
            <FieldType>SortedSet</FieldType>
        </Field>
        <Field>
            <FieldName>freeList</FieldName>
            <FieldType>FileEntry</FieldType>
        </Field>
        <Field>
            <FieldName>filePos</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>file</FieldName>
            <FieldType>File</FieldType>
        </Field>
        <Field>
            <FieldName>fragmentationFactor</FieldName>
            <FieldType>float</FieldType>
        </Field>
        <Field>
            <FieldName>resizeLock</FieldName>
            <FieldType>ReadWriteLock</FieldType>
        </Field>
        <Field>
            <FieldName>timeService</FieldName>
            <FieldType>TimeService</FieldType>
        </Field>
        <Field>
            <FieldName>offset</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>size</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>keyLen</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>dataLen</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>metadataLen</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>expiryTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>readers</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InitializationContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rebuildIndex</MethodName>
            <MethodComment>/** 
 * Rebuilds the in-memory index from file.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ByteBuffer [buf=ByteBuffer.allocate(KEY_POS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment>/** 
 * The base class implementation calls  {@link #load(Object)} for this, we can do better becausewe keep all keys in memory.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileEntry [entry=entries.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allocate</MethodName>
            <MethodComment>/** 
 * Allocates the requested space in the file.
 * @param len requested space
 * @return allocated file position and length as FileEntry object
 */
</MethodComment>
            <ReturnType>FileEntry</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allocateExistingEntry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileEntry</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>free</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [remainder=free.size - len]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNewFreeEntry</MethodName>
            <MethodComment>/** 
 * Writes a new free entry to the file and also adds it to the free list
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fe</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ByteBuffer [buf=ByteBuffer.allocate(KEY_POS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buf;putInt;[fe.size]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;putInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;putInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;putInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;putLong;[-1]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;flip;[]</InnerMethodInvoke>
                <InnerMethodInvoke>channel;write;[buf, fe.offset]</InnerMethodInvoke>
                <InnerMethodInvoke>freeList;add;[fe]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>free</MethodName>
            <MethodComment>/** 
 * Frees the space of the specified file entry (for reuse by allocate). &lt;p/&gt; Note: Caller must hold the  {@code resizeLock} in shared mode.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fe</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>marshalledEntry</ParamName>
                    <ParamType>? extends K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>evict</MethodName>
            <MethodComment>/** 
 * Try to evict an entry if the capacity of the cache store is reached.
 * @return FileEntry to evict, or null (if unbounded or capacity is not yet reached)
 */
</MethodComment>
            <ReturnType>FileEntry</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resizeLock.writeLock();lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resizeLock.readLock();lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>load</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>_load</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadValue</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadMetadata</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileEntry [fe]</InnerVar>
                <InnerVar>org.infinispan.commons.io.ByteBuffer [valueBb=null]</InnerVar>
                <InnerVar>org.infinispan.commons.io.ByteBuffer [metadataBb=null]</InnerVar>
                <InnerVar>byte[] [data]</InnerVar>
                <InnerVar>ByteBufferFactory [factory=ctx.getByteBufferFactory()]</InnerVar>
                <InnerVar>org.infinispan.commons.io.ByteBuffer [keyBb=factory.newByteBuffer(data,0,fe.keyLen)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resizeLock.readLock();lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>process</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>? super K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>task</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executor</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchValue</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchMetadata</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;KeyValuePair&lt;K,FileEntry&gt;&gt; [keysToLoad=new ArrayList&lt;&gt;(entries.size())]</InnerVar>
                <InnerVar>ExecutorAllCompletionService [eacs=new ExecutorAllCompletionService(executor)]</InnerVar>
                <InnerVar>TaskContextImpl [taskContext=new TaskContextImpl()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keysToLoad;sort;[(o1,o2) -&gt; {
  long offset1=o1.getValue().offset;
  long offset2=o2.getValue().offset;
  return offset1 &lt; offset2 ? -1 : offset1 == offset2 ? 0 : 1;
}
]</InnerMethodInvoke>
                <InnerMethodInvoke>eacs;waitUntilAllCompleted;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processFreeEntries</MethodName>
            <MethodComment>/** 
 * Manipulates the free entries for optimizing disk space.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;FileEntry&gt; [l=new ArrayList&lt;&gt;(freeList)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>l;sort;[(o1,o2) -&gt; {
  long diff=o1.offset - o2.offset;
  return (diff == 0) ? 0 : ((diff &gt; 0) ? -1 : 1);
}
]</InnerMethodInvoke>
                <InnerMethodInvoke>null;truncateFile;[l]</InnerMethodInvoke>
                <InnerMethodInvoke>null;mergeFreeEntries;[l]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncateFile</MethodName>
            <MethodComment>/** 
 * Removes free entries towards the end of the file and truncates the file.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entries</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [startTime=0]</InnerVar>
                <InnerVar>int [reclaimedSpace=0]</InnerVar>
                <InnerVar>int [removedEntries=0]</InnerVar>
                <InnerVar>long [truncateOffset=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeFreeEntries</MethodName>
            <MethodComment>/** 
 * Coalesces adjacent free entries to create larger free entries (so that the probability of finding a free entry during allocation increases)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entries</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [startTime=0]</InnerVar>
                <InnerVar>FileEntry [lastEntry=null]</InnerVar>
                <InnerVar>FileEntry [newEntry=null]</InnerVar>
                <InnerVar>int [mergeCounter=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeAndLogEntry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entry</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeCounter</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purge</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>threadPool</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>task</ParamName>
                    <ParamType>PurgeListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [now=timeService.wallClockTime()]</InnerVar>
                <InnerVar>List&lt;KeyValuePair&lt;Object,FileEntry&gt;&gt; [entriesToPurge=new ArrayList&lt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resizeLock.readLock();lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEntries</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFreeList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileEntry</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConfiguration</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SingleFileStoreConfiguration</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FileEntry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FileEntry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadataLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expiryTime</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FileEntry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fe</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadataLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expiryTime</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLocked</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unlock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitUnlocked</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isExpired</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>now</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>actualSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fe</ParamName>
                    <ParamType>FileEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [diff=size - fe.size]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileEntry [fileEntry=(FileEntry)o]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [result=(int)(offset ^ (offset &gt;&gt;&gt; 32))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>