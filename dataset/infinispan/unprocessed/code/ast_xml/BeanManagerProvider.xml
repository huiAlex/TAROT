<Class>
    <Id>2612</Id>
    <Package>org.infinispan.cdi.common.util</Package>
    <ClassName>BeanManagerProvider</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Extension</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BeanManagerProvider  /** 
 * &lt;p&gt;This class provides access to the  {@link BeanManager}by registering the current  {@link BeanManager} in an extension andmaking it available via a singleton factory for the current application.&lt;/p&gt; &lt;p&gt;This is really handy if you like to access CDI functionality from places where no injection is available.&lt;/p&gt; &lt;p&gt;If a simple but manual bean-lookup is needed, it's easier to use the  {@link BeanProvider}.&lt;/p&gt; &lt;p/&gt; &lt;p&gt;As soon as an application shuts down, the reference to the  {@link BeanManager} will be removed.&lt;p&gt;&lt;p/&gt; &lt;p&gt;Usage:&lt;p/&gt; &lt;pre&gt; BeanManager bm = BeanManagerProvider.getInstance().getBeanManager(); &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Attention:&lt;/b&gt; This method is intended for being used in user code at runtime. If this method gets used during Container boot (in an Extension), non-portable behaviour results. During bootstrapping an Extension shall &amp;#064;Inject BeanManager to get access to the underlying BeanManager (see e.g.  {@link #cleanupFinalBeanManagers} ).This is the only way to guarantee to get the right BeanManager in more complex Container scenarios.&lt;/p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
        <Field>
            <FieldName>bmpSingleton</FieldName>
            <FieldType>BeanManagerProvider</FieldType>
        </Field>
        <Field>
            <FieldName>loadTimeBm</FieldName>
            <FieldType>BeanManager</FieldType>
        </Field>
        <Field>
            <FieldName>finalBm</FieldName>
            <FieldType>BeanManager</FieldType>
        </Field>
        <Field>
            <FieldName>booted</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bmInfos</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>bmInfos</FieldName>
            <FieldType>ClassLoader</FieldType>
        </Field>
        <Field>
            <FieldName>object</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>isActive</MethodName>
            <MethodComment>/** 
 * Returns if the  {@link BeanManagerProvider} has been initialized.Usually it isn't needed to call this method in application code. It's e.g. useful for other frameworks to check if DeltaSpike and the CDI container in general have been started.
 * @return true if the bean-manager-provider is ready to be used
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstance</MethodName>
            <MethodComment>/** 
 * Allows to get the current provider instance which provides access to the current  {@link BeanManager}
 * @throws IllegalStateException if the {@link BeanManagerProvider} isn't ready to be used.That's the case if the environment isn't configured properly and therefore the  {@link AfterBeanDiscovery}hasn't be called before this method gets called.
 * @return the singleton BeanManagerProvider
 */
</MethodComment>
            <ReturnType>BeanManagerProvider</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeanManager</MethodName>
            <MethodComment>/** 
 * It basically doesn't matter which of the system events we use, but basically we use the  {@link AfterBeanDiscovery} event since it allows to use the{@link BeanManagerProvider} for all events which occur after the {@link AfterBeanDiscovery} event.
 * @param afterBeanDiscovery event which we don't actually use ;)
 * @param beanManager        the BeanManager we store and make available.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>afterBeanDiscovery</ParamName>
                    <ParamType>AfterBeanDiscovery</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>beanManager</ParamName>
                    <ParamType>BeanManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BeanManagerInfo [bmi=getBeanManagerInfo(getClassLoader(null))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setBeanManagerProvider;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBeanManager</MethodName>
            <MethodComment>/** 
 * The active  {@link BeanManager} for the current application (/{@link ClassLoader}). This method will throw an {@link IllegalStateException} if the BeanManager cannot be found.
 * @return the current bean-manager, never &lt;code&gt;null&lt;/code&gt;
 * @throws IllegalStateException if the BeanManager cannot be found
 */
</MethodComment>
            <ReturnType>BeanManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BeanManagerInfo [bmi=getBeanManagerInfo(getClassLoader(null))]</InnerVar>
                <InnerVar>BeanManager [result=bmi.finalBm]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassLoader</MethodName>
            <MethodComment>/** 
 * Detect the right ClassLoader. The lookup order is determined by: &lt;ol&gt; &lt;li&gt;ContextClassLoader of the current Thread&lt;/li&gt; &lt;li&gt;ClassLoader of the given Object 'o'&lt;/li&gt; &lt;li&gt;ClassLoader of this very ClassUtils class&lt;/li&gt; &lt;/ol&gt;
 * @param o if not &lt;code&gt;null&lt;/code&gt; it may get used to detect the classloader.
 * @return The {@link ClassLoader} which should get used to create new instances
 */
</MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>GetClassLoaderAction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassLoaderInternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassLoader [loader=Thread.currentThread().getContextClassLoader()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupFinalBeanManagers</MethodName>
            <MethodComment>/** 
 * By cleaning the final BeanManager map after the Deployment got Validated, we prevent premature loading of information from JNDI in cases where the container might not be fully setup yet. This might happen if someone uses the BeanManagerProvider during Extension startup.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>adv</ParamName>
                    <ParamType>AfterDeploymentValidation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupStoredBeanManagerOnShutdown</MethodName>
            <MethodComment>/** 
 * Cleanup on container shutdown
 * @param beforeShutdown cdi shutdown event
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beforeShutdown</ParamName>
                    <ParamType>BeforeShutdown</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassLoader [classLoader=getClassLoader(null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>bmpSingleton.bmInfos;remove;[classLoader]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveBeanManagerViaJndi</MethodName>
            <MethodComment>/** 
 * Get the BeanManager from the JNDI registry.
 * @return current {@link BeanManager} which is provided via JNDI
 */
</MethodComment>
            <ReturnType>BeanManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBeanManagerInfo</MethodName>
            <MethodComment>/** 
 * Get or create the BeanManagerInfo for the given ClassLoader
 */
</MethodComment>
            <ReturnType>BeanManagerInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cl</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BeanManagerInfo [bmi=bmpSingleton.bmInfos.get(cl)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeanManagerProvider</MethodName>
            <MethodComment>/** 
 * This function exists to prevent findbugs to complain about setting a static member from a non-static function.
 * @param beanManagerProvider the bean-manager-provider which should be used if there isn't an existing provider
 * @return the first BeanManagerProvider
 */
</MethodComment>
            <ReturnType>BeanManagerProvider</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beanManagerProvider</ParamName>
                    <ParamType>BeanManagerProvider</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>