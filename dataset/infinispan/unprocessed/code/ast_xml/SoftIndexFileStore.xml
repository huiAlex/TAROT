<Class>
    <Id>651</Id>
    <Package>org.infinispan.persistence.sifs</Package>
    <ClassName>SoftIndexFileStore</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>AdvancedLoadWriteStore</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SoftIndexFileStore  /** 
 * Local file-based cache store, optimized for write-through use with strong consistency guarantees (ability to flush disk operations before returning from the store call). * DESIGN: There are three threads operating in the cache-store: - LogAppender:  Requests to store entries are passed to the LogAppender thread via queue, then the requestor threads wait until LogAppender notifies them about successful store. LogAppender serializes the writes into append-only file, writes the offset into TemporaryTable and enqueues request to update index into UpdateQueue. The append-only files have limited size, when the file is full, new file is started. - IndexUpdater: Reads the UpdateQueue, applies the operation into B-tree-like structure Index (exact description below) and then removes the entry from TemporaryTable. When the Index is overwriten, the current entry offset is retrieved and IndexUpdater increases the unused space statistics in FileStats. - Compactor:    When a limit of unused space in some file is reached (according to FileStats), the Compactor starts reading this file sequentially, querying TemporaryTable or Index for the current entry position and copying the unchanged entries into another file. For the entries that are still valid in the original file, a compare-and-set (file-offset based) request is enqueued into UpdateQueue - therefore this operation cannot interfere with concurrent writes overwriting the entry. Multiple files can be merged into single file during compaction. Structures: - TemporaryTable: keeps the records about current entry location until this is applied to the Index. Each read request goes to the TemporaryTable, if the key is not found here, Index is queried. - UpdateQueue:    bounded queue (to prevent grow the TemporaryTable too much) of either forced writes (used for regular stores) or compare-and-set writes (used by Compactor). - FileStats:      simple (Concurrent)HashTable with actual file size and amount of unused space for each file. - Index:          B+-tree of IndexNodes. The tree is dropped and built a new if the process crashes, it does not need to flush disk operations. On disk it is kept as single random-accessed file, with free blocks list stored in memory. As IndexUpdater may easily become a bottleneck under heavy load, the IndexUpdater thread, UpdateQueue and tree of IndexNodes may be multiplied several times - the Index is divided into Segments. Each segment owns keys according to the hashCode() of the key. Amount of entries in IndexNode is limited by the size it occupies on disk. This size is limited by configurable nodeSize (4096 bytes by default?), only in case that the node contains single pivot (too long) it can be longer. A key_prefix common for all keys in the IndexNode is stored in order to reduce space requirements. For implementation reasons the keys are limited to 32kB - this requirement may be circumvented later. The pivots are not whole keys - it is the shortest part of key that is greater than all left children (but lesser or equal to all right children) - let us call this key_part. The key_parts are sorted in the IndexNode, naturally. On disk it has this format: key_prefix_length(2 bytes), key_prefix, num_parts(2 bytes), ( key_part_length (2 bytes), key_part, left_child_index_node_offset (8 bytes))+, right_child_index_node_offset (8 bytes) In memory, for every child a SoftReference&lt;IndexNode&gt; is held. When this reference is empty (but the offset in file is set), any reader may load the reference using double-locking pattern (synchronized over the reference itself). The entry is never loaded by multiple threads in parallel and even may block other threads trying to read this node. For each node in memory a RW-lock is held. When the IndexUpdater thread updates the Index (modifying some IndexNodes), it prepares a copy of these nodes (already stored into index file). Then, in locks only the uppermost node for writing, overwrites the references to new data and unlocks the this node. After that the changed nodes are traversed from top down, write locked and their record in index file is released. Reader threads crawl the tree from top down, locking the parent node (for reading), locking child node and unlocking parent node.
 * @author Radim Vansa &amp;lt;rvansa@redhat.com&amp;gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>configuration</FieldName>
            <FieldType>SoftIndexFileStoreConfiguration</FieldType>
        </Field>
        <Field>
            <FieldName>started</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>temporaryTable</FieldName>
            <FieldType>TemporaryTable</FieldType>
        </Field>
        <Field>
            <FieldName>indexQueue</FieldName>
            <FieldType>IndexQueue</FieldType>
        </Field>
        <Field>
            <FieldName>storeQueue</FieldName>
            <FieldType>SyncProcessingQueue</FieldType>
        </Field>
        <Field>
            <FieldName>storeQueue</FieldName>
            <FieldType>LogRequest</FieldType>
        </Field>
        <Field>
            <FieldName>fileProvider</FieldName>
            <FieldType>FileProvider</FieldType>
        </Field>
        <Field>
            <FieldName>logAppender</FieldName>
            <FieldType>LogAppender</FieldType>
        </Field>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>Index</FieldType>
        </Field>
        <Field>
            <FieldName>compactor</FieldName>
            <FieldType>Compactor</FieldType>
        </Field>
        <Field>
            <FieldName>marshaller</FieldName>
            <FieldType>StreamingMarshaller</FieldType>
        </Field>
        <Field>
            <FieldName>byteBufferFactory</FieldName>
            <FieldType>ByteBufferFactory</FieldType>
        </Field>
        <Field>
            <FieldName>marshalledEntryFactory</FieldName>
            <FieldType>MarshalledEntryFactory</FieldType>
        </Field>
        <Field>
            <FieldName>timeService</FieldName>
            <FieldType>TimeService</FieldType>
        </Field>
        <Field>
            <FieldName>maxKeyLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InitializationContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AtomicLong [maxSeqId=new AtomicLong(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compactor;setIndex;[index]</InnerMethodInvoke>
                <InnerMethodInvoke>null;startIndex;[]</InnerMethodInvoke>
                <InnerMethodInvoke>logAppender;setSeqId;[maxSeqId.get() + 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSeqIdOld</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>seqId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializedKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>index;start;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIndexLoaded</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>temporaryTable;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>compactor;resumeAfterPause;[]</InnerMethodInvoke>
                <InnerMethodInvoke>logAppender;resumeAfterPause;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PersistenceException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purge</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>threadPool</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>PurgeListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;trace;["Purge method not supported, ignoring."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entry</ParamName>
                    <ParamType>MarshalledEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [keyLength=entry.getKeyBytes().getLength()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contains</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>load</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MarshalledEntry</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugInfo</MethodName>
            <MethodComment>/** 
 * This method should be called by reflection to get more info about the missing/invalid key (from test tools)
 * @param key
 * @return
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EntryPosition [entry=temporaryTable.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBuffer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ByteBuffer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializedKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializedMetadata</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serializedValue</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>seqId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expiration</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forEachOnDisk</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>readMetadata</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>readValues</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>functor</ParamName>
                    <ParamType>EntryFunctor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileFunctor</ParamName>
                    <ParamType>IntConsumer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PersistenceException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>process</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>KeyFilter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>task</ParamName>
                    <ParamType>CacheLoaderTask</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executor</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchValue</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchMetadata</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TaskContext [context=new TaskContextImpl()]</InnerVar>
                <InnerVar>KeyFilter [notNullFilter=PersistenceUtil.notNull(filter)]</InnerVar>
                <InnerVar>AtomicLong [tasksSubmitted=new AtomicLong()]</InnerVar>
                <InnerVar>AtomicLong [tasksFinished=new AtomicLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forEachOnDisk;[fetchMetadata, fetchValue, (file,offset,size,serializedKey,serializedMetadata,serializedValue,seqId,expiration) -&gt; {
  if (context.isStopped()) {
    return false;
  }
  final Object key=marshaller.objectFromByteBuffer(serializedKey);
  if (!notNullFilter.accept(key)) {
    return true;
  }
  if (isSeqIdOld(seqId,key,serializedKey)) {
    return true;
  }
  if (serializedValue != null &amp;&amp; (expiration &lt; 0 || expiration &gt; timeService.wallClockTime())) {
    executor.execute(() -&gt; {
      try {
        task.processEntry(marshalledEntryFactory.newMarshalledEntry(key,serializedValue == null ? null : marshaller.objectFromByteBuffer(serializedValue),serializedMetadata == null ? null : (InternalMetadata)marshaller.objectFromByteBuffer(serializedMetadata)),context);
      }
 catch (      Exception e) {
        log.errorf(e,"Failed to process task for key %s",key);
      }
 finally {
        long finished=tasksFinished.incrementAndGet();
        if (finished == tasksSubmitted.longValue()) {
synchronized (context) {
            context.notifyAll();
          }
        }
      }
    }
);
    tasksSubmitted.incrementAndGet();
    return !context.isStopped();
  }
  return true;
}
, file -&gt; {
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>