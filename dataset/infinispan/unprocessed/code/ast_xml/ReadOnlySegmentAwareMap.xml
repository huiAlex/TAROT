<Class>
    <Id>6</Id>
    <Package>org.infinispan.distribution.util</Package>
    <ClassName>ReadOnlySegmentAwareMap</ClassName>
    <SuperClass>AbstractDelegatingMap</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ReadOnlySegmentAwareMap  /** 
 * Map implementation that shows a read only view of the provided entry by only allowing entries whose key maps to a given segment using the provided consistent hash. &lt;p&gt; Any operation that would modify this map will throw an  {@link UnsupportedOperationException}&lt;p&gt; This map is useful when you don't want to copy an entire map but only need to see entries from the given segments. &lt;p&gt; Note many operations are not constant time when using this map.  The {@link ReadOnlySegmentAwareMap#values} method is not supported as well. Please check\the method you are using to see if it will perform differently than normally expected.
 * @author wburns
 * @since 7.2
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>map</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>map</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>ch</FieldName>
            <FieldType>ConsistentHash</FieldType>
        </Field>
        <Field>
            <FieldName>allowedSegments</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>allowedSegments</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>segmentAwareKeySet</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>segmentAwareKeySet</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>segmentAwareEntrySet</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>segmentAwareEntrySet</FieldName>
            <FieldType>Map.Entry&lt;K,V&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>delegate</FieldName>
            <FieldType>AbstractDelegatingCollection</FieldType>
        </Field>
        <Field>
            <FieldName>delegate</FieldName>
            <FieldType>T</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ReadOnlySegmentAwareMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ConsistentHash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delegate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keyAllowed</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [segment=ch.getSegment(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entrySet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>java.util.Map.Entry&lt;K,V&gt;</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * Checks if the provided map is empty.  This is done by iterating over all of the keys until it can find a key that maps to a given segment. &lt;p&gt; This method should always be preferred over checking the size to see if it is empty. &lt;p&gt; This time complexity for this method between O(1) to O(N).
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keySet=keySet()]</InnerVar>
                <InnerVar>Iterator&lt;K&gt; [iter=keySet.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keySet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>K</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Returns the size of the read only map.  This is done by iterating over all of the keys counting all that are in the segments. &lt;p&gt; If you are using this method to verify if the map is empty, you should instead use the  {@link ReadOnlySegmentAwareEntryMap#isEmpty()} as it will perform better if thesize is only used for this purpose. &lt;p&gt; This time complexity for this method is always O(N).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;K&gt; [keySet=keySet()]</InnerVar>
                <InnerVar>Iterator&lt;K&gt; [iter=keySet.iterator()]</InnerVar>
                <InnerVar>int [count=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>values</MethodName>
            <MethodComment>/** 
 * NOTE: this method is not supported.  Due to the nature of this map, we don't want to copy the underlying value collection.  Thus almost any operation will require O(N) and therefore this method is not provided.
 */
</MethodComment>
            <ReturnType>V</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CollectionAsSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>delegate</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delegate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>