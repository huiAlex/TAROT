<Class>
    <Id>3762</Id>
    <Package>org.infinispan.commons.marshall</Package>
    <ClassName>MarshallUtil</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MarshallUtil  /** 
 * MarshallUtil.
 * @author Galder Zamarre√±o
 * @since 4.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>NULL_VALUE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>marshallMap</MethodName>
            <MethodComment>/** 
 * Marshall the  {@code map} to the {@code ObjectOutput}. &lt;p&gt; {@code null} maps are supported.
 * @param map {@link Map} to marshall.
 * @param out {@link ObjectOutput} to write. It must be non-null.
 * @param &lt; K &gt; Key type of the map.
 * @param &lt; V &gt; Value type of the map.
 * @param &lt; T &gt; Type of the {@link Map}.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [mapSize=map == null ? NULL_VALUE : map.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, mapSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallMap</MethodName>
            <MethodComment>/** 
 * Unmarshall the  {@link Map}. &lt;p&gt; If the marshalled map is  {@link null}, then the  {@link MapBuilder} is not invoked.
 * @param in      {@link ObjectInput} to read.
 * @param builder {@link MapBuilder} to create the concrete {@link Map} implementation.
 * @return The populated {@link Map} created by the {@link MapBuilder} or {@code null}.
 * @throws IOException            If any of the usual Input/Output related exceptions occur.
 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
 * @see #marshallMap(Map,ObjectOutput)
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>T [map=Objects.requireNonNull(builder,"MapBuilder must be non-null").build(computeCapacity(size))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallMap</MethodName>
            <MethodComment>/** 
 * Marshall the  {@code map} to the {@code ObjectOutput}. &lt;p&gt; {@code null} maps are supported.
 * @param map {@link Map} to marshall.
 * @param out {@link ObjectOutput} to write. It must be non-null.
 * @param &lt; K &gt; Key type of the map.
 * @param &lt; V &gt; Value type of the map.
 * @param &lt; T &gt; Type of the {@link Map}.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyWriter</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueWrite</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [mapSize=map == null ? NULL_VALUE : map.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, mapSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallMap</MethodName>
            <MethodComment>/** 
 * Unmarshall the  {@link Map}. &lt;p&gt; If the marshalled map is  {@link null}, then the  {@link MapBuilder} is not invoked.
 * @param in      {@link ObjectInput} to read.
 * @param builder {@link MapBuilder} to create the concrete {@link Map} implementation.
 * @return The populated {@link Map} created by the {@link MapBuilder} or {@code null}.
 * @throws IOException            If any of the usual Input/Output related exceptions occur.
 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
 * @see #marshallMap(Map,ElementWriter,ElementWriter,ObjectOutput)
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyReader</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueReader</ParamName>
                    <ParamType>V</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>T [map=Objects.requireNonNull(builder,"MapBuilder must be non-null").build(computeCapacity(size))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallUUID</MethodName>
            <MethodComment>/** 
 * Marshall the  {@link UUID} by sending the most and lest significant bits.&lt;p&gt; This method supports  {@code null} if {@code checkNull} is set to {@link true}.
 * @param uuid      {@link UUID} to marshall.
 * @param out       {@link ObjectOutput} to write.
 * @param checkNull If {@code true}, it checks if  {@code uuid} is {@code null}.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkNull</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeLong;[uuid.getMostSignificantBits()]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[uuid.getLeastSignificantBits()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallUUID</MethodName>
            <MethodComment>/** 
 * Unmarshall  {@link UUID}.
 * @param in        {@link ObjectInput} to read.
 * @param checkNull If {@code true}, it checks if the  {@link UUID} marshalled was {@link null}.
 * @return {@link UUID} marshalled.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 * @see #marshallUUID(UUID, ObjectOutput, boolean).
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkNull</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallArray</MethodName>
            <MethodComment>/** 
 * Marshall arrays. &lt;p&gt; This method supports  {@code null} {@code array}.
 * @param array Array to marshall.
 * @param out   {@link ObjectOutput} to write.
 * @param &lt; E &gt;   Array type.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>E[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=array == null ? NULL_VALUE : array.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, size]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallArray</MethodName>
            <MethodComment>/** 
 * Unmarshall arrays.
 * @param in      {@link ObjectInput} to read.
 * @param builder {@link ArrayBuilder} to build the array.
 * @param &lt; E &gt;     Array type.
 * @return The populated array.
 * @throws IOException            If any of the usual Input/Output related exceptions occur.
 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
 * @see #marshallArray(Object[], ObjectOutput).
 */
</MethodComment>
            <ReturnType>E[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>E[] [array=Objects.requireNonNull(builder,"ArrayBuilder must be non-null").build(size)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallCollection</MethodName>
            <MethodComment>/** 
 * Marshall a  {@link Collection}. &lt;p&gt; This method supports  {@code null} {@code collection}.
 * @param collection {@link Collection} to marshal.
 * @param out        {@link ObjectOutput} to write.
 * @param &lt; E &gt;        Collection's element type.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collection</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallCollection;[collection, out, ObjectOutput::writeObject]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallCollection</MethodName>
            <MethodComment>/** 
 * Marshall a  {@link Collection}. &lt;p&gt; This method supports  {@code null} {@code collection}.
 * @param collection {@link Collection} to marshal.
 * @param out        {@link ObjectOutput} to write.
 * @param writer     {@link ElementWriter} that writes single element to the output.
 * @param &lt; E &gt;        Collection's element type.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collection</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=collection == null ? NULL_VALUE : collection.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, size]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallCollection</MethodName>
            <MethodComment>/** 
 * Unmarshal a  {@link Collection}.
 * @param in      {@link ObjectInput} to read.
 * @param builder {@link CollectionBuilder} builds the concrete {@link Collection} based on size.
 * @param reader {@link ElementReader} reads one element from the input.
 * @param &lt; E &gt;     Collection's element type.
 * @param &lt; T &gt;     {@link Collection} implementation.
 * @return The concrete {@link Collection} implementation.
 * @throws IOException            If any of the usual Input/Output related exceptions occur.
 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>T [collection=Objects.requireNonNull(builder,"CollectionBuilder must be non-null").build(size)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallCollection</MethodName>
            <MethodComment>/** 
 * Unmarshal a  {@link Collection}.
 * @param in      {@link ObjectInput} to read.
 * @param builder {@link CollectionBuilder} builds the concrete {@link Collection} based on size.
 * @param &lt; E &gt;     Collection's element type.
 * @param &lt; T &gt;     {@link Collection} implementation.
 * @return The concrete {@link Collection} implementation.
 * @throws IOException            If any of the usual Input/Output related exceptions occur.
 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallCollectionUnbounded</MethodName>
            <MethodComment>/** 
 * Same as  {@link #unmarshallCollection(ObjectInput,CollectionBuilder)}. &lt;p&gt; Used when the size of the  {@link Collection} is not needed for it construction.
 * @see #unmarshallCollection(ObjectInput, CollectionBuilder).
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>T [collection=Objects.requireNonNull(builder,"UnboundedCollectionBuilder must be non-null").build()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallString</MethodName>
            <MethodComment>/** 
 * Marshall the  {@link String}. &lt;p&gt; Same behavior as  {@link ObjectOutput#writeUTF(String)} but it checks for {@code null}. If the  {@code string} isnever  {@code null}, it is better to use  {@link ObjectOutput#writeUTF(String)}.
 * @param string {@link String} to marshall.
 * @param out    {@link ObjectOutput} to write.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeBoolean;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeUTF;[string]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallString</MethodName>
            <MethodComment>/** 
 * Unmarshall a  {@link String}.
 * @param in {@link ObjectInput} to read.
 * @return The {@link String} or {@code null}.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 * @see #marshallString(String, ObjectOutput).
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallByteArray</MethodName>
            <MethodComment>/** 
 * Same as  {@link #marshallArray(Object[],ObjectOutput)} but specialized for byte arrays.
 * @see #marshallArray(Object[], ObjectOutput).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=array == null ? NULL_VALUE : array.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, size]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[array]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallByteArray</MethodName>
            <MethodComment>/** 
 * Same as  {@link #unmarshallArray(ObjectInput,ArrayBuilder)} but specialized for byte array.&lt;p&gt; No  {@link ArrayBuilder} is necessary.
 * @see #unmarshallArray(ObjectInput, ArrayBuilder).
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>byte[] [array=new byte[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>in;readFully;[array]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallSize</MethodName>
            <MethodComment>/** 
 * A special marshall implementation for integer. &lt;p&gt; This method supports negative values but they are handles as  {@link #NULL_VALUE}. It means that the real value is lost and  {@link #NULL_VALUE} is returned by {@link #unmarshallSize(ObjectInput)}. &lt;p&gt; The integer is marshalled in a variable length from 1 to 5 bytes. Negatives values are always marshalled in 1 byte.
 * @param out   {@link ObjectOutput} to write.
 * @param value Integer value to marshall.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeByte;[(value &amp; 0x3F) | 0x40]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeByte;[(byte)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallSize</MethodName>
            <MethodComment>/** 
 * Unmarshall an integer.
 * @param in {@link ObjectInput} to read.
 * @return The integer value or {@link #NULL_VALUE} if the original value was negative.
 * @throws IOException If any of the usual Input/Output related exceptions occur.
 * @see #marshallSize(ObjectOutput, int).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [b=in.readByte()]</InnerVar>
                <InnerVar>int [i=b &amp; 0x3F]</InnerVar>
                <InnerVar>int [shift=6]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallEnum</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>output</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallEnum</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>E</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [ordinal=input.readByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>marshallIntCollection</MethodName>
            <MethodComment>/** 
 * Marshalls a collection of integers.
 * @param collection the collection to marshall.
 * @param out        the {@link ObjectOutput} to write to.
 * @throws IOException if an error occurs.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collection</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=collection == null ? NULL_VALUE : collection.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;marshallSize;[out, size]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unmarshallIntCollection</MethodName>
            <MethodComment>/** 
 * Unmarshalls a collection of integers.
 * @param in      the {@link ObjectInput} to read from.
 * @param builder the {@link CollectionBuilder} to build the collection of integer.
 * @param &lt; T &gt;     the concrete type of the collection.
 * @return the collection.
 * @throws IOException if an error occurs.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=unmarshallSize(in)]</InnerVar>
                <InnerVar>T [collection=Objects.requireNonNull(builder,"CollectionBuilder must be non-null").build(size)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>build</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>E[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>build</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>build</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>build</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>build</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>E</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ordinal</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readFrom</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>E</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>output</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>