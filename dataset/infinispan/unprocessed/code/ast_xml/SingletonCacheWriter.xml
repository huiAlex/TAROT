<Class>
    <Id>308</Id>
    <Package>org.infinispan.persistence.support</Package>
    <ClassName>SingletonCacheWriter</ClassName>
    <SuperClass>DelegatingCacheWriter</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SingletonCacheWriter  /** 
 * SingletonStore is a delegating cache store used for situations when only one instance should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. &lt;p/&gt; SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore. &lt;p/&gt; Writes are delegated &lt;i&gt;only if&lt;/i&gt; this SingletonStore is currently the coordinator. This avoids having all stores in a cluster writing the same data to the same underlying store. Although not incorrect (e.g. a DB will just discard additional INSERTs for the same key, and throw an exception), this will avoid a lot of redundant work. &lt;p/&gt; Whenever the current coordinator dies (or leaves), the second in line will take over. That SingletonStore will then pass writes through to its underlying CacheStore. Optionally, when a new coordinator takes over the Singleton, it can push the in-memory state to the cache cacheStore, within a time constraint.
 * @author Mircea Markus
 * @since 6.0
 * @deprecated this writer will be removed in 10.0. If it is desirable that all nodes don't write to the underlying storethen a shared store should be used instead, as this only performs store writes at a key's primary owner.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>singletonConfiguration</FieldName>
            <FieldType>SingletonStoreConfiguration</FieldType>
        </Field>
        <Field>
            <FieldName>THREAD_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>executor</FieldName>
            <FieldType>ExecutorService</FieldType>
        </Field>
        <Field>
            <FieldName>pushStateFuture</FieldName>
            <FieldType>Future</FieldType>
        </Field>
        <Field>
            <FieldName>pushStateFuture</FieldName>
            <FieldType>?</FieldType>
        </Field>
        <Field>
            <FieldName>localAddress</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>active</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SingletonCacheWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actual</ParamName>
                    <ParamType>CacheWriter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singletonConfiguration</ParamName>
                    <ParamType>SingletonStoreConfiguration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newThread</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Thread</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>Runnable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ctx.getCache().getCacheManager();addListener;[new SingletonStoreListener()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>executor;shutdownNow;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entry</ParamName>
                    <ParamType>MarshalledEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPushStateTask</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [debugEnabled=log.isDebugEnabled()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[ctx.getCache()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushState</MethodName>
            <MethodComment>/** 
 * Pushes the state of a specific cache by reading the cache's data and putting in the cache store.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataContainer&lt;?,?&gt; [dc=cache.getAdvancedCache().getDataContainer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dc.iterator();forEachRemaining;[entry -&gt; {
  MarshalledEntry me=ctx.getMarshalledEntryFactory().newMarshalledEntry(entry.getKey(),entry.getValue(),internalMetadata(entry));
  write(me);
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>awaitForPushToFinish</MethodName>
            <MethodComment>/** 
 * Method that waits for the in-memory to cache loader state to finish. This method's called in case a push state is already in progress and we need to wait for it to finish.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>future</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unit</ParamName>
                    <ParamType>TimeUnit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [debugEnabled=log.isDebugEnabled()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>activeStatusChanged</MethodName>
            <MethodComment>/** 
 * Method called when the cache either becomes the coordinator or stops being the coordinator. If it becomes the coordinator, it can optionally start the in-memory state transfer to the underlying cache store.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newActiveState</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["changed mode %s", this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PushStateException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCoordinator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newView</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentAddress</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doPushState</MethodName>
            <MethodComment>/** 
 * Called when the SingletonStore discovers that the cache has become the coordinator and push in memory state has been enabled. It might not actually push the state if there's an ongoing push task running, in which case will wait for the push task to finish.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PushStateException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForTaskToFinish</MethodName>
            <MethodComment>/** 
 * Waits, within a time constraint, for a task to finish.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>future</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeout</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unit</ParamName>
                    <ParamType>TimeUnit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cacheStarted</MethodName>
            <MethodComment>/** 
 * Cache started, check whether the cache is the coordinator and set the singleton store's active status.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Event</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EmbeddedCacheManager [cm=ctx.getCache().getCacheManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>viewChange</MethodName>
            <MethodComment>/** 
 * The cluster formation changed, so determine whether the current cache stopped being the coordinator or became the coordinator. This method can lead to an optional in memory to cache loader state push, if the current cache became the coordinator. This method will report any issues that could potentially arise from this push.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>event</ParamName>
                    <ParamType>ViewChangedEvent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [tmp=isCoordinator(event.getNewMembers(),event.getLocalAddress())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PushStateException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>message</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cause</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>