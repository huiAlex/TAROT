<Class>
    <Id>3388</Id>
    <Package>org.infinispan.container.offheap</Package>
    <ClassName>OffHeapEntryFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>OffHeapEntryFactory  /** 
 * Factory that can create  {@link InternalCacheEntry} objects that use off-heap heap memory.  These are stored bya long to symbolize the memory address.
 * @author wburns
 * @since 9.0
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>create</MethodName>
            <MethodComment>/** 
 * Creates an off heap entry using the provided key value and metadata
 * @param key the key to use
 * @param value the value to use
 * @param metadata the metadata to use
 * @return the address of where the entry was created
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metadata</ParamName>
                    <ParamType>Metadata</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSize</MethodName>
            <MethodComment>/** 
 * Returns how many bytes in memory this address location uses assuming it is an  {@link InternalCacheEntry}
 * @param address the address of the entry
 * @return how many bytes this address was allocated as
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNext</MethodName>
            <MethodComment>/** 
 * Returns the address to the next linked pointer if there is one for this bucket or 0 if there isn't one
 * @param address the address of the entry
 * @return the next address entry for this bucket or 0
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNext</MethodName>
            <MethodComment>/** 
 * Called to update the next pointer index when a collision occurs requiring a linked list within the entries themselves
 * @param address the address of the entry to update
 * @param value the value of the linked node to set
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLruNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entryAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLruNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>entryAddress</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHashCode</MethodName>
            <MethodComment>/** 
 * Returns the hashCode of the address.  This
 * @param address the address of the entry
 * @return the has code of the entry
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromMemory</MethodName>
            <MethodComment>/** 
 * Create an entry from the off heap pointer
 * @param address the address of the entry to read
 * @return the entry created on heap from off heap
 */
</MethodComment>
            <ReturnType>WrappedBytes</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKey</MethodName>
            <MethodComment>/** 
 * Returns the key for the given address
 * @param address the address pointer to find the key of
 * @return the key of the given address pointer
 */
</MethodComment>
            <ReturnType>WrappedBytes</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalsKey</MethodName>
            <MethodComment>/** 
 * Returns whether the given key as bytes is the same key as the key stored in the entry for the given address.
 * @param address the address of the entry's key to check
 * @param wrappedBytes the key to check equality with
 * @return whether or not the keys are equal
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>address</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wrappedBytes</ParamName>
                    <ParamType>WrappedBytes</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>