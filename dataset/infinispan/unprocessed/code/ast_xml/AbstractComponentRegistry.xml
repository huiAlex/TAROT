<Class>
    <Id>1775</Id>
    <Package>org.infinispan.factories</Package>
    <ClassName>AbstractComponentRegistry</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Lifecycle</SuperInterface>
        <SuperInterface>Cloneable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AbstractComponentRegistry  /** 
 * A registry where components which have been created are stored.  Components are stored as singletons, registered under a specific name. &lt;p/&gt; Components can be retrieved from the registry using  {@link #getComponent(Class)}. &lt;p/&gt; Components can be registered using  {@link #registerComponent(Object,Class)}, which will cause any dependencies to be wired in as well.  Components that need to be created as a result of wiring will be done using  {@link #getOrCreateComponent(Class)}, which will look up the default factory for the component type (factories annotated with the appropriate  {@link DefaultFactoryFor} annotation.&lt;p/&gt; Default factories are treated as components too and will need to be wired before being used. &lt;p/&gt; The registry can exist in one of several states, as defined by the  {@link org.infinispan.lifecycle.ComponentStatus}enumeration. In terms of the cache, state changes in the following manner: &lt;ul&gt; &lt;li&gt;INSTANTIATED - when first constructed&lt;/li&gt; &lt;li&gt;CONSTRUCTED - when created using the DefaultCacheFactory&lt;/li&gt; &lt;li&gt;STARTED - when  {@link org.infinispan.Cache#start()} is called&lt;/li&gt; &lt;li&gt;STOPPED - when {@link org.infinispan.Cache#stop()} is called&lt;/li&gt;&lt;/ul&gt; &lt;p/&gt; Cache configuration can only be changed and will only be re-injected if the cache is not in the  {@link org.infinispan.lifecycle.ComponentStatus#RUNNING} state.Thread Safety: instances of  {@link GlobalComponentRegistry} can be concurrently updated so allthe write operations are serialized through class intrinsic lock.
 * @author Manik Surtani
 * @author Galder Zamarre√±o
 * @since 4.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>DEPENDENCIES_ENABLE_JVMOPTION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DEBUG_DEPENDENCIES</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>debugStack</FieldName>
            <FieldType>Stack</FieldType>
        </Field>
        <Field>
            <FieldName>debugStack</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NULL_COMPONENT</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>componentLookup</FieldName>
            <FieldType>ConcurrentMap</FieldType>
        </Field>
        <Field>
            <FieldName>componentLookup</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>state</FieldName>
            <FieldType>ComponentStatus</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_PRIO_METHODS</FieldName>
            <FieldType>PrioritizedMethod[]</FieldType>
        </Field>
        <Field>
            <FieldName>instance</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>name</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>methodsScanned</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>injectionMethods</FieldName>
            <FieldType>ComponentMetadata.InjectMetadata[]</FieldType>
        </Field>
        <Field>
            <FieldName>startMethods</FieldName>
            <FieldType>PrioritizedMethod[]</FieldType>
        </Field>
        <Field>
            <FieldName>postStartMethods</FieldName>
            <FieldType>PrioritizedMethod[]</FieldType>
        </Field>
        <Field>
            <FieldName>stopMethods</FieldName>
            <FieldType>PrioritizedMethod[]</FieldType>
        </Field>
        <Field>
            <FieldName>metadata</FieldName>
            <FieldType>ComponentMetadata</FieldType>
        </Field>
        <Field>
            <FieldName>metadata</FieldName>
            <FieldType>ComponentMetadata.PrioritizedMethodMetadata</FieldType>
        </Field>
        <Field>
            <FieldName>component</FieldName>
            <FieldType>Component</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getStatus</MethodName>
            <MethodComment>/** 
 * Retrieves the state of the registry
 * @return state of the registry
 */
</MethodComment>
            <ReturnType>ComponentStatus</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassLoader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLog</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Log</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponentMetadataRepo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ComponentMetadataRepo</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wireDependencies</MethodName>
            <MethodComment>/** 
 * Wires an object instance with dependencies annotated with the  {@link Inject} annotation, creating more componentsas needed based on the Configuration passed in if these additional components don't exist in the  {@link ComponentRegistry}.  Strictly for components that don't otherwise live in the registry and have a lifecycle, such as Commands.
 * @param target object to wire
 * @throws CacheConfigurationException if there is a problem wiring the instance
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CacheConfigurationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerComponent</MethodName>
            <MethodComment>/** 
 * Registers a component in the registry under the given type, and injects any dependencies needed.  If a component of this type already exists, it is overwritten.
 * @param component component to register
 * @param type      type of component
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponent;[component, type.getName(), type.equals(component.getClass())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponent;[component, name, name.equals(component.getClass().getName())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameIsFQCN</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponentInternal;[component, name, nameIsFQCN]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerNonVolatileComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponentInternal;[component, name, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerNonVolatileComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponentInternal;[component, type.getName(), true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerComponentInternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>component</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameIsFQCN</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Component [old=componentLookup.get(name)]</InnerVar>
                <InnerVar>Component [c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>c;injectDependencies;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokeInjectionMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>injectMetadata</ParamName>
                    <ParamType>ComponentMetadata.InjectMetadata</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt;[] [dependencies=injectMetadata.getParameterClasses()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrCreateComponent</MethodName>
            <MethodComment>/** 
 * Retrieves a component if one exists, and if not, attempts to find a factory capable of constructing the component (factories annotated with the  {@link DefaultFactoryFor} annotation that is capable of creating the componentclass). &lt;p/&gt; If an instance needs to be constructed, dependencies are then automatically wired into the instance, based on methods on the component type annotated with  {@link Inject}. &lt;p/&gt; Summing it up, component retrieval happens in the following order:&lt;br /&gt; 1.  Look for a component that has already been created and registered. 2.  Look for an appropriate component that exists in the  {@link Configuration} thatmay be injected from an external system. 3.  Look for a class definition passed in to the  {@link Configuration} -such as an EvictionPolicy implementation 4.  Attempt to create it by looking for an appropriate factory (annotated with  {@link DefaultFactoryFor}) &lt;p/&gt;
 * @param componentClass type of component to be retrieved.  Should not be null.
 * @return a fully wired component instance, or null if one cannot be found or constructed.
 * @throws CacheConfigurationException if there is a problem with constructing or wiring the instance.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrCreateComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrCreateComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameIsFQCN</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [component]</InnerVar>
                <InnerVar>Component [oldWrapper=lookupComponent(componentClass.getName(),name,nameIsFQCN)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFactory</MethodName>
            <MethodComment>/** 
 * Retrieves a component factory instance capable of constructing components of a specified type.  If the factory doesn't exist in the registry, one is created.
 * @param componentClass type of component to construct
 * @return component factory capable of constructing such components
 */
</MethodComment>
            <ReturnType>AbstractComponentFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [cfClass=getComponentMetadataRepo().findFactoryForComponent(componentClass)]</InnerVar>
                <InnerVar>AbstractComponentFactory [cf=getComponent(cfClass)]</InnerVar>
                <InnerVar>Component [c=lookupComponent(cfClass,cfClass,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLog();tracef;["Looking up factory for class %s", componentClass]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createComponentFactoryInternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AbstractComponentFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cfClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AbstractComponentFactory [component=getComponent(cfClass)]</InnerVar>
                <InnerVar>AbstractComponentFactory [cf=instantiateFactory(cfClass)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLog();tracef;["Creating factory %s for component %s", cfClass, componentClass]</InnerMethodInvoke>
                <InnerMethodInvoke>null;registerComponent;[cf, cfClass]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Component</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>componentName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameIsFQCN</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>instantiateFactory</MethodName>
            <MethodComment>/** 
 * No such thing as a meta factory yet.  Factories are created using this method which attempts to use an empty public constructor.
 * @param factoryName classname of factory to be created
 * @return factory instance
 */
</MethodComment>
            <ReturnType>AbstractComponentFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [factory=Util.loadClass(factoryName,getClass().getClassLoader())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerNullComponent</MethodName>
            <MethodComment>/** 
 * registers a special "null" component that has no dependencies.
 * @param name name of component to register as a null
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponent;[NULL_COMPONENT, name, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConfiguration</MethodName>
            <MethodComment>/** 
 * Retrieves the configuration component.
 * @return a Configuration object
 */
</MethodComment>
            <ReturnType>Configuration</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponent</MethodName>
            <MethodComment>/** 
 * Retrieves a component of a specified type from the registry, or null if it cannot be found.
 * @param type type to find
 * @return component, or null
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [className=type.getName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>componentClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameIsFQCN</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Component [wrapper=lookupComponent(componentClassName,name,nameIsFQCN)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptionalComponent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unwrapComponent</MethodName>
            <MethodComment>/** 
 * Get the component from a wrapper, properly handling &lt;code&gt;null&lt;/code&gt; components.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>wrapper</ParamName>
                    <ParamType>Component</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerDefaultClassLoader</MethodName>
            <MethodComment>/** 
 * Registers the default class loader.  This method *must* be called before any other components are registered, typically called by bootstrap code.  Defensively, it is called in the constructor of ComponentRegistry with a null parameter.
 * @param loader a class loader to use by default.  If this is null, the class loader used to load this instance ofComponentRegistry is used.
 */
</MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassLoader [loaderToUse=loader == null ? getClass().getClassLoader() : loader]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerComponent;[loaderToUse, ClassLoader.class]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rewire</MethodName>
            <MethodComment>/** 
 * Rewires components.  Used to rewire components in the CR if a cache has been stopped (moved to state TERMINATED), which would (almost) empty the registry of components.  Rewiring will re-inject all dependencies so that the cache can be started again. &lt;p/&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>populateLifecycleMethods</MethodName>
            <MethodComment>/** 
 * Scans each registered component for lifecycle methods, and adds them to the appropriate lists, and then sorts them by priority.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processPrioritizedMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PrioritizedMethod[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodMetadata</ParamName>
                    <ParamType>ComponentMetadata.PrioritizedMethodMetadata[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>componentClass</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Component</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PrioritizedMethod[] [retval]</InnerVar>
                <InnerVar>int [numStartMethods=methodMetadata.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>populateLifeCycleMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Component</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetVolatileComponents</MethodName>
            <MethodComment>/** 
 * Removes any components not annotated as @SurvivesRestarts.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLog();tracef;["Resetting volatile components"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment>/** 
 * This starts the components in the registry, connecting to channels, starting service threads, etc.  If the component is not in the  {@link org.infinispan.lifecycle.ComponentStatus#INITIALIZING} state, it will be initialized first.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postStart</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;PrioritizedMethod&gt; [methods=new ArrayList&lt;&gt;(componentLookup.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invokePrioritizedMethods;[methods]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment>/** 
 * Stops the component and sets its status to  {@link org.infinispan.lifecycle.ComponentStatus#TERMINATED} once itis done.  If the component is not in the  {@link org.infinispan.lifecycle.ComponentStatus#RUNNING} state, this is ano-op.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [failed=state == ComponentStatus.FAILED]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleLifecycleTransitionFailure</MethodName>
            <MethodComment>/** 
 * Sets the cacheStatus to FAILED and re-throws the problem as one of the declared types. Converts any non-RuntimeException Exception to CacheException.
 * @param t throwable thrown during failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalStart</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;PrioritizedMethod&gt; [methods=new ArrayList&lt;&gt;(componentLookup.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;populateLifecycleMethods;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;invokePrioritizedMethods;[methods]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addShutdownHook;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CacheException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invokePrioritizedMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <ParamType>PrioritizedMethod</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [traceEnabled=getLog().isTraceEnabled()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Collections;sort;[methods]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addShutdownHook</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeShutdownHook</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalStop</MethodName>
            <MethodComment>/** 
 * Actual stop
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;PrioritizedMethod&gt; [stopMethods=new ArrayList&lt;&gt;(componentLookup.size())]</InnerVar>
                <InnerVar>boolean [traceEnabled=getLog().isTraceEnabled()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;removeShutdownHook;[]</InnerMethodInvoke>
                <InnerMethodInvoke>Collections;sort;[stopMethods]</InnerMethodInvoke>
                <InnerMethodInvoke>null;resetVolatileComponents;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invocationsAllowed</MethodName>
            <MethodComment>/** 
 * Asserts whether invocations are allowed on the cache or not.  Returns &lt;tt&gt;true&lt;/tt&gt; if invocations are to be allowed, &lt;tt&gt;false&lt;/tt&gt; otherwise.  If the origin of the call is remote and the cache status is  {@link org.infinispan.lifecycle.ComponentStatus#INITIALIZING}, this method will block for up to  {@link org.infinispan.configuration.cache.StateTransferConfiguration#timeout()} millis, checking for a valid state.
 * @param originLocal true if the call originates locally (i.e., from the {@link org.infinispan.cache.impl.CacheImpl} or falseif it originates remotely, i.e., from the  {@link org.infinispan.remoting.inboundhandler.InboundInvocationHandler}.
 * @return true if invocations are allowed, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>originLocal</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLog();trace;["Testing if invocations are allowed."]</InnerMethodInvoke>
                <InnerMethodInvoke>getLog();trace;["Is remotely originating."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>blockUntilCacheStarts</MethodName>
            <MethodComment>/** 
 * Blocks until the current cache instance is in its  {@link org.infinispan.lifecycle.ComponentStatus#RUNNING started}phase. Blocks for up to  {@link org.infinispan.configuration.cache.StateTransferConfiguration#timeout()} milliseconds, throwing anIllegalStateException if the cache doesn't reach this state even after this maximum wait time.
 * @throws InterruptedException  if interrupted while waiting
 * @throws IllegalStateException if even after waiting the cache has not started.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [pollFrequencyMS=20]</InnerVar>
                <InnerVar>TimeService [timeService=getTimeService()]</InnerVar>
                <InnerVar>long [startupWaitTime=getConfiguration().clustering().stateTransfer().timeout()]</InnerVar>
                <InnerVar>long [giveUpTime=timeService.expectedEndTime(startupWaitTime,TimeUnit.MILLISECONDS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
                <ExceptionType>IllegalStateException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRegisteredComponents</MethodName>
            <MethodComment>/** 
 * Returns an immutable set containing all the components that exists in the repository at this moment.
 * @return a set of components
 */
</MethodComment>
            <ReturnType>Component</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>HashSet&lt;Component&gt; [defensiveCopy=new HashSet&lt;&gt;(componentLookup.values())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AbstractComponentRegistry</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AbstractComponentRegistry [dolly=(AbstractComponentRegistry)super.clone()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CloneNotSupportedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeService</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TimeService</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>injectDependencies</MethodName>
            <MethodComment>/** 
 * Injects dependencies into this component.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetadata</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ComponentMetadata</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildInjectionMethodsList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>PrioritizedMethod</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [thisVal=metadata.getPriority()]</InnerVar>
                <InnerVar>int [anotherVal=o.metadata.getPriority()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PrioritizedMethod [that=(PrioritizedMethod)o]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [result=metadata != null ? metadata.hashCode() : 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invoke</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invokeAccessibly;[component.instance, metadata.getMethod(), null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwStackAwareConfigurationException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>message</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>