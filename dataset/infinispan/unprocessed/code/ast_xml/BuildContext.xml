<Class>
    <Id>1492</Id>
    <Package>org.infinispan.lucene.directory</Package>
    <ClassName>BuildContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BuildContext  /** 
 * Building context to set construction parameters of Infinispan Directory instances
 * @since 5.2
 * @author Sanne Grinovero
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>create</MethodName>
            <MethodComment>/** 
 * Creates a Directory instance
 * @see org.apache.lucene.store.Directory
 * @return the new Directory
 */
</MethodComment>
            <ReturnType>Directory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chunkSize</MethodName>
            <MethodComment>/** 
 * Sets the chunkSize option for the Directory being created.
 * @param bytes segments are fragmented in chunkSize bytes; larger values are more efficient for searching but less fordistribution and network replication
 * @return the same building context to eventually create the Directory instance
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>overrideSegmentReadLocker</MethodName>
            <MethodComment>/** 
 * Overrides the default SegmentReadLocker. In some cases you might be able to provide more efficient implementations than the default one by controlling the IndexReader's lifecycle
 * @see org.infinispan.lucene.readlocks
 * @param srl the new read locking strategy for fragmented segments
 * @return the same building context to eventually create the Directory instance
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>srl</ParamName>
                    <ParamType>SegmentReadLocker</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>overrideWriteLocker</MethodName>
            <MethodComment>/** 
 * Overrides the IndexWriter LockFactory
 * @see org.infinispan.lucene.locking
 * @param lf the LockFactory to be used by IndexWriters.
 * @return the same building context to eventually create the Directory instance
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lf</ParamName>
                    <ParamType>LockFactory</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFileListAsynchronously</MethodName>
            <MethodComment>/** 
 * When set to true, the list of files of the Directory is propagated to other nodes asynchronously. This implies that a committed change to the index will not immediately be accessible by searching threads on other nodes, but the gap in time is not longer than the time of a single RPC so this gap should not be measurable unless there is some form of congestion. Currently defaults to false as it's safer.
 * @param writeFileListAsync
 * @return the same building context to eventually create the Directory instance
 * @experimental
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writeFileListAsync</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteOperationsExecutor</MethodName>
            <MethodComment>/** 
 * Provides an Executor to handle delete operations in a background thread
 * @param executor
 * @return
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>executor</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>affinityLocationIntoSegment</MethodName>
            <MethodComment>/** 
 * When set to a positive integer, this will force a specific data distribution: the hashing function will resolve all keys used to store the various entries for the resulting index to be owned by the specified segment id. Use with caution, as this will obviously lead into a severely unbalanced distribution.
 * @param segmentId
 * @return
 */
</MethodComment>
            <ReturnType>BuildContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>