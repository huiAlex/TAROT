<Class>
    <Id>2918</Id>
    <Package>org.infinispan.persistence.sifs</Package>
    <ClassName>IndexNode</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>IndexNode  /** 
 * The recursive index structure. References to children are held in soft references, which allows JVM-handled caching and reduces the amount of reads required while evading OOMs if the index gets too big.
 * @author Radim Vansa &amp;lt;rvansa@redhat.com&amp;gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>HAS_LEAVES</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>HAS_NODES</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>INNER_NODE_HEADER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INNER_NODE_REFERENCE_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LEAF_NODE_REFERENCE_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RESERVED_SPACE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>segment</FieldName>
            <FieldType>Index.Segment</FieldType>
        </Field>
        <Field>
            <FieldName>prefix</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>keyParts</FieldName>
            <FieldType>byte[][]</FieldType>
        </Field>
        <Field>
            <FieldName>innerNodes</FieldName>
            <FieldType>InnerNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>leafNodes</FieldName>
            <FieldType>LeafNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>lock</FieldName>
            <FieldType>ReadWriteLock</FieldType>
        </Field>
        <Field>
            <FieldName>offset</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>contentLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>totalLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>occupiedSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>node</FieldName>
            <FieldType>IndexNode</FieldType>
        </Field>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>from</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>to</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>newNodes</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>newNodes</FieldName>
            <FieldType>IndexNode</FieldType>
        </Field>
        <Field>
            <FieldName>NOOP</FieldName>
            <FieldType>OverwriteHook</FieldType>
        </Field>
        <Field>
            <FieldName>reference</FieldName>
            <FieldType>SoftReference</FieldType>
        </Field>
        <Field>
            <FieldName>reference</FieldName>
            <FieldType>IndexNode</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_ARRAY</FieldName>
            <FieldType>LeafNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>keyReference</FieldName>
            <FieldType>SoftReference</FieldType>
        </Field>
        <Field>
            <FieldName>keyReference</FieldName>
            <FieldType>EntryRecord</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>IndexNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>occupiedSpace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ByteBuffer [buffer=loadBuffer(segment.getIndexFile(),offset,occupiedSpace)]</InnerVar>
                <InnerVar>byte [flags=buffer.get()]</InnerVar>
                <InnerVar>int [numKeyParts=buffer.getShort()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;get;[prefix]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadBuffer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ByteBuffer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexFile</ParamName>
                    <ParamType>FileChannel</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>occupiedSpace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ByteBuffer [buffer=ByteBuffer.allocate(occupiedSpace)]</InnerVar>
                <InnerVar>int [read=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;rewind;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IndexNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPrefix</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newKeyParts</ParamName>
                    <ParamType>byte[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newLeafNodes</ParamName>
                    <ParamType>LeafNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IndexNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPrefix</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newKeyParts</ParamName>
                    <ParamType>byte[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newInnerNodes</ParamName>
                    <ParamType>InnerNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexNode [indexNode=(IndexNode)o]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceContent</MethodName>
            <MethodComment>/** 
 * Can be called only from single writer thread (therefore the write lock guards only other readers)
 * @param other
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>store</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexSpace</ParamName>
                    <ParamType>Index.IndexSpace</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ByteBuffer [buffer=ByteBuffer.allocate(length())]</InnerVar>
                <InnerVar>byte [flags=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;putShort;[(short)prefix.length]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[prefix]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[flags]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)keyParts.length]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;flip;[]</InnerMethodInvoke>
                <InnerMethodInvoke>segment.getIndexFile();write;[buffer, offset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Path</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryRecord</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leafNode</ParamName>
                    <ParamType>LeafNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeService</ParamName>
                    <ParamType>TimeService</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryPosition</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leafNode</ParamName>
                    <ParamType>LeafNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeService</ParamName>
                    <ParamType>TimeService</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EntryRecord [hak=leafNode.loadHeaderAndKey(fileProvider)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leafNode</ParamName>
                    <ParamType>LeafNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeService</ParamName>
                    <ParamType>TimeService</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EntryRecord [hak=leafNode.loadHeaderAndKey(fileProvider)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leafNode</ParamName>
                    <ParamType>LeafNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeService</ParamName>
                    <ParamType>TimeService</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyOnLeaf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rootLock</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operation</ParamName>
                    <ParamType>ReadOperation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [attempts=0]</InnerVar>
                <InnerVar>ArrayList&lt;IndexNode&gt; [path=new ArrayList&lt;IndexNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>root</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overwriteHook</ParamName>
                    <ParamType>OverwriteHook</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordChange</ParamName>
                    <ParamType>RecordChange</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexNode [node=root]</InnerVar>
                <InnerVar>Stack&lt;Path&gt; [stack=new Stack&lt;Path&gt;()]</InnerVar>
                <InnerVar>IndexNode [copy=node.copyWith(key,file,offset,size,overwriteHook,recordChange)]</InnerVar>
                <InnerVar>Stack&lt;IndexNode&gt; [garbage=new Stack&lt;IndexNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>JoinSplitResult</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newNodes</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>manageLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>JoinSplitResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stack</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copy</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>garbage</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [from, to]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>join</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>middleKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [newPrefix=commonPrefix(left.prefix,right.prefix)]</InnerVar>
                <InnerVar>byte[][] [newKeyParts=new byte[left.keyParts.length + right.keyParts.length + 1][]]</InnerVar>
                <InnerVar>byte[] [rightmostKey]</InnerVar>
                <InnerVar>int [commonLength=Math.abs(compare(middleKey,rightmostKey))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;copyKeyParts;[left.keyParts, 0, newKeyParts, 0, left.keyParts.length, left.prefix, newPrefix]</InnerMethodInvoke>
                <InnerMethodInvoke>null;copyKeyParts;[right.keyParts, 0, newKeyParts, left.keyParts.length + 1, right.keyParts.length, right.prefix, newPrefix]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyWith</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldNodesFrom</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldNodesTo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newNodes</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InnerNode[] [newInnerNodes=new InnerNode[innerNodes.length + newNodes.size() - 1 - oldNodesTo + oldNodesFrom]]</InnerVar>
                <InnerVar>byte[][] [newKeys=new byte[newNodes.size() - 1][]]</InnerVar>
                <InnerVar>byte[] [newPrefix=prefix]</InnerVar>
                <InnerVar>byte[][] [newKeyParts=new byte[keyParts.length + newNodes.size() - 1 - oldNodesTo + oldNodesFrom][]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[innerNodes, 0, newInnerNodes, 0, oldNodesFrom]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[innerNodes, oldNodesTo + 1, newInnerNodes, oldNodesFrom + newNodes.size(), innerNodes.length - oldNodesTo - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;copyKeyParts;[keyParts, 0, newKeyParts, 0, oldNodesFrom, prefix, newPrefix]</InnerMethodInvoke>
                <InnerMethodInvoke>null;copyKeyParts;[keyParts, oldNodesTo, newKeyParts, oldNodesFrom + newKeys.length, keyParts.length - oldNodesTo, prefix, newPrefix]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftmostKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rightmostKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyWith</MethodName>
            <MethodComment>/** 
 * Called on the most bottom node
 * @param key
 * @param file
 * @param offset
 * @param recordChange
 * @return
 */
</MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overwriteHook</ParamName>
                    <ParamType>OverwriteHook</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordChange</ParamName>
                    <ParamType>RecordChange</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [newPrefix]</InnerVar>
                <InnerVar>byte[][] [newKeyParts]</InnerVar>
                <InnerVar>LeafNode[] [newLeafNodes]</InnerVar>
                <InnerVar>int [insertPart=getInsertionPoint(key)]</InnerVar>
                <InnerVar>LeafNode [oldLeafNode=leafNodes[insertPart]]</InnerVar>
                <InnerVar>short [numRecords=oldLeafNode.numRecords]</InnerVar>
                <InnerVar>EntryRecord [hak]</InnerVar>
                <InnerVar>int [keyComp=compare(hak.getKey(),key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInsertionPoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [comp=compare(prefix,key,prefix.length)]</InnerVar>
                <InnerVar>int [insertionPoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>split</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [headerLength=headerLength()]</InnerVar>
                <InnerVar>int [contentLength=contentLength()]</InnerVar>
                <InnerVar>int [maxLength=segment.getMaxNodeSize()]</InnerVar>
                <InnerVar>int [targetParts=contentLength / Math.max(maxLength - headerLength,1) + 1]</InnerVar>
                <InnerVar>int [targetLength=contentLength / targetParts + headerLength]</InnerVar>
                <InnerVar>List&lt;IndexNode&gt; [list=new ArrayList&lt;IndexNode&gt;()]</InnerVar>
                <InnerVar>int [childLength=innerNodes != null ? INNER_NODE_REFERENCE_SIZE : LEAF_NODE_REFERENCE_SIZE]</InnerVar>
                <InnerVar>byte[] [prefixExtension=keyParts[0]]</InnerVar>
                <InnerVar>int [currentLength=INNER_NODE_HEADER_SIZE + prefix.length + prefixExtension.length+ 2 * childLength + 2]</InnerVar>
                <InnerVar>int [nodeFrom=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>subNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newPrefixExtension</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>childFrom</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>childTo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[][] [newKeyParts=new byte[childTo - childFrom][]]</InnerVar>
                <InnerVar>byte[] [newPrefix=childFrom == childTo ? new byte[0] : concat(prefix,newPrefixExtension)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>concat</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>second</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [result=new byte[first.length + second.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[first, 0, result, 0, first.length]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[second, 0, result, first.length, second.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyKeyParts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>src</ParamName>
                    <ParamType>byte[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>srcIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dest</ParamName>
                    <ParamType>byte[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>destIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldPrefix</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>common</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findNewKeyPart</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldPrefix</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldKeyPart</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>common</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [newPart=new byte[oldKeyPart.length + oldPrefix.length - common.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[oldPrefix, common.length, newPart, 0, oldPrefix.length - common.length]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[oldKeyPart, 0, newPart, oldPrefix.length - common.length, oldKeyPart.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>substring</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>begin</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [sub=new byte[end - begin]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[key, begin, sub, 0, end - begin]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commonPrefix</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldPrefix</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i]</InnerVar>
                <InnerVar>byte[] [prefix=new byte[i]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>second</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>second</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>headerLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contentLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [sum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>length</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>emptyWithLeaves</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>emptyWithInnerNodes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>check</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldFile</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOverwritten</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>overwritten</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prevFile</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prevOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InnerNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InnerNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>IndexNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IndexNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>Index.Segment</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IndexNode [node]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LeafNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numRecords</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadHeaderAndKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryRecord</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeaderAndKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryRecord</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>FileProvider.Handle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EntryRecord [headerAndKey]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadRecord</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryRecord</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileProvider</ParamName>
                    <ParamType>FileProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeService</ParamName>
                    <ParamType>TimeService</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileProvider.Handle [handle=fileProvider.getFile(file)]</InnerVar>
                <InnerVar>int [readOffset=offset &lt; 0 ? ~offset : offset]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IndexNodeOutdatedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>IndexNodeOutdatedException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>message</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;['\n']</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>