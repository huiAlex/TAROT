<Class>
    <Id>3670</Id>
    <Package>org.infinispan.commands</Package>
    <ClassName>ReplicableCommand</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ReplicableCommand  /** 
 * The core of the command-based cache framework.  Commands correspond to specific areas of functionality in the cache, and can be replicated using the  {@link org.infinispan.remoting.rpc.RpcManager}
 * @author Mircea.Markus@jboss.com
 * @author Manik Surtani
 * @since 4.0
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>invokeAsync</MethodName>
            <MethodComment>/** 
 * Invoke the command asynchronously. &lt;p&gt; &lt;p&gt;This method replaces  {@link #perform(InvocationContext)} for remote execution.The default implementation and  {@link #perform(InvocationContext)} will be removed in future versions.&lt;/p&gt;
 * @since 9.0
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invoke</MethodName>
            <MethodComment>/** 
 * Invoke the command synchronously. &lt;p&gt; &lt;p&gt;This method is optional. Unless your command never blocks, please implement  {@link #invokeAsync()} instead.&lt;/p&gt;
 * @since 9.0
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>perform</MethodName>
            <MethodComment>/** 
 * Performs the primary function of the command.  Please see specific implementation classes for details on what is performed as well as return types. &lt;b&gt;Important&lt;/b&gt;: this method will be invoked at the end of interceptors chain. It should never be called directly from a custom interceptor.
 * @param ctx invocation context
 * @return arbitrary return value generated by performing this command
 * @throws Throwable in the event of problems.
 * @deprecated Since 9.0, split into {@link #invokeAsync()} and {@link VisitableCommand#perform(InvocationContext)}.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>InvocationContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCommandId</MethodName>
            <MethodComment>/** 
 * Used by marshallers to convert this command into an id for streaming.
 * @return the method id of this command.  This is compatible with pre-2.2.0 MethodCall ids.
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReturnValueExpected</MethodName>
            <MethodComment>/** 
 * If true, a return value will be provided when performed remotely.  Otherwise, a remote  {@link org.infinispan.remoting.responses.ResponseGenerator} may choose to simply return null to save on marshallingcosts.
 * @return true or false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSuccessful</MethodName>
            <MethodComment>/** 
 * If true, a return value will be marshalled as a  {@link org.infinispan.remoting.responses.SuccessfulResponse}, otherwise it will be marshalled as a  {@link org.infinispan.remoting.responses.UnsuccessfulResponse}.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canBlock</MethodName>
            <MethodComment>/** 
 * If true, the command is processed asynchronously in a thread provided by an Infinispan thread pool. Otherwise, the command is processed directly in the JGroups thread. &lt;p/&gt; This feature allows to avoid keep a JGroups thread busy that can originate discard of messages and retransmissions. So, the commands that can block (waiting for some state, acquiring locks, etc.) should return true.
 * @return {@code true} if the command can block/wait, {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment>/** 
 * Writes this instance to the  {@link ObjectOutput}.
 * @param output the stream.
 * @throws IOException if an error occurred during the I/O.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>output</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readFrom</MethodName>
            <MethodComment>/** 
 * Reads this instance from the stream written by  {@link #writeTo(ObjectOutput)}.
 * @param input the stream to read.
 * @throws IOException            if an error occurred during the I/O.
 * @throws ClassNotFoundException if it tries to load an undefined class.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOrigin</MethodName>
            <MethodComment>/** 
 * Sets the sender's  {@link Address}. &lt;p&gt; By default, it doesn't set anything. Implement this method if the sender's  {@link Address} is needed.
 * @param origin the sender's {@link Address}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>origin</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>