<Class>
    <Id>2431</Id>
    <Package>org.infinispan.commons.marshall</Package>
    <ClassName>StreamingMarshaller</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Marshaller</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StreamingMarshaller  /** 
 * A specialization of  {@link Marshaller} that supports streams.&lt;p/&gt; A single instance of any implementation is shared by multiple threads, so implementations &lt;i&gt;need&lt;/i&gt; to be threadsafe, and preferably immutable.
 * @author Manik Surtani
 * @author Galder Zamarre√±o
 * @since 4.0
 * @see Marshaller
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>startObjectOutput</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Create and open an ObjectOutput instance for the given output stream. This method should be used for opening data outputs when multiple objectToObjectStream() calls will be made before the stream is closed by calling finishObjectOutput().&lt;/p&gt; &lt;p&gt;This method also takes a boolean that represents whether this particular call to startObjectOutput() is reentrant or not. A call to startObjectOutput() should be marked reentrant whenever a 2nd or more calls to this method are made without having called finishObjectOutput() first. &lt;p&gt;To potentially speed up calling startObjectOutput multiple times in a non-reentrant way, i.e. startObjectOutput/finishObjectOutput...startObjectOutput/finishObjectOutput...etc, which is is the most common case, the StreamingMarshaller implementation could potentially use some mechanisms to speed up this startObjectOutput call. &lt;p&gt;On the other hand, when a call is reentrant, i.e. startObjectOutput/startObjectOutput(reentrant)...finishObjectOutput/finishObjectOutput, the StreamingMarshaller implementation might treat it differently. An example of reentrancy would be marshalling of  {@link MarshalledValue}. When sending or storing a MarshalledValue, a call to startObjectOutput() would occur so that the stream is open and following, a 2nd call could occur so that MarshalledValue's raw byte array version is calculated and sent across. This enables storing as binary on the receiver side which is performance gain. The StreamingMarshaller implementation could decide that it needs a separate ObjectOutput or similar for the 2nd call since it's aim is only to get the raw byte array version and the close finish with it.&lt;/p&gt;
 * @param os output stream
 * @param isReentrant whether the call is reentrant or not.
 * @param estimatedSize estimated size in bytes of the output. Only meant as a possible performance optimization.
 * @return ObjectOutput to write to
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ObjectOutput</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>os</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isReentrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>estimatedSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishObjectOutput</MethodName>
            <MethodComment>/** 
 * Finish using the given ObjectOutput. After opening a ObjectOutput and calling objectToObjectStream() multiple times, use this method to flush the data and close if necessary
 * @param oo data output that finished using
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oo</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objectToObjectStream</MethodName>
            <MethodComment>/** 
 * Marshalls an object to a given  {@link java.io.ObjectOutput}
 * @param obj object to marshall
 * @param out stream to marshall to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startObjectInput</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Create and open a new ObjectInput for the given input stream. This method should be used for opening data inputs when multiple objectFromObjectStream() calls will be made before the stream is closed.&lt;/p&gt; &lt;p&gt;This method also takes a boolean that represents whether this particular call to startObjectInput() is reentrant or not. A call to startObjectInput() should be marked reentrant whenever a 2nd or more calls to this method are made without having called finishObjectInput() first.&lt;/p&gt; &lt;p&gt;To potentially speed up calling startObjectInput multiple times in a non-reentrant way, i.e. startObjectInput/finishObjectInput...startObjectInput/finishObjectInput...etc, which is is the most common case, the StreamingMarshaller implementation could potentially use some mechanisms to speed up this startObjectInput call.&lt;/p&gt;
 * @param is input stream
 * @param isReentrant whether the call is reentrant or not.
 * @return ObjectInput to read from
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ObjectInput</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isReentrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishObjectInput</MethodName>
            <MethodComment>/** 
 * Finish using the given ObjectInput. After opening a ObjectInput and calling objectFromObjectStream() multiple times, use this method to flush the data and close if necessary
 * @param oi data input that finished using
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oi</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objectFromObjectStream</MethodName>
            <MethodComment>/** 
 * Unmarshalls an object from an  {@link java.io.ObjectInput}
 * @param in stream to unmarshall from
 * @throws IOException if unmarshalling cannot complete due to some I/O error
 * @throws ClassNotFoundException if the class of the object trying to unmarshall is unknown
 * @throws InterruptedException if the unmarshalling was interrupted. Clients should take this as a sign thatthe marshaller is no longer available, maybe due to shutdown, and so no more unmarshalling should be attempted.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objectFromInputStream</MethodName>
            <MethodComment>/** 
 * Unmarshall an object from an  {@link InputStream}
 * @param is stream to unmarshall from
 * @return the unmarshalled object instance
 * @throws IOException if unmarshalling cannot complete due to some I/O error
 * @throws ClassNotFoundException if the class of the object trying to unmarshall is unknown
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment>/** 
 * Stop the marshaller. Implementations of this method should clear up any cached data, or close any resources while marshalling/unmarshalling that have not been already closed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>