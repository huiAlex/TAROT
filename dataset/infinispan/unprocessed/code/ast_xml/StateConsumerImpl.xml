<Class>
    <Id>289</Id>
    <Package>org.infinispan.statetransfer</Package>
    <ClassName>StateConsumerImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>StateConsumer</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StateConsumerImpl  /** 
 * {@link StateConsumer} implementation.
 * @author anistor@redhat.com
 * @since 5.2
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>NO_STATE_TRANSFER_IN_PROGRESS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>STATE_TRANSFER_FLAGS</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>cache</FieldName>
            <FieldType>Cache</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferManager</FieldName>
            <FieldType>StateTransferManager</FieldType>
        </Field>
        <Field>
            <FieldName>localTopologyManager</FieldName>
            <FieldType>LocalTopologyManager</FieldType>
        </Field>
        <Field>
            <FieldName>cacheName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>configuration</FieldName>
            <FieldType>Configuration</FieldType>
        </Field>
        <Field>
            <FieldName>rpcManager</FieldName>
            <FieldType>RpcManager</FieldType>
        </Field>
        <Field>
            <FieldName>transactionManager</FieldName>
            <FieldType>TransactionManager</FieldType>
        </Field>
        <Field>
            <FieldName>commandsFactory</FieldName>
            <FieldType>CommandsFactory</FieldType>
        </Field>
        <Field>
            <FieldName>transactionTable</FieldName>
            <FieldType>TransactionTable</FieldType>
        </Field>
        <Field>
            <FieldName>dataContainer</FieldName>
            <FieldType>DataContainer</FieldType>
        </Field>
        <Field>
            <FieldName>dataContainer</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>persistenceManager</FieldName>
            <FieldType>PersistenceManager</FieldType>
        </Field>
        <Field>
            <FieldName>interceptorChain</FieldName>
            <FieldType>AsyncInterceptorChain</FieldType>
        </Field>
        <Field>
            <FieldName>icf</FieldName>
            <FieldType>InvocationContextFactory</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferLock</FieldName>
            <FieldType>StateTransferLock</FieldType>
        </Field>
        <Field>
            <FieldName>cacheNotifier</FieldName>
            <FieldType>CacheNotifier</FieldType>
        </Field>
        <Field>
            <FieldName>totalOrderManager</FieldName>
            <FieldType>TotalOrderManager</FieldType>
        </Field>
        <Field>
            <FieldName>remoteCommandsExecutor</FieldName>
            <FieldType>BlockingTaskAwareExecutorService</FieldType>
        </Field>
        <Field>
            <FieldName>timeout</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>isFetchEnabled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isTransactional</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isInvalidationMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isTotalOrder</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>keyInvalidationListener</FieldName>
            <FieldType>KeyInvalidationListener</FieldType>
        </Field>
        <Field>
            <FieldName>commitManager</FieldName>
            <FieldType>CommitManager</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferExecutor</FieldName>
            <FieldType>ExecutorService</FieldType>
        </Field>
        <Field>
            <FieldName>commandAckCollector</FieldName>
            <FieldType>CommandAckCollector</FieldType>
        </Field>
        <Field>
            <FieldName>triangleOrderManager</FieldName>
            <FieldType>TriangleOrderManager</FieldType>
        </Field>
        <Field>
            <FieldName>distributionManager</FieldName>
            <FieldType>DistributionManager</FieldType>
        </Field>
        <Field>
            <FieldName>keyPartitioner</FieldName>
            <FieldType>KeyPartitioner</FieldType>
        </Field>
        <Field>
            <FieldName>conflictManager</FieldName>
            <FieldType>InternalConflictManager</FieldType>
        </Field>
        <Field>
            <FieldName>cacheTopology</FieldName>
            <FieldType>CacheTopology</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferTopologyId</FieldName>
            <FieldType>AtomicInteger</FieldType>
        </Field>
        <Field>
            <FieldName>waitingForState</FieldName>
            <FieldType>AtomicBoolean</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferFuture</FieldName>
            <FieldType>CompletableFuture</FieldType>
        </Field>
        <Field>
            <FieldName>stateTransferFuture</FieldName>
            <FieldType>Void</FieldType>
        </Field>
        <Field>
            <FieldName>transferMapsLock</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>transfersBySource</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>transfersBySource</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>transfersBySegment</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>transfersBySegment</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>stateRequestExecutor</FieldName>
            <FieldType>LimitedExecutor</FieldType>
        </Field>
        <Field>
            <FieldName>ownsData</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>synchronousRpcOptions</FieldName>
            <FieldType>RpcOptions</FieldType>
        </Field>
        <Field>
            <FieldName>synchronousIgnoreLeaversRpcOptions</FieldName>
            <FieldType>RpcOptions</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>StateConsumerImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stopApplyingState</MethodName>
            <MethodComment>/** 
 * Stops applying incoming state. Also stops tracking updated keys. Should be called at the end of state transfer or when a ClearCommand is committed during state transfer.
 * @param topologyId
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>commitManager;stopTrack;[PUT_FOR_STATE_TRANSFER]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cache</ParamName>
                    <ParamType>Cache</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateTransferExecutor</ParamName>
                    <ParamType>ExecutorService</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateTransferManager</ParamName>
                    <ParamType>StateTransferManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localTopologyManager</ParamName>
                    <ParamType>LocalTopologyManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>interceptorChain</ParamName>
                    <ParamType>AsyncInterceptorChain</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>icf</ParamName>
                    <ParamType>InvocationContextFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>configuration</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rpcManager</ParamName>
                    <ParamType>RpcManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transactionManager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commandsFactory</ParamName>
                    <ParamType>CommandsFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>persistenceManager</ParamName>
                    <ParamType>PersistenceManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataContainer</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transactionTable</ParamName>
                    <ParamType>TransactionTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateTransferLock</ParamName>
                    <ParamType>StateTransferLock</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cacheNotifier</ParamName>
                    <ParamType>CacheNotifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>totalOrderManager</ParamName>
                    <ParamType>TotalOrderManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remoteCommandsExecutor</ParamName>
                    <ParamType>BlockingTaskAwareExecutorService</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commitManager</ParamName>
                    <ParamType>CommitManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commandAckCollector</ParamName>
                    <ParamType>CommandAckCollector</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triangleOrderManager</ParamName>
                    <ParamType>TriangleOrderManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distributionManager</ParamName>
                    <ParamType>DistributionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyPartitioner</ParamName>
                    <ParamType>KeyPartitioner</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conflictManager</ParamName>
                    <ParamType>InternalConflictManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasActiveTransfers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStateTransferInProgress</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStateTransferInProgressForKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DistributionInfo [distributionInfo=distributionManager.getCacheTopology().getDistribution(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ownsData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onTopologyUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheTopology</ParamName>
                    <ParamType>CacheTopology</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRebalance</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isMember=cacheTopology.getMembers().contains(rpcManager.getAddress())]</InnerVar>
                <InnerVar>boolean [startConflictResolution=!isRebalance &amp;&amp; cacheTopology.getPhase() == CacheTopology.Phase.CONFLICT_RESOLUTION]</InnerVar>
                <InnerVar>boolean [startRebalance=isRebalance]</InnerVar>
                <InnerVar>ConsistentHash [newWriteCh=cacheTopology.getWriteConsistentHash()]</InnerVar>
                <InnerVar>CacheTopology [previousCacheTopology=this.cacheTopology]</InnerVar>
                <InnerVar>ConsistentHash [previousReadCh=previousCacheTopology != null ? previousCacheTopology.getCurrentCH() : null]</InnerVar>
                <InnerVar>ConsistentHash [previousWriteCh=previousCacheTopology != null ? previousCacheTopology.getWriteConsistentHash() : null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;awaitTotalOrderTransactions;[cacheTopology, startRebalance]</InnerMethodInvoke>
                <InnerMethodInvoke>waitingForState;set;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>stateTransferLock;acquireExclusiveTopologyLock;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;beforeTopologyInstalled;[cacheTopology.getTopologyId(), startRebalance, previousWriteCh, newWriteCh]</InnerMethodInvoke>
                <InnerMethodInvoke>triangleOrderManager;updateCacheTopology;[cacheTopology]</InnerMethodInvoke>
                <InnerMethodInvoke>stateTransferLock;releaseExclusiveTopologyLock;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stateTransferLock;notifyTopologyInstalled;[cacheTopology.getTopologyId()]</InnerMethodInvoke>
                <InnerMethodInvoke>remoteCommandsExecutor;checkForReadyTasks;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beforeTopologyInstalled</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startRebalance</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previousWriteCh</ParamName>
                    <ParamType>ConsistentHash</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newWriteCh</ParamName>
                    <ParamType>ConsistentHash</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleSegments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startRebalance</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>addedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>removedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>awaitTotalOrderTransactions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheTopology</ParamName>
                    <ParamType>CacheTopology</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRebalance</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notifyEndOfStateTransferIfNeeded</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOwnedSegments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>consistentHash</ParamName>
                    <ParamType>ConsistentHash</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Address [address=rpcManager.getAddress()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pushTransfer</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateChunks</ParamName>
                    <ParamType>StateChunk</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConsistentHash [wCh=cacheTopology.getWriteConsistentHash()]</InnerVar>
                <InnerVar>int [rebalanceTopologyId=stateTransferTopologyId.get()]</InnerVar>
                <InnerVar>CountDownLatch [countDownLatch=new CountDownLatch(stateChunks.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyChunk</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mySegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateChunk</ParamName>
                    <ParamType>StateChunk</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InboundTransferTask [inboundTransfer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doApplyState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cacheEntries</ParamName>
                    <ParamType>InternalCacheEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [transactional=transactionManager != null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyTransactions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sender</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transactions</ParamName>
                    <ParamType>TransactionInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["Applying %d transactions for cache %s transferred from node %s", transactions.size(), cacheName, sender]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CacheMode [mode=configuration.clustering().cacheMode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCacheTopology</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CacheTopology</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setKeyInvalidationListener</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keyInvalidationListener</ParamName>
                    <ParamType>KeyInvalidationListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTransfers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Address&gt; [excludedSources=new HashSet&lt;&gt;()]</InnerVar>
                <InnerVar>Map&lt;Address,Set&lt;Integer&gt;&gt; [sources=new HashMap&lt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["Adding inbound state transfer for segments %s", segments]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findSources</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludedSources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SmallIntSet [segmentsWithoutSource=new SmallIntSet(configuration.clustering().hash().numSegments())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findSource</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Address</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludedSources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Address&gt; [owners=cacheTopology.getReadConsistentHash().locateOwnersForSegment(segmentId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requestTransactions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludedSources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [seenFailures=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findSources;[segments, sources, excludedSources]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClusterListeners</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DistributedCallable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topology</ParamName>
                    <ParamType>CacheTopology</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Response</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StateRequestCommand [cmd=commandsFactory.buildStateRequestCommand(StateRequestCommand.Type.GET_TRANSACTIONS,rpcManager.getAddress(),topologyId,segments)]</InnerVar>
                <InnerVar>Map&lt;Address,Response&gt; [responses=rpcManager.invokeRemotely(Collections.singleton(source),cmd,synchronousRpcOptions)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requestSegments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludedSources</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cancelTransfers</MethodName>
            <MethodComment>/** 
 * Cancel transfers for segments we no longer own.
 * @param removedSegments segments to be cancelled
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeStaleData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConcurrentHashSet&lt;Object&gt; [keysToRemove=new ConcurrentHashSet&lt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["Removing no longer owned entries for cache %s", cacheName]</InnerMethodInvoke>
                <InnerMethodInvoke>dataContainer;executeTask;[KeyFilter.ACCEPT_ALL_FILTER, (o,ice) -&gt; {
  Object key=ice.getKey();
  int keySegment=getSegment(key);
  if (removedSegments.contains(keySegment)) {
    keysToRemove.add(key);
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restartBrokenTransfers</MethodName>
            <MethodComment>/** 
 * Check if any of the existing transfers should be restarted from a different source because the initial source is no longer a member.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheTopology</ParamName>
                    <ParamType>CacheTopology</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>addedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Address&gt; [members=new HashSet&lt;&gt;(cacheTopology.getReadConsistentHash().getMembers())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTransfer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InboundTransferTask</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>Address</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentsFromSource</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InboundTransferTask [inboundTransfer]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stateRequestExecutor;executeAsync;[() -&gt; {
  CompletableFuture&lt;Void&gt; transferStarted=inboundTransfer.requestSegments();
  if (trace)   log.tracef("Waiting for inbound transfer to finish: %s",inboundTransfer);
  return transferStarted.whenComplete((aVoid,throwable) -&gt; onTaskCompletion(inboundTransfer));
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTransfer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inboundTransfer</ParamName>
                    <ParamType>InboundTransferTask</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>transfersBySource.computeIfAbsent(inboundTransfer.getSource(),s -&gt; new ArrayList&lt;&gt;());add;[inboundTransfer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeTransfer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inboundTransfer</ParamName>
                    <ParamType>InboundTransferTask</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [found=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onTaskCompletion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inboundTransfer</ParamName>
                    <ParamType>InboundTransferTask</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beforeInvalidation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedSegments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staleL1Segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>