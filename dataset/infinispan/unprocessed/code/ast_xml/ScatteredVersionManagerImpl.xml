<Class>
    <Id>1373</Id>
    <Package>org.infinispan.scattered.impl</Package>
    <ClassName>ScatteredVersionManagerImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ScatteredVersionManager</SuperInterface>
        <SuperInterface>K</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ScatteredVersionManagerImpl  /** 
 * @author Radim Vansa &amp;lt;rvansa@redhat.com&amp;gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>scheduledKeysSwapper</FieldName>
            <FieldType>AtomicReferenceFieldUpdater</FieldType>
        </Field>
        <Field>
            <FieldName>scheduledKeysSwapper</FieldName>
            <FieldType>ScatteredVersionManagerImpl</FieldType>
        </Field>
        <Field>
            <FieldName>removedKeysSwapper</FieldName>
            <FieldType>AtomicReferenceFieldUpdater</FieldType>
        </Field>
        <Field>
            <FieldName>removedKeysSwapper</FieldName>
            <FieldType>ScatteredVersionManagerImpl</FieldType>
        </Field>
        <Field>
            <FieldName>topologyIdUpdater</FieldName>
            <FieldType>AtomicIntegerFieldUpdater</FieldType>
        </Field>
        <Field>
            <FieldName>topologyIdUpdater</FieldName>
            <FieldType>ScatteredVersionManagerImpl</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>trace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>configuration</FieldName>
            <FieldType>Configuration</FieldType>
        </Field>
        <Field>
            <FieldName>invalidationBatchSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numSegments</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>componentRegistry</FieldName>
            <FieldType>ComponentRegistry</FieldType>
        </Field>
        <Field>
            <FieldName>executorService</FieldName>
            <FieldType>ExecutorService</FieldType>
        </Field>
        <Field>
            <FieldName>commandsFactory</FieldName>
            <FieldType>CommandsFactory</FieldType>
        </Field>
        <Field>
            <FieldName>rpcManager</FieldName>
            <FieldType>RpcManager</FieldType>
        </Field>
        <Field>
            <FieldName>dataContainer</FieldName>
            <FieldType>DataContainer</FieldType>
        </Field>
        <Field>
            <FieldName>dataContainer</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>syncIgnoreLeavers</FieldName>
            <FieldType>RpcOptions</FieldType>
        </Field>
        <Field>
            <FieldName>persistenceManager</FieldName>
            <FieldType>PersistenceManager</FieldType>
        </Field>
        <Field>
            <FieldName>stateConsumer</FieldName>
            <FieldType>StateConsumer</FieldType>
        </Field>
        <Field>
            <FieldName>clusterTopologyManager</FieldName>
            <FieldType>ClusterTopologyManager</FieldType>
        </Field>
        <Field>
            <FieldName>orderedUpdatesManager</FieldName>
            <FieldType>OrderedUpdatesManager</FieldType>
        </Field>
        <Field>
            <FieldName>preloadedTopologyId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>topologyId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>segmentStates</FieldName>
            <FieldType>AtomicReferenceArray</FieldType>
        </Field>
        <Field>
            <FieldName>segmentStates</FieldName>
            <FieldType>SegmentState</FieldType>
        </Field>
        <Field>
            <FieldName>blockedFutures</FieldName>
            <FieldType>AtomicReferenceArray</FieldType>
        </Field>
        <Field>
            <FieldName>blockedFutures</FieldName>
            <FieldType>CompletableFuture&lt;Void&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>segmentVersions</FieldName>
            <FieldType>AtomicLongArray</FieldType>
        </Field>
        <Field>
            <FieldName>ownerTopologyIds</FieldName>
            <FieldType>AtomicIntegerArray</FieldType>
        </Field>
        <Field>
            <FieldName>scheduledKeys</FieldName>
            <FieldType>ConcurrentMap</FieldType>
        </Field>
        <Field>
            <FieldName>scheduledKeys</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>removedKeys</FieldName>
            <FieldType>ConcurrentMap</FieldType>
        </Field>
        <Field>
            <FieldName>removedKeys</FieldName>
            <FieldType>K</FieldType>
        </Field>
        <Field>
            <FieldName>transferringValues</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>valuesTopology</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>valuesFuture</FieldName>
            <FieldType>CompletableFuture</FieldType>
        </Field>
        <Field>
            <FieldName>valuesFuture</FieldName>
            <FieldType>Void</FieldType>
        </Field>
        <Field>
            <FieldName>valuesLock</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>topologyId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>version</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>removal</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>configuration</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>componentRegistry</ParamName>
                    <ParamType>ComponentRegistry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executorService</ParamName>
                    <ParamType>ExecutorService</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commandsFactory</ParamName>
                    <ParamType>CommandsFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rpcManager</ParamName>
                    <ParamType>RpcManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataContainer</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>persistenceManager</ParamName>
                    <ParamType>PersistenceManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stateConsumer</ParamName>
                    <ParamType>StateConsumer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>clusterTopologyManager</ParamName>
                    <ParamType>ClusterTopologyManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderedUpdatesManager</ParamName>
                    <ParamType>OrderedUpdatesManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>start</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CacheTopology [cacheTopology=stateConsumer.getCacheTopology()]</InnerVar>
                <InnerVar>ConsistentHash [consistentHash=cacheTopology == null ? null : cacheTopology.getCurrentCH()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;printTable;[]</InnerMethodInvoke>
                <InnerMethodInvoke>configuration.clustering().attributes().attribute(ClusteringConfiguration.REMOTE_TIMEOUT);addListener;[((a,o) -&gt; initRpcOptions())]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initRpcOptions;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initRpcOptions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initTopologyId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AtomicInteger [maxTopologyId=new AtomicInteger(preloadedTopologyId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>persistenceManager;processOnAllStores;[new WithinThreadExecutor(), KeyFilter.ACCEPT_ALL_FILTER, (marshalledEntry,taskContext) -&gt; {
  InternalMetadata metadata=marshalledEntry.getMetadata();
  if (metadata != null) {
    EntryVersion entryVersion=metadata.version();
    if (entryVersion instanceof SimpleClusteredVersion) {
      int entryTopologyId=((SimpleClusteredVersion)entryVersion).topologyId;
      if (maxTopologyId.get() &lt; entryTopologyId) {
        maxTopologyId.updateAndGet(current -&gt; Math.max(current,entryTopologyId));
      }
    }
  }
}
, false, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;trace;["Stopping " + this + " on "+ rpcManager.getAddress()]</InnerMethodInvoke>
                <InnerMethodInvoke>log;trace;["Stopped " + this + " on "+ rpcManager.getAddress()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementVersion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EntryVersion</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>scheduleKeyInvalidation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>EntryVersion</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>removal</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConcurrentMap&lt;K,InvalidationInfo&gt; [scheduledKeys]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startFlush</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ConcurrentMap&lt;K,InvalidationInfo&gt; [scheduledKeys=this.scheduledKeys]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ownerTopologyIds;set;[segment, topologyId]</InnerMethodInvoke>
                <InnerMethodInvoke>segmentVersions;set;[segment, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>blockedFutures;set;[segment, new CompletableFuture&lt;&gt;()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unregisterSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SegmentState [previous=segmentStates.getAndSet(segment,SegmentState.NOT_OWNED)]</InnerVar>
                <InnerVar>CompletableFuture&lt;Void&gt; [blockedFuture=blockedFutures.get(segment)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isVersionActual</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>EntryVersion</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SimpleClusteredVersion [clusteredVersion=(SimpleClusteredVersion)version]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notifyKeyTransferFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expectValues</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cancelled</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SegmentState [update]</InnerVar>
                <InnerVar>SegmentState [previous=segmentStates.getAndSet(segment,update)]</InnerVar>
                <InnerVar>CompletableFuture&lt;Void&gt; [blockedFuture=blockedFutures.get(segment)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSegmentState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SegmentState</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValuesTransferTopology</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;tracef;["Node will transfer value for topology %d", topologyId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notifyValueTransferFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debugf;["Node %s received values for all segments in topology %d", rpcManager.getAddress(), topologyId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBlockingFuture</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTopologyId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [currentTopologyId=this.topologyId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatePreloadedEntryVersion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>EntryVersion</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>valuesFuture</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOwnedSegments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startKeyTransfer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder("Segments for node ").append(rpcManager.getAddress()).append(':')]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debug;[sb.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sorted</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segments</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Integer[] [array=segments.toArray(new Integer[segments.size()])]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Arrays;sort;[array]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tryRegularInvalidations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scheduledKeys</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>force</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>executorService;execute;[() -&gt; {
  int numKeys=scheduledKeys.size();
  Object[] keys=new Object[numKeys];
  int[] topologyIds=new int[numKeys];
  long[] versions=new long[numKeys];
  boolean[] isRemoved=new boolean[numKeys];
  int numRemoved=0;
  int i=0;
  for (  Map.Entry&lt;K,InvalidationInfo&gt; entry : scheduledKeys.entrySet()) {
    keys[i]=entry.getKey();
    topologyIds[i]=entry.getValue().topologyId;
    versions[i]=entry.getValue().version;
    if (isRemoved[i]=entry.getValue().removal) {
      numRemoved++;
    }
    if (++i &gt; numKeys) {
      numKeys=scheduledKeys.size();
      keys=Arrays.copyOf(keys,numKeys);
      topologyIds=Arrays.copyOf(topologyIds,numKeys);
      versions=Arrays.copyOf(versions,numKeys);
      isRemoved=Arrays.copyOf(isRemoved,numKeys);
    }
  }
  InvalidateVersionsCommand command=commandsFactory.buildInvalidateVersionsCommand(-1,keys,topologyIds,versions,false);
  sendRegularInvalidations(command,keys,topologyIds,versions,numRemoved,isRemoved,force);
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendRegularInvalidations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>InvalidateVersionsCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topologyIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>versions</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numRemoved</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRemoved</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>force</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompletableFuture&lt;Map&lt;Address,Response&gt;&gt; [future=rpcManager.invokeRemotelyAsync(null,command,syncIgnoreLeavers)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>future;whenComplete;[(r,t) -&gt; {
  if (t != null) {
    log.failedInvalidatingRemoteCache(t);
    sendRegularInvalidations(command,keys,topologyIds,versions,numRemoved,isRemoved,force);
  }
 else   if (numRemoved &gt; 0 || force) {
    regularInvalidationFinished(keys,topologyIds,versions,isRemoved,force);
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>regularInvalidationFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topologyIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>versions</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRemoved</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>force</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConcurrentMap&lt;K,InvalidationInfo&gt; [removedKeys]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tryRemovedInvalidations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedKeys</ParamName>
                    <ParamType>K</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendRemoveInvalidations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removeCommand</ParamName>
                    <ParamType>InvalidateVersionsCommand</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rpcManager.invokeRemotelyAsync(null,removeCommand,syncIgnoreLeavers);whenComplete;[(r,t) -&gt; {
  if (t != null) {
    log.failedInvalidatingRemoteCache(t);
    sendRemoveInvalidations(removeCommand);
  }
 else {
    removeInvalidationsFinished();
  }
}
]</InnerMethodInvoke>
                <InnerMethodInvoke>removeCommand;init;[dataContainer, orderedUpdatesManager, null, null]</InnerMethodInvoke>
                <InnerMethodInvoke>removeCommand;invokeAsync;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeInvalidationsFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearInvalidations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scheduledKeysSwapper;set;[this, new ConcurrentHashMap&lt;&gt;(invalidationBatchSize)]</InnerMethodInvoke>
                <InnerMethodInvoke>removedKeysSwapper;set;[this, new ConcurrentHashMap&lt;&gt;(invalidationBatchSize)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InvalidationInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>SimpleClusteredVersion</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>removal</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InvalidationInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topologyId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>