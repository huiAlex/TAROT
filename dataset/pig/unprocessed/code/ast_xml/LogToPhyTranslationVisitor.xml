<Class>
    <Id>353</Id>
    <Package>org.apache.pig.newplan.logical.relational</Package>
    <ClassName>LogToPhyTranslationVisitor</ClassName>
    <SuperClass>LogicalRelationalNodesVisitor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>logToPhyMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>logToPhyMap</FieldName>
            <FieldType>Operator</FieldType>
        </Field>
        <Field>
            <FieldName>currentPlans</FieldName>
            <FieldType>Deque</FieldType>
        </Field>
        <Field>
            <FieldName>currentPlans</FieldName>
            <FieldType>PhysicalPlan</FieldType>
        </Field>
        <Field>
            <FieldName>currentPlan</FieldName>
            <FieldType>PhysicalPlan</FieldType>
        </Field>
        <Field>
            <FieldName>nodeGen</FieldName>
            <FieldType>NodeIdGenerator</FieldType>
        </Field>
        <Field>
            <FieldName>pc</FieldName>
            <FieldType>PigContext</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>LogToPhyTranslationVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPigContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>PigContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogToPhyMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Operator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPhysicalPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PhysicalPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loLoad</ParamName>
                    <ParamType>LOLoad</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POLoad [load=new POLoad(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loLoad.getLoadFunc())]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=loLoad.getPlan().getPredecessors(loLoad)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>load;addOriginalLocation;[loLoad.getAlias(), loLoad.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setLFile;[loLoad.getFileSpec()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setPc;[pc]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setSignature;[loLoad.getSignature()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setLimit;[loLoad.getLimit()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setIsTmpLoad;[loLoad.isTmpLoad()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setCacheFiles;[loLoad.getLoadFunc().getCacheFiles()]</InnerMethodInvoke>
                <InnerMethodInvoke>load;setShipFiles;[loLoad.getLoadFunc().getShipFiles()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[load]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loLoad, load]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loNative</ParamName>
                    <ParamType>LONative</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>PONative [poNative=new PONative(new OperatorKey(scope,nodeGen.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=loNative.getPlan().getPredecessors(loNative)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poNative;addOriginalLocation;[loNative.getAlias(), loNative.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poNative;setNativeMRjar;[loNative.getNativeMRJar()]</InnerMethodInvoke>
                <InnerMethodInvoke>poNative;setParams;[loNative.getParams()]</InnerMethodInvoke>
                <InnerMethodInvoke>poNative;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loNative, poNative]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poNative]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>LOFilter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POFilter [poFilter=new POFilter(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),filter.getRequestedParallelism())]</InnerVar>
                <InnerVar>PlanWalker [childWalker=new ReverseDependencyOrderWalkerWOSeenChk(filter.getFilterPlan())]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=filter.getPlan().getPredecessors(filter)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poFilter;addOriginalLocation;[filter.getAlias(), filter.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poFilter;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poFilter]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[filter, poFilter]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlans;push;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>null;pushWalker;[childWalker]</InnerMethodInvoke>
                <InnerMethodInvoke>currentWalker;walk;[new ExpToPhyTranslationVisitor(currentWalker.getPlan(),childWalker,filter,currentPlan,logToPhyMap)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;popWalker;[]</InnerMethodInvoke>
                <InnerMethodInvoke>poFilter;setPlan;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>null;translateSoftLinks;[filter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sort</ParamName>
                    <ParamType>LOSort</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>List&lt;LogicalExpressionPlan&gt; [logPlans=sort.getSortColPlans()]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [sortPlans=new ArrayList&lt;PhysicalPlan&gt;(logPlans.size())]</InnerVar>
                <InnerVar>POSort [poSort]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=sort.getPlan().getPredecessors(sort)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentPlans;push;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>poSort;addOriginalLocation;[sort.getAlias(), sort.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poSort;setLimit;[sort.getLimit()]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[sort, poSort]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poSort]</InnerMethodInvoke>
                <InnerMethodInvoke>poSort;setResultType;[DataType.BAG]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * Transformation from Logical to Physical Plan involves the following steps: First, it is generated a random number which will link a POCounter within a PORank. On this way, avoiding possible collisions on parallel rank operations. Then, if it is row number mode: &lt;pre&gt; In case of a RANK operation (row number mode), are used two steps: 1.- Each tuple is counted sequentially on each mapper, and are produced global counters 2.- Global counters are gathered and summed, each tuple calls to the respective counter value in order to calculate the corresponding rank value. &lt;/pre&gt; or not: &lt;pre&gt; In case of a RANK BY operation, then are necessary five steps: 1.- Group by the fields involved on the rank operation: POPackage 2.- In case of multi-fields, the key (group field) is flatten: POForEach 3.- Sort operation by the fields available after flattening: POSort 4.- Each group is sequentially counted on each mapper through a global counter: POCounter 5.- Global counters are summed and passed to the rank operation: PORank &lt;/pre&gt;
 * @param loRank describe if the rank operation is on a row number modeor is rank by (dense or not)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loRank</ParamName>
                    <ParamType>LORank</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>PORank [poRank]</InnerVar>
                <InnerVar>POCounter [poCounter]</InnerVar>
                <InnerVar>Random [randomGenerator=new Random()]</InnerVar>
                <InnerVar>Long [operationID=Math.abs(randomGenerator.nextLong())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cross</ParamName>
                    <ParamType>LOCross</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputs=cross.getPlan().getPredecessors(cross)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>LOStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POStream [poStream=new POStream(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),stream.getExecutableManager(),stream.getStreamingCommand(),this.pc.getProperties())]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=stream.getPlan().getPredecessors(stream)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poStream;addOriginalLocation;[stream.getAlias(), stream.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poStream]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[stream, poStream]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>load</ParamName>
                    <ParamType>LOInnerLoad</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POProject [exprOp=new POProject(new OperatorKey(scope,nodeGen.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>LogicalSchema [s=load.getSchema()]</InnerVar>
                <InnerVar>ProjectExpression [proj=load.getProjection()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logToPhyMap;put;[load, exprOp]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[exprOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>foreach</ParamName>
                    <ParamType>LOForEach</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [innerPlans=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>org.apache.pig.newplan.logical.relational.LogicalPlan [inner=foreach.getInnerPlan()]</InnerVar>
                <InnerVar>LOGenerate [gen=(LOGenerate)inner.getSinks().get(0)]</InnerVar>
                <InnerVar>List&lt;LogicalExpressionPlan&gt; [exps=gen.getOutputPlans()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [preds=inner.getPredecessors(gen)]</InnerVar>
                <InnerVar>boolean[] [flatten=gen.getFlattenFlags()]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flattenList=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>LogicalSchema [logSchema=foreach.getSchema()]</InnerVar>
                <InnerVar>Schema [schema=null]</InnerVar>
                <InnerVar>POForEach [poFE=new POForEach(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),foreach.getRequestedParallelism(),innerPlans,flattenList,schema)]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=foreach.getPlan().getPredecessors(foreach)]</InnerVar>
                <InnerVar>PhysicalOperator [from=logToPhyMap.get(op.get(0))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentPlans;push;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>poFE;addOriginalLocation;[foreach.getAlias(), foreach.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poFE;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[foreach, poFE]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poFE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;translateSoftLinks;[foreach]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>translateExpressionPlans</MethodName>
            <MethodComment>/** 
 * This function takes in a List of LogicalExpressionPlan and converts them to a list of PhysicalPlans
 * @param plans
 * @return
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>PhysicalPlan</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loj</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>plans</ParamName>
                    <ParamType>LogicalExpressionPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;PhysicalPlan&gt; [exprPlans=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentPlans;push;[currentPlan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loStore</ParamName>
                    <ParamType>LOStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POStore [store=new POStore(new OperatorKey(scope,nodeGen.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=loStore.getPlan().getPredecessors(loStore)]</InnerVar>
                <InnerVar>PhysicalOperator [from=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>store;addOriginalLocation;[loStore.getAlias(), loStore.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setSFile;[loStore.getOutputSpec()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setInputSpec;[loStore.getInputSpec()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setSignature;[loStore.getSignature()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setSortInfo;[loStore.getSortInfo()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setIsTmpStore;[loStore.isTmpStore()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setStoreFunc;[loStore.getStoreFunc()]</InnerMethodInvoke>
                <InnerMethodInvoke>store;setSchema;[Util.translateSchema(loStore.getSchema())]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[store]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loStore, store]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cg</ParamName>
                    <ParamType>LOCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;translateSoftLinks;[cg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>translateCollectedCogroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cg</ParamName>
                    <ParamType>LOCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalRelationalOperator [pred=(LogicalRelationalOperator)plan.getPredecessors(cg).get(0)]</InnerVar>
                <InnerVar>List&lt;LogicalExpressionPlan&gt; [exprPlans=cg.getExpressionPlans().get(0)]</InnerVar>
                <InnerVar>POCollectedGroup [physOp=new POCollectedGroup(new OperatorKey(DEFAULT_SCOPE,nodeGen.getNextNodeId(DEFAULT_SCOPE)))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [pExprPlans=translateExpressionPlans(cg,exprPlans)]</InnerVar>
                <InnerVar>Byte [type=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>physOp;addOriginalLocation;[cg.getAlias(), cg.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>physOp;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[physOp]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[cg, physOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compileToMergeCogrp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>POMergeCogroup</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>relationalOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>innerPlans</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [inputs=relationalOp.getPlan().getPredecessors(relationalOp)]</InnerVar>
                <InnerVar>POLocalRearrange[] [innerLRs=new POLocalRearrange[inputs.size()]]</InnerVar>
                <InnerVar>int [count=0]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [inpPOs=new ArrayList&lt;PhysicalOperator&gt;(inputs.size())]</InnerVar>
                <InnerVar>POMergeCogroup [poCogrp=new POMergeCogroup(new OperatorKey(DEFAULT_SCOPE,nodeGen.getNextNodeId(DEFAULT_SCOPE)),inpPOs,innerLRs,relationalOp.getRequestedParallelism())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>translateMergeCogroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cg</ParamName>
                    <ParamType>LOCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [inputs=cg.getPlan().getPredecessors(cg)]</InnerVar>
                <InnerVar>MapSideMergeValidator [validator=new MapSideMergeValidator()]</InnerVar>
                <InnerVar>POMergeCogroup [poCogrp=compileToMergeCogrp(cg,cg.getExpressionPlans())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>validator;validateMapSideMerge;[inputs, cg.getPlan()]</InnerMethodInvoke>
                <InnerMethodInvoke>poCogrp;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>poCogrp;addOriginalLocation;[cg.getAlias(), cg.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poCogrp]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[cg, poCogrp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateMergeCogrp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>innerFlags</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loj</ParamName>
                    <ParamType>LOJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputs=loj.getPlan().getPredecessors(loj)]</InnerVar>
                <InnerVar>MultiMap&lt;PhysicalOperator,PhysicalPlan&gt; [joinPlans=new LinkedMultiMap&lt;PhysicalOperator,PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>List&lt;List&lt;PhysicalPlan&gt;&gt; [ppLists=new ArrayList&lt;List&lt;PhysicalPlan&gt;&gt;()]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [inp=new ArrayList&lt;PhysicalOperator&gt;()]</InnerVar>
                <InnerVar>List&lt;List&lt;Byte&gt;&gt; [keyTypes=new ArrayList&lt;List&lt;Byte&gt;&gt;()]</InnerVar>
                <InnerVar>boolean[] [innerFlags=loj.getInnerFlags()]</InnerVar>
                <InnerVar>String [alias=loj.getAlias()]</InnerVar>
                <InnerVar>SourceLocation [location=loj.getLocation()]</InnerVar>
                <InnerVar>int [parallel=loj.getRequestedParallelism()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;translateSoftLinks;[loj]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compileToLR_GR_PackTrio</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>POPackage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>relationalOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>customPartitioner</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>innerFlags</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>innerPlans</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>POGlobalRearrange [poGlobal=new POGlobalRearrange(new OperatorKey(DEFAULT_SCOPE,nodeGen.getNextNodeId(DEFAULT_SCOPE)),relationalOp.getRequestedParallelism())]</InnerVar>
                <InnerVar>POPackage [poPackage=new POPackage(new OperatorKey(DEFAULT_SCOPE,nodeGen.getNextNodeId(DEFAULT_SCOPE)),relationalOp.getRequestedParallelism())]</InnerVar>
                <InnerVar>int [count=0]</InnerVar>
                <InnerVar>Byte [type=null]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputs=relationalOp.getPlan().getPredecessors(relationalOp)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poGlobal;addOriginalLocation;[relationalOp.getAlias(), relationalOp.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poGlobal;setCustomPartitioner;[customPartitioner]</InnerMethodInvoke>
                <InnerMethodInvoke>poPackage;addOriginalLocation;[relationalOp.getAlias(), relationalOp.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poGlobal]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poPackage]</InnerMethodInvoke>
                <InnerMethodInvoke>poPackage.getPkgr();setKeyType;[type]</InnerMethodInvoke>
                <InnerMethodInvoke>poPackage;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>poPackage;setNumInps;[count]</InnerMethodInvoke>
                <InnerMethodInvoke>poPackage.getPkgr();setInner;[innerFlags]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compileFE4Flattening</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>POForEach</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>innerFlags</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scope</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parallel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>SourceLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputs</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;PhysicalPlan&gt; [fePlans=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flattenLst=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>POForEach [fe]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loUnion</ParamName>
                    <ParamType>LOUnion</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POUnion [physOp=new POUnion(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loUnion.getRequestedParallelism())]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [ops=loUnion.getPlan().getPredecessors(loUnion)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>physOp;addOriginalLocation;[loUnion.getAlias(), loUnion.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[physOp]</InnerMethodInvoke>
                <InnerMethodInvoke>physOp;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loUnion, physOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loDistinct</ParamName>
                    <ParamType>LODistinct</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>PODistinct [physOp=new PODistinct(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loDistinct.getRequestedParallelism())]</InnerVar>
                <InnerVar>Operator [op=loDistinct.getPlan().getPredecessors(loDistinct).get(0)]</InnerVar>
                <InnerVar>PhysicalOperator [from=logToPhyMap.get(op)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>physOp;setCustomPartitioner;[loDistinct.getCustomPartitioner()]</InnerMethodInvoke>
                <InnerMethodInvoke>physOp;addOriginalLocation;[loDistinct.getAlias(), loDistinct.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[physOp]</InnerMethodInvoke>
                <InnerMethodInvoke>physOp;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loDistinct, physOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loLimit</ParamName>
                    <ParamType>LOLimit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POLimit [poLimit=new POLimit(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loLimit.getRequestedParallelism())]</InnerVar>
                <InnerVar>Operator [op=loLimit.getPlan().getPredecessors(loLimit).get(0)]</InnerVar>
                <InnerVar>PhysicalOperator [from=logToPhyMap.get(op)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poLimit;setLimit;[loLimit.getLimit()]</InnerMethodInvoke>
                <InnerMethodInvoke>poLimit;addOriginalLocation;[loLimit.getAlias(), loLimit.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poLimit;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poLimit]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loLimit, poLimit]</InnerMethodInvoke>
                <InnerMethodInvoke>null;translateSoftLinks;[loLimit]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loSplit</ParamName>
                    <ParamType>LOSplit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POSplit [physOp=new POSplit(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loSplit.getRequestedParallelism())]</InnerVar>
                <InnerVar>FileSpec [splStrFile]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=loSplit.getPlan().getPredecessors(loSplit)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>physOp;addOriginalLocation;[loSplit.getAlias(), loSplit.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>physOp;setSplitStore;[splStrFile]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loSplit, physOp]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[physOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loSplitOutput</ParamName>
                    <ParamType>LOSplitOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [scope=DEFAULT_SCOPE]</InnerVar>
                <InnerVar>POFilter [poFilter=new POFilter(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loSplitOutput.getRequestedParallelism())]</InnerVar>
                <InnerVar>PlanWalker [childWalker=new ReverseDependencyOrderWalkerWOSeenChk(loSplitOutput.getFilterPlan())]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [op=loSplitOutput.getPlan().getPredecessors(loSplitOutput)]</InnerVar>
                <InnerVar>PhysicalOperator [from]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>poFilter;addOriginalLocation;[loSplitOutput.getAlias(), loSplitOutput.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>poFilter;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlan;add;[poFilter]</InnerMethodInvoke>
                <InnerMethodInvoke>logToPhyMap;put;[loSplitOutput, poFilter]</InnerMethodInvoke>
                <InnerMethodInvoke>currentPlans;push;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>null;pushWalker;[childWalker]</InnerMethodInvoke>
                <InnerMethodInvoke>currentWalker;walk;[new ExpToPhyTranslationVisitor(currentWalker.getPlan(),childWalker,loSplitOutput,currentPlan,logToPhyMap)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;popWalker;[]</InnerMethodInvoke>
                <InnerMethodInvoke>poFilter;setPlan;[currentPlan]</InnerMethodInvoke>
                <InnerMethodInvoke>null;translateSoftLinks;[loSplitOutput]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateWithEmptyBagCheck</MethodName>
            <MethodComment>/** 
 * updates plan with check for empty bag and if bag is empty to flatten a bag with as many null's as dictated by the schema
 * @param fePlan the plan to update
 * @param joinInput the relation for which the corresponding bag is being checked
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fePlan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinInput</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalSchema [inputSchema=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>CompilerUtils;addEmptyBagOuterJoin;[fePlan, Util.translateSchema(inputSchema), false, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>translateSoftLinks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [preds=op.getPlan().getSoftLinkPredecessors(op)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>