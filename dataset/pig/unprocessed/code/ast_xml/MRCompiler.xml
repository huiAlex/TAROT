<Class>
    <Id>15</Id>
    <Package>org.apache.pig.backend.hadoop.executionengine.mapReduceLayer</Package>
    <ClassName>MRCompiler</ClassName>
    <SuperClass>PhyPlanVisitor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MRCompiler  /** 
 * The compiler that compiles a given physical plan into a DAG of MapReduce operators which can then be converted into the JobControl structure. Is implemented as a visitor of the PhysicalPlan it is compiling. Currently supports all operators except the MR Sort operator Uses a predecessor based depth first traversal. To compile an operator, first compiles the predecessors into MapReduce Operators and tries to merge the current operator into one of them. The goal being to keep the number of MROpers to a minimum. It also merges multiple Map jobs, created by compiling the inputs individually, into a single job. Here a new map job is created and then the contents of the previous map plans are added. However, any other state that was in the previous map plans, should be manually moved over. So, if you are adding something new take care about this. Ex of this is in requestedParallelism Only in case of blocking operators and splits, a new MapReduce operator is started using a store-load combination to connect the two operators. Whenever this happens care is taken to add the MROper into the MRPlan and connect it appropriately.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>pigContext</FieldName>
            <FieldType>PigContext</FieldType>
        </Field>
        <Field>
            <FieldName>plan</FieldName>
            <FieldType>PhysicalPlan</FieldType>
        </Field>
        <Field>
            <FieldName>MRPlan</FieldName>
            <FieldType>MROperPlan</FieldType>
        </Field>
        <Field>
            <FieldName>curMROp</FieldName>
            <FieldType>MapReduceOper</FieldType>
        </Field>
        <Field>
            <FieldName>compiledInputs</FieldName>
            <FieldType>MapReduceOper[]</FieldType>
        </Field>
        <Field>
            <FieldName>splitsSeen</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>splitsSeen</FieldName>
            <FieldType>OperatorKey</FieldType>
        </Field>
        <Field>
            <FieldName>nig</FieldName>
            <FieldType>NodeIdGenerator</FieldType>
        </Field>
        <Field>
            <FieldName>scope</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>udfFinder</FieldName>
            <FieldType>UDFFinder</FieldType>
        </Field>
        <Field>
            <FieldName>messageCollector</FieldName>
            <FieldType>CompilationMessageCollector</FieldType>
        </Field>
        <Field>
            <FieldName>phyToMROpMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>phyToMROpMap</FieldName>
            <FieldType>PhysicalOperator</FieldType>
        </Field>
        <Field>
            <FieldName>USER_COMPARATOR_MARKER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>FILE_CONCATENATION_THRESHOLD</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>OPTIMISTIC_FILE_CONCATENATION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>fileConcatenationThreshold</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>optimisticFileConcatenation</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>chunkSize</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>keyType</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>newSpec</FieldName>
            <FieldType>FileSpec</FieldType>
        </Field>
        <Field>
            <FieldName>oldSpec</FieldName>
            <FieldType>FileSpec</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MRCompiler</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MRCompilerException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MRCompiler</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pigContext</ParamName>
                    <ParamType>PigContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;PhysicalOperator&gt; [roots=plan.getRoots()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>LOG;info;["File concatenation threshold: " + fileConcatenationThreshold + " optimistic? "+ optimisticFileConcatenation]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MRCompilerException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>aggregateScalarsFiles</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;MapReduceOper&gt; [mrOpList=new ArrayList&lt;MapReduceOper&gt;()]</InnerVar>
                <InnerVar>Configuration [conf=ConfigurationUtil.toConfiguration(pigContext.getProperties())]</InnerVar>
                <InnerVar>boolean [combinable=!conf.getBoolean("pig.noSplitCombination",false)]</InnerVar>
                <InnerVar>Set&lt;FileSpec&gt; [seen=new HashSet&lt;FileSpec&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMRPlan</MethodName>
            <MethodComment>/** 
 * Used to get the compiled plan
 * @return map reduce plan built by the compiler
 */
</MethodComment>
            <ReturnType>MROperPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPlan</MethodName>
            <MethodComment>/** 
 * Used to get the plan that was compiled
 * @return physical plan
 */
</MethodComment>
            <ReturnType>PhysicalPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMessageCollector</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CompilationMessageCollector</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compile</MethodName>
            <MethodComment>/** 
 * The front-end method that the user calls to compile the plan. Assumes that all submitted plans have a Store operators as the leaf.
 * @return A map reduce plan
 * @throws IOException
 * @throws PlanException
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>MROperPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;PhysicalOperator&gt; [leaves=plan.getLeaves()]</InnerVar>
                <InnerVar>List&lt;POStore&gt; [stores=PlanHelper.getPhysicalOperators(plan,POStore.class)]</InnerVar>
                <InnerVar>List&lt;PONative&gt; [nativeMRs=PlanHelper.getPhysicalOperators(plan,PONative.class)]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [ops]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ops;addAll;[nativeMRs]</InnerMethodInvoke>
                <InnerMethodInvoke>Collections;sort;[ops]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>connectSoftLink</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compile</MethodName>
            <MethodComment>/** 
 * Compiles the plan below op into a MapReduce Operator and stores it in curMROp.
 * @param op
 * @throws IOException
 * @throws PlanException
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PhysicalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MapReduceOper[] [prevCompInp=compiledInputs]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [predecessors=plan.getPredecessors(op)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>op;visit;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMROp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNativeMROp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>NativeMapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mrJar</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLoad</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>POLoad</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>POLoad [ld=new POLoad(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ld;setPc;[pigContext]</InnerMethodInvoke>
                <InnerMethodInvoke>ld;setIsTmpLoad;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>POStore</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>POStore [st=new POStore(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>st;setIsTmpStore;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nonBlocking</MethodName>
            <MethodComment>/** 
 * A map MROper is an MROper whose map plan is still open for taking more non-blocking operators. A reduce MROper is an MROper whose map plan is done but the reduce plan is open for taking more non-blocking opers. Used for compiling non-blocking operators. The logic here is simple. If there is a single input, just push the operator into whichever phase is open. Otherwise, we merge the compiled inputs into a list of MROpers where the first oper is the merged oper consisting of all map MROpers and the rest are reduce MROpers as reduce plans can't be merged. Then we add the input oper op into the merged map MROper's map plan as a leaf and connect the reduce MROpers using store-load combinations to the input operator which is the leaf. Also care is taken to connect the MROpers according to the dependencies.
 * @param op
 * @throws PlanException
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PhysicalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addToMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PhysicalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>blocking</MethodName>
            <MethodComment>/** 
 * Used for compiling blocking operators. If there is a single input and its map phase is still open, then close it so that further operators can be compiled into the reduce phase. If its reduce phase is open, add a store and close it. Start a new map MROper into which further operators can be compiled into. If there are multiple inputs, the logic is to merge all map MROpers into one map MROper and retain the reduce MROpers. Since the operator is blocking, it has to be a Global Rerrange at least now. This operator need not be inserted into our plan as it is implemented by hadoop. But this creates the map-reduce boundary. So the merged map MROper is closed and its reduce phase is started. Depending on the number of reduce MROpers and the number of pipelines in the map MRoper a Union operator is inserted whenever necessary. This also leads to the possibility of empty map plans. So have to be careful while handling it in the PigMapReduce class. If there are no map plans, then a new one is created as a side effect of the merge process. If there are no reduce MROpers, and only a single pipeline in the map, then no union oper is added. Otherwise a Union oper is added to the merged map MROper to which all the reduce MROpers are connected by store-load combinations. Care is taken to connect the MROpers in the MRPlan.
 * @param op
 * @throws IOException
 * @throws PlanException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PhysicalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>connRedOper</MethodName>
            <MethodComment>/** 
 * Connect the reduce MROpers to the leaf node in the map MROper mro by adding appropriate loads
 * @param mergedPlans - The list of reduce MROpers
 * @param mro - The map MROper
 * @throws PlanException
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergedPlans</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mro</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PhysicalOperator [leaf=null]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [leaves=mro.mapPlan.getLeaves()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endSingleInputPlanWithStr</MethodName>
            <MethodComment>/** 
 * Force an end to the current map reduce job with a store into a temporary file.
 * @param fSpec Temp file to force a store into.
 * @return MR operator that now is finished with a store.
 * @throws PlanException
 */
</MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fSpec</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MapReduceOper [mro=compiledInputs[0]]</InnerVar>
                <InnerVar>POStore [str=getStore()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>str;setSFile;[fSpec]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startNew</MethodName>
            <MethodComment>/** 
 * Starts a new MRoper and connects it to the old one by load-store. The assumption is that the store is already inserted into the old MROper.
 * @param fSpec
 * @param old
 * @return
 * @throws IOException
 * @throws PlanException
 */
</MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fSpec</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>POLoad [ld=getLoad()]</InnerVar>
                <InnerVar>MapReduceOper [ret=getMROp()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ld;setLFile;[fSpec]</InnerMethodInvoke>
                <InnerMethodInvoke>ret.mapPlan;add;[ld]</InnerMethodInvoke>
                <InnerMethodInvoke>MRPlan;add;[ret]</InnerMethodInvoke>
                <InnerMethodInvoke>MRPlan;connect;[old, ret]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTempFileSpec</MethodName>
            <MethodComment>/** 
 * Returns a temporary DFS Path
 * @return
 * @throws IOException
 */
</MethodComment>
            <ReturnType>FileSpec</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * Merges the map MROpers in the compiledInputs into a single merged map MRoper and returns a List with the merged map MROper as the first oper and the rest being reduce MROpers. Care is taken to remove the map MROpers that are merged from the MRPlan and their connections moved over to the merged map MROper. Merge is implemented as a sequence of binary merges. merge(PhyPlan finPlan, List&lt;PhyPlan&gt; lst) := finPlan,merge(p) foreach p in lst
 * @param compiledInputs
 * @return
 * @throws PlanException
 * @throws IOException
 */
</MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compiledInputs</ParamName>
                    <ParamType>MapReduceOper[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MapReduceOper&gt; [ret=new ArrayList&lt;MapReduceOper&gt;()]</InnerVar>
                <InnerVar>MapReduceOper [mergedMap=getMROp()]</InnerVar>
                <InnerVar>Set&lt;MapReduceOper&gt; [toBeConnected=new HashSet&lt;MapReduceOper&gt;()]</InnerVar>
                <InnerVar>List&lt;MapReduceOper&gt; [remLst=new ArrayList&lt;MapReduceOper&gt;()]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [mpLst=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>Iterator&lt;MapReduceOper&gt; [it=toBeConnected.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ret;add;[mergedMap]</InnerMethodInvoke>
                <InnerMethodInvoke>MRPlan;add;[mergedMap]</InnerMethodInvoke>
                <InnerMethodInvoke>null;merge;[ret.get(0).mapPlan, mpLst]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * The merge of a list of map plans
 * @param &lt; O &gt;
 * @param &lt; E &gt;
 * @param finPlan - Final Plan into which the list of plans is merged
 * @param plans - list of map plans to be merged
 * @throws PlanException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>finPlan</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>plans</ParamName>
                    <ParamType>E</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processUDFs</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitSplit</MethodName>
            <MethodComment>/** 
 * Compiles a split operator. The logic is to close the split job by replacing the split oper by a store and creating a new Map MRoper and return that as the current MROper to which other operators would be compiled into. The new MROper would be connected to the split job by load-store. Also add the split oper to the splitsSeen map.
 * @param op - The split operator
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POSplit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitLoad</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POLoad</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitNative</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PONative</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitFilter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POFilter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCross</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POCross</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitLimit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POLimit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitLocalRearrange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POLocalRearrange</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCollectedGroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POCollectedGroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPOForEach</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POForEach</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitGlobalRearrange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POGlobalRearrange</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPackage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POPackage</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitUnion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POUnion</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitFRJoin</MethodName>
            <MethodComment>/** 
 * This is an operator which will have multiple inputs(= to number of join inputs) But it prunes off all inputs but the fragment input and creates separate MR jobs for each of the replicated inputs and uses these as the replicated files that are configured in the POFRJoin operator. It also sets that this is FRJoin job and some parametes associated with it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POFRJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasTooManyInputFiles</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mro</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PhysicalPlan [mapPlan=mro.mapPlan]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [roots=mapPlan.getRoots()]</InnerVar>
                <InnerVar>int [numFiles=0]</InnerVar>
                <InnerVar>boolean [ret=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>LOG;info;["number of input files: " + numFiles]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConcatenateJob</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fSpec</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>POStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MapReduceOper [mro=startNew(fSpec,old)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mro.mapPlan;addAsLeaf;[str]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;setMapDone;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>LOG;info;["Insert a file-concatenation job"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMergeCoGroup</MethodName>
            <MethodComment>/** 
 * Leftmost relation is referred as base relation (this is the one fed into mappers.) First, close all MROpers except for first one (referred as baseMROPer) Then, create a MROper which will do indexing job (idxMROper) Connect idxMROper before the mappedMROper in the MRPlan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>poCoGrp</ParamName>
                    <ParamType>POMergeCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FuncSpec&gt; [funcSpecs=new ArrayList&lt;FuncSpec&gt;(compiledInputs.length - 1)]</InnerVar>
                <InnerVar>List&lt;String&gt; [fileSpecs=new ArrayList&lt;String&gt;(compiledInputs.length - 1)]</InnerVar>
                <InnerVar>List&lt;String&gt; [loaderSigns=new ArrayList&lt;String&gt;(compiledInputs.length - 1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexingJob</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexerMROp</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseMROp</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mapperLRInnerPlans</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PhysicalPlan [baseMapPlan=baseMROp.mapPlan]</InnerVar>
                <InnerVar>POLoad [baseLoader=(POLoad)baseMapPlan.getRoots().get(0)]</InnerVar>
                <InnerVar>FileSpec [origLoaderFileSpec=baseLoader.getLFile()]</InnerVar>
                <InnerVar>FuncSpec [funcSpec=origLoaderFileSpec.getFuncSpec()]</InnerVar>
                <InnerVar>LoadFunc [loadFunc=baseLoader.getLoadFunc()]</InnerVar>
                <InnerVar>String[] [indexerArgs=new String[6]]</InnerVar>
                <InnerVar>PhysicalPlan [phyPlan]</InnerVar>
                <InnerVar>POLoad [idxJobLoader=getLoad()]</InnerVar>
                <InnerVar>POStore [st=getStore()]</InnerVar>
                <InnerVar>FileSpec [strFile=getTempFileSpec()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>idxJobLoader;setLFile;[new FileSpec(origLoaderFileSpec.getFileName(),new FuncSpec(MergeJoinIndexer.class.getName(),indexerArgs))]</InnerMethodInvoke>
                <InnerMethodInvoke>indexerMROp.mapPlan;add;[idxJobLoader]</InnerMethodInvoke>
                <InnerMethodInvoke>indexerMROp.UDFs;add;[baseLoader.getLFile().getFuncSpec().toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>MRUtil;simpleConnectMapToReduce;[indexerMROp, scope, nig]</InnerMethodInvoke>
                <InnerMethodInvoke>indexerMROp;useTypedComparator;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>st;setSFile;[strFile]</InnerMethodInvoke>
                <InnerMethodInvoke>indexerMROp.reducePlan;addAsLeaf;[st]</InnerMethodInvoke>
                <InnerMethodInvoke>indexerMROp;setReduceDone;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MRCompilerException</ExceptionType>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>CloneNotSupportedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMergeJoin</MethodName>
            <MethodComment>/** 
 * Since merge-join works on two inputs there are exactly two MROper predecessors identified  as left and right. Instead of merging two operators, both are used to generate a MR job each. First MR oper is run to generate on-the-fly index on right side. Second is used to actually do the join. First MR oper is identified as rightMROper and second as curMROper. 1) RightMROper: If it is in map phase. It can be preceded only by POLoad. If there is anything else in physical plan, that is yanked and set as inner plans of joinOp. If it is reduce phase. Close this operator and start new MROper. 2) LeftMROper:  If it is in map phase, add the Join operator in it. If it is in reduce phase. Close it and start new MROper.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>joinOp</ParamName>
                    <ParamType>POMergeJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitDistinct</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PODistinct</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitSkewedJoin</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POSkewedJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitSort</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POSort</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitCounter</MethodName>
            <MethodComment>/** 
 * For the counter job, it depends if it is row number or not. In case of being a row number, any previous jobs are saved and POCounter is added as a leaf on a map task. If it is not, then POCounter is added as a leaf on a reduce task (last sorting phase).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POCounter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitRank</MethodName>
            <MethodComment>/** 
 * In case of PORank, it is closed any other previous job (containing POCounter as a leaf) and PORank is added on map phase.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>PORank</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSortCols</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Pair&lt;POProject,Byte&gt;[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plans</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [errCode=2026]</InnerVar>
                <InnerVar>String [msg="No expression plan found in POSort."]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSortJob</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sort</ParamName>
                    <ParamType>POSort</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>quantJob</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>quantFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fields</ParamName>
                    <ParamType>Pair&lt;POProject,Byte&gt;[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MapReduceOper [mro=startNew(lFile,quantJob)]</InnerVar>
                <InnerVar>long [limit=sort.getLimit()]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [eps1=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>byte [keyType=DataType.UNKNOWN]</InnerVar>
                <InnerVar>boolean[] [sortOrder]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [sortOrderList=sort.getMAscCols()]</InnerVar>
                <InnerVar>POLocalRearrange [lr=new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>POPackage [pkg=new POPackage(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>LitePackager [pkgr=new LitePackager()]</InnerVar>
                <InnerVar>PhysicalPlan [ep=new PhysicalPlan()]</InnerVar>
                <InnerVar>POProject [prj=new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [eps2=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flattened=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>POForEach [nfe1=new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,eps2,flattened)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mro;setQuantFile;[quantFile.getFileName()]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;setGlobalSort;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setKeyType;[(fields == null || fields.length &gt; 1) ? DataType.TUPLE : keyType]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setPlans;[eps1]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;addOriginalLocation;[sort.getAlias(), sort.getOriginalLocations()]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.mapPlan;addAsLeaf;[lr]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;setMapDone;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>pkgr;setKeyType;[(fields == null || fields.length &gt; 1) ? DataType.TUPLE : keyType]</InnerMethodInvoke>
                <InnerMethodInvoke>pkg;setPkgr;[pkgr]</InnerMethodInvoke>
                <InnerMethodInvoke>pkg;setNumInps;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[pkg]</InnerMethodInvoke>
                <InnerMethodInvoke>prj;setColumn;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>prj;setOverloaded;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>prj;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>ep;add;[prj]</InnerMethodInvoke>
                <InnerMethodInvoke>eps2;add;[ep]</InnerMethodInvoke>
                <InnerMethodInvoke>flattened;add;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[nfe1]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;connect;[pkg, nfe1]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.phyToMRMap;put;[sort, nfe1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQuantileJob</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inpSort</ParamName>
                    <ParamType>POSort</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prevJob</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>quantFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>POSort [sort=new POSort(inpSort.getOperatorKey(),inpSort.getRequestedParallelism(),null,inpSort.getSortPlans(),inpSort.getMAscCols(),inpSort.getMSortFunc())]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [ascCols=inpSort.getMAscCols()]</InnerVar>
                <InnerVar>String[] [ascs=new String[ascCols.size()]]</InnerVar>
                <InnerVar>String[] [ctorArgs=ascs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sort;addOriginalLocation;[inpSort.getAlias(), inpSort.getOriginalLocations()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSkewedJoinSampleJob</MethodName>
            <MethodComment>/** 
 * Create Sampling job for skewed join.
 */
</MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>POSkewedJoin</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prevJob</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sampleFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MultiMap&lt;PhysicalOperator,PhysicalPlan&gt; [joinPlans=op.getJoinPlans()]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [l=plan.getPredecessors(op)]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [groups=joinPlans.get(l.get(0))]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [ascCol=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>POSort [sort=new POSort(op.getOperatorKey(),op.getRequestedParallelism(),null,groups,ascCol,null)]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [transformPlans=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>POProject [prjStar=new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [ufInps=new ArrayList&lt;PhysicalOperator&gt;()]</InnerVar>
                <InnerVar>PhysicalPlan [ep=new PhysicalPlan()]</InnerVar>
                <InnerVar>POUserFunc [uf=new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,ufInps,new FuncSpec(GetMemNumRows.class.getName(),(String[])null))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>transformPlans;addAll;[groups]</InnerMethodInvoke>
                <InnerMethodInvoke>prjStar;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>prjStar;setStar;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>ufInps;add;[prjStar]</InnerMethodInvoke>
                <InnerMethodInvoke>uf;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>ep;add;[uf]</InnerMethodInvoke>
                <InnerMethodInvoke>ep;add;[prjStar]</InnerMethodInvoke>
                <InnerMethodInvoke>ep;connect;[prjStar, uf]</InnerMethodInvoke>
                <InnerMethodInvoke>transformPlans;add;[ep]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSamplingJob</MethodName>
            <MethodComment>/** 
 * Create a sampling job to collect statistics by sampling an input file. The sequence of operations is as following: &lt;li&gt;Transform input sample tuples into another tuple.&lt;/li&gt; &lt;li&gt;Add an extra field &amp;quot;all&amp;quot; into the tuple &lt;/li&gt; &lt;li&gt;Package all tuples into one bag &lt;/li&gt; &lt;li&gt;Add constant field for number of reducers. &lt;/li&gt; &lt;li&gt;Sorting the bag &lt;/li&gt; &lt;li&gt;Invoke UDF with the number of reducers and the sorted bag.&lt;/li&gt; &lt;li&gt;Data generated by UDF is stored into a file.&lt;/li&gt;
 * @param sort  the POSort operator used to sort the bag
 * @param prevJob  previous job of current sampling job
 * @param transformPlans  PhysicalPlans to transform input samples
 * @param lFile  path of input file
 * @param sampleFile  path of output file
 * @param rp  configured parallemism
 * @param sortKeyPlans  PhysicalPlans to be set into POSort operator to get sorting keys
 * @param udfClassName  the class name of UDF
 * @param udfArgs   the arguments of UDF
 * @param sampleLdrClassName class name for the sample loader
 * @return pair&lt;mapreduceoper,integer&gt;
 * @throws PlanException
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>MapReduceOper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sort</ParamName>
                    <ParamType>POSort</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prevJob</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transformPlans</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sampleFile</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sortKeyPlans</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfArgs</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sampleLdrClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [rslargs=new String[2]]</InnerVar>
                <InnerVar>FileSpec [quantLdFilName=new FileSpec(lFile.getFileName(),new FuncSpec(sampleLdrClassName,rslargs))]</InnerVar>
                <InnerVar>MapReduceOper [mro=startNew(quantLdFilName,prevJob)]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flat1=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [eps1=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>POForEach [nfe1=new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,eps1,flat1)]</InnerVar>
                <InnerVar>PhysicalPlan [ep1=new PhysicalPlan()]</InnerVar>
                <InnerVar>ConstantExpression [ce=new ConstantExpression(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [eps=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>POLocalRearrange [lr=new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>POPackage [pkg=new POPackage(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>Packager [pkgr=new Packager()]</InnerVar>
                <InnerVar>boolean[] [inner={false}]</InnerVar>
                <InnerVar>PhysicalPlan [fe2Plan=new PhysicalPlan()]</InnerVar>
                <InnerVar>POProject [topPrj=new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [nesSortPlanLst=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>PhysicalPlan [rpep=new PhysicalPlan()]</InnerVar>
                <InnerVar>ConstantExpression [rpce=new ConstantExpression(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [genEps=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flattened2=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>POForEach [nfe2=new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,genEps,flattened2)]</InnerVar>
                <InnerVar>PhysicalPlan [ep4=new PhysicalPlan()]</InnerVar>
                <InnerVar>POProject [prjStar4=new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)))]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [ufInps=new ArrayList&lt;PhysicalOperator&gt;()]</InnerVar>
                <InnerVar>POUserFunc [uf=new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,ufInps,new FuncSpec(udfClassName,udfArgs))]</InnerVar>
                <InnerVar>List&lt;PhysicalPlan&gt; [ep4s=new ArrayList&lt;PhysicalPlan&gt;()]</InnerVar>
                <InnerVar>List&lt;Boolean&gt; [flattened3=new ArrayList&lt;Boolean&gt;()]</InnerVar>
                <InnerVar>POForEach [nfe3=new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,ep4s,flattened3)]</InnerVar>
                <InnerVar>POStore [str=getStore()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mro.mapPlan;addAsLeaf;[nfe1]</InnerMethodInvoke>
                <InnerMethodInvoke>ce;setValue;["all"]</InnerMethodInvoke>
                <InnerMethodInvoke>ce;setResultType;[DataType.CHARARRAY]</InnerMethodInvoke>
                <InnerMethodInvoke>ep1;add;[ce]</InnerMethodInvoke>
                <InnerMethodInvoke>eps;add;[ep1]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setKeyType;[DataType.CHARARRAY]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setPlans;[eps]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>lr;addOriginalLocation;[sort.getAlias(), sort.getOriginalLocations()]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.mapPlan;add;[lr]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.mapPlan;connect;[nfe1, lr]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;setMapDone;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>pkg;setPkgr;[pkgr]</InnerMethodInvoke>
                <InnerMethodInvoke>pkgr;setKeyType;[DataType.CHARARRAY]</InnerMethodInvoke>
                <InnerMethodInvoke>pkg;setNumInps;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>pkgr;setInner;[inner]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[pkg]</InnerMethodInvoke>
                <InnerMethodInvoke>topPrj;setColumn;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>topPrj;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>topPrj;setOverloaded;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>fe2Plan;add;[topPrj]</InnerMethodInvoke>
                <InnerMethodInvoke>sort;setSortPlans;[nesSortPlanLst]</InnerMethodInvoke>
                <InnerMethodInvoke>sort;setResultType;[DataType.BAG]</InnerMethodInvoke>
                <InnerMethodInvoke>fe2Plan;add;[sort]</InnerMethodInvoke>
                <InnerMethodInvoke>fe2Plan;connect;[topPrj, sort]</InnerMethodInvoke>
                <InnerMethodInvoke>rpce;setRequestedParallelism;[rp]</InnerMethodInvoke>
                <InnerMethodInvoke>rpce;setValue;[rp]</InnerMethodInvoke>
                <InnerMethodInvoke>rpce;setResultType;[DataType.INTEGER]</InnerMethodInvoke>
                <InnerMethodInvoke>rpep;add;[rpce]</InnerMethodInvoke>
                <InnerMethodInvoke>genEps;add;[rpep]</InnerMethodInvoke>
                <InnerMethodInvoke>genEps;add;[fe2Plan]</InnerMethodInvoke>
                <InnerMethodInvoke>flattened2;add;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>flattened2;add;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[nfe2]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;connect;[pkg, nfe2]</InnerMethodInvoke>
                <InnerMethodInvoke>prjStar4;setResultType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>prjStar4;setStar;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>ep4;add;[prjStar4]</InnerMethodInvoke>
                <InnerMethodInvoke>ufInps;add;[prjStar4]</InnerMethodInvoke>
                <InnerMethodInvoke>ep4;add;[uf]</InnerMethodInvoke>
                <InnerMethodInvoke>ep4;connect;[prjStar4, uf]</InnerMethodInvoke>
                <InnerMethodInvoke>ep4s;add;[ep4]</InnerMethodInvoke>
                <InnerMethodInvoke>flattened3;add;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[nfe3]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;connect;[nfe2, nfe3]</InnerMethodInvoke>
                <InnerMethodInvoke>str;setSFile;[sampleFile]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;add;[str]</InnerMethodInvoke>
                <InnerMethodInvoke>mro.reducePlan;connect;[nfe3, str]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;setReduceDone;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>mro;markSampler;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>PlanException</ExceptionType>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LastInputStreamingOptimizer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>MROperPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunkSize</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitMROp</MethodName>
            <MethodComment>/** 
 * indTupIter Look for pattern POPackage-&gt;POForEach(if both are flatten), change it to POJoinPackage We can avoid materialize the input and construct the result of join on the fly
 * @param mr - map-reduce plan to optimize
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mr</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;PhysicalOperator&gt; [mpLeaves=mr.mapPlan.getLeaves()]</InnerVar>
                <InnerVar>PhysicalOperator [op=mpLeaves.get(0)]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [mrRoots=mr.reducePlan.getRoots()]</InnerVar>
                <InnerVar>POPackage [pack=(POPackage)op]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [sucs=mr.reducePlan.getSuccessors(pack)]</InnerVar>
                <InnerVar>boolean [lastInputFlattened=true]</InnerVar>
                <InnerVar>boolean [allSimple=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceWithPOJoinPackage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mr</ParamName>
                    <ParamType>MapReduceOper</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pack</ParamName>
                    <ParamType>POPackage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forEach</ParamName>
                    <ParamType>POForEach</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chunkSize</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JoinPackager [pkgr=new JoinPackager(pack.getPkgr(),forEach)]</InnerVar>
                <InnerVar>List&lt;PhysicalOperator&gt; [succs=plan.getSuccessors(forEach)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pkgr;setChunkSize;[Long.parseLong(chunkSize)]</InnerMethodInvoke>
                <InnerMethodInvoke>pack;setPkgr;[pkgr]</InnerMethodInvoke>
                <InnerMethodInvoke>plan;remove;[pack]</InnerMethodInvoke>
                <InnerMethodInvoke>mr.phyToMRMap;put;[forEach, pack]</InnerMethodInvoke>
                <InnerMethodInvoke>LogFactory.getLog(LastInputStreamingOptimizer.class);info;["Rewrite: POPackage-&gt;POForEach to POPackage(JoinPackager)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FindKeyTypeVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitProject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>POProject</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FindStoreNameVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>PhysicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newSpec</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldSpec</ParamName>
                    <ParamType>FileSpec</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sto</ParamName>
                    <ParamType>POStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileSpec [spec=sto.getSFile()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>