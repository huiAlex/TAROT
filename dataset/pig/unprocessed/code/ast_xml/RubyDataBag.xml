<Class>
    <Id>37</Id>
    <Package>org.apache.pig.scripting.jruby</Package>
    <ClassName>RubyDataBag</ClassName>
    <SuperClass>RubyObject</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Iterable</SuperInterface>
        <SuperInterface>Tuple</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>RubyDataBag  /** 
 * This provides a Ruby-esque way to interact with DataBag objects. It encapsulates a bag object, and provides an easy to use interface. One difference between the Ruby and the the Java API on DataBag is that in Ruby you iterate on the bag directly. &lt;p&gt; The RubyDataBag class  uses JRuby's API for the defintion Ruby class using Java code. The comments in this class will more extensively explain the annotations for those not familiar with JRuby. &lt;p&gt; In JRuby, the annotations are provided for convenience, and are detected and used by the "defineAnnotatedMethods" method. The JRubyClass annotation sets the class name as it will be seen in the Ruby runtime, and alows you to include any modules. In the case of the RubyDataBag, within Ruby we just want it to be called DataBag, and we want it to be enumerable.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>mTupleFactory</FieldName>
            <FieldType>TupleFactory</FieldType>
        </Field>
        <Field>
            <FieldName>mBagFactory</FieldName>
            <FieldType>BagFactory</FieldType>
        </Field>
        <Field>
            <FieldName>internalDB</FieldName>
            <FieldType>DataBag</FieldType>
        </Field>
        <Field>
            <FieldName>ALLOCATOR</FieldName>
            <FieldType>ObjectAllocator</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getBag</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataBag</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allocate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>IRubyObject</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>runtime</ParamName>
                    <ParamType>Ruby</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>klass</ParamName>
                    <ParamType>RubyClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>define</MethodName>
            <MethodComment>/** 
 * This method registers the class with the given runtime. It is not necessary to do this here, but it is simpler to associate the methods necessary to register the class with the class itself, so on the Library side it is possible to just specify "RubyDataBag.define(runtime)".
 * @param runtime an instance of the Ruby runtime
 * @return        a RubyClass object with metadata about the registered class
 */
</MethodComment>
            <ReturnType>RubyClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>runtime</ParamName>
                    <ParamType>Ruby</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RubyClass [result=runtime.defineClass("DataBag",runtime.getObject(),ALLOCATOR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;includeModule;[runtime.getEnumerable()]</InnerMethodInvoke>
                <InnerMethodInvoke>result;defineAnnotatedMethods;[RubyDataBag.class]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isKindOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>IRubyObject</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>RubyModule</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RubyDataBag</MethodName>
            <MethodComment>/** 
 * This constructor encapsulated an empty bag.
 * @param ruby an instance of the ruby runtime
 * @param rc   an instance of the class object with meatadata
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ruby</ParamName>
                    <ParamType>Ruby</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>RubyClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RubyDataBag</MethodName>
            <MethodComment>/** 
 * This constructor encapsulates the bag that is passed to it. Note: the resultant RubyDataBag will encapsulated that bag directly, not a copy.
 * @param ruby an instance of the ruby runtime
 * @param rc   an instance of the class object with meatadata
 * @param db   a DataBag to encapsulate
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ruby</ParamName>
                    <ParamType>Ruby</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>RubyClass</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>db</ParamName>
                    <ParamType>DataBag</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * The initialize method is the method used on the Ruby side to construct the RubyDataBag object. The default is just an empty bag.
 * @return the initialized RubyDataBag
 */
</MethodComment>
            <ReturnType>RubyDataBag</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * The initialize method can optionally receive a DataBag. In the case of a RubyDataBag, a RubyDataBag will be returned that directly encapsulates it.
 * @param arg an IRubyObject that is a RubyDataBag to encapsulate
 * @return    the initialized RubyDataBag
 */
</MethodComment>
            <ReturnType>RubyDataBag</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>IRubyObject</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * This method deletes all of the entries in the underlying DataBag.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>internalDB;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDistinct</MethodName>
            <MethodComment>/** 
 * This returns whether the encapsulated DatBag is distinct, per the distinct setting.
 * @param context the context the method is being executed in
 * @return        true if it the encapsulated is distinct, false otherwise
 */
</MethodComment>
            <ReturnType>RubyBoolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSorted</MethodName>
            <MethodComment>/** 
 * This returns whether the encapsulated DatBag is distinct, per the sorted setting.
 * @param context the context the method is being executed in
 * @return        true if it the encapsulated is sorted, false otherwise
 */
</MethodComment>
            <ReturnType>RubyBoolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * This returns the size of the encapsulated DataBag.
 * @param context the context the method is being executed in
 * @return        the size of the encapsulated DataBag
 */
</MethodComment>
            <ReturnType>RubyFixnum</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>add</MethodName>
            <MethodComment>/** 
 * The add method accepts a varargs argument; each argument can be either a random object, a DataBag, or a RubyArray. In the case of a random object, that object will be converted to a Pig object and put into a Tuple. In the case of a RubyArray, it will be treated as a Tuple and added. In the case of a DataBag, it will iterate over the DataBag and add all of the elements to the element encapsulated by RubyDataBag.
 * @param context the context the method is being executed in
 * @param args    varargs passed to add. Each argument can be a RubyDataBag, whosecontents will be copied; a RubyArray, which will be treated as a Tuple, or another object which will be converted over per {@link PigJrubyLibrary#rubyToPig}.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>IRubyObject[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment>/** 
 * This method returns a copy of the encapsulated DataBag.
 * @param context the context the method is being executed in
 * @return        the copied RubyDataBag
 */
</MethodComment>
            <ReturnType>RubyDataBag</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataBag [b=mBagFactory.newDefaultBag()]</InnerVar>
                <InnerVar>Ruby [runtime=context.getRuntime()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * This method returns whether or not the encapsulated DataBag is empty.
 * @param context the context the method is being executed ini @return        true if the encapsulated DAtaBag is empty, false otherwise
 */
</MethodComment>
            <ReturnType>RubyBoolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inspect</MethodName>
            <MethodComment>/** 
 * This method returns a string representation of the RubyDataBag. If given an optional argument, then if that argument is true, the contents of the bag will also be printed.
 * @param context the context the method is being executed in
 * @param args    optional true/false argument passed to inspect
 * @return        string representation of the RubyDataBag
 */
</MethodComment>
            <ReturnType>RubyString</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>IRubyObject[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Ruby [runtime=context.getRuntime()]</InnerVar>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb.append("[DataBag: size: ");append;[internalDB.size()]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["]"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Tuple</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>each</MethodName>
            <MethodComment>/** 
 * This is an implementation of the each method which opens up the Enumerable interface, and makes it very convenient to iterate over the elements of a DataBag. Note that currently, due to a deficiency in JRuby, it is not possible to call each without a block given.
 * @param context the context the method is being executed in
 * @param block   a block to call on the elements of the bag
 * @return        enumerator object if null block given, nil otherwise
 */
</MethodComment>
            <ReturnType>IRubyObject</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>block</ParamName>
                    <ParamType>Block</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Ruby [runtime=context.getRuntime()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flatten</MethodName>
            <MethodComment>/** 
 * This is a convenience method which will run the given block on the first element of each tuple contained.
 * @param context the context the method is being executed in
 * @param block   a block to call on the elements of the bag
 * @return        enumerator object if null block given, nil otherwise
 */
</MethodComment>
            <ReturnType>IRubyObject</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>ThreadContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>block</ParamName>
                    <ParamType>Block</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Ruby [runtime=context.getRuntime()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>