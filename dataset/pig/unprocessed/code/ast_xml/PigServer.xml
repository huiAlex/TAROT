<Class>
    <Id>1059</Id>
    <Package>org.apache.pig</Package>
    <ClassName>PigServer</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>PigServer  /** 
 * A class for Java programs to connect to Pig. Typically a program will create a PigServer instance. The programmer then registers queries using registerQuery() and retrieves results using openIterator() or store(). After doing so, the shutdown() method should be called to free any resources used by the current PigServer instance. Not doing so could result in a memory leak.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>PRETTY_PRINT_SCHEMA_PROPERTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>PIG_LOCATION_CHECK_STRICT</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>graphs</FieldName>
            <FieldType>Deque</FieldType>
        </Field>
        <Field>
            <FieldName>graphs</FieldName>
            <FieldType>Graph</FieldType>
        </Field>
        <Field>
            <FieldName>currDAG</FieldName>
            <FieldType>Graph</FieldType>
        </Field>
        <Field>
            <FieldName>pigContext</FieldName>
            <FieldType>PigContext</FieldType>
        </Field>
        <Field>
            <FieldName>jobName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>jobPriority</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>scopeCounter</FieldName>
            <FieldType>AtomicInteger</FieldType>
        </Field>
        <Field>
            <FieldName>scope</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>validateEachStatement</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>skipParseInRegisterForBatch</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>filter</FieldName>
            <FieldType>BlackAndWhitelistFilter</FieldType>
        </Field>
        <Field>
            <FieldName>aliases</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>aliases</FieldName>
            <FieldType>LogicalRelationalOperator</FieldType>
        </Field>
        <Field>
            <FieldName>operators</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>operators</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>lastRel</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>scriptCache</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>scriptCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>fileNameMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>fileNameMap</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>batchMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>processedStores</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>lp</FieldName>
            <FieldType>LogicalPlan</FieldType>
        </Field>
        <Field>
            <FieldName>currentLineNum</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>constructScope</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetScope</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scopeCounter;set;[0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment>/** 
 * @param execTypeString can be 'mapreduce' or 'local'.  Local mode willuse Hadoop's local job runner to execute the job on the local machine. Mapreduce mode will connect to a cluster to execute the job. If execTypeString is not one of these two, Pig will deduce the ExecutionEngine if it is on the classpath and use it for the backend execution.
 * @throws ExecException
 * @throws IOException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execTypeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execTypeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addExecTypeProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>execType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>properties;setProperty;["exectype", execType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment>/** 
 * @param execType execution type to start the engine.  Local mode willuse Hadoop's local job runner to execute the job on the local machine. Mapreduce mode will connect to a cluster to execute the job.
 * @throws ExecException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execType</ParamName>
                    <ParamType>ExecType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execType</ParamName>
                    <ParamType>ExecType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execType</ParamName>
                    <ParamType>ExecType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>PigContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PigServer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>PigContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>connect</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [auditId=PigATSClient.getPigAuditId(pigContext)]</InnerVar>
                <InnerVar>String [callerId=(String)pigContext.getProperties().get(PigConfiguration.PIG_LOG_TRACE_ID)]</InnerVar>
                <InnerVar>Class [callerContextClass=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addHadoopProperties;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addJarsFromProperties;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;markPredeployedJarsFromProperties;[]</InnerMethodInvoke>
                <InnerMethodInvoke>PigStats;start;[pigContext.getExecutionEngine().instantiatePigStats()]</InnerMethodInvoke>
                <InnerMethodInvoke>log;info;["Pig Script ID for the session: " + auditId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addHadoopProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [codecs=pigContext.getProperties().getProperty("io.compression.codecs")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addJarsFromProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [jar_str=pigContext.getProperties().getProperty("pig.additional.jars")]</InnerVar>
                <InnerVar>String [jar_str_comma=pigContext.getProperties().getProperty("pig.additional.jars.uris")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markPredeployedJarsFromProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [jar_str=pigContext.getProperties().getProperty("pig.predeployed.jars")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPigContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PigContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentDAG</MethodName>
            <MethodComment>/** 
 * Current DAG
 * @return
 */
</MethodComment>
            <ReturnType>Graph</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugOn</MethodName>
            <MethodComment>/** 
 * Set the logging level to DEBUG.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Logger.getLogger("org.apache.pig");setLevel;[Level.DEBUG]</InnerMethodInvoke>
                <InnerMethodInvoke>pigContext.getLog4jProperties();setProperty;["log4j.logger.org.apache.pig", Level.DEBUG.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugOff</MethodName>
            <MethodComment>/** 
 * Set the logging level to the default.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Logger.getLogger("org.apache.pig");setLevel;[pigContext.getDefaultLogLevel()]</InnerMethodInvoke>
                <InnerMethodInvoke>pigContext.getLog4jProperties();setProperty;["log4j.logger.org.apache.pig", pigContext.getDefaultLogLevel().toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultParallel</MethodName>
            <MethodComment>/** 
 * Set the default parallelism for this job
 * @param p default number of reducers to use for this job.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBatchOn</MethodName>
            <MethodComment>/** 
 * Starts batch execution mode.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debug;["Create a new graph."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBatchOn</MethodName>
            <MethodComment>/** 
 * Retrieve the current execution mode.
 * @return true if the execution mode is batch; false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBatchEmpty</MethodName>
            <MethodComment>/** 
 * Returns whether there is anything to process in the current batch.
 * @throws FrontendException
 * @return true if there are no stores to process in the currentbatch, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseAndBuild</MethodName>
            <MethodComment>/** 
 * This method parses the scripts and builds the LogicalPlan. This method should be followed by  {@link PigServer#executeBatch(boolean)} withargument as false. Do Not use  {@link PigServer#executeBatch()} aftercalling this method as that will re-parse and build the script.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currDAG;parseQuery;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;buildPlan;[null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeBatch</MethodName>
            <MethodComment>/** 
 * Submits a batch of Pig commands for execution.
 * @return list of jobs being executed
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ExecJob</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeBatch</MethodName>
            <MethodComment>/** 
 * Submits a batch of Pig commands for execution. Parse and build of script should be skipped if user called  {@link PigServer#parseAndBuild()}before. Pass false as an argument in which case.
 * @param parseAndBuild
 * @return
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ExecJob</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parseAndBuild</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PigStats [stats=execute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJobs</MethodName>
            <MethodComment>/** 
 * Retrieves a list of Job objects from the PigStats object
 * @param stats
 * @return A list of ExecJob objects
 */
</MethodComment>
            <ReturnType>ExecJob</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stats</ParamName>
                    <ParamType>PigStats</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LinkedList&lt;ExecJob&gt; [jobs=new LinkedList&lt;ExecJob&gt;()]</InnerVar>
                <InnerVar>JobGraph [jGraph=stats.getJobGraph()]</InnerVar>
                <InnerVar>Iterator&lt;JobStats&gt; [iter=jGraph.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>discardBatch</MethodName>
            <MethodComment>/** 
 * Discards a batch of Pig commands.
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPathToSkip</MethodName>
            <MethodComment>/** 
 * Add a path to be skipped while automatically shipping binaries for streaming.
 * @param path path to be skipped
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pigContext;addPathToSkip;[path]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerFunction</MethodName>
            <MethodComment>/** 
 * Defines an alias for the given function spec. This is useful for functions that require arguments to the constructor.
 * @param function - the new function alias to define.
 * @param funcSpec - the FuncSpec object representing the name ofthe function class and any arguments to constructor.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>funcSpec</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pigContext;registerFunction;[function, funcSpec]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerStreamingCommand</MethodName>
            <MethodComment>/** 
 * Defines an alias for the given streaming command.
 * @param commandAlias - the new command alias to define
 * @param command - streaming command to be executed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commandAlias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>command</ParamName>
                    <ParamType>StreamingCommand</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pigContext;registerStreamCmd;[commandAlias, command]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateJarFromResources</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>URL</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jarName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Enumeration&lt;URL&gt; [urls=ClassLoader.getSystemResources(jarName)]</InnerVar>
                <InnerVar>URL [resourceLocation=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerJar</MethodName>
            <MethodComment>/** 
 * Registers a jar file. Name of the jar file can be an absolute or relative path. If multiple resources are found with the specified name, the first one is registered as returned by getSystemResources. A warning is issued to inform the user.
 * @param name of the jar file to register
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.REGISTER]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerCode</MethodName>
            <MethodComment>/** 
 * Universal Scripting Language Support, see PIG-928
 * @param path path of the script file
 * @param scriptingLang language keyword or scriptingEngine used to interpret the script
 * @param namespace namespace defined for functions of this script
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scriptingLang</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>namespace</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FetchFileRet [ret=FileLocalizer.fetchFile(pigContext.getProperties(),path)]</InnerVar>
                <InnerVar>File [f=ret.file]</InnerVar>
                <InnerVar>String [cwd=new File(".").getCanonicalPath()]</InnerVar>
                <InnerVar>String [filePath=f.getCanonicalPath()]</InnerVar>
                <InnerVar>String [nameInJar=filePath]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pigContext;addScriptFile;[nameInJar, filePath]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerQuery</MethodName>
            <MethodComment>/** 
 * Register a query with the Pig runtime. The query is parsed and registered, but it is not executed until it is needed.
 * @param query a Pig Latin expression to be evaluated.
 * @param startLine line number of the query within the whole script
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>query</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currDAG;registerQuery;[query, startLine, validateEachStatement, skipParseInRegisterForBatch]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerQuery</MethodName>
            <MethodComment>/** 
 * Register a query with the Pig runtime. The query is parsed and registered, but it is not executed until it is needed.  Equivalent to calling  {@link #registerQuery(String,int)}with startLine set to 1.
 * @param query a Pig Latin expression to be evaluated.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>query</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerQuery;[query, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script from InputStream source which is more general and extensible the pig script can be from local file, then you can use FileInputStream. or pig script can be in memory which you build it dynamically, the you can use ByteArrayInputStream even pig script can be in remote machine, which you get wrap it as SocketInputStream
 * @param in
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[in, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script from InputStream source which is more general and extensible the pig script can be from local file, then you can use FileInputStream. or pig script can be in memory which you build it dynamically, the you can use ByteArrayInputStream even pig script can be in remote machine, which you get wrap it as SocketInputStream. The parameters in the pig script will be substituted with the values in params
 * @param in
 * @param params the key is the parameter name, and the value is the parameter value
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[in, params, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script from InputStream source which is more general and extensible the pig script can be from local file, then you can use FileInputStream. or pig script can be in memory which you build it dynamically, the you can use ByteArrayInputStream even pig script can be in remote machine, which you get wrap it as SocketInputStream The parameters in the pig script will be substituted with the values in the parameter files
 * @param in
 * @param paramsFiles  files which have the parameter setting
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramsFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[in, null, paramsFiles]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script from InputStream.&lt;br&gt; The pig script can be from local file, then you can use FileInputStream. Or pig script can be in memory which you build it dynamically, the you can use ByteArrayInputStream Pig script can even be in remote machine, which you get wrap it as SocketInputStream.&lt;br&gt; The parameters in the pig script will be substituted with the values in the map and the parameter files. The values in params Map will override the value in parameter file if they have the same parameter
 * @param in
 * @param params the key is the parameter name, and the value is the parameter value
 * @param paramsFiles  files which have the parameter setting
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramsFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>paramMapToList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [paramList=new ArrayList&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClonedGraph</MethodName>
            <MethodComment>/** 
 * Creates a clone of the current DAG
 * @return A Graph object which is a clone of the current DAG
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Graph</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Graph [graph=currDAG.duplicate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a query with the Pig runtime.  The query will be read from the indicated file.
 * @param fileName file to read query from.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[fileName, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script file.  The parameters in the file will be substituted with the values in params
 * @param fileName  pig script file
 * @param params  the key is the parameter name, and the value is the parameter value
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[fileName, params, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script file.  The parameters in the file will be substituted with the values in the parameter files
 * @param fileName pig script file
 * @param paramsFiles  files which have the parameter setting
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramsFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;registerScript;[fileName, null, paramsFiles]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerScript</MethodName>
            <MethodComment>/** 
 * Register a pig script file.  The parameters in the file will be substituted with the values in the map and the parameter files The values in params Map will override the value in parameter file if they have the same parameter
 * @param fileName  pig script
 * @param params  the key is the parameter name, and the value is the parameter value
 * @param paramsFiles   files which have the parameter setting
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramsFiles</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileInputStream [fis=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printAliases</MethodName>
            <MethodComment>/** 
 * Intended to be used by unit tests only. Print a list of all aliases in in the current Pig Latin script.  Output is written to System.out.
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System.out;println;["aliases: " + currDAG.getAliasOp().keySet()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dumpSchema</MethodName>
            <MethodComment>/** 
 * Write the schema for an alias to System.out.
 * @param alias Alias whose schema will be written out
 * @return Schema of alias dumped
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dumpSchemaNested</MethodName>
            <MethodComment>/** 
 * Write the schema for a nestedAlias to System.out. Denoted by alias::nestedAlias.
 * @param alias Alias whose schema has nestedAlias
 * @param nestedAlias Alias whose schema will be written out
 * @return Schema of alias dumped
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nestedAlias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setJobName</MethodName>
            <MethodComment>/** 
 * Set the name of the job.  This name will get translated to mapred.job.name.
 * @param name of job
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setJobPriority</MethodName>
            <MethodComment>/** 
 * Set Hadoop job priority.  This value will get translated to mapred.job.priority.
 * @param priority valid values are found in {@link org.apache.hadoop.mapred.JobPriority}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>priority</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openIterator</MethodName>
            <MethodComment>/** 
 * Executes a Pig Latin script up to and including indicated alias.  That is, if a user does: &lt;pre&gt; PigServer server = new PigServer(); server.registerQuery("A = load 'foo';"); server.registerQuery("B = filter A by $0 &amp;gt; 0;"); server.registerQuery("C = order B by $1;"); &lt;/pre&gt; Then &lt;pre&gt; server.openIterator("B"); &lt;/pre&gt; filtered but unsorted data will be returned.  If instead a user does &lt;pre&gt; server.openIterator("C"); &lt;/pre&gt; filtered and sorted data will be returned.
 * @param id Alias to open iterator for
 * @return iterator of tuples returned from the script
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Tuple</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>store</MethodName>
            <MethodComment>/** 
 * Executes a Pig Latin script up to and including indicated alias and stores the resulting records into a file.  That is, if a user does: &lt;pre&gt; PigServer server = new PigServer(); server.registerQuery("A = load 'foo';"); server.registerQuery("B = filter A by $0 &amp;gt; 0;"); server.registerQuery("C = order B by $1;"); &lt;/pre&gt; Then &lt;pre&gt; server.store("B", "bar"); &lt;/pre&gt; filtered but unsorted data will be stored to the file &lt;tt&gt;bar&lt;/tt&gt;.  If instead a user does &lt;pre&gt; server.store("C", "bar"); &lt;/pre&gt; filtered and sorted data will be stored to the file &lt;tt&gt;bar&lt;/tt&gt;. Equivalent to calling  {@link #store(String,String,String)} with&lt;tt&gt;org.apache.pig.PigStorage&lt;/tt&gt; as the store function.
 * @param id The alias to store
 * @param filename The file to which to store to
 * @return {@link ExecJob} containing information about this job
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ExecJob</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>store</MethodName>
            <MethodComment>/** 
 * Executes a Pig Latin script up to and including indicated alias and stores the resulting records into a file.  That is, if a user does: &lt;pre&gt; PigServer server = new PigServer(); server.registerQuery("A = load 'foo';"); server.registerQuery("B = filter A by $0 &amp;gt; 0;"); server.registerQuery("C = order B by $1;"); &lt;/pre&gt; Then &lt;pre&gt; server.store("B", "bar", "mystorefunc"); &lt;/pre&gt; filtered but unsorted data will be stored to the file &lt;tt&gt;bar&lt;/tt&gt; using &lt;tt&gt;mystorefunc&lt;/tt&gt;.  If instead a user does &lt;pre&gt; server.store("C", "bar", "mystorefunc"); &lt;/pre&gt; filtered and sorted data will be stored to the file &lt;tt&gt;bar&lt;/tt&gt; using &lt;tt&gt;mystorefunc&lt;/tt&gt;. &lt;p&gt;
 * @param id The alias to store
 * @param filename The file to which to store to
 * @param func store function to use
 * @return {@link ExecJob} containing information about this job
 * @throws IOException
 */
</MethodComment>
            <ReturnType>ExecJob</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PigStats [stats=storeEx(id,filename,func)]</InnerVar>
                <InnerVar>OutputStats [output=stats.getOutputStats().get(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeEx</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PigStats</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currDAG;parseQuery;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;skipStores;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;buildPlan;[alias]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>explain</MethodName>
            <MethodComment>/** 
 * Provide information on how a pig query will be executed.  For now this information is very developer focussed, and probably not very useful to the average user.
 * @param alias Name of alias to explain.
 * @param stream PrintStream to write explanation to.
 * @throws IOException if the requested alias cannot be found.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>PrintStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;explain;[alias, "text", true, false, stream, stream, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>explain</MethodName>
            <MethodComment>/** 
 * Provide information on how a pig query will be executed.
 * @param alias Name of alias to explain.
 * @param format Format in which the explain should be printed.  If text, then the plan willbe printed in plain text.  Otherwise, the execution plan will be printed in &lt;a href="http://en.wikipedia.org/wiki/DOT_language"&gt;DOT&lt;/a&gt; format.
 * @param verbose Controls the amount of information printed
 * @param markAsExecute When set will treat the explain like acall to execute in the respoect that all the pending stores are marked as complete.
 * @param lps Stream to print the logical tree
 * @param eps Stream to print the ExecutionEngine trees. If null, then will print to files
 * @param dir Directory to print ExecutionEngine trees. If null, will use eps
 * @param suffix Suffix of file names
 * @throws IOException if the requested alias cannot be found.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>format</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>verbose</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>markAsExecute</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lps</ParamName>
                    <ParamType>PrintStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>eps</ParamName>
                    <ParamType>PrintStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>suffix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>capacity</MethodName>
            <MethodComment>/** 
 * Returns the unused byte capacity of an HDFS filesystem. This value does not take into account a replication factor, as that can vary from file to file. Thus if you are using this to determine if you data set will fit in the HDFS, you need to divide the result of this call by your specific replication setting.
 * @return unused byte capacity of the file system.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fileSize</MethodName>
            <MethodComment>/** 
 * Returns the length of a file in bytes which exists in the HDFS (accounts for replication).
 * @param filename
 * @return length of the file in bytes
 * @throws IOException
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataStorage [dfs=pigContext.getDfs()]</InnerVar>
                <InnerVar>ElementDescriptor [elem=dfs.asElement(filename)]</InnerVar>
                <InnerVar>Map&lt;String,Object&gt; [stats=elem.getStatistics()]</InnerVar>
                <InnerVar>long [length=(Long)stats.get(ElementDescriptor.LENGTH_KEY)]</InnerVar>
                <InnerVar>int [replication=(Short)stats.get(ElementDescriptor.BLOCK_REPLICATION_KEY)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsFile</MethodName>
            <MethodComment>/** 
 * Test whether a file exists.
 * @param filename to test
 * @return true if file exists, false otherwise
 * @throws IOException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ElementDescriptor [elem=pigContext.getDfs().asElement(filename)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteFile</MethodName>
            <MethodComment>/** 
 * Delete a file.
 * @param filename to delete
 * @return true
 * @throws IOException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ElementDescriptor [elem=pigContext.getDfs().asElement(filename)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.RM]</InnerMethodInvoke>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.RMF]</InnerMethodInvoke>
                <InnerMethodInvoke>elem;delete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>renameFile</MethodName>
            <MethodComment>/** 
 * Rename a file.
 * @param source file to rename
 * @param target new file name
 * @return true
 * @throws IOException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.MV]</InnerMethodInvoke>
                <InnerMethodInvoke>pigContext;rename;[source, target]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mkdirs</MethodName>
            <MethodComment>/** 
 * Make a directory.
 * @param dirs directory to make
 * @return true
 * @throws IOException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dirs</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerDescriptor [container=pigContext.getDfs().asContainer(dirs)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.MKDIR]</InnerMethodInvoke>
                <InnerMethodInvoke>container;create;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>listPaths</MethodName>
            <MethodComment>/** 
 * List the contents of a directory.
 * @param dir name of directory to list
 * @return array of strings, one for each file name
 * @throws IOException
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection&lt;String&gt; [allPaths=new ArrayList&lt;String&gt;()]</InnerVar>
                <InnerVar>ContainerDescriptor [container=pigContext.getDfs().asContainer(dir)]</InnerVar>
                <InnerVar>Iterator&lt;ElementDescriptor&gt; [iter=container.iterator()]</InnerVar>
                <InnerVar>String[] [type=new String[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;validate;[PigCommandFilter.Command.LS]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliases</MethodName>
            <MethodComment>/** 
 * Return a map containing the logical plan associated with each alias.
 * @return map
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Map&lt;String,LogicalPlan&gt; [aliasPlans=new HashMap&lt;String,LogicalPlan&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shutdown</MethodName>
            <MethodComment>/** 
 * Reclaims resources used by this instance of PigServer. This method deletes all temporary files generated by the current thread while executing Pig commands.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>FileLocalizer;deleteTempFiles;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasKeySet</MethodName>
            <MethodComment>/** 
 * Get the set of all current aliases.
 * @return set
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExamples</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Operator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExampleGenerator [exgen=new ExampleGenerator(currDAG.lp,pigContext)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printHistory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>withNumbers</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [sc=currDAG.getScriptCache()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildStorePlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currDAG;parseQuery;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;buildPlan;[alias]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;compile;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Compile and execute the current plan.
 * @return
 * @throws IOException
 */
</MethodComment>
            <ReturnType>PigStats</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PigStats [stats=executeCompiledLogicalPlan()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pigContext.getProperties();setProperty;[PigContext.JOB_NAME, jobName]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;countExecutedStores;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;compile;[]</InnerMethodInvoke>
                <InnerMethodInvoke>pigContext.getProperties();setProperty;["pig.logical.plan.signature", currDAG.lp.getSignature()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeCompiledLogicalPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PigStats</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ScriptState.get();setScriptFeatures;[currDAG.lp]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG.lp;optimize;[pigContext]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>launchPlan</MethodName>
            <MethodComment>/** 
 * A common method for launching the jobs according to the logical plan
 * @param lp The logical plan
 * @param jobName A String containing the job name to be used
 * @return The PigStats object
 * @throws ExecException
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>PigStats</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lp</ParamName>
                    <ParamType>LogicalPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jobName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PigStats [stats=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildLp</MethodName>
            <MethodComment>/** 
 * NOTE: For testing only. Don't use.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>LogicalPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currDAG;buildPlan;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;compile;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperatorForAlias</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalRelationalOperator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalRelationalOperator [op=(LogicalRelationalOperator)currDAG.getOperator(alias)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;buildStorePlan;[alias]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogicalPlanData</MethodName>
            <MethodComment>/** 
 * Returns data associated with LogicalPlan. It makes sense to call this method only after a query/script has been registered with one of the  {@link #registerQuery(String)}or  {@link #registerScript(InputStream)} methods.
 * @return LogicalPlanData
 */
</MethodComment>
            <ReturnType>LogicalPlanData</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Graph</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>batchMode</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countExecutedStores</MethodName>
            <MethodComment>/** 
 * Call back method for counting executed stores.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;LOStore&gt; [sinks=Util.getLogicalRelationalOperators(lp,LOStore.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalRelationalOperator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasOp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBatchOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBatchEmpty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsExecuted</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogicalPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperator</MethodName>
            <MethodComment>/** 
 * Get the operator with the given alias in the raw plan. Null if not found.
 */
</MethodComment>
            <ReturnType>Operator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalPlan</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalPlan [plan=lp]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildPlan</MethodName>
            <MethodComment>/** 
 * Build a plan for the given alias. Extra branches and child branch under alias will be ignored. Dependent branch (i.e. scalar) will be kept.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Queue&lt;Operator&gt; [queue=new LinkedList&lt;Operator&gt;()]</InnerVar>
                <InnerVar>LogicalPlan [plan=new LogicalPlan()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalExpressionVisitor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exprPlan</ParamName>
                    <ParamType>LogicalExpressionPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>ScalarExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Operator [refOp=expr.getImplicitReferencedOperator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipStores</MethodName>
            <MethodComment>/** 
 * Remove stores that have been executed previously from the overall plan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;LOStore&gt; [sinks=Util.getLogicalRelationalOperators(lp,LOStore.class)]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [sinksToRemove=new ArrayList&lt;Operator&gt;()]</InnerVar>
                <InnerVar>int [skipCount=processedStores]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeToLoad</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toRemove</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [successors=lp.getSuccessors(toRemove)]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [succToRemove=new ArrayList&lt;Operator&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerQuery</MethodName>
            <MethodComment>/** 
 * Accumulate the given statement to previous query statements and generate an overall (raw) plan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>query</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validateEachStatement</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>skipParseForBatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;parseQuery;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateQuery</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [query=buildQuery()]</InnerVar>
                <InnerVar>QueryParserDriver [parserDriver=new QueryParserDriver(pigContext,scope,fileNameMap)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScriptCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQuery</MethodName>
            <MethodComment>/** 
 * Parse the accumulated pig statements and generate an overall plan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [query=buildQuery()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>UDFContext.getUDFContext();reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>UDFContext.getUDFContext();setClientSystemProps;[pigContext.getProperties()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastRel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildQuery</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [accuQuery=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lp;validate;[pigContext, scope, false]</InnerMethodInvoke>
                <InnerMethodInvoke>currDAG;postProcess;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postProcess</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;LOLoad&gt; [loadOps=new HashSet&lt;LOLoad&gt;()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [sources=lp.getSources()]</InnerVar>
                <InnerVar>Set&lt;LOStore&gt; [storeOps=new HashSet&lt;LOStore&gt;()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [sinks=lp.getSinks()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkDuplicateStoreLoc</MethodName>
            <MethodComment>/** 
 * This method checks whether the multiple sinks (STORE) use the same "file-based" location. If yes, throws a RuntimeException
 * @param storeOps
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>storeOps</ParamName>
                    <ParamType>LOStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;String&gt; [uniqueStoreLoc=new HashSet&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>duplicate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Graph</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [lineNumber=1]</InnerVar>
                <InnerVar>Graph [graph=new Graph(isBatchOn())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValidateEachStatement</MethodName>
            <MethodComment>/** 
 * This can be called to indicate if the query is being parsed/compiled in a mode that expects each statement to be validated as it is entered, instead of just doing it once for whole script.
 * @param validateEachStatement
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>validateEachStatement</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSkipParseInRegisterForBatch</MethodName>
            <MethodComment>/** 
 * Set whether to skip parsing while registering the query in batch mode
 * @param skipParseInRegisterForBatch
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>skipParseInRegisterForBatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastRel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDebugOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJobName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJobPriority</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>