<Class>
    <Id>1255</Id>
    <Package>org.apache.pig.newplan.optimizer</Package>
    <ClassName>Rule</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Rule  /** 
 * Rules describe a pattern of operators.  They also reference a Transformer. If the pattern of operators is found one or more times in the provided plan, then the optimizer will use the associated Transformer to transform the plan. Note: the pattern matching logic implemented here has a limitation  that it assumes that all the leaves in the pattern are siblings. See more  detailed description here - https://issues.apache.org/jira/browse/PIG-1742 If new rules use patterns that don't work with this limitation, the pattern match logic will need to be updated. 
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>name</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>pattern</FieldName>
            <FieldType>OperatorPlan</FieldType>
        </Field>
        <Field>
            <FieldName>currentPlan</FieldName>
            <FieldType>OperatorPlan</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>matchedNodes</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>matchedNodes</FieldName>
            <FieldType>Operator</FieldType>
        </Field>
        <Field>
            <FieldName>mandatory</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>skipListener</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>Rule</MethodName>
            <MethodComment>/** 
 * Create this rule by using the default pattern that this rule provided
 * @param n Name of this rule
 * @param mandatory if it is set to false, this rule can be disabled by user
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mandatory</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Rule</MethodName>
            <MethodComment>/** 
 * @param n Name of this rule
 * @param p Pattern to look for.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildPattern</MethodName>
            <MethodComment>/** 
 * Build the pattern that this rule will look for
 * @return  the pattern to look for by this rule
 */
</MethodComment>
            <ReturnType>OperatorPlan</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewTransformer</MethodName>
            <MethodComment>/** 
 * Get the transformer for this rule.  Abstract because the rule may want to choose how to instantiate the transformer.   This should never return a cached transformer, it should always return a fresh one with no state.
 * @return Transformer to use with this rule
 */
</MethodComment>
            <ReturnType>Transformer</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPattern</MethodName>
            <MethodComment>/** 
 * Return the pattern to be matched for this rule
 * @return the pattern to be matched for this rule
 */
</MethodComment>
            <ReturnType>OperatorPlan</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSkipListener</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSkipListener</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>skip</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>match</MethodName>
            <MethodComment>/** 
 * Search for all the sub-plans that matches the pattern defined by this rule.  See class description above for limitations on the patterns supported.
 * @return A list of all matched sub-plans. The returned plans arepartial views of the original OperatorPlan. Each is a  sub-set of the original plan and represents the same topology as the pattern, but operators in the returned plan   are the same objects as the original plan. Therefore,  a call getPlan() from any node in the return plan would  return the original plan.
 * @param plan the OperatorPlan to look for matches to the pattern
 */
</MethodComment>
            <ReturnType>OperatorPlan</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [leaves=pattern.getSinks()]</InnerVar>
                <InnerVar>Iterator&lt;Operator&gt; [iter=plan.getOperators()]</InnerVar>
                <InnerVar>List&lt;OperatorPlan&gt; [matchedList=new ArrayList&lt;OperatorPlan&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>matchedNodes;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isMandatory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>match</MethodName>
            <MethodComment>/** 
 * Check if two operators match each other, we want to find matches that don't share nodes
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>planNode</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>patternNode</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PatternMatchOperatorPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>basePlan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>check</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>planOps</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [patternOps=pattern.getSinks()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>check</MethodName>
            <MethodComment>/** 
 * Check if the plan operator and its sub-tree has a match to the pattern  operator and its sub-tree. This algorithm only search and return one match. It doesn't recursively search for all possible matches. For example, for a plan that looks like join /     \ load   load if we are looking for join-&gt;load pattern, only one match will be returned instead of two, so that the matched subsets don't share nodes.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>planOp</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>patternOp</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>opers</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [preds1=getBasePlan().getPredecessors(planOp)]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [preds2=pattern.getPredecessors(patternOp)]</InnerVar>
                <InnerVar>int [index=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>