<Class>
    <Id>886</Id>
    <Package>org.apache.pig</Package>
    <ClassName>EvalFunc</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EvalFunc  /** 
 * The class is used to implement functions to be applied to fields in a dataset. The function is applied to each Tuple in the set. The programmer should not make assumptions about state maintained between invocations of the exec() method since the Pig runtime will schedule and localize invocations based on information provided at runtime.  The programmer also should not make assumptions about when or how many times the class will be instantiated, since it may be instantiated multiple times in both the front and back end.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>reporter</FieldName>
            <FieldType>PigProgressable</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>pigLogger</FieldName>
            <FieldType>PigLogger</FieldType>
        </Field>
        <Field>
            <FieldName>nextSchemaId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>returnType</FieldName>
            <FieldType>Type</FieldType>
        </Field>
        <Field>
            <FieldName>inputSchemaInternal</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getSchemaName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [alias=name + "_"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>EvalFunc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Map&lt;TypeVariable&lt;?&gt;,Type&gt; [typesByTypeVariable=new HashMap&lt;TypeVariable&lt;?&gt;,Type&gt;()]</InnerVar>
                <InnerVar>Class&lt;?&gt; [cls=getClass()]</InnerVar>
                <InnerVar>Type [type=cls.getGenericSuperclass()]</InnerVar>
                <InnerVar>Type [targetType=EvalFunc.class.getTypeParameters()[0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReturnTypeFromSpec</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Type</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpec</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReturnType</MethodName>
            <MethodComment>/** 
 * Get the Type that this EvalFunc returns.
 * @return Type
 */
</MethodComment>
            <ReturnType>Type</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>progress</MethodName>
            <MethodComment>/** 
 * Utility method to allow UDF to report progress.  If exec will take more than a a few seconds  {@link PigProgressable#progress} should be calledoccasionally to avoid timeouts.  Default Hadoop timeout is 600 seconds.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>warn</MethodName>
            <MethodComment>/** 
 * Issue a warning.  Warning messages are aggregated and reported to the user.
 * @param msg String message of the warning
 * @param warningEnum type of warning
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>warningEnum</ParamName>
                    <ParamType>Enum</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment>/** 
 * Placeholder for cleanup to be performed at the end. User defined functions can override. Default implementation is a no-op.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>exec</MethodName>
            <MethodComment>/** 
 * This callback method must be implemented by all subclasses. This is the method that will be invoked on every Tuple of a given dataset. Since the dataset may be divided up in a variety of ways the programmer should not make assumptions about state that is maintained between invocations of this method.
 * @param input the Tuple to be processed.
 * @return result, of type T.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>outputSchema</MethodName>
            <MethodComment>/** 
 * Report the schema of the output of this UDF.  Pig will make use of this in error checking, optimization, and planning.  The schema of input data to this UDF is provided. &lt;p&gt; The default implementation interprets the  {@link OutputSchema} annotation,if one is present. Otherwise, it returns &lt;code&gt;null&lt;/code&gt; (no known output schema).
 * @param input Schema of the input
 * @return Schema of the output
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OutputSchema [schema=this.getClass().getAnnotation(OutputSchema.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAsynchronous</MethodName>
            <MethodComment>/** 
 * This function should be overriden to return true for functions that return their values asynchronously.  Currently pig never attempts to execute a function asynchronously.
 * @return true if the function can be executed asynchronously.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReporter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PigProgressable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReporter</MethodName>
            <MethodComment>/** 
 * Set the reporter.  Called by Pig to provide a reference of the reporter to the UDF.
 * @param reporter Hadoop reporter
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reporter</ParamName>
                    <ParamType>PigProgressable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getArgToFuncMapping</MethodName>
            <MethodComment>/** 
 * Allow a UDF to specify type specific implementations of itself.  For example, an implementation of arithmetic sum might have int and float implementations, since integer arithmetic performs much better than floating point arithmetic.  Pig's typechecker will call this method and using the returned list plus the schema of the function's input data, decide which implementation of the UDF to use.
 * @return A List containing FuncSpec objects representing the EvalFunc classwhich can handle the inputs corresponding to the schema in the objects.  Each FuncSpec should be constructed with a schema that describes the input for that implementation.  For example, the sum function above would return two elements in its list: &lt;ol&gt; &lt;li&gt;FuncSpec(this.getClass().getName(), new Schema(new Schema.FieldSchema(null, DataType.DOUBLE))) &lt;li&gt;FuncSpec(IntSum.getClass().getName(), new Schema(new Schema.FieldSchema(null, DataType.INTEGER))) &lt;/ol&gt; This would indicate that the main implementation is used for doubles, and the special implementation IntSum is used for ints.
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCacheFiles</MethodName>
            <MethodComment>/** 
 * Allow a UDF to specify a list of hdfs files it would like placed in the distributed cache.  These files will be put in the cache for every job the UDF is used in. The default implementation returns null.
 * @return A list of files
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getShipFiles</MethodName>
            <MethodComment>/** 
 * Allow a UDF to specify a list of local files it would like placed in the distributed cache. These files will be put in the cache for every job the UDF is used in. Check for {@link FuncUtils} for utility function to facilitate itThe default implementation returns null.
 * @return A list of files
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPigLogger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PigLogger</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPigLogger</MethodName>
            <MethodComment>/** 
 * Set the PigLogger object.  Called by Pig to provide a reference to the UDF.
 * @param pigLogger PigLogger object.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pigLogger</ParamName>
                    <ParamType>PigLogger</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Log</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUDFContextSignature</MethodName>
            <MethodComment>/** 
 * This method will be called by Pig both in the front end and back end to pass a unique signature to the  {@link EvalFunc}. The signature can be used to store into the  {@link UDFContext} any information which the{@link EvalFunc} needs to store between various method invocations in thefront end and back end.
 * @param signature a unique signature to identify this EvalFunc
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>signature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInputSchema</MethodName>
            <MethodComment>/** 
 * This method is for internal use. It is called by Pig core in both front-end and back-end to setup the right input schema for EvalFunc
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInputSchema</MethodName>
            <MethodComment>/** 
 * This method is intended to be called by the user in  {@link EvalFunc} to get the inputschema of the EvalFunc
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaType</MethodName>
            <MethodComment>/** 
 * Returns the  {@link SchemaType} of the EvalFunc. User defined functions can overridethis method to return  {@link SchemaType#VARARG}. In this case the last FieldSchema added to the Schema in  {@link #getArgToFuncMapping()} will be considered as a vararg field.
 * @return the schema type of the UDF
 */
</MethodComment>
            <ReturnType>SchemaType</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allowCompileTimeCalculation</MethodName>
            <MethodComment>/** 
 * Whether the UDF should be evaluated at compile time if all inputs are constant. This is applicable for most UDF, however, if a UDF will access hdfs file which is not available at compile time, it has to be false
 * @return Whether or not compile time calculation is allowed, default to falseto ensure legacy UDF will get the right behavior
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needEndOfAllInputProcessing</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEndOfAllInput</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>endOfAllInput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLoadCaster</MethodName>
            <MethodComment>/** 
 * This will be called on both the front end and the back end during execution.
 * @return the {@link LoadCaster} associated with this eval. Returning nullindicates that casts from bytearray will pick the one associated with the parameters when they all come from the same loadcaster type.
 * @throws IOException if there is an exception during LoadCaster
 */
</MethodComment>
            <ReturnType>LoadCaster</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>