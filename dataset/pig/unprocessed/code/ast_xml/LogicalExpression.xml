<Class>
    <Id>656</Id>
    <Package>org.apache.pig.newplan.logical.expression</Package>
    <ClassName>LogicalExpression</ClassName>
    <SuperClass>Operator</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LogicalExpression  /** 
 * Logical representation of expression operators.  Expression operators have a data type and a uid.  Uid is a unique id for each expression.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>nextUid</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>fieldSchema</FieldName>
            <FieldType>LogicalSchema.LogicalFieldSchema</FieldType>
        </Field>
        <Field>
            <FieldName>uidOnlyFieldSchema</FieldName>
            <FieldType>LogicalSchema.LogicalFieldSchema</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getNextUid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetNextUid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LogicalExpression</MethodName>
            <MethodComment>/** 
 * @param name of the operator
 * @param plan LogicalExpressionPlan this is part of
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasFieldSchema</MethodName>
            <MethodComment>/** 
 * This is a convenience method to avoid the side-effectful nature of getFieldSchema(). It simply returns whether or not fieldSchema is currently null.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldSchema</MethodName>
            <MethodComment>/** 
 * Get the field schema for the output of this expression operator.  This does not merely return the field schema variable.  If schema is not yet set, this will attempt to construct it.  Therefore it is abstract since each operator will need to construct its field schema differently.
 * @return the FieldSchema
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>LogicalSchema.LogicalFieldSchema</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetFieldSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment>/** 
 * Get the data type for this expression.
 * @return data type, one of the static bytes of DataType
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [msg=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>msg;append;["(Name: " + name + " Type: "]</InnerMethodInvoke>
                <InnerMethodInvoke>msg;append;[" Uid: "]</InnerMethodInvoke>
                <InnerMethodInvoke>msg;append;[")"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>neverUseForRealSetFieldSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deepCopy</MethodName>
            <MethodComment>/** 
 * Create the deep copy of this expression and add that into the passed LogicalExpressionPlan Return the copy of this expression with updated logical expression plan.
 * @param lgExpPlan LogicalExpressionPlan in which this expression will be added.
 * @return LogicalExpression with its own logical expression plan.
 * @throws IOException.
 */
</MethodComment>
            <ReturnType>LogicalExpression</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lgExpPlan</ParamName>
                    <ParamType>LogicalExpressionPlan</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetUid</MethodName>
            <MethodComment>/** 
 * Erase all cached uid, regenerate uid when we regenerating schema. This process currently only used in ImplicitSplitInsert, which will insert split and invalidate some uids in plan
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>