<Class>
    <Id>393</Id>
    <Package>org.apache.pig.data</Package>
    <ClassName>DataType</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataType  /** 
 * A class of static final values used to encode data type and a number of static helper functions for manipulating data objects.  The data type values could be done as an enumeration, but it is done as byte codes instead to save creating objects.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>UNKNOWN</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>NULL</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BYTE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>INTEGER</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>LONG</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>FLOAT</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>DATETIME</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BYTEARRAY</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>CHARARRAY</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BIGINTEGER</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BIGDECIMAL</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BIGCHARARRAY</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>MAP</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>TUPLE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>BAG</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>GENERIC_WRITABLECOMPARABLE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>INTERNALMAP</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>ERROR</FieldName>
            <FieldType>byte</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>findType</MethodName>
            <MethodComment>/** 
 * Determine the datatype of an object.
 * @param o Object to test.
 * @return byte code of the type, or ERROR if we don't know.
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findType</MethodName>
            <MethodComment>/** 
 * Given a Type object determine the data type it represents.  This isn't cheap, as it uses reflection, so use sparingly.
 * @param t Type to examine
 * @return byte code of the type, or ERROR if we don't know.
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractTypeFromClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [c=(Class)t]</InnerVar>
                <InnerVar>Class[] [ioeInterfaces=c.getInterfaces()]</InnerVar>
                <InnerVar>Class[] [interfaces=null]</InnerVar>
                <InnerVar>boolean [matchedWritableComparable=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numTypes</MethodName>
            <MethodComment>/** 
 * Return the number of types Pig knows about.
 * @return number of types
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [types=genAllTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genAllTypes</MethodName>
            <MethodComment>/** 
 * Get an array of all type values.
 * @return byte array with an entry for each type.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [types={DataType.BAG,DataType.BIGCHARARRAY,DataType.BOOLEAN,DataType.BYTE,DataType.BYTEARRAY,DataType.CHARARRAY,DataType.DOUBLE,DataType.FLOAT,DataType.DATETIME,DataType.GENERIC_WRITABLECOMPARABLE,DataType.INTEGER,DataType.INTERNALMAP,DataType.LONG,DataType.MAP,DataType.TUPLE,DataType.BIGINTEGER,DataType.BIGDECIMAL}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genAllTypeNames</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String[] [names={"BAG","BIGCHARARRAY","BOOLEAN","BYTE","BYTEARRAY","CHARARRAY","DOUBLE","FLOAT","DATETIME","GENERIC_WRITABLECOMPARABLE","INTEGER","INTERNALMAP","LONG","MAP","TUPLE","BIGINTEGER","BIGDECIMAL"}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genTypeToNameMap</MethodName>
            <MethodComment>/** 
 * Get a map of type values to type names.
 * @return map
 */
</MethodComment>
            <ReturnType>Byte</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [types=genAllTypes()]</InnerVar>
                <InnerVar>String[] [names=genAllTypeNames()]</InnerVar>
                <InnerVar>Map&lt;Byte,String&gt; [ret=new HashMap&lt;Byte,String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genNameToTypeMap</MethodName>
            <MethodComment>/** 
 * Get a map of type names to type values.
 * @return map
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [types=genAllTypes()]</InnerVar>
                <InnerVar>String[] [names=genAllTypeNames()]</InnerVar>
                <InnerVar>Map&lt;String,Byte&gt; [ret=new HashMap&lt;String,Byte&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTypeName</MethodName>
            <MethodComment>/** 
 * Get the type name.
 * @param o Object to test.
 * @return type name, as a String.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTypeName</MethodName>
            <MethodComment>/** 
 * Get the type name from the type byte code
 * @param dt Type byte code
 * @return type name, as a String.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dt</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTypeClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dt</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTypeByName</MethodName>
            <MethodComment>/** 
 * Get the type code from the type name 
 * @param name Type name
 * @return type code
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isComplex</MethodName>
            <MethodComment>/** 
 * Determine whether the this data type is complex.
 * @param dataType Data type code to test.
 * @return true if dataType is bag, tuple, or map.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isComplex</MethodName>
            <MethodComment>/** 
 * Determine whether the object is complex or atomic.
 * @param o Object to determine type of.
 * @return true if dataType is bag, tuple, or map.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAtomic</MethodName>
            <MethodComment>/** 
 * Determine whether the this data type is atomic.
 * @param dataType Data type code to test.
 * @return true if dataType is bytearray, bigchararray, chararray, integer, long,float, or boolean.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAtomic</MethodName>
            <MethodComment>/** 
 * Determine whether the this data type is atomic.
 * @param o Object to determine type of.
 * @return true if dataType is bytearray, chararray, integer, long,float, or boolean.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSchemaType</MethodName>
            <MethodComment>/** 
 * Determine whether the this object can have a schema.
 * @param o Object to determine if it has a schema
 * @return true if the type can have a valid schema (i.e., bag or tuple)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSchemaType</MethodName>
            <MethodComment>/** 
 * Determine whether the this data type can have a schema.
 * @param dataType dataType to determine if it has a schema
 * @return true if the type can have a valid schema (i.e., bag or tuple)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * / Compare two objects to each other.  This function is necessary because there's no super class that implements compareTo.  This function provides an (arbitrary) ordering of objects of different types as follows:  NULL &amp;lt; BOOLEAN &amp;lt; BYTE &amp;lt; INTEGER &amp;lt; LONG &amp;lt; FLOAT &amp;lt; DOUBLE &amp;lt; DATETIME &amp;lt; BYTEARRAY &amp;lt; STRING &amp;lt; MAP &amp;lt; TUPLE &amp;lt; BAG.  No other functions should implement this cross object logic.  They should call this function for it instead.
 * @param o1 First object
 * @param o2 Second object
 * @return -1 if o1 is less, 0 if they are equal, 1 if o2 is less.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [dt1=findType(o1)]</InnerVar>
                <InnerVar>byte [dt2=findType(o2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * Same as  {@link #compare(Object,Object)}, but does not use reflection to determine the type of passed in objects, relying instead on the caller to provide the appropriate values, as determined by  {@link DataType#findType(Object)}. Use this version in cases where multiple objects of the same type have to be repeatedly compared.
 * @param o1 first object
 * @param o2 second object
 * @param dt1 type, as byte value, of o1
 * @param dt2 type, as byte value, of o2
 * @return -1 if o1 is &amp;lt; o2, 0 if they are equal, 1 if o1 &amp;gt; o2
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dt1</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dt2</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBoolean</MethodName>
            <MethodComment>/** 
 * Force a data object to a Boolean, if possible. Any numeric type can be forced to a Boolean, as well as CharArray, ByteArray. Complex types cannot be forced to a Boolean. This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Boolean you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a Boolean.
 * @throws ExecException if the type can't be forced to a Boolean.
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBoolean</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toInteger</MethodName>
            <MethodComment>/** 
 * Force a data object to an Integer, if possible.  Any numeric type can be forced to an Integer (though precision may be lost), as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to an Integer.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is an Integer you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as an Integer.
 * @throws ExecException if the type can't be forced to an Integer.
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toInteger</MethodName>
            <MethodComment>/** 
 * Force a data object to an Integer, if possible.  Any numeric type can be forced to an Integer (though precision may be lost), as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to an Integer.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is an Integer you should just cast it.  Unlike  {@link #toInteger(Object,byte)} thismethod will first determine the type of o and then do the cast. Use  {@link #toInteger(Object,byte)} if you already know the type.
 * @param o object to cast
 * @return The object as an Integer.
 * @throws ExecException if the type can't be forced to an Integer.
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toLong</MethodName>
            <MethodComment>/** 
 * Force a data object to a Long, if possible.  Any numeric type can be forced to a Long (though precision may be lost), as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to a Long.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Long you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a Long.
 * @throws ExecException if the type can't be forced to a Long.
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toLong</MethodName>
            <MethodComment>/** 
 * Force a data object to a Long, if possible.  Any numeric type can be forced to a Long (though precision may be lost), as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to an Long.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Long you should just cast it.  Unlike  {@link #toLong(Object,byte)} thismethod will first determine the type of o and then do the cast. Use  {@link #toLong(Object,byte)} if you already know the type.
 * @param o object to cast
 * @return The object as a Long.
 * @throws ExecException if the type can't be forced to an Long.
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toFloat</MethodName>
            <MethodComment>/** 
 * Force a data object to a Float, if possible.  Any numeric type can be forced to a Float (though precision may be lost), as well as CharArray, ByteArray.  Complex types cannot be forced to a Float.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Float you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a Float.
 * @throws ExecException if the type can't be forced to a Float.
 */
</MethodComment>
            <ReturnType>Float</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toFloat</MethodName>
            <MethodComment>/** 
 * Force a data object to a Float, if possible.  Any numeric type can be forced to a Float (though precision may be lost), as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to an Float.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Float you should just cast it.  Unlike  {@link #toFloat(Object,byte)} thismethod will first determine the type of o and then do the cast. Use  {@link #toFloat(Object,byte)} if you already know the type.
 * @param o object to cast
 * @return The object as a Float.
 * @throws ExecException if the type can't be forced to an Float.
 */
</MethodComment>
            <ReturnType>Float</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDouble</MethodName>
            <MethodComment>/** 
 * Force a data object to a Double, if possible.  Any numeric type can be forced to a Double, as well as CharArray, ByteArray.  Complex types cannot be forced to a Double.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Double you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a Double.
 * @throws ExecException if the type can't be forced to a Double.
 */
</MethodComment>
            <ReturnType>Double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDateTime</MethodName>
            <MethodComment>/** 
 * Force a data object to a DateTime, if possible. Only CharArray, ByteArray can be forced to a DateTime. Numeric types and complex types cannot be forced to a DateTime. This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a DateTime you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a Boolean.
 * @throws ExecException if the type can't be forced to a Boolean.
 */
</MethodComment>
            <ReturnType>DateTime</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDateTime</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DateTime</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDouble</MethodName>
            <MethodComment>/** 
 * Force a data object to a Double, if possible.  Any numeric type can be forced to a Double, as well as CharArray, ByteArray, or Boolean.  Complex types cannot be forced to an Double.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Double you should just cast it.  Unlike  {@link #toDouble(Object,byte)} thismethod will first determine the type of o and then do the cast. Use  {@link #toDouble(Object,byte)} if you already know the type.
 * @param o object to cast
 * @return The object as a Double.
 * @throws ExecException if the type can't be forced to an Double.
 */
</MethodComment>
            <ReturnType>Double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBigInteger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BigInteger</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBigInteger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BigInteger</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBigDecimal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BigDecimal</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBigDecimal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BigDecimal</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Force a data object to a String, if possible.  Any simple (atomic) type can be forced to a String including ByteArray.  Complex types cannot be forced to a String.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a String you should just cast it.
 * @param o object to cast
 * @param type of the object you are casting
 * @return The object as a String.
 * @throws ExecException if the type can't be forced to a String.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Force a data object to a String, if possible.  Any simple (atomic) type can be forced to a String including ByteArray.  Complex types cannot be forced to a String.  This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a String you should just cast it.  Unlike  {@link #toString(Object,byte)} thismethod will first determine the type of o and then do the cast. Use  {@link #toString(Object,byte)} if you already know the type.
 * @param o object to cast
 * @return The object as a String.
 * @throws ExecException if the type can't be forced to a String.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toMap</MethodName>
            <MethodComment>/** 
 * If this object is a map, return it as a map. This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Map you should just cast it.
 * @param o object to cast
 * @return The object as a Map.
 * @throws ExecException if the type can't be forced to a Double.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toTuple</MethodName>
            <MethodComment>/** 
 * If this object is a tuple, return it as a tuple. This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a Tuple you should just cast it.
 * @param o object to cast
 * @return The object as a Double.
 * @throws ExecException if the type can't be forced to a Double.
 */
</MethodComment>
            <ReturnType>Tuple</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toBag</MethodName>
            <MethodComment>/** 
 * If this object is a bag, return it as a bag. This isn't particularly efficient, so if you already &lt;b&gt;know&lt;/b&gt; that the object you have is a bag you should just cast it.
 * @param o object to cast
 * @return The object as a Double.
 * @throws ExecException if the type can't be forced to a Double.
 */
</MethodComment>
            <ReturnType>DataBag</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spillTupleContents</MethodName>
            <MethodComment>/** 
 * Purely for debugging
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>label</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;Object&gt; [i=t.getAll().iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System.out;print;["Tuple " + label + " "]</InnerMethodInvoke>
                <InnerMethodInvoke>System.out;println;[t.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNumberType</MethodName>
            <MethodComment>/** 
 * Determine if this type is a numeric type.
 * @param t type (as byte value) to test
 * @return true if this is a numeric type, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUsableType</MethodName>
            <MethodComment>/** 
 * Determine if this is a type that can work can be done on.
 * @param t type (as a byte value) to test
 * @return false if the type is unknown, null, or error; true otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castable</MethodName>
            <MethodComment>/** 
 * Test if one type can cast to the other.
 * @param castType data type of the cast type
 * @param inputType data type of the input
 * @return true or false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>castType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeType</MethodName>
            <MethodComment>/** 
 * Merge types if possible.  Merging types means finding a type that one or both types can be upcast to.
 * @param type1
 * @param type2
 * @return the merged type, or DataType.ERROR if not successful
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type1</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type2</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapToString</MethodName>
            <MethodComment>/** 
 * Given a map, turn it into a String.
 * @param m map
 * @return string representation of the map
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>m</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [hasNext=false]</InnerVar>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;["["]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["]"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalByteArrays</MethodName>
            <MethodComment>/** 
 * Test whether two byte arrays (Java byte arrays not Pig byte arrays) are equal.  I have no idea why we have this function.
 * @param lhs byte array 1
 * @param rhs byte array 2
 * @return true if both are null or the two are the same length and havethe same bytes.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lhs</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rhs</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>determineFieldSchema</MethodName>
            <MethodComment>/** 
 * Utility method that determines the schema from the passed in dataType. If the dataType is Bag or Tuple, then we need to determine the schemas inside this dataType; for this we iterate through the fields inside this field. This method works both for raw objects and ResourceSchema.ResourceFieldSchema field descriptions; the specific behavior is determined by the klass parameter.
 * @param dataType  DataType.CHARARRAY, DataType.TUPLE, and so on
 * @param fieldIter iterator over the fields if this is a tuple or a bag
 * @param fieldNum number of fields inside the field if a tuple
 * @param klass  should be Object or ResourceSchema.ResourceFieldSchema
 * @return
 * @throws ExecException
 * @throws FrontendException
 * @throws SchemaMergeException
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldIter</ParamName>
                    <ParamType>Iterator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>klass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>FrontendException</ExceptionType>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>determineFieldSchema</MethodName>
            <MethodComment>/** 
 * Determine the field schema of an ResourceFieldSchema
 * @param rcFieldSchema the rcFieldSchema we want translated
 * @return the field schema corresponding to the object
 * @throws ExecException ,FrontendException,SchemaMergeException
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcFieldSchema</ParamName>
                    <ParamType>ResourceSchema.ResourceFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [dt=rcFieldSchema.getType()]</InnerVar>
                <InnerVar>Iterator&lt;ResourceSchema.ResourceFieldSchema&gt; [fieldIter=null]</InnerVar>
                <InnerVar>long [fieldNum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>FrontendException</ExceptionType>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>determineFieldSchema</MethodName>
            <MethodComment>/** 
 * Determine the field schema of an object
 * @param o the object whose field schema is to be determined
 * @return the field schema corresponding to the object
 * @throws ExecException ,FrontendException,SchemaMergeException
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [dt=findType(o)]</InnerVar>
                <InnerVar>Iterator [fieldIter=null]</InnerVar>
                <InnerVar>long [fieldNum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ExecException</ExceptionType>
                <ExceptionType>FrontendException</ExceptionType>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>