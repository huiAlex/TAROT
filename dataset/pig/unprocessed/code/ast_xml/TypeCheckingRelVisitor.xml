<Class>
    <Id>1187</Id>
    <Package>org.apache.pig.newplan.logical.visitor</Package>
    <ClassName>TypeCheckingRelVisitor</ClassName>
    <SuperClass>LogicalRelationalNodesVisitor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>msgCollector</FieldName>
            <FieldType>CompilationMessageCollector</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>TypeCheckingRelVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msgCollector</ParamName>
                    <ParamType>CompilationMessageCollector</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>load</ParamName>
                    <ParamType>LOLoad</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>store</ParamName>
                    <ParamType>LOStore</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>store;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>store;getSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * The schema of filter output will be the same as filter input
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>LOFilter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpressionPlan [comparisonPlan=filter.getFilterPlan()]</InnerVar>
                <InnerVar>byte [innerCondType=((LogicalExpression)comparisonPlan.getSources().get(0)).getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>filter;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitExpressionPlan;[comparisonPlan, filter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwTypeCheckerException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fe</ParamName>
                    <ParamType>FrontendException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>TypeCheckerException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gen</ParamName>
                    <ParamType>LOGenerate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>gen;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>gen;getSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>innerLoad</ParamName>
                    <ParamType>LOInnerLoad</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>innerLoad;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>innerLoad;getSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forEach</ParamName>
                    <ParamType>LOForEach</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitExpressionPlan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>explPlan</ParamName>
                    <ParamType>LogicalExpressionPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeCheckingExpVisitor [expTypeCheck=new TypeCheckingExpVisitor(explPlan,msgCollector,relOp)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expTypeCheck;visit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>u</ParamName>
                    <ParamType>LOUnion</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [inputs=new ArrayList&lt;Operator&gt;(u.getInputs())]</InnerVar>
                <InnerVar>LogicalSchema [schema=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>u;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>u;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>u;getSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCastForEachInBetweenIfNecessary</MethodName>
            <MethodComment>/** 
 * For casting insertion for relational operators only if it's necessary Currently this only does "shallow" casting
 * @param fromOp
 * @param toOp
 * @return the inserted operator. null is no insertion
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>LOForEach</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [preList=plan.getPredecessors(toOp)]</InnerVar>
                <InnerVar>boolean [found=false]</InnerVar>
                <InnerVar>LogicalSchema [fromSchema=null]</InnerVar>
                <InnerVar>LogicalSchema [toSchema=null]</InnerVar>
                <InnerVar>ArrayList&lt;LogicalExpressionPlan&gt; [generatePlans=new ArrayList&lt;LogicalExpressionPlan&gt;()]</InnerVar>
                <InnerVar>LogicalPlan [innerPlan=new LogicalPlan()]</InnerVar>
                <InnerVar>LOGenerate [loGen=new LOGenerate(innerPlan,generatePlans,new boolean[toSchema.size()])]</InnerVar>
                <InnerVar>LOForEach [foreach=new LOForEach(plan)]</InnerVar>
                <InnerVar>int [castNeededCounter=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>innerPlan;add;[loGen]</InnerMethodInvoke>
                <InnerMethodInvoke>foreach;setInnerPlan;[innerPlan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>LOSplitOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OperatorPlan [lp=op.getPlan()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [list=lp.getPredecessors(op)]</InnerVar>
                <InnerVar>LogicalExpressionPlan [condPlan=op.getFilterPlan()]</InnerVar>
                <InnerVar>byte [innerCondType=((LogicalExpression)condPlan.getSources().get(0)).getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>op;resetSchema;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitExpressionPlan;[condPlan, op]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * LODistinct, output schema should be the same as input
 * @param op
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>LODistinct</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>op;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>limit</ParamName>
                    <ParamType>LOLimit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpressionPlan [expressionPlan=limit.getLimitPlan()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>limit;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * Return concatenated of all fields from all input operators If one of the inputs have no schema then we cannot construct the output schema.
 * @param cs
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cs</ParamName>
                    <ParamType>LOCross</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cs;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * The schema of sort output will be the same as sort input.
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sort</ParamName>
                    <ParamType>LOSort</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sort;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * The schema of rank output will be the same as input, plus a rank field.
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rank</ParamName>
                    <ParamType>LORank</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;LogicalExpressionPlan&gt; [rankColPlans=rank.getRankColPlans()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rank;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * The schema of split output will be the same as split input
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>split</ParamName>
                    <ParamType>LOSplit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OperatorPlan [lp=split.getPlan()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputList=lp.getPredecessors(split)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>split;resetSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * LOJoin visitor
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>join</ParamName>
                    <ParamType>LOJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MultiMap&lt;Integer,LogicalExpressionPlan&gt; [joinColPlans=join.getExpressionPlans()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputs=join.getInputs((LogicalPlan)plan)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isJoinOnMultiCols</MethodName>
            <MethodComment>/** 
 * @param join
 * @return true if there is more than one join column for an input
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>join</ParamName>
                    <ParamType>LOJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MultiMap&lt;Integer,LogicalExpressionPlan&gt; [exprPlans=join.getExpressionPlans()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAtomicJoinColType</MethodName>
            <MethodComment>/** 
 * This can be used to get the merged type of output join col only when the join col is of atomic type
 * @return The type of the join col 
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>join</ParamName>
                    <ParamType>LOJoin</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [groupType=DataType.BYTEARRAY]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAtomicColType</MethodName>
            <MethodComment>/** 
 * This can be used to get the merged type of output join col only when the join/cogroup col is of atomic type
 * @return The type of the join col 
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allExprPlans</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [groupType=DataType.BYTEARRAY]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isMultiExprPlanPerInput</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exprPlans</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAtomicCastForInnerPlan</MethodName>
            <MethodComment>/** 
 * Cast the single output operator of innerPlan to toType
 * @param innerPlan
 * @param relOp - join or cogroup
 * @param toType
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>innerPlan</ParamName>
                    <ParamType>LogicalExpressionPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Operator&gt; [outputs=innerPlan.getSources()]</InnerVar>
                <InnerVar>LogicalExpression [currentOutput=(LogicalExpression)outputs.get(0)]</InnerVar>
                <InnerVar>LogicalFieldSchema [newFS=new LogicalFieldSchema(currentOutput.getFieldSchema().alias,null,toType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>TypeCheckingExpVisitor;collectCastWarning;[relOp, currentOutput.getType(), toType, msgCollector]</InnerMethodInvoke>
                <InnerMethodInvoke>null;visitExpressionPlan;[innerPlan, relOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaFromInnerPlans</MethodName>
            <MethodComment>/** 
 * Create combined group-by/join column schema based on join/cogroup  expression plans for all inputs. This implementation is based on the assumption that all the  inputs have the same join col tuple arity.
 * @param exprPlans
 * @return
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exprPlans</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;LogicalFieldSchema&gt; [fsList=new ArrayList&lt;LogicalFieldSchema&gt;()]</InnerVar>
                <InnerVar>int [outputSchemaSize=exprPlans.get(0).size()]</InnerVar>
                <InnerVar>LogicalSchema [tupleSchema=new LogicalSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * COGroup All group by cols from all inputs have to be of the same type
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cg</ParamName>
                    <ParamType>LOCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MultiMap&lt;Integer,LogicalExpressionPlan&gt; [groupByPlans=cg.getExpressionPlans()]</InnerVar>
                <InnerVar>List&lt;Operator&gt; [inputs=cg.getInputs((LogicalPlan)plan)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCoGroupOnMultiCols</MethodName>
            <MethodComment>/** 
 * @param coGroup
 * @return true if there is more than one join column for an input
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>coGroup</ParamName>
                    <ParamType>LOCogroup</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MultiMap&lt;Integer,LogicalExpressionPlan&gt; [exprPlans=coGroup.getExpressionPlans()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>