<Class>
    <Id>501</Id>
    <Package>org.apache.pig.piggybank.storage</Package>
    <ClassName>MultiStorage</ClassName>
    <SuperClass>StoreFunc</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MultiStorage  /** 
 * The UDF is useful for splitting the output data into a bunch of directories and files dynamically based on user specified key field in the output tuple. Sample usage: &lt;code&gt; A = LOAD 'mydata' USING PigStorage() as (a, b, c); STORE A INTO '/my/home/output' USING MultiStorage('/my/home/output','0', 'bz2', '\\t'); &lt;/code&gt; Parameter details:- ========== &lt;b&gt;/my/home/output &lt;/b&gt;(Required) : The DFS path where output directories and files will be created. &lt;b&gt; 0 &lt;/b&gt;(Required) : Index of field whose values should be used to create directories and files( field 'a' in this case). &lt;b&gt;'bz2' &lt;/b&gt;(Optional) : The compression type. Default is 'none'. Supported types are:- 'none', 'gz' and 'bz2' &lt;b&gt; '\\t' &lt;/b&gt;(Optional) : Output field separator. Let 'a1', 'a2' be the unique values of field 'a'. Then output may look like this /my/home/output/a1/a1-0000 /my/home/output/a1/a1-0001 /my/home/output/a1/a1-0002 ... /my/home/output/a2/a2-0000 /my/home/output/a2/a2-0001 /my/home/output/a2/a2-0002 The prefix '0000*' is the task-id of the mapper/reducer task executing this store. In case user does a GROUP BY on the field followed by MultiStorage(), then its imperative that all tuples for a particular group will go exactly to 1 reducer. So in the above case for e.g. there will be only 1 file each under 'a1' and 'a2' directories. If the output is compressed,then the sub directories and the output files will be having the extension. Say for example in the above case if bz2 is used one file  will look like ;/my/home/output.bz2/a1.bz2/a1-0000.bz2 Key field can also be a comma separated list of indices e.g. '0,1' - in this case storage will be multi-level: /my/home/output/a1/b1/a1-b1-0000 /my/home/output/a1/b2/a1-b2-0000 There is also an option to leave key values out of storage, see isRemoveKeys.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>KEYFIELD_DELIMETER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>outputPath</FieldName>
            <FieldType>Path</FieldType>
        </Field>
        <Field>
            <FieldName>splitFieldIndices</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>splitFieldIndices</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>fieldDel</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>comp</FieldName>
            <FieldType>Compression</FieldType>
        </Field>
        <Field>
            <FieldName>isRemoveKeys</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>writer</FieldName>
            <FieldType>RecordWriter</FieldType>
        </Field>
        <Field>
            <FieldName>writer</FieldName>
            <FieldType>List&lt;String&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>keyValueSeparator</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>fieldDel</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>skipIndices</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>skipIndices</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>storeMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>storeMap</FieldName>
            <FieldType>List&lt;String&gt;</FieldType>
        </Field>
        <Field>
            <FieldName>BUFFER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>mOut</FieldName>
            <FieldType>ByteArrayOutputStream</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MultiStorage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPathStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitFieldIndex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MultiStorage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPathStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitFieldIndex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compression</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MultiStorage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPathStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitFieldIndex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compression</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldDel</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MultiStorage</MethodName>
            <MethodComment>/** 
 * Constructor
 * @param parentPathStr Parent output dir path (this will be specified in store statement, so MultiStorage don't use this parameter in reality. However, we don't want to change the construct to break backward compatibility)
 * @param splitFieldIndex key field index
 * @param compression 'bz2', 'bz', 'gz' or 'none'
 * @param fieldDel Output record field delimiter.
 * @param isRemoveKeys Removes key columns from result during write.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPathStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitFieldIndex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compression</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldDel</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRemoveKeys</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [splitFieldIndices=splitFieldIndex.split(KEYFIELD_DELIMETER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tuple</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [fields=new ArrayList&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOutputFormat</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OutputFormat</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MultiStorageOutputFormat [format=new MultiStorageOutputFormat()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>format;setKeyValueSeparator;[fieldDel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToWrite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>RecordWriter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStoreLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>job.getConfiguration();set;[MRConfiguration.TEXTOUTPUTFORMAT_SEPARATOR, ""]</InnerMethodInvoke>
                <InnerMethodInvoke>FileOutputFormat;setOutputPath;[job, new Path(location)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsParallelWriteToStoreLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>List&lt;String&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>TaskAttemptContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TaskAttemptContext [ctx=context]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>InterruptedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [sz=val.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getStore(key);write;[null, new Text(mOut.toByteArray())]</InnerMethodInvoke>
                <InnerMethodInvoke>mOut;reset;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>TaskAttemptContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MyLineRecordWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldValues</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MyLineRecordWriter [store=storeMap.get(fieldValues)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createOutputStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataOutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldValues</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Configuration [conf=ctx.getConfiguration()]</InnerVar>
                <InnerVar>TaskID [taskId=ctx.getTaskAttemptID().getTaskID()]</InnerVar>
                <InnerVar>boolean [isCompressed=getCompressOutput(ctx)]</InnerVar>
                <InnerVar>CompressionCodec [codec=null]</InnerVar>
                <InnerVar>String [extension=""]</InnerVar>
                <InnerVar>NumberFormat [nf=NumberFormat.getInstance()]</InnerVar>
                <InnerVar>StringBuffer [pathStringBuffer=new StringBuffer()]</InnerVar>
                <InnerVar>String [pathString=pathStringBuffer.toString()]</InnerVar>
                <InnerVar>String [idString=pathString.replaceAll("\\/","-")]</InnerVar>
                <InnerVar>Path [path=new Path(pathString + extension,idString + '-' + nf.format(taskId.getId())+ extension)]</InnerVar>
                <InnerVar>Path [workOutputPath=((FileOutputCommitter)getOutputCommitter(ctx)).getWorkPath()]</InnerVar>
                <InnerVar>Path [file=new Path(workOutputPath,path)]</InnerVar>
                <InnerVar>FileSystem [fs=file.getFileSystem(conf)]</InnerVar>
                <InnerVar>FSDataOutputStream [fileOut=fs.create(file,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>nf;setMinimumIntegerDigits;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>pathStringBuffer;deleteCharAt;[pathStringBuffer.length() - 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setKeyValueSeparator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sep</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSkipIndices</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>skipIndices</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MyLineRecordWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DataOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyValueSeparator</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>