<Class>
    <Id>727</Id>
    <Package>org.apache.pig.newplan.logical.relational</Package>
    <ClassName>LogicalSchema</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LogicalSchema  /** 
 * Schema, from a logical perspective.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>alias</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>type</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>uid</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>schema</FieldName>
            <FieldType>LogicalSchema</FieldType>
        </Field>
        <Field>
            <FieldName>fields</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>fields</FieldName>
            <FieldType>LogicalFieldSchema</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>LogicalFieldSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LogicalFieldSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LogicalFieldSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqual</MethodName>
            <MethodComment>/** 
 * Equality is defined as having the same type and either the same schema or both null schema.  Alias and uid are not checked.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqual</MethodName>
            <MethodComment>/** 
 * Equality is defined as having the same type and either the same schema or both null schema. if compareAlias argument is set to true, alias is also compared.
 * @param other 
 * @param compareAlias
 * @return true if equal
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compareAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>verbose</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [uidString=""]</InnerVar>
                <InnerVar>String [aliasToPrint=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stampFieldSchema</MethodName>
            <MethodComment>/** 
 * Give new value for uid if uid of field schema or those in fields schema of inner schema are -1.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compatible</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uidOnlyFieldSchema</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeMatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs1</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs2</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeUid</MethodName>
            <MethodComment>/** 
 * Adds the uid from FieldSchema argument to this FieldSchema If the argument is null, it stamps this FieldSchema with uid
 * @param uidOnlyFieldSchema
 * @return FieldSchema 
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>LogicalSchema.LogicalFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uidOnlyFieldSchema</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetUid</MethodName>
            <MethodComment>/** 
 * Rest uid of this fieldschema and inner schema
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneUid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [resultFs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deepCopy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [newFs=new LogicalFieldSchema(alias != null ? alias : null,schema != null ? schema.deepCopy() : null,type,uid)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Compare two field schema for equality
 * @param relaxInner If true, we don't check inner tuple schemas
 * @param relaxAlias If true, we don't check aliases
 * @return true if FieldSchemas are equal, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fschema</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fother</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxInner</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castable</MethodName>
            <MethodComment>/** 
 * Check if FieldSchema inFs is castable to outFs
 * @param inFs
 * @param outFs
 * @return true if it is castable
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inFs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outFs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [inType=inFs.type]</InnerVar>
                <InnerVar>byte [outType=outFs.type]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * Merge two LogicalFieldSchema, the behavior of merge depends on mode.  If mode==MergeType.LoadForEach or MergeType.LoadForEachInner, take left side if compatible, otherwise, throw exception. If mode==MergeType.UnionInner, if not same type, throw exception, end up with null inner schema. If mode==MergeType.Union, take more specific type.
 * @param fs1 In Load/Foreach, fs1 is user declared schema; in Union, fs1 is left side
 * @param fs2 In Load/Foreach, fs1 is inferred schema; in Union, fs1 is left side
 * @param mode merge mode
 */
</MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs1</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs2</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>MergeMode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [mergedAlias]</InnerVar>
                <InnerVar>byte [mergedType=DataType.UNKNOWN]</InnerVar>
                <InnerVar>LogicalSchema [mergedSubSchema=null]</InnerVar>
                <InnerVar>LogicalFieldSchema [mergedFS=new LogicalFieldSchema(mergedAlias,mergedSubSchema,mergedType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqualUnlessUnknown</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs1</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs2</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalize</MethodName>
            <MethodComment>/** 
 * Old Pig field schema does not require a tuple schema inside a bag; Now it is required to have that; this method is to fill the gap
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LogicalSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetUid</MethodName>
            <MethodComment>/** 
 * Reset uids of all fieldschema that the schema contains
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castable</MethodName>
            <MethodComment>/** 
 * Recursively compare two schemas to check if the input schema  can be cast to the cast schema
 * @param inSch schema of the cast input
 * @param outSch schema of the cast operator
 * @return true if castable
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inSch</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outSch</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;LogicalFieldSchema&gt; [i=outSch.fields.iterator()]</InnerVar>
                <InnerVar>Iterator&lt;LogicalFieldSchema&gt; [j=inSch.fields.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addField</MethodName>
            <MethodComment>/** 
 * Add a field to this schema.
 * @param field to be added to the schema
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>fields;add;[field]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Fetch a field by alias
 * @param alias
 * @return field associated with alias, or null if no such field
 * @throws FrontendException 
 */
</MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldSubNameMatch</MethodName>
            <MethodComment>/** 
 * Given an alias name, find the associated LogicalFieldSchema. If exact name is  not found see if any field matches the part of the 'namespaced' alias. eg. if given alias is nm::a , and schema is (a,b). It will return  FieldSchema of a. if given alias is nm::a and schema is (nm2::a, b), it will return null
 * @param alias Alias to look up.
 * @return LogicalFieldSchema, or null if no such alias is in this tuple.
 */
</MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [fs=getField(alias)]</InnerVar>
                <InnerVar>String [sep="::"]</InnerVar>
                <InnerVar>ArrayList&lt;LogicalFieldSchema&gt; [matchedFieldSchemas=new ArrayList&lt;LogicalFieldSchema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [fs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Fetch a field by field number
 * @param fieldNum field number to fetch
 * @return field
 */
</MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFields</MethodName>
            <MethodComment>/** 
 * Get all fields
 * @return list of all fields
 */
</MethodComment>
            <ReturnType>LogicalFieldSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Get the size of the schema.
 * @return size
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqual</MethodName>
            <MethodComment>/** 
 * Two schemas are equal if they are of equal size and their fields schemas considered in order are equal. This function does  not compare the alias of the fields.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqual</MethodName>
            <MethodComment>/** 
 * Two schemas are equal if they are of equal size and their fields schemas considered in order are equal. If compareAlias argument is  set to true, the alias of the fields are also compared.
 * @param other
 * @param compareAlias
 * @return true if equal
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compareAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findField</MethodName>
            <MethodComment>/** 
 * Look for the index of the field that contains the specified uid
 * @param uid the uid to look for
 * @return the index of the field, -1 if not found
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * Merge two schemas.
 * @param s1 In Load/ForEach, s1 is user declared schema; In Union, s1 is left side.
 * @param s2 In Load/ForEach, s2 is infered schema; In Union, s2 is right side.
 * @param mode We merge schema in Load/Foreach/Union. In Load/Foreach, we always take s1 if compatible (s1 is set to be user defined schema),In union, we take more specific type (between numeric and string, we take string). In the case type mismatch in s1/s2,  we expect TypeCheckingVisitor will fill the gap later. 
 * @return a merged schema, or null if the merge fails
 */
</MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>MergeMode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalSchema [mergedSchema=new LogicalSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEqualUnlessUnknown</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>verbose</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [str=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeUid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uidOnlySchema</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deepCopy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogicalSchema [newSchema=new LogicalSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchemasByAlias</MethodName>
            <MethodComment>/** 
 * Merges collection of schemas using their column aliases  (unlike mergeSchema(..) functions which merge using positions) Schema will not be merged if types are incompatible,  as per DataType.mergeType(..) For Tuples and Bags, SubSchemas have to be equal be considered compatible
 * @param schemas - list of schemas to be merged using their column alias
 * @return merged schema
 */
</MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemas</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalSchema [mergedSchema=null]</InnerVar>
                <InnerVar>ArrayList&lt;LogicalSchema&gt; [mergedSchemas=new ArrayList&lt;LogicalSchema&gt;(schemas.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchemaByAlias</MethodName>
            <MethodComment>/** 
 * Merges two schemas using their column aliases  (unlike mergeSchema(..) functions which merge using positions) Schema will not be merged if types are incompatible,  as per DataType.mergeType(..) For Tuples and Bags, SubSchemas have to be equal be considered compatible
 */
</MethodComment>
            <ReturnType>LogicalSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema1</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema2</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalSchema [mergedSchema=new LogicalSchema()]</InnerVar>
                <InnerVar>HashSet&lt;LogicalFieldSchema&gt; [schema2colsAdded=new HashSet&lt;LogicalFieldSchema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkNullAlias</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeNameSpacedAlias</MethodName>
            <MethodComment>/** 
 * If one of the aliases is of form 'nm::str1', and other is of the form 'str1', this returns str1
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alias2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Recursively compare two schemas for equality
 * @param schema
 * @param other
 * @param relaxInner if true, inner schemas will not be checked
 * @param relaxAlias if true, aliases will not be checked
 * @return true if schemas are equal, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>LogicalSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxInner</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;LogicalFieldSchema&gt; [i=schema.fields.iterator()]</InnerVar>
                <InnerVar>Iterator&lt;LogicalFieldSchema&gt; [j=other.fields.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalize</MethodName>
            <MethodComment>/** 
 * Old Pig schema does not require a tuple schema inside a bag; Now it is required to have that; this method is to fill the gap
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>