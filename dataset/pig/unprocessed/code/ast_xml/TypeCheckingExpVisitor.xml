<Class>
    <Id>871</Id>
    <Package>org.apache.pig.newplan.logical.visitor</Package>
    <ClassName>TypeCheckingExpVisitor</ClassName>
    <SuperClass>LogicalExpressionVisitor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>msgCollector</FieldName>
            <FieldType>CompilationMessageCollector</FieldType>
        </Field>
        <Field>
            <FieldName>currentRelOp</FieldName>
            <FieldType>LogicalRelationalOperator</FieldType>
        </Field>
        <Field>
            <FieldName>INF</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>castLookup</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>castLookup</FieldName>
            <FieldType>Byte</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>TypeCheckingExpVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expPlan</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msgCollector</ParamName>
                    <ParamType>CompilationMessageCollector</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relOp</ParamName>
                    <ParamType>LogicalRelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldSchemaResetter [sr=new FieldSchemaResetter(expPlan)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sr;visit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>AddExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToNumericBinExpression;[binOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>SubtractExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToNumericBinExpression;[binOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>MultiplyExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToNumericBinExpression;[binOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>DivideExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToNumericBinExpression;[binOp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addCastsToNumericBinExpression</MethodName>
            <MethodComment>/** 
 * Add casts to promote numeric type to larger of two input numeric types of the  {@link BinaryExpression}  binOp . If one of the inputs is numericand other bytearray, cast the bytearray type to other numeric type. If both inputs are bytearray, cast them to double.
 * @param binOp
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpression [lhs=binOp.getLhs()]</InnerVar>
                <InnerVar>LogicalExpression [rhs=binOp.getRhs()]</InnerVar>
                <InnerVar>byte [lhsType=lhs.getType()]</InnerVar>
                <InnerVar>byte [rhsType=rhs.getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>ModExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpression [lhs=binOp.getLhs()]</InnerVar>
                <InnerVar>LogicalExpression [rhs=binOp.getRhs()]</InnerVar>
                <InnerVar>byte [lhsType=lhs.getType()]</InnerVar>
                <InnerVar>byte [rhsType=rhs.getType()]</InnerVar>
                <InnerVar>boolean [error=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateIncompatibleTypesMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [msg=binOp.toString()]</InnerVar>
                <InnerVar>LogicalFieldSchema [lhsFs=binOp.getLhs().getFieldSchema()]</InnerVar>
                <InnerVar>LogicalFieldSchema [rhsFs=binOp.getRhs().getFieldSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>negExp</ParamName>
                    <ParamType>NegativeExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [type=negExp.getExpression().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>notExp</ParamName>
                    <ParamType>NotExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [type=notExp.getExpression().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>orExp</ParamName>
                    <ParamType>OrExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitBooleanBinary;[orExp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>andExp</ParamName>
                    <ParamType>AndExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitBooleanBinary;[andExp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitBooleanBinary</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>boolExp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpression [lhs=boolExp.getLhs()]</InnerVar>
                <InnerVar>LogicalExpression [rhs=boolExp.getRhs()]</InnerVar>
                <InnerVar>byte [lhsType=lhs.getType()]</InnerVar>
                <InnerVar>byte [rhsType=rhs.getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;insertCastsForNullToBoolean;[boolExp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>LessThanExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>LessThanEqualExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>GreaterThanExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>GreaterThanEqualExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>EqualExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>NotEqualExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addCastsToCompareBinaryExp;[binOp, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addCastsToCompareBinaryExp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isEquality</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalExpression [lhs=binOp.getLhs()]</InnerVar>
                <InnerVar>LogicalExpression [rhs=binOp.getRhs()]</InnerVar>
                <InnerVar>byte [lhsType=lhs.getType()]</InnerVar>
                <InnerVar>byte [rhsType=rhs.getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwIncompatibleTypeError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [errCode=1039]</InnerVar>
                <InnerVar>String [msg=generateIncompatibleTypesMessage(binOp)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>msgCollector;collect;[msg, MessageType.Error]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCastsForNullToBoolean</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binOp</ParamName>
                    <ParamType>BinaryExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCast</MethodName>
            <MethodComment>/** 
 * add cast to convert the input of exp {@link LogicalExpression} arg to type toType
 * @param exp
 * @param toType
 * @param arg
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exp</ParamName>
                    <ParamType>LogicalExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>LogicalExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogicalFieldSchema [toFs=new LogicalSchema.LogicalFieldSchema(null,null,toType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;insertCast;[exp, toFs, arg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCast</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>LogicalExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toFs</ParamName>
                    <ParamType>LogicalFieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>LogicalExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CastExpression [cast=new CastExpression(plan,arg,toFs)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;collectCastWarning;[node, arg.getType(), toFs.type, msgCollector]</InnerMethodInvoke>
                <InnerMethodInvoke>cast;setLocation;[node.getLocation()]</InnerMethodInvoke>
                <InnerMethodInvoke>this;visit;[cast]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * For Basic Types: 0) Casting to itself is always ok 1) Casting from number to number is always ok 2) ByteArray to anything is ok 3) number to chararray is ok For Composite Types: Recursively traverse the schemas till you get a basic type
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cast</ParamName>
                    <ParamType>CastExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [inType=cast.getExpression().getType()]</InnerVar>
                <InnerVar>byte [outType=cast.getType()]</InnerVar>
                <InnerVar>LogicalFieldSchema [inFs=cast.getExpression().getFieldSchema()]</InnerVar>
                <InnerVar>LogicalFieldSchema [outFs=cast.getFieldSchema()]</InnerVar>
                <InnerVar>boolean [castable=LogicalFieldSchema.castable(inFs,outFs)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment>/** 
 * {@link RegexExpression} expects CharArray as inputItself always returns Boolean
 * @param rg
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rg</ParamName>
                    <ParamType>RegexExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>binCond</ParamName>
                    <ParamType>BinCondExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [lhsType=binCond.getLhs().getType()]</InnerVar>
                <InnerVar>byte [rhsType=binCond.getRhs().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>MapLookupExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>deref</ParamName>
                    <ParamType>DereferenceExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [inputType=deref.getReferredExpression().getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;LogicalExpression&gt; [list=func.getArguments()]</InnerVar>
                <InnerVar>Schema [currentArgSchema=new Schema()]</InnerVar>
                <InnerVar>EvalFunc&lt;?&gt; [ef=(EvalFunc&lt;?&gt;)PigContext.instantiateFuncFromSpec(func.getFuncSpec())]</InnerVar>
                <InnerVar>List&lt;FuncSpec&gt; [funcSpecs=null]</InnerVar>
                <InnerVar>SchemaType [udfSchemaType=ef.getSchemaType()]</InnerVar>
                <InnerVar>FuncSpec [matchingSpec=null]</InnerVar>
                <InnerVar>boolean [notExactMatch=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bestFitMatchWithByteArrays</MethodName>
            <MethodComment>/** 
 * Tries to find the schema supported by one of funcSpecs which can be obtained by inserting a set of casts to the input schema
 * @param funcSpecs -mappings provided by udf
 * @param s -input schema
 * @param func -udf expression
 * @param udfSchemaType -schema type of the udf
 * @return the funcSpec that supports the schema that is best suited to s.The best suited schema is one that has the lowest score as returned by fitPossible().
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpecs</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Pair&lt;Long,FuncSpec&gt;&gt; [scoreFuncSpecList=new ArrayList&lt;Pair&lt;Long,FuncSpec&gt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>exactMatchWithByteArrays</MethodName>
            <MethodComment>/** 
 * Finds if there is an exact match between the schema supported by one of the funcSpecs and the input schema s. Here first exact match for all non byte array fields is first attempted and if there is exactly one candidate, it is chosen (since the bytearray(s) can just be cast to corresponding type(s) in the candidate)
 * @param funcSpecs - mappings provided by udf
 * @param s - input schema
 * @param func - UserFuncExpression for which matching is requested
 * @param udfSchemaType - schema type of the udf
 * @return the matching spec if found else null
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpecs</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>exactMatch</MethodName>
            <MethodComment>/** 
 * Finds if there is an exact match between the schema supported by one of the funcSpecs and the input schema s. Here an exact match for all fields is attempted.
 * @param funcSpecs - mappings provided by udf
 * @param s - input schema
 * @param func - UserFuncExpression for which matching is requested
 * @param udfSchemaType - schema type of the user defined function
 * @return the matching spec if found else null
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpecs</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bestFitMatch</MethodName>
            <MethodComment>/** 
 * Tries to find the schema supported by one of funcSpecs which can be obtained by inserting a set of casts to the input schema
 * @param funcSpecs - mappings provided by udf
 * @param s - input schema
 * @param udfSchemaType - schema type of the udf
 * @return the funcSpec that supports the schema that is best suitedto s. The best suited schema is one that has the lowest score as returned by fitPossible().
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpecs</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FuncSpec [matchingSpec=null]</InnerVar>
                <InnerVar>long [score=INF]</InnerVar>
                <InnerVar>long [prevBestScore=Long.MAX_VALUE]</InnerVar>
                <InnerVar>long [bestScore=Long.MAX_VALUE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>byteArrayFound</MethodName>
            <MethodComment>/** 
 * Checks to see if any field of the input schema is a byte array
 * @param func
 * @param s - input schema
 * @return true if found else false
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getByteArrayPositions</MethodName>
            <MethodComment>/** 
 * Gets the positions in the schema which are byte arrays
 * @param func
 * @param s -input schema
 * @throws VisitorException
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Integer&gt; [result=new ArrayList&lt;Integer&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>VisitorException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>exactMatchHelper</MethodName>
            <MethodComment>/** 
 * Finds if there is an exact match between the schema supported by one of the funcSpecs and the input schema s
 * @param funcSpecs - mappings provided by udf
 * @param s - input schema
 * @param func user defined function
 * @param udfSchemaType - schema type of the user defined function
 * @param ignoreByteArrays - flag for whether the exact match is to computedafter ignoring bytearray (if true) or without ignoring bytearray (if false)
 * @return the matching spec if found else null
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>FuncSpec</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcSpecs</ParamName>
                    <ParamType>FuncSpec</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreByteArrays</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FuncSpec&gt; [matchingSpecs=new ArrayList&lt;FuncSpec&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>schemaEqualsForMatching</MethodName>
            <MethodComment>/** 
 * Compare two schemas for equality for argument matching purposes. This is a more relaxed form of Schema.equals wherein first the Datatypes of the field schema are checked for equality. Then if a field schema in the udf schema is for a complex type AND if the inner schema is NOT null, check for schema equality of the inner schemas of the UDF field schema and input field schema
 * @param inputSchema
 * @param udfSchema
 * @param ignoreByteArrays
 * @return true if FieldSchemas are equal for argument matching, falseotherwise
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputSchema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udfSchemaType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreByteArrays</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;FieldSchema&gt; [i=inputSchema.getFields().iterator()]</InnerVar>
                <InnerVar>Iterator&lt;FieldSchema&gt; [j=udfSchema.getFields().iterator()]</InnerVar>
                <InnerVar>FieldSchema [udfFieldSchema=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNotBagWithEmptyTuple</MethodName>
            <MethodComment>/** 
 * Check if the fieldSch is a bag with empty tuple schema
 * @param fieldSch
 * @return
 * @throws FrontendException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldSch</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isBagWithEmptyTuple=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertEmptyTupleToBytearrayTuple</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fitPossible</MethodName>
            <MethodComment>/** 
 * Computes a modified version of manhattan distance between the two schemas: s1 &amp; s2. Here the value on the same axis are preferred over values that change axis as this means that the number of casts required will be lesser on the same axis. However, this function ceases to be a metric as the triangle inequality does not hold. Each schema is an s1.size() dimensional vector. The ordering for each axis is as defined by castLookup. Unallowed casts are returned a dist of INFINITY.
 * @param s1
 * @param s2
 * @param s2Type
 * @return
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2Type</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FieldSchema&gt; [sFields=s1.getFields()]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [fsFields=s2.getFields()]</InnerVar>
                <InnerVar>long [score=0]</InnerVar>
                <InnerVar>int [castCnt=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCastsForUDF</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>func</ParamName>
                    <ParamType>UserFuncExpression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromSch</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toSch</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toSchType</ParamName>
                    <ParamType>SchemaType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FieldSchema&gt; [fsLst=fromSch.getFields()]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [tsLst=toSch.getFields()]</InnerVar>
                <InnerVar>List&lt;LogicalExpression&gt; [args=func.getArguments()]</InnerVar>
                <InnerVar>int [i=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectCastWarning</MethodName>
            <MethodComment>/** 
 * Helper for collecting warning when casting is inserted to the plan (implicit casting)
 * @param node
 * @param originalType
 * @param toType
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>originalType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msgCollector</ParamName>
                    <ParamType>CompilationMessageCollector</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [originalTypeName=DataType.findTypeName(originalType)]</InnerVar>
                <InnerVar>String [toTypeName=DataType.findTypeName(toType)]</InnerVar>
                <InnerVar>String [opName=node.getClass().getSimpleName()]</InnerVar>
                <InnerVar>PigWarning [kind=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>msgCollector;collect;[originalTypeName + " is implicitly cast to " + toTypeName+ " under "+ opName+ " Operator", MessageType.Warning, kind]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FieldSchemaResetter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>OperatorPlan</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>LogicalExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>op;resetFieldSchema;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>