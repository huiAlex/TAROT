<Class>
    <Id>507</Id>
    <Package>org.apache.pig</Package>
    <ClassName>StoreFuncInterface</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StoreFuncInterface  /** 
 * StoreFuncs take records from Pig's processing and store them into a data store.  Most frequently this is an HDFS file, but it could also be an HBase instance, RDBMS, etc.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>relToAbsPathForStoreLocation</MethodName>
            <MethodComment>/** 
 * This method is called by the Pig runtime in the front end to convert the output location to an absolute path if the location is relative. The StoreFuncInterface implementation is free to choose how it converts a relative  location to an absolute location since this may depend on what the location string represent (hdfs path or some other data source).  The static method  {@link LoadFunc#getAbsolutePath} provides a default implementation for hdfs and hadoop local file system and it can be used to implement this method.  
 * @param location location as provided in the "store" statement of the script
 * @param curDir the current working direction based on any "cd" statementsin the script before the "store" statement. If there are no "cd" statements in the script, this would be the home directory -  &lt;pre&gt;/user/&lt;username&gt; &lt;/pre&gt;
 * @return the absolute location based on the arguments passed
 * @throws IOException if the conversion is not possible
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>curDir</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOutputFormat</MethodName>
            <MethodComment>/** 
 * Return the OutputFormat associated with StoreFuncInterface.  This will be called on the front end during planning and on the backend during execution. 
 * @return the {@link OutputFormat} associated with StoreFuncInterface
 * @throws IOException if an exception occurs while constructing the OutputFormat
 */
</MethodComment>
            <ReturnType>OutputFormat</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStoreLocation</MethodName>
            <MethodComment>/** 
 * Communicate to the storer the location where the data needs to be stored.   The location string passed to the  {@link StoreFuncInterface} here is the return value of  {@link StoreFuncInterface#relToAbsPathForStoreLocation(String,Path)}This method will be called in the frontend and backend multiple times. Implementations should bear in mind that this method is called multiple times and should ensure there are no inconsistent side effects due to the multiple calls. {@link #checkSchema(ResourceSchema)} will be called before any call to{@link #setStoreLocation(String,Job)}.
 * @param location Location returned by {@link StoreFuncInterface#relToAbsPathForStoreLocation(String,Path)}
 * @param job The {@link Job} object
 * @throws IOException if the location is not valid.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkSchema</MethodName>
            <MethodComment>/** 
 * Set the schema for data to be stored.  This will be called on the front end during planning if the store is associated with a schema. A Store function should implement this function to check that a given schema is acceptable to it.  For example, it can check that the correct partition keys are included; a storage function to be written directly to an OutputFormat can make sure the schema will translate in a well defined way.  
 * @param s to be checked
 * @throws IOException if this schema is not acceptable.  It should includea detailed error message indicating what is wrong with the schema.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>ResourceSchema</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToWrite</MethodName>
            <MethodComment>/** 
 * Initialize StoreFuncInterface to write data.  This will be called during execution before the call to putNext.
 * @param writer RecordWriter to use.
 * @throws IOException if an exception occurs during initialization
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>RecordWriter</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putNext</MethodName>
            <MethodComment>/** 
 * Write a tuple to the data store.
 * @param t the tuple to store.
 * @throws IOException if an exception occurs during the write
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStoreFuncUDFContextSignature</MethodName>
            <MethodComment>/** 
 * This method will be called by Pig both in the front end and back end to pass a unique signature to the  {@link StoreFuncInterface} which it can use to storeinformation in the  {@link UDFContext} which it needs to store betweenvarious method invocations in the front end and back end.  This is necessary because in a Pig Latin script with multiple stores, the different instances of store functions need to be able to find their (and only their) data in the UDFContext object.
 * @param signature a unique signature to identify this StoreFuncInterface
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>signature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnFailure</MethodName>
            <MethodComment>/** 
 * This method will be called by Pig if the job which contains this store fails. Implementations can clean up output locations in this method to ensure that no incorrect/incomplete results are left in the output location
 * @param location Location returned by {@link StoreFuncInterface#relToAbsPathForStoreLocation(String,Path)}
 * @param job The {@link Job} object - this should be used only to obtain cluster properties through  {@link Job#getConfiguration()} and not to set/queryany runtime job information. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnSuccess</MethodName>
            <MethodComment>/** 
 * This method will be called by Pig if the job which contains this store is successful, and some cleanup of intermediate resources is required. Implementations can clean up output locations in this method to ensure that no incorrect/incomplete results are left in the output location
 * @param location Location returned by {@link StoreFuncInterface#relToAbsPathForStoreLocation(String,Path)}
 * @param job The {@link Job} object - this should be used only to obtain cluster properties through  {@link Job#getConfiguration()} and not to set/queryany runtime job information. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>