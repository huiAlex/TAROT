<Class>
    <Id>384</Id>
    <Package>org.apache.pig.impl.logicalLayer.schema</Package>
    <ClassName>Schema</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Serializable</SuperInterface>
        <SuperInterface>Cloneable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Schema  /** 
 * The Schema class encapsulates the notion of a schema for a relational operator. A schema is a list of columns that describe the output of a relational operator. Each column in the relation is represented as a FieldSchema, a static class inside the Schema. A column by definition has an alias, a type and a possible schema (if the column is a bag or a tuple). In addition, each column in the schema has a unique auto generated name used for tracking the lineage of the column in a sequence of statements. The lineage of the column is tracked using a map of the predecessors' columns to the operators that generate the predecessor columns. The predecessor columns are the columns required in order to generate the column under consideration.  Similarly, a reverse lookup of operators that generate the predecessor column to the predecessor column is maintained.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>alias</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>type</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>schema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>canonicalName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>canonicalNamer</FieldName>
            <FieldType>CanonicalNamer</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>mFields</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>mFields</FieldName>
            <FieldType>FieldSchema</FieldType>
        </Field>
        <Field>
            <FieldName>mAliases</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>mAliases</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>mFieldSchemas</FieldName>
            <FieldType>MultiMap</FieldType>
        </Field>
        <Field>
            <FieldName>mFieldSchemas</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>twoLevelAccessRequired</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>primeList</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FieldSchema</MethodName>
            <MethodComment>/** 
 * Constructor for any type.
 * @param a Alias, if known. If unknown leave null.
 * @param t Type, using codes from {@link org.apache.pig.data.DataType}.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FieldSchema</MethodName>
            <MethodComment>/** 
 * Constructor for tuple fields.
 * @param a Alias, if known. If unknown leave null.
 * @param s Schema of this tuple.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FieldSchema</MethodName>
            <MethodComment>/** 
 * Constructor for tuple fields.
 * @param a Alias, if known. If unknown leave null.
 * @param s Schema of this tuple.
 * @param t Type, using codes from {@link org.apache.pig.data.DataType}.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>log;debug;["t: " + t + " Bag: "+ DataType.BAG+ " tuple: "+ DataType.TUPLE]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FieldSchema</MethodName>
            <MethodComment>/** 
 * Copy Constructor.
 * @param fs Source FieldSchema
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Two field schemas are equal if types and schemas are equal in all levels. In order to relax alias equivalent requirement, instead use equals(FieldSchema fschema, FieldSchema fother, boolean relaxInner, boolean relaxAlias)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldSchema [otherfs=(FieldSchema)other]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castable</MethodName>
            <MethodComment>/** 
 * Recursively compare two schemas to check if the input schema  can be cast to the cast schema
 * @param castFs schema of the cast operator
 * @param inputFs schema of the cast input
 * @return true or falsew!
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>castFs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputFs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [inputType=inputFs.type]</InnerVar>
                <InnerVar>byte [castType=castFs.type]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Compare two field schema for equality
 * @param fschema
 * @param fother
 * @param relaxInner If true, we don't check inner tuple schemas
 * @param relaxAlias If true, we don't check aliases
 * @return true if FieldSchemas are equal, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fschema</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fother</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxInner</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;[DataType.findTypeName(type)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment>/** 
 * Make a deep copy of this FieldSchema and return it.
 * @return clone of the this FieldSchema.
 * @throws CloneNotSupportedException
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CloneNotSupportedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergePrefixFieldSchema</MethodName>
            <MethodComment>/** 
 * Recursively prefix merge two schemas
 * @param otherFs the other field schema to be merged with
 * @return the prefix merged field schema this can be null if one schema is null andallowIncompatibleTypes is true
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherFs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergePrefixFieldSchema</MethodName>
            <MethodComment>/** 
 * Recursively prefix merge two schemas
 * @param otherFs the other field schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherfield schema take precedence
 * @return the prefix merged field schema this can be null if one schema is null andallowIncompatibleTypes is true
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherFs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergePrefixFieldSchema</MethodName>
            <MethodComment>/** 
 * Recursively prefix merge two schemas
 * @param otherFs the other field schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherfield schema take precedence
 * @param allowMergeableTypes true if "mergeable" types should be allowed.Two types are mergeable if any of the following conditions is true IN THE BELOW ORDER of checks: 1) if either one has a type null or unknown and other has a type OTHER THAN null or unknown, the result type will be the latter non null/unknown type 2) If either type is bytearray, then result type will be the other (possibly non BYTEARRAY) type 3) If current type can be cast to the other type, then the result type will be the other type 
 * @return the prefix merged field schema this can be null. 
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema.FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherFs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowMergeableTypes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema.FieldSchema [myFs=this]</InnerVar>
                <InnerVar>Schema.FieldSchema [mergedFs=null]</InnerVar>
                <InnerVar>byte [mergedType=DataType.NULL]</InnerVar>
                <InnerVar>String [mergedAlias=mergeAlias(myFs.alias,otherFs.alias,otherTakesAliasPrecedence)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFieldSchemaDefaultType</MethodName>
            <MethodComment>/** 
 * Recursively set NULL type to the specifid type 
 * @param fs the field schema whose NULL type has to be set 
 * @param t the specified type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>Schema.FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNullOrUnknownType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findFieldSchema</MethodName>
            <MethodComment>/** 
 * Find a field schema instance in this FieldSchema hierarchy (including "this") that matches the given canonical name.
 * @param canonicalName canonical name
 * @return the FieldSchema instance found
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>canonicalName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Schema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Schema</MethodName>
            <MethodComment>/** 
 * @param fields List of field schemas that describes the fields.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fields</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Schema</MethodName>
            <MethodComment>/** 
 * Create a schema with only one field.
 * @param fieldSchema field to put in this schema.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldSchema</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mFields;add;[fieldSchema]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Schema</MethodName>
            <MethodComment>/** 
 * Copy Constructor.
 * @param s source schema
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Given an alias name, find the associated FieldSchema.
 * @param alias Alias to look up.
 * @return FieldSchema, or null if no such alias is in this tuple.
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldSchema [fs=mAliases.get(alias)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldSubNameMatch</MethodName>
            <MethodComment>/** 
 * Given an alias name, find the associated FieldSchema. If exact name is  not found see if any field matches the part of the 'namespaced' alias. eg. if given alias is nm::a , and schema is (a,b). It will return  FieldSchema of a. if given alias is nm::a and schema is (nm2::a, b), it will return null
 * @param alias Alias to look up.
 * @return FieldSchema, or null if no such alias is in this tuple.
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldSchema [fs=getField(alias)]</InnerVar>
                <InnerVar>String [sep="::"]</InnerVar>
                <InnerVar>ArrayList&lt;FieldSchema&gt; [matchedFieldSchemas=new ArrayList&lt;FieldSchema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Given a field number, find the associated FieldSchema.
 * @param fieldNum Field number to look up.
 * @return FieldSchema for this field.
 * @throws ParseException if the field number exceeds the number of fields in the tuple.
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Find the number of fields in the schema.
 * @return number of fields.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reconcile</MethodName>
            <MethodComment>/** 
 * Reconcile this schema with another schema.  The schema being reconciled with should have the same number of columns.  The use case is where a schema already exists but may not have alias and or type information.  If an alias exists in this schema and a new one is given, then the new one will be used.  Similarly with types, though this needs to be used carefully, as types should not be lightly changed.
 * @param other Schema to reconcile with.
 * @throws ParseException if this cannot be reconciled.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * For two schemas to be equal, they have to be deeply equal. Use Schema.equals(Schema schema, Schema other, boolean relaxInner, boolean relaxAlias) if relaxation of aliases is a requirement.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [s=(Schema)other]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment>/** 
 * Make a deep copy of a schema.
 * @throws CloneNotSupportedException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Schema [s=new Schema()]</InnerVar>
                <InnerVar>Map&lt;FieldSchema,FieldSchema&gt; [fsMap=new HashMap&lt;FieldSchema,FieldSchema&gt;(size())]</InnerVar>
                <InnerVar>Map&lt;String,FieldSchema&gt; [fsCanonicalNameMap=new HashMap&lt;String,FieldSchema&gt;(size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CloneNotSupportedException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [idx=0]</InnerVar>
                <InnerVar>int [hashCode=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prettyPrint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toIndentedString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indentLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringifySchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sb</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;stringifySchema;[sb, schema, type, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringifySchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sb</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indentLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;indent;[sb, indentLevel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>indent</MethodName>
            <MethodComment>/** 
 * no-op if indentLevel is negative.&lt;br&gt; otherwise, print newline and 4*indentLevel spaces.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sb</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indentLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>add</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mFields;add;[f]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPosition</MethodName>
            <MethodComment>/** 
 * Given an alias, find the associated position of the field schema.
 * @param alias alias of the FieldSchema.
 * @return position of the FieldSchema.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPositionSubName</MethodName>
            <MethodComment>/** 
 * Given an alias, find the associated position of the field schema. It uses getFieldSubNameMatch to look for subName matches as well.
 * @param alias alias of the FieldSchema.
 * @return position of the FieldSchema.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isSubNameMatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addAlias</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printAliases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Set&lt;String&gt; [aliasNames=mAliases.keySet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFields</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castable</MethodName>
            <MethodComment>/** 
 * Recursively compare two schemas to check if the input schema  can be cast to the cast schema
 * @param cast schema of the cast operator
 * @param input schema of the cast input
 * @return true or falsew!
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cast</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;FieldSchema&gt; [i=cast.mFields.iterator()]</InnerVar>
                <InnerVar>Iterator&lt;FieldSchema&gt; [j=input.mFields.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Recursively compare two schemas for equality
 * @param schema
 * @param other
 * @param relaxInner if true, inner schemas will not be checked
 * @param relaxAlias if true, aliases will not be checked
 * @return true if schemas are equal, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxInner</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relaxAlias</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Iterator&lt;FieldSchema&gt; [i=schema.mFields.iterator()]</InnerVar>
                <InnerVar>Iterator&lt;FieldSchema&gt; [j=other.mFields.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>merge</MethodName>
            <MethodComment>/** 
 * Merge this schema with the other schema
 * @param other the other schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherschema take precedence
 * @return the merged schema, null if they are not compatible
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchema</MethodName>
            <MethodComment>/** 
 * Recursively merge two schemas
 * @param schema the initial schema
 * @param other the other schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherschema take precedence
 * @return the merged schema, null if they are not compatible
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchema</MethodName>
            <MethodComment>/** 
 * Recursively merge two schemas
 * @param schema the initial schema
 * @param other the other schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherschema take precedence
 * @param allowDifferentSizeMerge allow merging of schemas of different types
 * @param allowIncompatibleTypes 1) if types in schemas are not compatiblethey will be treated as ByteArray (untyped) 2) if schemas in schemas are not compatible and allowIncompatibleTypes is true those inner schemas in the output will be null.
 * @return the merged schema this can be null if one schema is null andallowIncompatibleTypes is true
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowDifferentSizeMerge</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowIncompatibleTypes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FieldSchema&gt; [outputList=new ArrayList&lt;FieldSchema&gt;()]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [mylist=schema.mFields]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [otherlist=other.mFields]</InnerVar>
                <InnerVar>int [iterateLimit=schema.mFields.size() &gt; other.mFields.size() ? other.mFields.size() : schema.mFields.size()]</InnerVar>
                <InnerVar>int [idx=0]</InnerVar>
                <InnerVar>Schema [result=new Schema(outputList)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeAlias</MethodName>
            <MethodComment>/** 
 * Merge two aliases. If one of aliases is null, return the other. Otherwise check the precedence condition
 * @param alias
 * @param other
 * @param otherTakesPrecedence
 * @return
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchemasByAlias</MethodName>
            <MethodComment>/** 
 * Merges collection of schemas using their column aliases  (unlike mergeSchema(..) functions which merge using positions) Schema will not be merged if types are incompatible,  as per DataType.mergeType(..) For Tuples and Bags, SubSchemas have to be equal be considered compatible
 * @param schemas - list of schemas to be merged using their column alias
 * @return merged schema
 * @throws SchemaMergeException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemas</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [mergedSchema=null]</InnerVar>
                <InnerVar>ArrayList&lt;Schema&gt; [mergedSchemas=new ArrayList&lt;Schema&gt;(schemas.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchemaByAlias</MethodName>
            <MethodComment>/** 
 * Merges two schemas using their column aliases  (unlike mergeSchema(..) functions which merge using positions) Schema will not be merged if types are incompatible,  as per DataType.mergeType(..) For Tuples and Bags, SubSchemas have to be equal be considered compatible
 * @param schema1
 * @param schema2
 * @return Merged Schema
 * @throws SchemaMergeException if schemas cannot be merged
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema1</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema2</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [mergedSchema=new Schema()]</InnerVar>
                <InnerVar>HashSet&lt;FieldSchema&gt; [schema2colsAdded=new HashSet&lt;FieldSchema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkNullAlias</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeFieldSchemaFirstLevelSameAlias</MethodName>
            <MethodComment>/** 
 * Schema will not be merged if types are incompatible,  as per DataType.mergeType(..) For Tuples and Bags, SubSchemas have to be equal be considered compatible Aliases are assumed to be same for both
 * @param fs1
 * @param fs2
 * @return
 * @throws SchemaMergeException
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fs1</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs2</ParamName>
                    <ParamType>FieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [innerSchema=null]</InnerVar>
                <InnerVar>String [alias=mergeNameSpacedAlias(fs1.alias,fs2.alias)]</InnerVar>
                <InnerVar>byte [mergedType=DataType.mergeType(fs1.type,fs2.type)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeNameSpacedAlias</MethodName>
            <MethodComment>/** 
 * If one of the aliases is of form 'nm::str1', and other is of the form 'str1', this returns str1
 * @param alias1
 * @param alias2
 * @return merged alias
 * @throws SchemaMergeException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>alias1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alias2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldSubNameMatchThrowSchemaMergeException</MethodName>
            <MethodComment>/** 
 * Utility function that calls schema.getFiled(alias), and converts  {@link FrontendException} to {@link SchemaMergeException}
 * @param schema
 * @param alias
 * @return FieldSchema
 * @throws SchemaMergeException
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldSchema [fs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateNestedSchema</MethodName>
            <MethodComment>/** 
 * @param topLevelType DataType type of the top level element
 * @param innerTypes DataType types of the inner level element
 * @return nested schema representing type of top level element at first level and inner schemarepresenting types of inner element(s)
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>topLevelType</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>innerTypes</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [innerSchema=new Schema()]</InnerVar>
                <InnerVar>Schema.FieldSchema [outerSchema=new Schema.FieldSchema(null,innerSchema,topLevelType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergePrefixSchema</MethodName>
            <MethodComment>/** 
 * Recursively prefix merge two schemas
 * @param other the other schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherschema take precedence
 * @return the prefix merged schema this can be null if one schema is null andallowIncompatibleTypes is true
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergePrefixSchema</MethodName>
            <MethodComment>/** 
 * Recursively prefix merge two schemas
 * @param other the other schema to be merged with
 * @param otherTakesAliasPrecedence true if aliases from the otherschema take precedence
 * @param allowMergeableTypes true if "mergeable" types should be allowed.Two types are mergeable if any of the following conditions is true IN THE  BELOW ORDER of checks: 1) if either one has a type null or unknown and other has a type OTHER THAN null or unknown, the result type will be the latter non null/unknown type 2) If either type is bytearray, then result type will be the other (possibly  non BYTEARRAY) type 3) If current type can be cast to the other type, then the result type will be the other type 
 * @return the prefix merged schema this can be null if one schema is null andallowIncompatibleTypes is true
 * @throws SchemaMergeException if they cannot be merged
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherTakesAliasPrecedence</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowMergeableTypes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema [schema=this]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [outputList=new ArrayList&lt;FieldSchema&gt;()]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [mylist=schema.mFields]</InnerVar>
                <InnerVar>List&lt;FieldSchema&gt; [otherlist=other.mFields]</InnerVar>
                <InnerVar>int [iterateLimit=other.mFields.size()]</InnerVar>
                <InnerVar>int [idx=0]</InnerVar>
                <InnerVar>Schema [s=new Schema(outputList)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setTwoLevelAccessRequired;[other.twoLevelAccessRequired]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SchemaMergeException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSchemaDefaultType</MethodName>
            <MethodComment>/** 
 * Recursively set NULL type to the specifid type in a schema
 * @param s the schema whose NULL type has to be set 
 * @param t the specified type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTwoLevelAccessRequired</MethodName>
            <MethodComment>/** 
 * @return the twoLevelAccess
 * @deprecated twoLevelAccess is no longer needed
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTwoLevelAccessRequired</MethodName>
            <MethodComment>/** 
 * @param twoLevelAccess the twoLevelAccess to set
 * @deprecated twoLevelAccess is no longer needed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>twoLevelAccess</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPigSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rSchema</ParamName>
                    <ParamType>ResourceSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;FieldSchema&gt; [fsList=new ArrayList&lt;FieldSchema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findFieldSchema</MethodName>
            <MethodComment>/** 
 * Look for a FieldSchema instance in the schema hierarchy which has the given canonical name.
 * @param canonicalName canonical name
 * @return the FieldSchema instance found
 */
</MethodComment>
            <ReturnType>FieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>canonicalName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>