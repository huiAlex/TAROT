<Class>
    <Id>417</Id>
    <Package>org.apache.pig.backend.hadoop.hbase</Package>
    <ClassName>HBaseStorage</ClassName>
    <SuperClass>LoadFunc</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>StoreFuncInterface</SuperInterface>
        <SuperInterface>LoadPushDown</SuperInterface>
        <SuperInterface>OrderedLoadFunc</SuperInterface>
        <SuperInterface>StoreResources</SuperInterface>
        <SuperInterface>CollectableLoadFunc</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>HBaseStorage  /** 
 * A HBase implementation of LoadFunc and StoreFunc. &lt;P&gt; Below is an example showing how to load data from HBase: &lt;pre&gt; {@code raw = LOAD 'hbase://SampleTable' USING org.apache.pig.backend.hadoop.hbase.HBaseStorage( 'info:first_name info:last_name friends:* info:*', '-loadKey true -limit 5') AS (id:bytearray, first_name:chararray, last_name:chararray, friends_map:map[], info_map:map[]);}&lt;/pre&gt; This example loads data redundantly from the info column family just to illustrate usage. Note that the row key is inserted first in the result schema. To load only column names that start with a given prefix, specify the column name with a trailing '*'. For example passing &lt;code&gt;friends:bob_*&lt;/code&gt; to the constructor in the above example would cause only columns that start with &lt;i&gt;bob_&lt;/i&gt; to be loaded. &lt;P&gt; Note that when using a prefix like &lt;code&gt;friends:bob_*&lt;/code&gt;, explicit HBase filters are set for all columns and prefixes specified. Querying HBase with many filters can cause performance degredation. This is typically seen when mixing one or more prefixed descriptors with a large list of columns. In that case better perfomance will be seen by either loading the entire family via &lt;code&gt;friends:*&lt;/code&gt; or by specifying explicit column descriptor names. &lt;P&gt; Below is an example showing how to store data into HBase: &lt;pre&gt; {@code copy = STORE raw INTO 'hbase://SampleTableCopy' USING org.apache.pig.backend.hadoop.hbase.HBaseStorage( 'info:first_name info:last_name friends:* info:*');}&lt;/pre&gt; Note that STORE will expect the first value in the tuple to be the row key. Scalars values need to map to an explicit column descriptor and maps need to map to a column family name. In the above examples, the &lt;code&gt;friends&lt;/code&gt; column family data from &lt;code&gt;SampleTable&lt;/code&gt; will be written to a &lt;code&gt;buddies&lt;/code&gt; column family in the &lt;code&gt;SampleTableCopy&lt;/code&gt; table.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Log</FieldType>
        </Field>
        <Field>
            <FieldName>STRING_CASTER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BYTE_CASTER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CASTER_PROPERTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ASTERISK</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>COLON</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>HBASE_SECURITY_CONF_KEY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>HBASE_CONFIG_SET</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>HBASE_TOKEN_SET</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>columnInfo_</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>columnInfo_</FieldName>
            <FieldType>ColumnInfo</FieldType>
        </Field>
        <Field>
            <FieldName>m_conf</FieldName>
            <FieldType>JobConf</FieldType>
        </Field>
        <Field>
            <FieldName>reader</FieldName>
            <FieldType>RecordReader</FieldType>
        </Field>
        <Field>
            <FieldName>writer</FieldName>
            <FieldType>RecordWriter</FieldType>
        </Field>
        <Field>
            <FieldName>outputFormat</FieldName>
            <FieldType>TableOutputFormat</FieldType>
        </Field>
        <Field>
            <FieldName>scan</FieldName>
            <FieldType>Scan</FieldType>
        </Field>
        <Field>
            <FieldName>contextSignature</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>configuredOptions_</FieldName>
            <FieldType>CommandLine</FieldType>
        </Field>
        <Field>
            <FieldName>validOptions_</FieldName>
            <FieldType>Options</FieldType>
        </Field>
        <Field>
            <FieldName>parser_</FieldName>
            <FieldType>CommandLineParser</FieldType>
        </Field>
        <Field>
            <FieldName>loadRowKey_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>delimiter_</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ignoreWhitespace_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>limit_</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>cacheBlocks_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>caching_</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>noWAL_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>minTimestamp_</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>maxTimestamp_</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>timestamp_</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>includeTimestamp_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>includeTombstone_</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>gt_</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>gte_</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>lt_</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>lte_</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>regex_</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>caster_</FieldName>
            <FieldType>LoadCaster</FieldType>
        </Field>
        <Field>
            <FieldName>schema_</FieldName>
            <FieldType>ResourceSchema</FieldType>
        </Field>
        <Field>
            <FieldName>requiredFieldList</FieldName>
            <FieldType>RequiredFieldList</FieldType>
        </Field>
        <Field>
            <FieldName>originalColumnName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>columnFamily</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>columnName</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>columnPrefix</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>populateValidOptions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Option [loadKey=OptionBuilder.hasOptionalArgs(1).withArgName("loadKey").withLongOpt("loadKey").withDescription("Load Key").create()]</InnerVar>
                <InnerVar>Option [noWal=OptionBuilder.hasOptionalArgs(1).withArgName("noWAL").withLongOpt("noWAL").withDescription("Sets the write ahead to false for faster loading. To be used with extreme caution since this could result in data loss (see http://hbase.apache.org/book.html#perf.hbase.client.putwal).").create()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>validOptions_;addOption;[loadKey]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["gt", true, "Records must be greater than this value " + "(binary, double-slash-escaped)"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["lt", true, "Records must be less than this value (binary, double-slash-escaped)"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["gte", true, "Records must be greater than or equal to this value"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["lte", true, "Records must be less than or equal to this value"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["regex", true, "Record must match this regular expression"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["cacheBlocks", true, "Set whether blocks should be cached for the scan"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["caching", true, "Number of rows scanners should cache"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["limit", true, "Per-region limit"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["maxResultsPerColumnFamily", true, "Limit the maximum number of values returned per row per column family"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["delim", true, "Column delimiter"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["ignoreWhitespace", true, "Ignore spaces when parsing columns"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["caster", true, "Caster to use for converting values. A class name, " + "HBaseBinaryConverter, or Utf8StorageConverter. For storage, casters must implement LoadStoreCaster."]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;[noWal]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["minTimestamp", true, "Record must have timestamp greater or equal to this value"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["maxTimestamp", true, "Record must have timestamp less then this value"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["timestamp", true, "Record must have timestamp equal to this value"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["includeTimestamp", false, "Record will include the timestamp after the rowkey on store (rowkey, timestamp, ...)"]</InnerMethodInvoke>
                <InnerMethodInvoke>validOptions_;addOption;["includeTombstone", false, "Record will include a tombstone marker on store after the rowKey and timestamp (if included) (rowkey, [timestamp,] tombstone, ...)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>HBaseStorage</MethodName>
            <MethodComment>/** 
 * Constructor. Construct a HBase Table LoadFunc and StoreFunc to load or store the cells of the provided columns.
 * @param columnList columnlist that is a presented string delimited by space and/or commas. To retreive all columns in a column family &lt;code&gt;Foo&lt;/code&gt;, specify a column as either &lt;code&gt;Foo:&lt;/code&gt; or &lt;code&gt;Foo:*&lt;/code&gt;. To fetch only columns in the CF that start with &lt;I&gt;bar&lt;/I&gt;, specify &lt;code&gt;Foo:bar*&lt;/code&gt;. The resulting tuple will always be the size of the number of tokens in &lt;code&gt;columnList&lt;/code&gt;. Items in the tuple will be scalar values when a full column descriptor is specified, or a map of column descriptors to values when a column family is specified.
 * @throws ParseException when unable to parse arguments
 * @throws IOException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ParseException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>HBaseStorage</MethodName>
            <MethodComment>/** 
 * Constructor. Construct a HBase Table LoadFunc and StoreFunc to load or store.
 * @param columnList
 * @param optString Loader options. Known options:&lt;ul&gt;&lt;li&gt;-loadKey=(true|false)  Load the row key as the first column &lt;li&gt;-gt=minKeyVal &lt;li&gt;-lt=maxKeyVal &lt;li&gt;-gte=minKeyVal &lt;li&gt;-lte=maxKeyVal &lt;li&gt;-regex=match regex on KeyVal &lt;li&gt;-limit=numRowsPerRegion max number of rows to retrieve per region &lt;li&gt;-maxResultsPerColumnFamily= Limit the maximum number of values returned per row per column family &lt;li&gt;-delim=char delimiter to use when parsing column names (default is space or comma) &lt;li&gt;-ignoreWhitespace=(true|false) ignore spaces when parsing column names (default true) &lt;li&gt;-cacheBlocks=(true|false) Set whether blocks should be cached for the scan (default false). &lt;li&gt;-caching=numRows  number of rows to cache (faster scans, more memory). &lt;li&gt;-noWAL=(true|false) Sets the write ahead to false for faster loading. &lt;li&gt;-minTimestamp= Scan's timestamp for min timeRange &lt;li&gt;-maxTimestamp= Scan's timestamp for max timeRange &lt;li&gt;-timestamp= Scan's specified timestamp &lt;li&gt;-includeTimestamp= Record will include the timestamp after the rowkey on store (rowkey, timestamp, ...) &lt;li&gt;-includeTombstone= Record will include a tombstone marker on store after the rowKey and timestamp (if included) (rowkey, [timestamp,] tombstone, ...) &lt;li&gt;-caster=(HBaseBinaryConverter|Utf8StorageConverter) Utf8StorageConverter is the default To be used with extreme caution, since this could result in data loss (see http://hbase.apache.org/book.html#perf.hbase.client.putwal). &lt;/ul&gt;
 * @throws ParseException
 * @throws IOException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [optsArr=optString.split(" ")]</InnerVar>
                <InnerVar>String [defaultCaster=UDFContext.getUDFContext().getClientSystemProps() != null ? UDFContext.getUDFContext().getClientSystemProps().getProperty(CASTER_PROPERTY,STRING_CASTER) : STRING_CASTER]</InnerVar>
                <InnerVar>String [casterOption=configuredOptions_.getOptionValue("caster",defaultCaster)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;populateValidOptions;[]</InnerMethodInvoke>
                <InnerMethodInvoke>LOG;debug;["Using caster " + caster_.getClass()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initScan;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ParseException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUDFProperties</MethodName>
            <MethodComment>/** 
 * Returns UDFProperties based on &lt;code&gt;contextSignature&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>projectedFieldsName</MethodName>
            <MethodComment>/** 
 * @return &lt;code&gt; contextSignature + "_projectedFields" &lt;/code&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseColumnList</MethodName>
            <MethodComment>/** 
 * @param columnList
 * @param delimiter
 * @param ignoreWhitespace
 * @return
 */
</MethodComment>
            <ReturnType>ColumnInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreWhitespace</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ColumnInfo&gt; [columnInfo=new ArrayList&lt;ColumnInfo&gt;()]</InnerVar>
                <InnerVar>String[] [colNames=columnList.split(delimiter)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [columnPrefixExists=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scan;setCacheBlocks;[cacheBlocks_]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;setCaching;[caching_]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addFiltersWithoutColumnPrefix</MethodName>
            <MethodComment>/** 
 * If there is no column with a prefix, we don't need filters, we can just call addColumn and addFamily on the scan
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnInfos</ParamName>
                    <ParamType>ColumnInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,List&lt;ColumnInfo&gt;&gt; [groupedMap=groupByFamily(columnInfos)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addFiltersWithColumnPrefix</MethodName>
            <MethodComment>/** 
 * If we have a qualifier with a prefix and a wildcard (i.e. cf:foo*), we need a filter on every possible column to be returned as shown below. This will become very inneficient for long lists of columns mixed with a prefixed wildcard. FilterList - must pass ALL of - FamilyFilter - AND a must pass ONE FilterList of - either Qualifier - or ColumnPrefixFilter If we have only column family filters (i.e. cf:*) or explicit column descriptors (i.e., cf:foo) or a mix of both then we don't need filters, since the scan will take care of that.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnInfos</ParamName>
                    <ParamType>ColumnInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FilterList [allColumnFilters=null]</InnerVar>
                <InnerVar>Map&lt;String,List&lt;ColumnInfo&gt;&gt; [groupedMap=groupByFamily(columnInfos)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRowFilter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>CompareOp</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addFilter;[new RowFilter(op,new BinaryComparator(val))]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addFilter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>Filter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FilterList [scanFilter=(FilterList)scan.getFilter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanFilter;addFilter;[filter]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;setFilter;[scanFilter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnInfoList</MethodName>
            <MethodComment>/** 
 * Returns the ColumnInfo list so external objects can inspect it.
 * @return List of ColumnInfo objects
 */
</MethodComment>
            <ReturnType>ColumnInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setColumnInfoList</MethodName>
            <MethodComment>/** 
 * Updates the ColumnInfo List. Use this if you need to implement custom projections
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnInfoList</ParamName>
                    <ParamType>ColumnInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeProjectedFieldNames</MethodName>
            <MethodComment>/** 
 * Stores the requiredFieldsList as a serialized object so it can be fetched on the cluster. If you plan to overwrite pushProjection, you need to call this with the requiredFieldList so it they can be accessed on the cluster.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requiredFieldList</ParamName>
                    <ParamType>RequiredFieldList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Tuple</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInputFormat</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InputFormat</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TableInputFormat [inputFormat=new HBaseTableIFBuilder().withLimit(limit_).withGt(gt_).withGte(gte_).withLt(lt_).withLte(lte_).withConf(m_conf).build()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>inputFormat;setScan;[scan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToRead</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>RecordReader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>split</ParamName>
                    <ParamType>PigSplit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUDFContextSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>signature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [udfProps=getUDFProperties()]</InnerVar>
                <InnerVar>String [delegationTokenSet=udfProps.getProperty(HBASE_TOKEN_SET)]</InnerVar>
                <InnerVar>String [tablename=location]</InnerVar>
                <InnerVar>String [projectedFields=udfProps.getProperty(projectedFieldsName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>job.getConfiguration();setBoolean;["pig.noSplitCombination", true]</InnerMethodInvoke>
                <InnerMethodInvoke>m_conf;set;[TableInputFormat.INPUT_TABLE, tablename]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addFiltersWithoutColumnPrefix;[columnInfo_]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getShipFiles</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;Class&gt; [classList=new ArrayList&lt;Class&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>classList;add;[org.apache.hadoop.hbase.client.HTable.class]</InnerMethodInvoke>
                <InnerMethodInvoke>classList;add;[org.apache.hadoop.hbase.mapreduce.TableSplit.class]</InnerMethodInvoke>
                <InnerMethodInvoke>classList;add;[org.apache.zookeeper.ZooKeeper.class]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addClassToList;["org.cloudera.htrace.Trace", classList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addClassToList;["org.apache.hadoop.hbase.protobuf.generated.HBaseProtos", classList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addClassToList;["org.apache.hadoop.hbase.TableName", classList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addClassToList;["org.apache.hadoop.hbase.CompatibilityFactory", classList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addClassToList;["org.jboss.netty.channel.ChannelFactory", classList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addClassToList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classList</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeLocalJobConfig</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>JobConf</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [udfProps=getUDFProperties()]</InnerVar>
                <InnerVar>Configuration [jobConf=job.getConfiguration()]</InnerVar>
                <InnerVar>JobConf [localConf=new JobConf(jobConf)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addHBaseDelegationToken</MethodName>
            <MethodComment>/** 
 * Get delegation token from hbase and add it to the Job
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hbaseConf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>relativeToAbsolutePath</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>curDir</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLoadCaster</MethodName>
            <MethodComment>/** 
 * Set up the caster to use for reading values out of, and writing to, HBase.
 */
</MethodComment>
            <ReturnType>LoadCaster</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOutputFormat</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OutputFormat</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>ResourceSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getUDFProperties();setProperty;[contextSignature + "_schema", ObjectSerializer.serialize(schema_)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToWrite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>RecordWriter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResourceFieldSchema[] [fieldSchemas=(schema_ == null) ? null : schema_.getFields()]</InnerVar>
                <InnerVar>byte [type=(fieldSchemas == null) ? DataType.findType(t.get(0)) : fieldSchemas[0].getType()]</InnerVar>
                <InnerVar>long [ts]</InnerVar>
                <InnerVar>int [startIndex=1]</InnerVar>
                <InnerVar>Put [put=createPut(t.get(0),type)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDelete</MethodName>
            <MethodComment>/** 
 * Public method to initialize a Delete.
 * @param key
 * @param type
 * @param timestamp
 * @return new delete
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Delete</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timestamp</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Delete [delete=new Delete(objToBytes(key,type))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>delete;setTimestamp;[timestamp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPut</MethodName>
            <MethodComment>/** 
 * Public method to initialize a Put. Used to allow assertions of how Puts are initialized by unit tests.
 * @param key
 * @param type
 * @return new put
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Put</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Put [put=new Put(objToBytes(key,type))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objToBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LoadStoreCaster [caster=(LoadStoreCaster)caster_]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>relToAbsPathForStoreLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>curDir</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStoreFuncUDFContextSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>signature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStoreLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [serializedSchema=getUDFProperties().getProperty(contextSignature + "_schema")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addHBaseDelegationToken;[m_conf, job]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnFailure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnSuccess</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>job</ParamName>
                    <ParamType>Job</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFeatures</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OperatorSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushProjection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RequiredFieldResponse</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requiredFieldList</ParamName>
                    <ParamType>RequiredFieldList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;RequiredField&gt; [requiredFields=requiredFieldList.getFields()]</InnerVar>
                <InnerVar>List&lt;ColumnInfo&gt; [newColumns=Lists.newArrayListWithExpectedSize(requiredFields.size())]</InnerVar>
                <InnerVar>int [colOffset=loadRowKey_ ? 1 : 0]</InnerVar>
                <InnerVar>int [projOffset=colOffset]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;storeProjectedFieldNames;[requiredFieldList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setColumnInfoList;[newColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FrontendException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureAllKeyInstancesInSameSplit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>LOG;debug;["ensureAllKeyInstancesInSameSplit"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSplitComparable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TableSplit</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>split</ParamName>
                    <ParamType>InputSplit</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ColumnInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [cfAndColumn=colName.split(COLON,2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnFamily</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPrefix</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isColumnMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasPrefixMatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>groupByFamily</MethodName>
            <MethodComment>/** 
 * Group the list of ColumnInfo objects by their column family and returns a map of CF to its list of ColumnInfo objects. Using String as key since it implements Comparable.
 * @param columnInfos the columnInfo list to group
 * @return a Map of lists, keyed by their column family.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnInfos</ParamName>
                    <ParamType>ColumnInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,List&lt;ColumnInfo&gt;&gt; [groupedMap=new HashMap&lt;String,List&lt;ColumnInfo&gt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>increment</MethodName>
            <MethodComment>/** 
 * Increments the byte array by one for use with setting stopRow. If all bytes in the array are set to the maximum byte value, then the original array will be returned with a 0 byte appended to it. This is because HBase compares bytes from left to right. If byte array B is equal to byte array A, but with an extra byte appended, A will be &lt; B. For example {@code}A = byte[] {-1} {@code} increments to{@code}B = byte[] {-1, 0} {@code} and {@code}A &lt; B {@code}
 * @param bytes array to increment bytes on
 * @return a copy of the byte array incremented by 1
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [allAtMax=true]</InnerVar>
                <InnerVar>byte[] [incremented=bytes.clone()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>