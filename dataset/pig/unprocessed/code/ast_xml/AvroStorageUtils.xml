<Class>
    <Id>704</Id>
    <Package>org.apache.pig.piggybank.storage.avro</Package>
    <ClassName>AvroStorageUtils</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AvroStorageUtils  /** 
 * This is utility class for this package
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>BooleanSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>LongSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>FloatSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>DoubleSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>IntSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>StringSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>BytesSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>NullSchema</FieldName>
            <FieldType>Schema</FieldType>
        </Field>
        <Field>
            <FieldName>NONAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>PIG_TUPLE_WRAPPER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>PATH_FILTER</FieldName>
            <FieldType>PathFilter</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>accept</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDummyFieldName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createUDField</MethodName>
            <MethodComment>/** 
 * create  an avro field using the given schema 
 */
</MethodComment>
            <ReturnType>Field</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createUDPartialRecordSchema</MethodName>
            <MethodComment>/** 
 * create an avro field with null schema (it is a space holder) 
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUDPartialRecordSchema</MethodName>
            <MethodComment>/** 
 * check whether a schema is a space holder (using field name) 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUDField</MethodName>
            <MethodComment>/** 
 * get field schema given index number 
 */
</MethodComment>
            <ReturnType>Field</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPaths</MethodName>
            <MethodComment>/** 
 * Gets the list of paths from the pathString specified which may contain comma-separated paths and glob style path
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Path</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pathString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>failIfNotFound</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Path&gt; [paths=new HashSet&lt;Path&gt;()]</InnerVar>
                <InnerVar>String[] [pathStrs=LoadFunc.getPathStrings(pathString)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllFilesRecursively</MethodName>
            <MethodComment>/** 
 * Returns all non-hidden files recursively inside the base paths given
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Path</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>basePaths</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Path&gt; [paths=new HashSet&lt;Path&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllFilesInternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>FileStatus</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conf</ParamName>
                    <ParamType>Configuration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paths</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FileSystem</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noDir</MethodName>
            <MethodComment>/** 
 * check whether there is NO directory in the input file (status) list
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ss</ParamName>
                    <ParamType>FileStatus[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLast</MethodName>
            <MethodComment>/** 
 * get last file of a hdfs path if it is  a directory; or return the file itself if path is a file
 */
</MethodComment>
            <ReturnType>Path</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FileSystem</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FileStatus [status=fs.getFileStatus(path)]</InnerVar>
                <InnerVar>FileStatus[] [statuses=fs.listStatus(path,PATH_FILTER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeType</MethodName>
            <MethodComment>/** 
 * This method merges two primitive avro types into one. This method must be used only to merge two primitive types. For complex types, null will be returned unless they are both the same type. Also note that not every primitive type can be merged. For types that cannot be merged, null is returned.
 * @param x first avro type to merge
 * @param y second avro type to merge
 * @return merged avro type
 */
</MethodComment>
            <ReturnType>Schema.Type</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>x</ParamName>
                    <ParamType>Schema.Type</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>y</ParamName>
                    <ParamType>Schema.Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeSchema</MethodName>
            <MethodComment>/** 
 * This method merges two avro schemas into one. Note that not every avro schema can be merged. For complex types to be merged, they must be the same type. For primitive types to be merged, they must meet certain conditions. For schemas that cannot be merged, an exception is thrown.
 * @param x first avro schema to merge
 * @param y second avro schema to merge
 * @return merged avro schema
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>x</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>y</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Schema.Type [xType=x.getType()]</InnerVar>
                <InnerVar>Schema.Type [yType=y.getType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaToMergedSchemaMap</MethodName>
            <MethodComment>/** 
 * When merging multiple avro record schemas, we build a map (schemaToMergedSchemaMap) to associate each input record with a remapping of its fields relative to the merged schema. Take the following two schemas for example: // path1 { "type": "record", "name": "x", "fields": [ { "name": "xField", "type": "string" } ] } // path2 { "type": "record", "name": "y", "fields": [ { "name": "yField", "type": "string" } ] } The merged schema will be something like this: // merged { "type": "record", "name": "merged", "fields": [ { "name": "xField", "type": "string" }, { "name": "yField", "type": "string" } ] } The schemaToMergedSchemaMap will look like this: // schemaToMergedSchemaMap { path1 : { 0 : 0 }, path2 : { 0 : 1 } } The meaning of the map is: - The field at index '0' of 'path1' is moved to index '0' in merged schema. - The field at index '0' of 'path2' is moved to index '1' in merged schema. With this map, we can now remap the field position of the original schema to that of the merged schema. This is necessary because in the backend, we don't use the merged avro schema but embedded avro schemas of input files to load them. Therefore, we must relocate each field from old positions in the original schema to new positions in the merged schema.
 * @param mergedSchema new schema generated from multiple input schemas
 * @param mergedFiles input avro files that are merged
 * @return schemaToMergedSchemaMap that maps old position of each field in theoriginal schema to new position in the new schema
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Path</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergedSchema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergedFiles</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;Path,Map&lt;Integer,Integer&gt;&gt; [result=new HashMap&lt;Path,Map&lt;Integer,Integer&gt;&gt;(mergedFiles.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wrapAsUnion</MethodName>
            <MethodComment>/** 
 * Wrap an avro schema as a nullable union if needed. For instance, wrap schema "int" as ["null", "int"]
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsRecursiveRecord</MethodName>
            <MethodComment>/** 
 * determine whether the input schema contains recursive records 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;String&gt; [set=new HashSet&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsRecursiveRecord</MethodName>
            <MethodComment>/** 
 * Called by  {@link #containsRecursiveRecord(Schema)} and it recursively checkswhether the input schema contains recursive records.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definedRecordNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsGenericUnion</MethodName>
            <MethodComment>/** 
 * determine whether the input schema contains generic unions 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Schema&gt; [set=new HashSet&lt;Schema&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsGenericUnion</MethodName>
            <MethodComment>/** 
 * Called by  {@link #containsGenericUnion(Schema)} and it recursively checkswhether the input schema contains generic unions.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>visitedRecords</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAcceptableUnion</MethodName>
            <MethodComment>/** 
 * determine whether a union is a nullable union; note that this function doesn't check containing types of the input union recursively. 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Schema&gt; [types=in.getTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wrapAsTuple</MethodName>
            <MethodComment>/** 
 * wrap a pig schema as tuple 
 */
</MethodComment>
            <ReturnType>ResourceFieldSchema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>subFieldSchema</ParamName>
                    <ParamType>ResourceFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResourceSchema [listSchema=new ResourceSchema()]</InnerVar>
                <InnerVar>ResourceFieldSchema [tupleWrapper=new ResourceFieldSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>listSchema;setFields;[new ResourceFieldSchema[]{subFieldSchema}]</InnerMethodInvoke>
                <InnerMethodInvoke>tupleWrapper;setType;[DataType.TUPLE]</InnerMethodInvoke>
                <InnerMethodInvoke>tupleWrapper;setName;[PIG_TUPLE_WRAPPER]</InnerMethodInvoke>
                <InnerMethodInvoke>tupleWrapper;setSchema;[listSchema]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTupleWrapper</MethodName>
            <MethodComment>/** 
 * check whether it is just a wrapped tuple 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pigSchema</ParamName>
                    <ParamType>ResourceFieldSchema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Boolean [status=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAcceptedType</MethodName>
            <MethodComment>/** 
 * extract schema from a nullable union 
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>Schema</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Schema&gt; [types=in.getTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchema</MethodName>
            <MethodComment>/** 
 * This method is called by  {@link #getAvroSchema}. The default implementation returns the schema of an avro file; or the schema of the last file in a first-level directory (it does not contain sub-directories).
 * @param path  path of a file or first level directory
 * @param fs  file system
 * @return avro schema
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Schema</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>Path</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fs</ParamName>
                    <ParamType>FileSystem</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Path [lastFile=AvroStorageUtils.getLast(path,fs)]</InnerVar>
                <InnerVar>GenericDatumReader&lt;Object&gt; [avroReader=new GenericDatumReader&lt;Object&gt;()]</InnerVar>
                <InnerVar>InputStream [hdfsInputStream=fs.open(lastFile)]</InnerVar>
                <InnerVar>DataFileStream&lt;Object&gt; [avroDataStream=new DataFileStream&lt;Object&gt;(hdfsInputStream,avroReader)]</InnerVar>
                <InnerVar>Schema [ret=avroDataStream.getSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>avroDataStream;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>