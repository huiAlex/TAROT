/**
 * Schema, from a logical perspective.
 */

/**
     * Reset uids of all fieldschema that the schema contains
     */

/**
     * Recursively compare two schemas to check if the input schema 
     * can be cast to the cast schema
     * @param inSch schema of the cast input
     * @param outSch schema of the cast operator
     * @return true if castable
     */

/**
     * Add a field to this schema.
     * @param field to be added to the schema
     */

/**
     * Fetch a field by alias
     * @param alias
     * @return field associated with alias, or null if no such field
     *      */

/**
     * Given an alias name, find the associated LogicalFieldSchema. If exact name is 
     * not found see if any field matches the part of the 'namespaced' alias.
     * eg. if given alias is nm::a , and schema is (a,b). It will return 
     * FieldSchema of a.
     * if given alias is nm::a and schema is (nm2::a, b), it will return null
     * @param alias Alias to look up.
     * @return LogicalFieldSchema, or null if no such alias is in this tuple.
     */

/**
     * Fetch a field by field number
     * @param fieldNum field number to fetch
     * @return field
     */

/**
     * Get all fields
     * @return list of all fields
     */

/**
     * Get the size of the schema.
     * @return size
     */

/**
     * Two schemas are equal if they are of equal size and their fields
     * schemas considered in order are equal. This function does 
     * not compare the alias of the fields.
     */

/**
     * Two schemas are equal if they are of equal size and their fields
     * schemas considered in order are equal. If compareAlias argument is 
     * set to true, the alias of the fields are also compared.
     * @param other
     * @param compareAlias
     * @return true if equal
     */

/**
     * Look for the index of the field that contains the specified uid
     * @param uid the uid to look for
     * @return the index of the field, -1 if not found
     */

/**
     * Merge two schemas.
     * @param s1 In Load/ForEach, s1 is user declared schema; In Union, s1 is left side.
     * @param s2 In Load/ForEach, s2 is infered schema; In Union, s2 is right side.
     * @param mode We merge schema in Load/Foreach/Union. In Load/Foreach, we always take s1 if compatible (s1 is set to be user defined schema),
     * In union, we take more specific type (between numeric and string, we take string). In the case type mismatch in s1/s2, 
     * we expect TypeCheckingVisitor will fill the gap later. 
     * @return a merged schema, or null if the merge fails
     */

/**
     * Merges collection of schemas using their column aliases 
     * (unlike mergeSchema(..) functions which merge using positions)
     * Schema will not be merged if types are incompatible, 
     * as per DataType.mergeType(..)
     * For Tuples and Bags, SubSchemas have to be equal be considered compatible
     * @param schemas - list of schemas to be merged using their column alias
     * @return merged schema
     */

/**
     * Merges two schemas using their column aliases 
     * (unlike mergeSchema(..) functions which merge using positions)
     * Schema will not be merged if types are incompatible, 
     * as per DataType.mergeType(..)
     * For Tuples and Bags, SubSchemas have to be equal be considered compatible
     */

/**
     * If one of the aliases is of form 'nm::str1', and other is of the form
     * 'str1', this returns str1
     */

/**
     * Recursively compare two schemas for equality
     * @param schema
     * @param other
     * @param relaxInner if true, inner schemas will not be checked
     * @param relaxAlias if true, aliases will not be checked
     * @return true if schemas are equal, false otherwise
     */

/***
     * Old Pig schema does not require a tuple schema inside a bag;
     * Now it is required to have that; this method is to fill the gap
     */

/**
         * Equality is defined as having the same type and either the same schema
         * or both null schema.  Alias and uid are not checked.
         */

/**
         * Equality is defined as having the same type and either the same schema
         * or both null schema. if compareAlias argument is set to true, alias
         * is also compared.
         * @param other 
         * @param compareAlias
         * @return true if equal
         */

/**
         * Give new value for uid if uid of field schema or those in fields schema
         * of inner schema are -1.
         */

/**
         * Adds the uid from FieldSchema argument to this FieldSchema
         * If the argument is null, it stamps this FieldSchema with uid
         * @param uidOnlyFieldSchema
         * @return FieldSchema 
         *          */

/**
         * Rest uid of this fieldschema and inner schema
         */

/***
         * Compare two field schema for equality

         * @param relaxInner If true, we don't check inner tuple schemas
         * @param relaxAlias If true, we don't check aliases
         * @return true if FieldSchemas are equal, false otherwise
         */

/**
         * Check if FieldSchema inFs is castable to outFs
         * @param inFs
         * @param outFs
         * @return true if it is castable
         */

/***
         * Merge two LogicalFieldSchema, the behavior of merge depends on mode. 
         * If mode==MergeType.LoadForEach or MergeType.LoadForEachInner, take left side if compatible, otherwise, throw exception.
         * If mode==MergeType.UnionInner, if not same type, throw exception, end up with null inner schema.
         * If mode==MergeType.Union, take more specific type.
         * @param fs1 In Load/Foreach, fs1 is user declared schema; in Union, fs1 is left side
         * @param fs2 In Load/Foreach, fs1 is inferred schema; in Union, fs1 is left side
         * @param mode merge mode
         */

/***
         * Old Pig field schema does not require a tuple schema inside a bag;
         * Now it is required to have that; this method is to fill the gap
         */

