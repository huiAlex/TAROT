<Class>
    <Id>254</Id>
    <Package>groovy.transform</Package>
    <ClassName>Immutable</ClassName>
    <ClassComment>Immutable  /** 
 * Class annotation used to assist in the creation of immutable classes. &lt;p&gt; It allows you to write classes in this shortened form: &lt;pre&gt; {@code @Immutable} class Customer {String first, last int age Date since Collection favItems } def d = new Date() def c1 = new Customer(first:'Tom', last:'Jones', age:21, since:d, favItems:['Books', 'Games']) def c2 = new Customer('Tom', 'Jones', 21, d, ['Books', 'Games']) assert c1 == c2 &lt;/pre&gt; The  {@code @Immutable} annotation instructs the compiler to execute anAST transformation which adds the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties. &lt;p&gt; A class created in this way has the following characteristics: &lt;ul&gt; &lt;li&gt;The class is automatically made final. &lt;li&gt;Properties must be of an immutable type or a type with a strategy for handling non-immutable characteristics. Specifically, the type must be one of the primitive or wrapper types, Strings, enums, other  {@code @Immutable} classes or known immutables (e.g. java.awt.Color, java.net.URI, java.util.UUID).Also handled are Cloneable classes, collections, maps and arrays, and other "effectively immutable" classes with special handling (e.g. java.util.Date). &lt;li&gt;Properties automatically have private, final backing fields with getters. Attempts to update the property will result in a  {@code ReadOnlyPropertyException}. &lt;li&gt;A map-based constructor is provided which allows you to set properties by name. &lt;li&gt;A tuple-style constructor is provided which allows you to set properties in the same order as they are defined. &lt;li&gt;Default  {@code equals},  {@code hashCode} and {@code toString} methods are provided based on the property values.Though not normally required, you may write your own implementations of these methods. For  {@code equals} and {@code hashCode}, if you do write your own method, it is up to you to obey the general contract for  {@code equals} methods and supplya corresponding matching  {@code hashCode} method.If you do provide one of these methods explicitly, the default implementation will be made available in a private "underscore" variant which you can call. E.g., you could provide a (not very elegant) multi-line formatted {@code toString} method for {@code Customer} above as follows:&lt;pre&gt; String toString() { _toString().replaceAll(/\(/, '(\n\t').replaceAll(/\)/, '\n)').replaceAll(/, /, '\n\t') } &lt;/pre&gt; If an "underscore" version of the respective method already exists, then no default implementation is provided. &lt;li&gt; {@code Date}s,  {@code Cloneable}s and arrays are defensively copied on the way in (constructor) and out (getters). Arrays and  {@code Cloneable} objects use the {@code clone} method. For your own classes,it is up to you to define this method and use deep cloning if appropriate. &lt;li&gt; {@code Collection}s and  {@code Map}s are wrapped by immutable wrapper classes (but not deeply cloned!). Attempts to update them will result in an  {@code UnsupportedOperationException}. &lt;li&gt;Fields that are enums or other  {@code @Immutable} classes are allowed but for anotherwise possible mutable property type, an error is thrown. &lt;li&gt;You don't have to follow Groovy's normal property conventions, e.g. you can create an explicit private field and then you can write explicit get and set methods. Such an approach, isn't currently prohibited (to give you some wiggle room to get around these conventions) but any fields created in this way are deemed not to be part of the significant state of the object and aren't factored into the  {@code equals} or {@code hashCode} methods.Similarly, you may use static properties (though usually this is discouraged) and these too will be ignored as far as significant state is concerned. If you do break standard conventions, you do so at your own risk and your objects may no longer be immutable. It is up to you to ensure that your objects remain immutable at least to the extent expected in other parts of your program! &lt;/ul&gt; Immutable classes are particularly useful for functional and concurrent styles of programming and for use as key values within maps. If you want similar functionality to what this annotation provides but don't need immutability then consider using  {@code @Canonical}. &lt;p&gt; Customising behaviour: &lt;p&gt; You can customise the toString() method provided for you by  {@code @Immutable}by also adding the  {@code @ToString} annotation to your class definition.&lt;p&gt; Limitations: &lt;ul&gt; &lt;li&gt; As outlined above, Arrays and  {@code Cloneable} objects use the {@code clone} method. For your own classes,it is up to you to define this method and use deep cloning if appropriate. &lt;/li&gt; &lt;li&gt; As outlined above,  {@code Collection}s and  {@code Map}s are wrapped by immutable wrapper classes (but not deeply cloned!). &lt;/li&gt; &lt;li&gt; Currently  {@code BigInteger} and {@code BigDecimal} are deemed immutable but see:http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6348370 &lt;/li&gt; &lt;li&gt; {@code java.awt.Color} is treated as "effectively immutable" but is not final so while not normally used with childclasses, it isn't strictly immutable. Use at your own risk. &lt;/li&gt; &lt;li&gt; {@code java.util.Date} is treated as "effectively immutable" but is not final so it isn't strictly immutable.Use at your own risk. &lt;/li&gt; &lt;li&gt; Groovy's normal map-style naming conventions will not be available if the first property has type  {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property.&lt;/li&gt; &lt;/ul&gt;
 * @author Paul King
 * @author Andre Steingress
 * @see groovy.transform.ToString
 * @see groovy.transform.Canonical
 * @since 1.7
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>