<Class>
    <Id>955</Id>
    <Package>org.codehaus.groovy.runtime</Package>
    <ClassName>IOGroovyMethods</ClassName>
    <SuperClass>DefaultGroovyMethodsSupport</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>IOGroovyMethods  /** 
 * This class defines new groovy methods for Files, URLs, URIs which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static long size(File self)&lt;/code&gt; provides a &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;. &lt;p&gt; NOTE: While this class contains many 'public' static methods, it is primarily regarded as an internal class (its internal package name suggests this also). We value backwards compatibility of these methods when used within Groovy but value less backwards compatibility at the Java method call level. I.e. future versions of Groovy may remove or move a method call in this file but would normally aim to keep the method available from within Groovy.
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author Jeremy Rayner
 * @author Sam Pullara
 * @author Rod Cope
 * @author Guillaume Laforge
 * @author John Wilson
 * @author Hein Meling
 * @author Dierk Koenig
 * @author Pilho Kim
 * @author Marc Guillemot
 * @author Russel Winder
 * @author bing ran
 * @author Jochen Theodorou
 * @author Paul King
 * @author Michael Baehr
 * @author Joachim Baumann
 * @author Alex Tkachman
 * @author Ted Naleid
 * @author Brad Long
 * @author Jim Jagielski
 * @author Rodolfo Velasco
 * @author jeremi Joslin
 * @author Hamlet D'Arcy
 * @author Cedric Champeau
 * @author Tim Yates
 * @author Dinko Srkoc
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
        <Field>
            <FieldName>charBufferSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>expectedLineLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>EOF</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextVal</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>nextMustRead</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>hasNext</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>nextVal</FieldName>
            <FieldType>Byte</FieldType>
        </Field>
        <Field>
            <FieldName>nextMustRead</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>hasNext</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the leftShift operator for Writer to allow an object to be written using Groovy's default representation for the object.
 * @param self  a Writer
 * @param value an Object whose default representation will be written to the Writer
 * @return the writer on which this operation was invoked
 * @throws IOException if an I/O error occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>InvokerHelper;write;[self, value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the leftShift operator for Appendable to allow an object to be appended using Groovy's default representation for the object.
 * @param self  an Appendable
 * @param value an Object whose default representation will be appended to the Appendable
 * @return the Appendable on which this operation was invoked
 * @throws IOException if an I/O error occurs.
 * @since 2.1.0
 */
</MethodComment>
            <ReturnType>Appendable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Appendable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>InvokerHelper;append;[self, value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withFormatter</MethodName>
            <MethodComment>/** 
 * Invokes a Closure that uses a Formatter taking care of resource handling. A Formatter is created and passed to the Closure as its argument. After the Closure executes, the Formatter is flushed and closed releasing any associated resources.
 * @param self    an Appendable
 * @param closure a 1-arg Closure which will be called with a Formatter as its argument
 * @return the Appendable on which this operation was invoked
 * @since 2.1.0
 */
</MethodComment>
            <ReturnType>Appendable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Appendable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Formatter [formatter=new Formatter(self)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;callWithFormatter;[closure, formatter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withFormatter</MethodName>
            <MethodComment>/** 
 * Invokes a Closure that uses a Formatter taking care of resource handling. A Formatter is created using the given Locale and passed to the Closure as its argument. After the Closure executes, the Formatter is flushed and closed releasing any associated resources.
 * @param self    an Appendable
 * @param locale  a Locale used when creating the Formatter
 * @param closure a 1-arg Closure which will be called with a Formatter as its argument
 * @return the Appendable on which this operation was invoked
 * @since 2.1.0
 */
</MethodComment>
            <ReturnType>Appendable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Appendable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locale</ParamName>
                    <ParamType>Locale</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Formatter [formatter=new Formatter(self,locale)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;callWithFormatter;[closure, formatter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithFormatter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formatter</ParamName>
                    <ParamType>Formatter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * A helper method so that dynamic dispatch of the writer.write(object) method will always use the more efficient Writable.writeTo(writer) mechanism if the object implements the Writable interface.
 * @param self     a Writer
 * @param writable an object implementing the Writable interface
 * @throws IOException if an I/O error occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writable</ParamName>
                    <ParamType>Writable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writable;writeTo;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the leftShift operator to provide an append mechanism to add values to a stream.
 * @param self  an OutputStream
 * @param value a value to append
 * @return a Writer
 * @throws java.io.IOException if an I/O error occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OutputStreamWriter [writer=new FlushingStreamWriter(self)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;leftShift;[writer, value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the leftShift operator to add objects to an ObjectOutputStream.
 * @param self  an ObjectOutputStream
 * @param value an object to write to the stream
 * @throws IOException if an I/O error occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>ObjectOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>self;writeObject;[value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Pipe an InputStream into an OutputStream for efficient stream copying.
 * @param self stream on which to write
 * @param in   stream to read from
 * @return the outputstream itself
 * @throws IOException if an I/O error occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [buf=new byte[1024]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>self;flush;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Overloads the leftShift operator to provide an append mechanism to add bytes to a stream.
 * @param self  an OutputStream
 * @param value a value to append
 * @return an OutputStream
 * @throws IOException if an I/O error occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>self;write;[value]</InnerMethodInvoke>
                <InnerMethodInvoke>self;flush;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectOutputStream</MethodName>
            <MethodComment>/** 
 * Create an object output stream for this output stream.
 * @param outputStream an output stream
 * @return an object output stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectOutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outputStream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectOutputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectOutputStream for this output stream and then pass it to the closure.  This method ensures the stream is closed after the closure returns.
 * @param outputStream am output stream
 * @param closure      a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #withStream(java.io.OutputStream,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outputStream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create an object input stream for this input stream.
 * @param inputStream an input stream
 * @return an object input stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create an object input stream for this input stream using the given class loader.
 * @param inputStream an input stream
 * @param classLoader the class loader to use when loading the class
 * @return an object input stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>desc</ParamName>
                    <ParamType>ObjectStreamClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachObject</MethodName>
            <MethodComment>/** 
 * Iterates through the given object stream object by object. The ObjectInputStream is closed afterwards.
 * @param ois     an ObjectInputStream, closed after the operation
 * @param closure a closure
 * @throws IOException            if an IOException occurs.
 * @throws ClassNotFoundException if the class  is not found.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ois</ParamName>
                    <ParamType>ObjectInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectInputStream for this file and pass it to the closure. This method ensures the stream is closed after the closure returns.
 * @param inputStream an input stream
 * @param closure     a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectInputStream for this file and pass it to the closure. This method ensures the stream is closed after the closure returns.
 * @param inputStream an input stream
 * @param classLoader the class loader to use when loading the class
 * @param closure     a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this stream reading with the provided charset, passing each line to the given 1 or 2 arg closure.  The stream is closed before this method returns.
 * @param stream  a stream
 * @param charset opens the stream with a specified charset
 * @param closure a closure (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.InputStream,java.lang.String,int,groovy.lang.Closure)
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this stream reading with the provided charset, passing each line to the given 1 or 2 arg closure.  The stream is closed after this method returns.
 * @param stream    a stream
 * @param charset   opens the stream with a specified charset
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this stream, passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param stream  a stream
 * @param closure a closure (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.InputStream,int,groovy.lang.Closure)
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this stream, passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param stream    a stream
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given reader line by line.  Each line is passed to the given 1 or 2 arg closure. If the closure has two arguments, the line count is passed as the second argument. The Reader is closed before this method returns.
 * @param self    a Reader, closed after the method returns
 * @param closure a closure (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given reader line by line.  Each line is passed to the given 1 or 2 arg closure. If the closure has two arguments, the line count is passed as the second argument. The Reader is closed before this method returns.
 * @param self      a Reader, closed after the method returns
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure which will be passed each line (or for 2 arg closures the line and line count)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [br]</InnerVar>
                <InnerVar>int [count=firstLine]</InnerVar>
                <InnerVar>T [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given reader line by line, splitting each line using the given regex separator. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression.  The Reader is closed afterwards. &lt;p&gt; Here is an example: &lt;pre&gt; def s = 'The 3 quick\nbrown 4 fox' def result = '' new StringReader(s).splitEachLine(/\d/){ parts -&gt; result += "${parts[0]}_${parts[1]}|" } assert result == 'The _ quick|brown _ fox|' &lt;/pre&gt;
 * @param self    a Reader, closed after the method returns
 * @param regex   the delimiting regular expression
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see java.lang.String#split(java.lang.String)
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given reader line by line, splitting each line using the given regex separator Pattern. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression.  The Reader is closed afterwards. &lt;p&gt; Here is an example: &lt;pre&gt; def s = 'The 3 quick\nbrown 4 fox' def result = '' new StringReader(s).splitEachLine(~/\d/){ parts -&gt; result += "${parts[0]}_${parts[1]}|" } assert result == 'The _ quick|brown _ fox|' &lt;/pre&gt;
 * @param self    a Reader, closed after the method returns
 * @param pattern the regular expression Pattern for the delimiter
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see java.lang.String#split(java.lang.String)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [br]</InnerVar>
                <InnerVar>T [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given InputStream line by line using the specified encoding, splitting each line using the given separator.  The list of tokens for each line is then passed to the given closure. Finally, the stream is closed.
 * @param stream  an InputStream
 * @param regex   the delimiting regular expression
 * @param charset opens the stream with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see #splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given InputStream line by line using the specified encoding, splitting each line using the given separator Pattern.  The list of tokens for each line is then passed to the given closure. Finally, the stream is closed.
 * @param stream  an InputStream
 * @param pattern the regular expression Pattern for the delimiter
 * @param charset opens the stream with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given InputStream line by line, splitting each line using the given separator.  The list of tokens for each line is then passed to the given closure. The stream is closed before the method returns.
 * @param stream  an InputStream
 * @param regex   the delimiting regular expression
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see #splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the given InputStream line by line, splitting each line using the given separator Pattern.  The list of tokens for each line is then passed to the given closure. The stream is closed before the method returns.
 * @param stream  an InputStream
 * @param pattern the regular expression Pattern for the delimiter
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLine</MethodName>
            <MethodComment>/** 
 * Read a single, whole line from the given Reader.
 * @param self a Reader
 * @return a line
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLineFromReaderWithMark</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char[] [cbuf=new char[charBufferSize]]</InnerVar>
                <InnerVar>int [count=input.read(cbuf)]</InnerVar>
                <InnerVar>StringBuilder [line=new StringBuilder(expectedLineLength)]</InnerVar>
                <InnerVar>int [ls=lineSeparatorIndex(cbuf,count)]</InnerVar>
                <InnerVar>int [skipLS=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>line;append;[cbuf, 0, ls]</InnerMethodInvoke>
                <InnerMethodInvoke>input;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>input;skip;[line.length() + skipLS]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLineFromReaderWithoutMark</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c=input.read()]</InnerVar>
                <InnerVar>StringBuilder [line=new StringBuilder(expectedLineLength)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lineSeparatorIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLineSeparator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the stream into a list, with one element for each line.
 * @param stream a stream
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see #readLines(java.io.Reader)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the stream into a list, with one element for each line.
 * @param stream  a stream
 * @param charset opens the stream with a specified charset
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see #readLines(java.io.Reader)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the reader into a list of Strings, with one entry for each line. The reader is closed before this method returns.
 * @param reader a Reader
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IteratorClosureAdapter&lt;String&gt; [closure=new IteratorClosureAdapter&lt;String&gt;(reader)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachLine;[reader, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of this InputStream and return it as a String. The stream is closed before this method returns.
 * @param is an input stream
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [reader=new BufferedReader(new InputStreamReader(is))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of this InputStream using specified charset and return it as a String.  The stream is closed before this method returns.
 * @param is      an input stream
 * @param charset opens the stream with a specified charset
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [reader=new BufferedReader(new InputStreamReader(is,charset))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of the Reader and return it as a String.  The reader is closed before this method returns.
 * @param reader a Reader whose content we want to read
 * @return a String containing the content of the buffered reader
 * @throws IOException if an IOException occurs.
 * @see #getText(java.io.BufferedReader)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [bufferedReader=new BufferedReader(reader)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of the BufferedReader and return it as a String. The BufferedReader is closed afterwards.
 * @param reader a BufferedReader whose content we want to read
 * @return a String containing the content of the buffered reader
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>BufferedReader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [answer=new StringBuilder()]</InnerVar>
                <InnerVar>char[] [charBuffer=new char[8192]]</InnerVar>
                <InnerVar>int [nbCharRead]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytes</MethodName>
            <MethodComment>/** 
 * Read the content of this InputStream and return it as a byte[]. The stream is closed before this method returns.
 * @param is an input stream
 * @return the byte[] from that InputStream
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ByteArrayOutputStream [answer=new ByteArrayOutputStream()]</InnerVar>
                <InnerVar>byte[] [byteBuffer=new byte[8192]]</InnerVar>
                <InnerVar>int [nbByteRead]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBytes</MethodName>
            <MethodComment>/** 
 * Write the byte[] to the output stream. The stream is closed before this method returns.
 * @param os    an output stream
 * @param bytes the byte[] to write to the output stream
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>os</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLine</MethodName>
            <MethodComment>/** 
 * Write the text and append a newline (using the platform's line-ending).
 * @param writer a BufferedWriter
 * @param line   the line to write
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>BufferedWriter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>line</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;write;[line]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;newLine;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * Creates an iterator which will traverse through the reader a line at a time.
 * @param self a Reader object
 * @return an Iterator for the Reader
 * @see java.io.BufferedReader#readLine()
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [bufferedReader]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [retval=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [nv=bufferedReader.readLine()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * Standard iterator for a input stream which iterates through the stream content in a byte-based fashion.
 * @param self an InputStream object
 * @return an Iterator for the InputStream
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>Byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * Standard iterator for a data input stream which iterates through the stream content a Byte at a time.
 * @param self a DataInputStream object
 * @return an Iterator for the DataInputStream
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>Byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>DataInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Byte</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Byte [retval=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a reader for this input stream.
 * @param self an input stream
 * @return a reader
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a reader for this input stream, using the specified charset as the encoding.
 * @param self    an input stream
 * @param charset the charset for this input stream
 * @return a reader
 * @throws UnsupportedEncodingException if the encoding specified is not supported
 * @since 1.6.0
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedEncodingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this Writer.
 * @param writer a Writer
 * @return a PrintWriter
 * @since 1.6.0
 */
</MethodComment>
            <ReturnType>PrintWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this OutputStream.
 * @param stream an OutputStream
 * @return a PrintWriter
 * @since 2.2.0
 */
</MethodComment>
            <ReturnType>PrintWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this Writer.  The writer is passed to the closure, and will be closed before this method returns.
 * @param writer  a writer
 * @param closure the closure to invoke with the PrintWriter
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.6.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this OutputStream.  The writer is passed to the closure, and will be closed before this method returns.
 * @param stream  an OutputStream
 * @param closure the closure to invoke with the PrintWriter
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 2.2.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Allows this writer to be used within the closure, ensuring that it is flushed and closed before this method returns.
 * @param writer  the writer which is used and then closed
 * @param closure the closure that the writer is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Allows this reader to be used within the closure, ensuring that it is closed before this method returns.
 * @param reader  the reader which is used and then closed
 * @param closure the closure that the writer is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withStream</MethodName>
            <MethodComment>/** 
 * Allows this input stream to be used within the closure, ensuring that it is flushed and closed before this method returns.
 * @param stream  the stream which is used and then closed
 * @param closure the closure that the stream is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>U</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Helper method to create a new Reader for a stream and then passes it into the closure.  The reader (and this stream) is closed after the closure returns.
 * @param in      a stream
 * @param closure the closure to invoke with the InputStream
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see java.io.InputStreamReader
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Helper method to create a new Reader for a stream and then passes it into the closure.  The reader (and this stream) is closed after the closure returns.
 * @param in      a stream
 * @param charset the charset used to decode the stream
 * @param closure the closure to invoke with the reader
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see java.io.InputStreamReader
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Creates a writer from this stream, passing it to the given closure. This method ensures the stream is closed after the closure returns.
 * @param stream  the stream which is used and then closed
 * @param closure the closure that the writer is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #withWriter(java.io.Writer,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Creates a writer for this stream.
 * @param stream the stream which is used and then closed
 * @return the newly created Writer
 * @since 2.2.0
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Creates a writer from this stream, passing it to the given closure. This method ensures the stream is closed after the closure returns.
 * @param stream  the stream which is used and then closed
 * @param charset the charset used
 * @param closure the closure that the writer is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #withWriter(java.io.Writer,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Creates a writer for this stream using the given charset.
 * @param stream the stream which is used and then closed
 * @param charset the charset used
 * @return the newly created Writer
 * @throws UnsupportedEncodingException if an encoding exception occurs.
 * @since 2.2.0
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedEncodingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withStream</MethodName>
            <MethodComment>/** 
 * Passes this OutputStream to the closure, ensuring that the stream is closed after the closure returns, regardless of errors.
 * @param os      the stream which is used and then closed
 * @param closure the closure that the stream is passed into
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>os</ParamName>
                    <ParamType>U</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Traverse through each byte of the specified stream. The stream is closed after the closure returns.
 * @param is      stream to iterate over, closed after the method call
 * @param closure closure to apply to each byte
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Traverse through each the specified stream reading bytes into a buffer and calling the 2 parameter closure with this buffer and the number of bytes.
 * @param is        stream to iterate over, closed after the method call.
 * @param bufferLen the length of the buffer to use.
 * @param closure   a 2 parameter closure which is passed the byte[] and a number of bytes successfully read.
 * @throws IOException if an IOException occurs.
 * @since 1.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bufferLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [buffer=new byte[bufferLen]]</InnerVar>
                <InnerVar>int [bytesRead]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transformChar</MethodName>
            <MethodComment>/** 
 * Transforms each character from this reader by passing it to the given closure.  The Closure should return each transformed character, which will be passed to the Writer.  The reader and writer will be both be closed before this method returns.
 * @param self    a Reader object
 * @param writer  a Writer to receive the transformed characters
 * @param closure a closure that performs the required transformation
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transformLine</MethodName>
            <MethodComment>/** 
 * Transforms the lines from a reader with a Closure and write them to a writer. Both Reader and Writer are closed after the operation.
 * @param reader  Lines of text to be transformed. Reader is closed afterwards.
 * @param writer  Where transformed lines are written. Writer is closed afterwards.
 * @param closure Single parameter closure that is called to transform each line oftext from the reader, before writing it to the writer.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [br=new BufferedReader(reader)]</InnerVar>
                <InnerVar>BufferedWriter [bw=new BufferedWriter(writer)]</InnerVar>
                <InnerVar>String [line]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter the lines from a reader and write them on the writer, according to a closure which returns true if the line should be included. Both Reader and Writer are closed after the operation.
 * @param reader  a reader, closed after the call
 * @param writer  a writer, closed after the call
 * @param closure the closure which returns booleans
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [br=new BufferedReader(reader)]</InnerVar>
                <InnerVar>BufferedWriter [bw=new BufferedWriter(writer)]</InnerVar>
                <InnerVar>String [line]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter the lines from this Reader, and return a Writable which can be used to stream the filtered lines to a destination.  The closure should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param reader  this reader
 * @param closure a closure used for filtering
 * @return a Writable which will use the closure to filter each linefrom the reader when the Writable#writeTo(Writer) is called.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [br=new BufferedReader(reader)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedWriter [bw=new BufferedWriter(out)]</InnerVar>
                <InnerVar>String [line]</InnerVar>
                <InnerVar>BooleanClosureWrapper [bcw=new BooleanClosureWrapper(closure)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>bw;flush;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringWriter [buffer=new StringWriter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter lines from an input stream using a closure predicate.  The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      an input stream
 * @param predicate a closure which returns boolean and takes a line
 * @return a writable which writes out the filtered lines
 * @see #filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter lines from an input stream using a closure predicate.  The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      an input stream
 * @param charset   opens the stream with a specified charset
 * @param predicate a closure which returns boolean and takes a line
 * @return a writable which writes out the filtered lines
 * @throws UnsupportedEncodingException if the encoding specified is not supported
 * @see #filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>UnsupportedEncodingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Uses a closure to filter lines from this InputStream and pass them to the given writer. The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      the InputStream
 * @param writer    a writer to write output to
 * @param predicate a closure which returns true if a line should be accepted
 * @throws IOException if an IOException occurs.
 * @see #filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;filterLine;[newReader(self), writer, predicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Uses a closure to filter lines from this InputStream and pass them to the given writer. The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      the InputStream
 * @param writer    a writer to write output to
 * @param charset   opens the stream with a specified charset
 * @param predicate a closure which returns true if a line should be accepted
 * @throws IOException if an IOException occurs.
 * @see #filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;filterLine;[newReader(self,charset), writer, predicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withCloseable</MethodName>
            <MethodComment>/** 
 * Allows this closeable to be used within the closure, ensuring that it is closed once the closure has been executed and before this method returns.
 * @param self the Closeable
 * @param action the closure taking the Closeable as parameter
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 2.4.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>U</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>