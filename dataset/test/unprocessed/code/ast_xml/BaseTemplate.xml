<Class>
    <Id>590</Id>
    <Package>groovy.text.markup</Package>
    <ClassName>BaseTemplate</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Writable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BaseTemplate  /** 
 * &lt;p&gt;All templates compiled through  {@link groovy.text.markup.MarkupTemplateEngine} extend this abstract class,which provides a number of utility methods to generate markup. An instance of this class can be obtained after calling  {@link groovy.text.Template#make()} or {@link groovy.text.Template#make(java.util.Map)})} on a template generated by  {@link groovy.text.markup.MarkupTemplateEngine#createTemplate(java.io.Reader)}.&lt;/p&gt; &lt;p&gt;It is advised to use a distinct template instance for each thread (or more simply, each rendered document) for thread safety and avoiding mixing models.&lt;/p&gt; &lt;p&gt;For the application needs, it is possible to provide more helper methods by extending this class and configuring the base template class using the  {@link groovy.text.markup.TemplateConfiguration#setBaseTemplateClass(Class)}method.&lt;/p&gt;
 * @author Cedric Champeau
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>EMPTY_MODEL</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>model</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>modelTypes</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>modelTypes</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>engine</FieldName>
            <FieldType>MarkupTemplateEngine</FieldType>
        </Field>
        <Field>
            <FieldName>configuration</FieldName>
            <FieldType>TemplateConfiguration</FieldType>
        </Field>
        <Field>
            <FieldName>cachedFragments</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>cachedFragments</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>out</FieldName>
            <FieldType>Writer</FieldType>
        </Field>
        <Field>
            <FieldName>doWriteIndent</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>array</FieldName>
            <FieldType>Object[]</FieldType>
        </Field>
        <Field>
            <FieldName>attributes</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>body</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BaseTemplate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templateEngine</ParamName>
                    <ParamType>MarkupTemplateEngine</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>model</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>modelTypes</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>configuration</ParamName>
                    <ParamType>TemplateConfiguration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getModel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Map</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>yieldUnescaped</MethodName>
            <MethodComment>/** 
 * Renders the object provided as parameter using its  {@link Object#toString()} method,The contents is rendered as is, unescaped. This means that depending on what the {@link Object#toString()} method call returns, you might create invalid markup.
 * @param obj the object to be rendered unescaped
 * @return this template instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>BaseTemplate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeIndent;[]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[obj.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>yield</MethodName>
            <MethodComment>/** 
 * Renders the object provided as parameter using its  {@link Object#toString()} method,The contents is rendered after being escaped for XML, enforcing valid XML output.
 * @param obj the object to be rendered
 * @return this template instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>BaseTemplate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeIndent;[]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[escapeXml(obj.toString())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cl</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [old=out]</InnerVar>
                <InnerVar>StringWriter [stringWriter=new StringWriter(32)]</InnerVar>
                <InnerVar>Object [result=cl.call()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>comment</MethodName>
            <MethodComment>/** 
 * Renders the supplied object using its  {@link Object#toString} method inside acomment markup block (&amp;lt;!-- ... --&amp;gt;). The object is rendered as is, unescaped.
 * @param cs the object to be rendered inside an XML comment block.
 * @return this template instance.
 * @throws IOException
 */
</MethodComment>
            <ReturnType>BaseTemplate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cs</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeIndent;[]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;["&lt;!--"]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[cs.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;["--&gt;"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xmlDeclaration</MethodName>
            <MethodComment>/** 
 * Renders an XML declaration header. If the declaration encoding is set in the {@link TemplateConfiguration#getDeclarationEncoding() template configuration}, then the encoding is rendered into the declaration.
 * @return this template instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>BaseTemplate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;write;["&lt;?xml "]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeAttribute;["version", "1.0"]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;["?&gt;"]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[configuration.getNewLineString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pi</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Renders processing instructions. The supplied map contains all elements to be rendered as processing instructions. The key is the name of the element, the value is either a map of attributes, or an object to be rendered directly. For example:&lt;/p&gt; &lt;code&gt; pi("xml-stylesheet":[href:"mystyle.css", type:"text/css"]) &lt;/code&gt; &lt;p&gt;will be rendered as:&lt;/p&gt; &lt;pre&gt; &amp;lt;?xml-stylesheet href='mystyle.css' type='text/css'?&amp;gt; &lt;/pre&gt;
 * @param attrs the attributes to render
 * @return this template instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>BaseTemplate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>attrs</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeAttribute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>attName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;write;[attName]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;["="]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeQt;[]</InnerMethodInvoke>
                <InnerMethodInvoke>out;write;[escapeQuotes(value)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeQt;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeQt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeIndent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>escapeQuotes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [quote=configuration.isUseDoubleQuotes() ? "\"" : "'"]</InnerVar>
                <InnerVar>String [escape=configuration.isUseDoubleQuotes() ? "&amp;quote;" : "&amp;apos;"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>methodMissing</MethodName>
            <MethodComment>/** 
 * This is the main method responsible for writing a tag and its attributes. The arguments may be: &lt;ul&gt; &lt;li&gt;a closure&lt;/li&gt; in which case the closure is rendered inside the tag body &lt;li&gt;a string&lt;/li&gt;, in which case the string is rendered as the tag body &lt;li&gt;a map of attributes&lt;/li&gt; in which case the attributes are rendered inside the opening tag &lt;/ul&gt; &lt;p&gt;or a combination of (attributes,string), (attributes,closure)&lt;/p&gt;
 * @param tagName the name of the tag
 * @param args tag generation arguments
 * @return this template instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tagName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [o=model.get(tagName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBody</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>body</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [indent=out instanceof DelegatingIndentWriter]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeAttributes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>attributes</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [wrt=out]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>includeGroovy</MethodName>
            <MethodComment>/** 
 * Includes another template inside this template.
 * @param templatePath the path to the included resource.
 * @throws IOException
 * @throws ClassNotFoundException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templatePath</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URL [resource=engine.resolveTemplate(templatePath)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>engine.createTypeCheckedModelTemplate(resource,modelTypes).make(model);writeTo;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>includeEscaped</MethodName>
            <MethodComment>/** 
 * Includes contents of another file, not as a template but as escaped text.
 * @param templatePath the path to the other file
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templatePath</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URL [resource=engine.resolveTemplate(templatePath)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;yield;[ResourceGroovyMethods.getText(resource,engine.getCompilerConfiguration().getSourceEncoding())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>includeUnescaped</MethodName>
            <MethodComment>/** 
 * Includes contents of another file, not as a template but as unescaped text.
 * @param templatePath the path to the other file
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templatePath</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URL [resource=engine.resolveTemplate(templatePath)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;yieldUnescaped;[ResourceGroovyMethods.getText(resource,engine.getCompilerConfiguration().getSourceEncoding())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tryEscape</MethodName>
            <MethodComment>/** 
 * Escapes the string representation of the supplied object if it derives from  {@link java.lang.CharSequence}, otherwise returns the object itself.
 * @param contents an object to be escaped for XML
 * @return  an escaped string, or the object itself
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contents</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOut</MethodName>
            <MethodComment>/** 
 * Convenience method to return the current writer instance.
 * @return the current writer
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newLine</MethodName>
            <MethodComment>/** 
 * Adds a new line to the output. The new line string can be configured by {@link groovy.text.markup.TemplateConfiguration#setNewLineString(String)}
 * @throws IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;yieldUnescaped;[configuration.getNewLineString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fragment</MethodName>
            <MethodComment>/** 
 * Renders an embedded template as a fragment. Fragments are cached in a template, meaning that if you use the same fragment in a template, it will only be compiled once, but once &lt;b&gt;per template instance&lt;/b&gt;. This is less performant than using  {@link #layout(java.util.Map,String)}.
 * @param model model to be passed to the template
 * @param templateText template body
 * @return this template instance
 * @throws IOException
 * @throws ClassNotFoundException
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>model</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>templateText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Template [template=cachedFragments.get(templateText)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>template.make(model);writeTo;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>layout</MethodName>
            <MethodComment>/** 
 * Imports a template and renders it using the specified model, allowing fine grained composition of templates and layouting. This works similarily to a template include but allows a distinct model to be used. This version doesn't inherit the model from the parent. If you need model inheritance, see  {@link #layout(java.util.Map,String,boolean)}.
 * @param model model to be passed to the template
 * @param templateName the name of the template to be used as a layout
 * @return this template instance
 * @throws IOException
 * @throws ClassNotFoundException
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>model</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>templateName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>layout</MethodName>
            <MethodComment>/** 
 * Imports a template and renders it using the specified model, allowing fine grained composition of templates and layouting. This works similarily to a template include but allows a distinct model to be used. If the layout inherits from the parent model, a new model is created, with the values from the parent model, eventually overriden with those provided specifically for this layout.
 * @param model        model to be passed to the template
 * @param templateName the name of the template to be used as a layout
 * @param inheritModel a boolean indicating if we should inherit the parent model
 * @return this template instance
 * @throws IOException
 * @throws ClassNotFoundException
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>model</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>templateName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inheritModel</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map [submodel=inheritModel ? forkModel(model) : model]</InnerVar>
                <InnerVar>URL [resource=engine.resolveTemplate(templateName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>engine.createTypeCheckedModelTemplate(resource,modelTypes).make(submodel);writeTo;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forkModel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Map</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>m</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map [result=new HashMap()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;putAll;[model]</InnerMethodInvoke>
                <InnerMethodInvoke>result;putAll;[m]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contents</MethodName>
            <MethodComment>/** 
 * Wraps a closure so that it can be used as a prototype for inclusion in layouts. This is useful when you want to use a closure in a model, but that you don't want to render the result of the closure but instead call it as if it was a specification of a template fragment.
 * @param cl the fragment to be wrapped
 * @return a wrapped closure returning an empty string
 */
</MethodComment>
            <ReturnType>Closure</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cl</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cl;call;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cl;call;[args]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cl;call;[arguments]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTo</MethodName>
            <MethodComment>/** 
 * Main method used to render a template.
 * @param out the Writer to which this Writable should output its data.
 * @return a writer instance
 * @throws IOException
 */
</MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TagData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAttributes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Map</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBody</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invoke</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TagData</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringWriter [wrt=new StringWriter(512)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>