<Class>
    <Id>759</Id>
    <Package>groovy.text</Package>
    <ClassName>StreamingTemplateEngine</ClassName>
    <SuperClass>TemplateEngine</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StreamingTemplateEngine  /** 
 * Processes template source files substituting variables and expressions into placeholders in a template source text to produce the desired output using a closure based approach. This engine has equivalent functionality to the {@link groovy.text.SimpleTemplateEngine} but creates the template usingwritable closures making it more scalable for large templates. &lt;p&gt; Specifically this template engine can handle strings larger than 64k which still causes problems for the other groovy template engines. &lt;/p&gt; &lt;p&gt; The template engine uses JSP style &amp;lt;% %&amp;gt; script and &amp;lt;%= %&amp;gt; expression syntax or GString style expressions. The variable '&lt;code&gt;out&lt;/code&gt;' is bound to the writer that the template is being written to. &lt;/p&gt; Frequently, the template source will be in a file but here is a simple example providing the template as a string: &lt;pre&gt; def binding = [ firstname : "Grace", lastname  : "Hopper", accepted  : true, title     : 'Groovy for COBOL programmers' ] def text = '''\ Dear &lt;% out.print firstname %&gt; ${lastname}, We &lt;% if (accepted) out.print 'are pleased' else out.print 'regret' %&gt; \ to inform you that your paper entitled '$title' was ${ accepted ? 'accepted' : 'rejected' }. The conference committee. ''' def template = new groovy.text.StreamingTemplateEngine().createTemplate(text) print template.make(binding) &lt;/pre&gt; This example uses a mix of the JSP style and GString style placeholders but you can typically use just one style if you wish. Running this example will produce this output: &lt;pre&gt; Dear Grace Hopper, We are pleased to inform you that your paper entitled 'Groovy for COBOL programmers' was accepted. The conference committee. &lt;/pre&gt; &lt;br /&gt; &lt;h3&gt;StreamingTemplateEngine as a servlet engine&lt;/h3&gt; The template engine can also be used as the engine for {@link groovy.servlet.TemplateServlet} by placing the following in your&lt;code&gt;web.xml&lt;/code&gt; file (plus a corresponding servlet-mapping element): &lt;pre&gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;StreamingTemplate&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;groovy.servlet.TemplateServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;template.engine&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;groovy.text.StreamingTemplateEngine&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/servlet&amp;gt; &lt;/pre&gt; In this case, your template source file should be HTML with the appropriate embedded placeholders. &lt;h3&gt;Debugging Template Code&lt;/h3&gt; &lt;p&gt;The template engine makes an effort to throw descriptive exceptions with context lines, ie: &lt;pre&gt; groovy.text.TemplateExecutionException: Template parse error at line 4: 3: We &lt;% if (accepted) out.print 'are pleased' else out.print 'regret' %&gt; to inform you that your paper entitled --&gt; 4: '$txitle' was ${ accepted ? 'accepted' : 'rejected' }. 5: at test.run(test.groovy:18) Caused by: groovy.lang.MissingPropertyException: No such property: txitle for class: groovy.tmp.templates.StreamingTemplateScript1 ... 1 more &lt;/pre&gt; and sanitize the exceptions to make things readable. &lt;/p&gt; &lt;p&gt;When the exceptions are not enough, it might sometimes be useful to view the actual script source generated by the template engine. This would conceptually be equivalent to viewing the .java file generated for a jsp page. The source is not currently very readable and until we get a built in groovy code pretty printer, we will probably continue to opt for compactness rather than readability.&lt;/p&gt; &lt;p&gt;With that being said, viewing the source might still have some value. For this reason the script source is accessible via the template.scriptSource property, i.e.: &lt;pre&gt; println template.scriptSource &lt;/pre&gt; In the above example. &lt;/p&gt;
 * @author mbjarland@gmail.com
 * @author Matias Bjarland
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>TEMPLATE_SCRIPT_PREFIX</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>parentLoader</FieldName>
            <FieldType>ClassLoader</FieldType>
        </Field>
        <Field>
            <FieldName>counter</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCRIPT_HEAD</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SCRIPT_TAIL</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>templateSource</FieldName>
            <FieldType>StringBuilder</FieldType>
        </Field>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>template</FieldName>
            <FieldType>Closure</FieldType>
        </Field>
        <Field>
            <FieldName>scriptSource</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>finishedReadingException</FieldName>
            <FieldType>FinishedReadingException</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_STACKTRACE</FieldName>
            <FieldType>StackTraceElement[]</FieldType>
        </Field>
        <Field>
            <FieldName>row</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>column</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>data</FieldName>
            <FieldType>StringBuilder</FieldType>
        </Field>
        <Field>
            <FieldName>firstSourcePosition</FieldName>
            <FieldType>Position</FieldType>
        </Field>
        <Field>
            <FieldName>lastSourcePosition</FieldName>
            <FieldType>Position</FieldType>
        </Field>
        <Field>
            <FieldName>lastTargetPosition</FieldName>
            <FieldType>Position</FieldType>
        </Field>
        <Field>
            <FieldName>useLastRead</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>lastRead</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>StreamingTemplateEngine</MethodName>
            <MethodComment>/** 
 * Create a streaming template engine instance using the default class loader
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StreamingTemplateEngine</MethodName>
            <MethodComment>/** 
 * Create a streaming template engine instance using a custom class loader &lt;p&gt;The custom loader is used when parsing the template code&lt;/p&gt;
 * @param parentLoader The class loader to use when parsing the template code.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTemplate</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Creates a template instance using the template source from the provided Reader.&lt;/p&gt; &lt;p&gt;The template can be applied repeatedly on different bindings to produce custom output.&lt;/p&gt; &lt;strong&gt;Technical detail&lt;/strong&gt;&lt;br /&gt; Under the hood the returned template is represented as a four argument closure where the three first arguments are  {@link groovy.lang.Closure#curry curried} inwhile generating the template. &lt;br /&gt; &lt;br /&gt; In essence we start with a closure on the form: &lt;pre&gt; { parentClass, stringSectionList, binding, out -&gt; //code generated by parsing the template data }                                                                              &lt;/pre&gt; , we then curry in the parentClass and stringSectionList arguments so that the StreamingTemplate instance returned from 'createTemplate' internally contains a template closure on the form: &lt;pre&gt; { binding, out -&gt; //code generated by parsing the template data }                                                                              &lt;/pre&gt; Calling template.make(binding), curries in the 'binding' argument: &lt;pre&gt; public Writable make(final Map map) { final Closure template = this.template.curry(new Object[]{map}); return (Writable) template; } &lt;/pre&gt; which only leaves the 'out' argument unbound. The only method on the  {@link groovy.lang.Writable writable} interface is{@link groovy.lang.Writable#writeTo writeTo(Writer out)} so groovy rules about casting a closure to a one-method-interfaceapply and the above works. I.e. we return the now one argument closure as the Writable which can be serialized to System.out, a file, etc according to the Writable interface contract. &lt;/p&gt;
 * @see groovy.text.TemplateEngine#createTemplate(java.io.Reader)
 */
</MethodComment>
            <ReturnType>Template</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CompilationFailedException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Position</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Position</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;set;[p]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>set</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StringSection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>firstSourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishStringSection</MethodName>
            <MethodComment>/** 
 * Called to handle the ending of a string section.
 * @param sections The list of string sections. The current section gets added to this section.
 * @param currentSection The current string section.
 * @param templateExpressions Template expressions
 * @param lastSourcePosition The last read position in the source template stream.
 * @param targetPosition The last written to position in the target script stream.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sections</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentSection</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>templateExpressions</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lastSourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sections;add;[currentSection]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[templateExpressions, targetPosition, "out&lt;&lt;_s[_i=" + index++ + "];"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>error</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sections</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=Math.max(0,index)]</InnerVar>
                <InnerVar>StringSection [precedingSection=sections.get(i)]</InnerVar>
                <InnerVar>int [traceLine=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLinesInSource</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [result=0]</InnerVar>
                <InnerVar>LineNumberReader [reader=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getErrorContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actualLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [minLine=Math.max(0,actualLine - 1)]</InnerVar>
                <InnerVar>int [maxLine=Math.min(getLinesInSource(),actualLine + 1)]</InnerVar>
                <InnerVar>LineNumberReader [r=new LineNumberReader(new StringReader(templateSource.toString()))]</InnerVar>
                <InnerVar>int [lineNr]</InnerVar>
                <InnerVar>StringBuilder [result=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padLeft</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [b=new StringBuilder(s)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StreamingTemplate</MethodName>
            <MethodComment>/** 
 * Turn the template into a writable Closure. When executed the closure evaluates all the code embedded in the template and then writes a GString containing the fixed and variable items to the writer passed as a parameter &lt;p/&gt; For example: &lt;pre&gt; '&lt;%= "test" %&gt; of expr and &lt;% test = 1 %&gt;${test} script.' &lt;/pre&gt; would compile into: &lt;pre&gt; { out -&gt; out &lt;&lt; "${"test"} of expr and "; test = 1 ; out &lt;&lt; "${test} script."}.asWritable() &lt;/pre&gt;
 * @param source A reader into the template source data
 * @param parentLoader A class loader we use
 * @throws CompilationFailedException
 * @throws ClassNotFoundException
 * @throws IOException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [target=new StringBuilder()]</InnerVar>
                <InnerVar>List&lt;StringSection&gt; [sections=new ArrayList&lt;StringSection&gt;()]</InnerVar>
                <InnerVar>Position [sourcePosition=new Position(1,1)]</InnerVar>
                <InnerVar>Position [targetPosition=new Position(1,1)]</InnerVar>
                <InnerVar>Position [lastSourcePosition=new Position(1,1)]</InnerVar>
                <InnerVar>StringSection [currentSection=new StringSection(sourcePosition)]</InnerVar>
                <InnerVar>StringBuilder [lookAhead=new StringBuilder(10)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[target, targetPosition, SCRIPT_HEAD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finishStringSection;[sections, currentSection, target, sourcePosition, targetPosition]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, SCRIPT_TAIL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>CompilationFailedException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lookAhead</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lookAhead;delete;[0, lookAhead.length()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleEscaping</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentSection</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lookAhead</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c=read(source,sourcePosition,lookAhead)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentSection.data;append;[(char)c]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clear;[lookAhead]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTemplateClosure</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Closure</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sections</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroovyClassLoader [loader=AccessController.doPrivileged(new PrivilegedAction&lt;GroovyClassLoader&gt;(){
  public GroovyClassLoader run(){
    return new GroovyClassLoader(parentLoader);
  }
}
)]</InnerVar>
                <InnerVar>Class [groovyClass]</InnerVar>
                <InnerVar>Closure [result]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroovyClassLoader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDollarIdentifier</MethodName>
            <MethodComment>/** 
 * Parses a non curly dollar preceded identifier of the type '$bird' in the following template example: &lt;pre&gt; Alice why is a $bird like a writing desk &lt;/pre&gt; which would produce the following template data: &lt;pre&gt; out &lt;&lt; "Alice why is a "; out &lt;&lt; bird; out &lt;&lt; " like a writing desk"; &lt;/pre&gt; This method is given the 'b' in 'bird' in argument c, checks if it is a valid java identifier start (we assume groovy did not mangle the java identifier rules). If so it proceeds to parse characters from the input until it encounters a non-java-identifier character. At that point
 * @param c The first letter of the potential identifier, 'b' in the above example
 * @param reader The reader reading from the template source
 * @param target The target groovy script source we write to
 * @param sourcePosition The reader position in the source stream
 * @param targetPosition The writer position in the target stream
 * @return true if a valid dollar preceded identifier was found, false otherwise. Morespecifically, returns true if the first character after the dollar sign is a valid java identifier. Note that the dollar curly syntax is handled by another method.
 * @throws IOException
 * @throws FinishedReadingException If we encountered the end of the source stream.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[target, targetPosition, "out&lt;&lt;"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, (char)c]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, ";"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDollarCurlyIdentifier</MethodName>
            <MethodComment>/** 
 * Parses a dollar curly preceded identifier of the type '${bird}' in the following template example: &lt;pre&gt; Alice why is a ${bird} like a writing desk &lt;/pre&gt; which would produce the following template data: &lt;pre&gt; out &lt;&lt; "Alice why is a "; out &lt;&lt; """${bird}"""; out &lt;&lt; " like a writing desk"; &lt;/pre&gt; This method is given the 'b' in 'bird' in argument c, checks if it is a valid java identifier start (we assume groovy did not mangle the java identifier rules). If so it proceeds to parse characters from the input until it encounters a non-java-identifier character. At that point
 * @param reader The reader reading from the template source
 * @param target The target groovy script source we write to
 * @param sourcePosition The reader position in the source stream
 * @param targetPosition The writer position in the target stream
 * @throws IOException
 * @throws FinishedReadingException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[target, targetPosition, "out&lt;&lt;\"\"\"${"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, "\"\"\";"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSection</MethodName>
            <MethodComment>/** 
 * Parse a &lt;% .... %&gt; section if we are writing a GString close and append ';' then write the section as a statement
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pendingC</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[target, targetPosition, "          "]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, (char)pendingC]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, ';']</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseExpression</MethodName>
            <MethodComment>/** 
 * Parse a &lt;%= .... %&gt; expression
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourcePosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[target, targetPosition, "out&lt;&lt;\"\"\"${"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;append;[target, targetPosition, "}\"\"\";"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>make</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>make</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Closure [template=this.template.curry(new Object[]{map})]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mangleMultipleCompilationErrorsException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RuntimeException</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>MultipleCompilationErrorsException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sections</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RuntimeException [result=e]</InnerVar>
                <InnerVar>ErrorCollector [collector=e.getErrorCollector()]</InnerVar>
                <InnerVar>List&lt;Message&gt; [errors=(List&lt;Message&gt;)collector.getErrors()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mangleExceptionMessage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>original</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [result=original]</InnerVar>
                <InnerVar>int [index=result.indexOf("@ line ")]</InnerVar>
                <InnerVar>int [count=0]</InnerVar>
                <InnerVar>String [msg="Template parse error '" + result + "' at line "+ p.row+ ", column "+ p.column]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>offsetPositionFromSection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findPrecedingSection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StringSection</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sections</ParamName>
                    <ParamType>StringSection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringSection [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>target;append;[c]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetPosition</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [len=s.length()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lookAhead</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c=read(reader,position)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lookAhead;append;[(char)c]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>Position</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>FinishedReadingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c=reader.read()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>templateSource;append;[(char)c]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>