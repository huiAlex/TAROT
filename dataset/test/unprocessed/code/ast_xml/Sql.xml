<Class>
    <Id>543</Id>
    <Package>groovy.sql</Package>
    <ClassName>Sql</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Sql  /** 
 * A facade over Java's normal JDBC APIs providing greatly simplified resource management and result set handling. Under the covers the facade hides away details associated with getting connections, constructing and configuring statements, interacting with the connection, closing resources and logging errors. Special features of the facade include using closures to iterate through result sets, a special GString syntax for representing prepared statements and treating result sets like collections of maps with the normal Groovy collection methods available. &lt;h4&gt;Typical usage&lt;/h4&gt; First you need to set up your sql instance. There are several constructors and a few &lt;code&gt;newInstance&lt;/code&gt; factory methods available to do this. In simple cases, you can just provide the necessary details to set up a connection (e.g. for hsqldb): &lt;pre&gt; def db = [url:'jdbc:hsqldb:mem:testDB', user:'sa', password:'', driver:'org.hsqldb.jdbc.JDBCDriver'] def sql = Sql.newInstance(db.url, db.user, db.password, db.driver) &lt;/pre&gt; or if you have an existing connection (perhaps from a connection pool) or a datasource use one of the constructors: &lt;pre&gt; def sql = new Sql(datasource) &lt;/pre&gt; Now you can invoke sql, e.g. to create a table: &lt;pre&gt; sql.execute ''' create table PROJECT ( id integer not null, name varchar(50), url varchar(100), ) ''' &lt;/pre&gt; Or insert a row using JDBC PreparedStatement inspired syntax: &lt;pre&gt; def params = [10, 'Groovy', 'http://groovy.codehaus.org'] sql.execute 'insert into PROJECT (id, name, url) values (?, ?, ?)', params &lt;/pre&gt; Or insert a row using GString syntax: &lt;pre&gt; def map = [id:20, name:'Grails', url:'http://grails.codehaus.org'] sql.execute "insert into PROJECT (id, name, url) values ($map.id, $map.name, $map.url)" &lt;/pre&gt; Or a row update: &lt;pre&gt; def newUrl = 'http://grails.org' def project = 'Grails' sql.executeUpdate "update PROJECT set url=$newUrl where name=$project" &lt;/pre&gt; Now try a query using &lt;code&gt;eachRow&lt;/code&gt;: &lt;pre&gt; println 'Some GR8 projects:' sql.eachRow('select * from PROJECT') { row -&gt; println "${row.name.padRight(10)} ($row.url)" } &lt;/pre&gt; Which will produce something like this: &lt;pre&gt; Some GR8 projects: Groovy     (http://groovy.codehaus.org) Grails     (http://grails.org) Griffon    (http://griffon.codehaus.org) Gradle     (http://gradle.org) &lt;/pre&gt; Now try a query using &lt;code&gt;rows&lt;/code&gt;: &lt;pre&gt; def rows = sql.rows("select * from PROJECT where name like 'Gra%'") assert rows.size() == 2 println rows.join('\n') &lt;/pre&gt; with output like this: &lt;pre&gt; [ID:20, NAME:Grails, URL:http://grails.org] [ID:40, NAME:Gradle, URL:http://gradle.org] &lt;/pre&gt; Also, &lt;code&gt;eachRow&lt;/code&gt; and &lt;code&gt;rows&lt;/code&gt; support paging.  Here's an example:  &lt;pre&gt; sql.eachRow('select * from PROJECT', 2, 2) { row -&gt; println "${row.name.padRight(10)} ($row.url)" } &lt;/pre&gt; Which will start at the second row and return a maximum of 2 rows.  Here's an example result: &lt;pre&gt; Grails     (http://grails.org) Griffon    (http://griffon.codehaus.org) &lt;/pre&gt; Finally, we should clean up: &lt;pre&gt; sql.close() &lt;/pre&gt; If we are using a DataSource and we haven't enabled statement caching, then strictly speaking the final &lt;code&gt;close()&lt;/code&gt; method isn't required - as all connection handling is performed transparently on our behalf; however, it doesn't hurt to have it there as it will return silently in that case. &lt;p&gt; If instead of &lt;code&gt;newInstance&lt;/code&gt; you use &lt;code&gt;withInstance&lt;/code&gt;, then &lt;code&gt;close()&lt;/code&gt; will be called automatically for you. &lt;h4&gt;Avoiding SQL injection&lt;/h4&gt; If you find yourself creating queries based on any kind of input from the user or a 3rd party application you might wish to avoid the pure string method variants in this class. While this is safe: &lt;code&gt;sql.firstRow('select * from PersonTable')&lt;/code&gt; This example is potentially at risk of SQL injection: &lt;code&gt;sql.firstRow('select * from PersonTable where SurnameColumn = ' + userInput)&lt;/code&gt; This in turn will be fine if '&lt;code&gt;userInput&lt;/code&gt;' is something like 'Smith' but maybe not so fine if '&lt;code&gt;userInput&lt;/code&gt;' is something like 'Smith; DROP table PersonTable'. Instead, use one of the variants with parameters and placeholders: &lt;code&gt;sql.firstRow("select * from PersonTable where SurnameColumn = ?", [userInput])&lt;/code&gt; or the GString variants which will be converted to the placeholder variants under the covers: &lt;code&gt;sql.firstRow("select * from PersonTable where SurnameColumn = $userInput")&lt;/code&gt; or the named parameter variants discussed next. &lt;h4&gt;Named and named ordinal parameters&lt;/h4&gt; Several of the methods in this class (ones which have a String-based sql query and params in a List&lt;Object&gt; or Object[] or Map) support &lt;em&gt;named&lt;/em&gt; or &lt;em&gt;named ordinal&lt;/em&gt; parameters. These methods are useful for queries with large numbers of parameters - though the GString variations are often preferred in such cases too. Reminder: when you see a variant with Object[] as the type of the last parameter, Groovy allows vararg style parameters so you don't explicitly need to create an Object[] and if the first parameter is of type Map, Groovy supports named arguments - examples of both are contained in the examples below. &lt;p&gt; Named parameter queries use placeholder values in the query String. Two forms are supported ':propname1' and '?.propname2'. For these variations, a single &lt;em&gt;model&lt;/em&gt; object is supplied in the parameter list/array/map. The propname refers to a property of that model object. The model object could be a map, Expando or domain class instance. Here are some examples: &lt;pre&gt; // using rows() with a named parameter with the parameter supplied in a map println sql.rows('select * from PROJECT where name=:foo', [foo:'Gradle']) // as above for eachRow() sql.eachRow('select * from PROJECT where name=:foo', [foo:'Gradle']) { // process row } // an example using both the ':' and '?.' variants of the notation println sql.rows('select * from PROJECT where name=:foo and id=?.bar', [foo:'Gradle', bar:40]) // as above but using Groovy's named arguments instead of an explicit map println sql.rows('select * from PROJECT where name=:foo and id=?.bar', foo:'Gradle', bar:40) // an example showing rows() with a domain object instead of a map class MyDomainClass { def baz = 'Griffon' } println sql.rows('select * from PROJECT where name=?.baz', new MyDomainClass()) // as above for eachRow() with the domain object supplied in a list sql.eachRow('select * from PROJECT where name=?.baz', [new MyDomainClass()]) { // process row } &lt;/pre&gt; Named ordinal parameter queries have multiple model objects with the index number (starting at 1) also supplied in the placeholder. Only the question mark variation of placeholder is supported. Here are some examples: &lt;pre&gt; // an example showing the model objects as vararg style parameters (since rows() has an Object[] variant) println sql.rows("select * from PROJECT where name=?1.baz and id=?2.num", new MyDomainClass(), [num:30]) // an example showing the model objects (one domain class and one map) provided in a list sql.eachRow("select * from PROJECT where name=?1.baz and id=?2.num", [new MyDomainClass(), [num:30]]) { // do something with row } &lt;/pre&gt; &lt;h4&gt;More details&lt;/h4&gt; See the method and constructor JavaDoc for more details. &lt;p&gt; For advanced usage, the class provides numerous extension points for overriding the facade behavior associated with the various aspects of managing the interaction with the underlying database.
 * @author Chris Stevenson
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author Paul King
 * @author Marc DeXeT
 * @author John Bito
 * @author John Hurst
 * @author David Durham
 * @author Daniel Henrique Alves Lima
 * @author David Sutherland
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_LIST</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY_LIST</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>USE_COLUMN_NAMES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>dataSource</FieldName>
            <FieldType>DataSource</FieldType>
        </Field>
        <Field>
            <FieldName>useConnection</FieldName>
            <FieldType>Connection</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetConcurrency</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetHoldability</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>updateCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>configureStatement</FieldName>
            <FieldType>Closure</FieldType>
        </Field>
        <Field>
            <FieldName>cacheConnection</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>cacheStatements</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>cacheNamedQueries</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>enableNamedQueries</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>withinBatch</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>statementCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>statementCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>namedParamSqlCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>namedParamSqlCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>namedParamIndexPropCache</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>namedParamIndexPropCache</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>keyColumnNames</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>keyColumnNames</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ARRAY</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>BIGINT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>BINARY</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>BIT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>BLOB</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>CHAR</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>CLOB</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>DATALINK</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>DATE</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>DISTINCT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>FLOAT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>INTEGER</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>JAVA_OBJECT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBINARY</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARCHAR</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>NULL</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>NUMERIC</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>OTHER</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>REAL</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>REF</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>STRUCT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>TIME</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>VARBINARY</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>VARCHAR</FieldName>
            <FieldType>OutParameter</FieldType>
        </Field>
        <Field>
            <FieldName>NO_RESULT_SETS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FIRST_RESULT_SET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALL_RESULT_SETS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>returnGeneratedKeys</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sql</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>statement</FieldName>
            <FieldType>Statement</FieldType>
        </Field>
        <Field>
            <FieldName>connection</FieldName>
            <FieldType>Connection</FieldType>
        </Field>
        <Field>
            <FieldName>maxRows</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>params</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>params</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @return a new Sql instance with a connection
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=DriverManager.getConnection(url)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param c the Closure to call
 * @see #newInstance(String)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL and some properties.
 * @param url        a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param properties a list of arbitrary string tag/value pairsas connection arguments; normally at least a "user" and "password" property should be included
 * @return a new Sql instance with a connection
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=DriverManager.getConnection(url,properties)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL and properties. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param properties a list of arbitrary string tag/value pairsas connection arguments; normally at least a "user" and "password" property should be included
 * @param c the Closure to call
 * @see #newInstance(String,java.util.Properties)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL, some properties and a driver class name.
 * @param url             a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param properties      a list of arbitrary string tag/value pairsas connection arguments; normally at least a "user" and "password" property should be included
 * @param driverClassName the fully qualified class name of the driver class
 * @return a new Sql instance with a connection
 * @throws SQLException           if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadDriver;[driverClassName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, properties and driver classname. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param properties a list of arbitrary string tag/value pairsas connection arguments; normally at least a "user" and "password" property should be included
 * @param driverClassName the fully qualified class name of the driver class
 * @param c the Closure to call
 * @see #newInstance(String,java.util.Properties,String)
 * @throws SQLException if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL, a username and a password.
 * @param url      a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param user     the database user on whose behalf the connectionis being made
 * @param password the user's password
 * @return a new Sql instance with a connection
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=DriverManager.getConnection(url,user,password)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, user and password. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param user     the database user on whose behalf the connectionis being made
 * @param password the user's password
 * @param c the Closure to call
 * @see #newInstance(String,String,String)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL, a username, a password and a driver class name.
 * @param url             a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param user            the database user on whose behalf the connectionis being made
 * @param password        the user's password
 * @param driverClassName the fully qualified class name of the driver class
 * @return a new Sql instance with a connection
 * @throws SQLException           if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadDriver;[driverClassName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param user            the database user on whose behalf the connectionis being made
 * @param password        the user's password
 * @param driverClassName the fully qualified class name of the driver class
 * @param c the Closure to call
 * @see #newInstance(String,String,String,String)
 * @throws SQLException if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given a JDBC connection URL and a driver class name.
 * @param url             a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param driverClassName the fully qualified class name of the driver class
 * @return a new Sql instance with a connection
 * @throws SQLException           if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadDriver;[driverClassName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given JDBC connection URL. The created connection will be closed if required.
 * @param url a database url of the form&lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
 * @param driverClassName the fully qualified class name of the driver class
 * @param c the Closure to call
 * @see #newInstance(String,String)
 * @throws SQLException if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInstance</MethodName>
            <MethodComment>/** 
 * Creates a new Sql instance given parameters in a Map. Recognized keys for the Map include: &lt;pre&gt; driverClassName the fully qualified class name of the driver class driver          a synonym for driverClassName url             a database url of the form: &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt; user            the database user on whose behalf the connection is being made password        the user's password properties      a list of arbitrary string tag/value pairs as connection arguments; normally at least a "user" and "password" property should be included &lt;em&gt;other&lt;/em&gt;           any of the public setter methods of this class may be used with property notation e.g. &lt;em&gt;cacheStatements: true, resultSetConcurrency: ResultSet.CONCUR_READ_ONLY&lt;/em&gt; &lt;/pre&gt; Of these, '&lt;code&gt;url&lt;/code&gt;' is required. Others may be needed depending on your database.&lt;br&gt; If '&lt;code&gt;properties&lt;/code&gt;' is supplied, neither '&lt;code&gt;user&lt;/code&gt;' nor '&lt;code&gt;password&lt;/code&gt;' should be supplied.&lt;br&gt; If one of '&lt;code&gt;user&lt;/code&gt;' or '&lt;code&gt;password&lt;/code&gt;' is supplied, both should be supplied. &lt;p&gt; Example usage: &lt;pre&gt; import groovy.sql.Sql import static java.sql.ResultSet. def sql = Sql.newInstance( url:'jdbc:hsqldb:mem:testDB', user:'sa', password:'', driver:'org.hsqldb.jdbc.JDBCDriver', cacheStatements: true, resultSetConcurrency: CONCUR_READ_ONLY ) &lt;/pre&gt;
 * @param args a Map contain further arguments
 * @return a new Sql instance with a connection
 * @throws SQLException           if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>Sql</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,Object&gt; [sqlArgs=new HashMap&lt;String,Object&gt;(args)]</InnerVar>
                <InnerVar>Object [driverClassName=sqlArgs.remove("driverClassName")]</InnerVar>
                <InnerVar>Properties [props=(Properties)sqlArgs.remove("properties")]</InnerVar>
                <InnerVar>Object [url=sqlArgs.remove("url")]</InnerVar>
                <InnerVar>Connection [connection]</InnerVar>
                <InnerVar>Sql [result=(Sql)InvokerHelper.invokeConstructorOf(Sql.class,sqlArgs)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;setConnection;[connection]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInstance</MethodName>
            <MethodComment>/** 
 * Invokes a closure passing it a new Sql instance created from the given map of arguments. The created connection will be closed if required.
 * @param args a Map contain further arguments
 * @param c the Closure to call
 * @see #newInstance(java.util.Map)
 * @throws SQLException if a database access error occurs
 * @throws ClassNotFoundException if the driver class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sql [sql=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetType</MethodName>
            <MethodComment>/** 
 * Gets the resultSetType for statements created using the connection.
 * @return the current resultSetType value
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultSetType</MethodName>
            <MethodComment>/** 
 * Sets the resultSetType for statements created using the connection. May cause SQLFeatureNotSupportedException exceptions to occur if the underlying database doesn't support the requested type value.
 * @param resultSetType one of the following &lt;code&gt;ResultSet&lt;/code&gt;constants: &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSetType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetConcurrency</MethodName>
            <MethodComment>/** 
 * Gets the resultSetConcurrency for statements created using the connection.
 * @return the current resultSetConcurrency value
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultSetConcurrency</MethodName>
            <MethodComment>/** 
 * Sets the resultSetConcurrency for statements created using the connection. May cause SQLFeatureNotSupportedException exceptions to occur if the underlying database doesn't support the requested concurrency value.
 * @param resultSetConcurrency one of the following &lt;code&gt;ResultSet&lt;/code&gt;constants: &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSetConcurrency</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetHoldability</MethodName>
            <MethodComment>/** 
 * Gets the resultSetHoldability for statements created using the connection.
 * @return the current resultSetHoldability value or -1 if not set
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultSetHoldability</MethodName>
            <MethodComment>/** 
 * Sets the resultSetHoldability for statements created using the connection. May cause SQLFeatureNotSupportedException exceptions to occur if the underlying database doesn't support the requested holdability value.
 * @param resultSetHoldability one of the following &lt;code&gt;ResultSet&lt;/code&gt;constants: &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSetHoldability</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadDriver</MethodName>
            <MethodComment>/** 
 * Attempts to load the JDBC driver on the thread, current or system class loaders
 * @param driverClassName the fully qualified class name of the driver class
 * @throws ClassNotFoundException if the class cannot be found or loaded
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>driverClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ARRAY</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BIGINT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BINARY</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BIT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BLOB</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BOOLEAN</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CHAR</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CLOB</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DATALINK</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DATE</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DECIMAL</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DISTINCT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DOUBLE</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FLOAT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>INTEGER</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>JAVA_OBJECT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LONGVARBINARY</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LONGVARCHAR</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>NULL</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>NUMERIC</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>OTHER</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>REAL</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>REF</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SMALLINT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>STRUCT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TIME</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TIMESTAMP</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TINYINT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>VARBINARY</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>VARCHAR</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>in</MethodName>
            <MethodComment>/** 
 * Create a new InParameter
 * @param type  the JDBC data type
 * @param value the object value
 * @return an InParameter
 */
</MethodComment>
            <ReturnType>InParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>out</MethodName>
            <MethodComment>/** 
 * Create a new OutParameter
 * @param type the JDBC data type.
 * @return an OutParameter
 */
</MethodComment>
            <ReturnType>OutParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inout</MethodName>
            <MethodComment>/** 
 * Create an inout parameter using this in parameter.
 * @param in the InParameter of interest
 * @return the resulting InOutParameter
 */
</MethodComment>
            <ReturnType>InOutParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InParameter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resultSet</MethodName>
            <MethodComment>/** 
 * Create a new ResultSetOutParameter
 * @param type the JDBC data type.
 * @return a ResultSetOutParameter
 */
</MethodComment>
            <ReturnType>ResultSetOutParameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>expand</MethodName>
            <MethodComment>/** 
 * When using GString SQL queries, allows a variable to be expanded in the Sql string rather than representing an sql parameter. &lt;p&gt; Example usage: &lt;pre&gt; def fieldName = 'firstname' def fieldOp = Sql.expand('like') def fieldVal = '%a%' sql.query "select * from PERSON where ${Sql.expand(fieldName)} $fieldOp ${fieldVal}", { ResultSet rs -&gt; while (rs.next()) println rs.getString('firstname') } // query will be 'select * from PERSON where firstname like ?' // params will be [fieldVal] &lt;/pre&gt;
 * @param object the object of interest
 * @return the expanded variable
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>ExpandedVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>object</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Sql</MethodName>
            <MethodComment>/** 
 * Constructs an SQL instance using the given DataSource. Each operation will use a Connection from the DataSource pool and close it when the operation is completed putting it back into the pool.
 * @param dataSource the DataSource to use
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataSource</ParamName>
                    <ParamType>DataSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Sql</MethodName>
            <MethodComment>/** 
 * Constructs an SQL instance using the given Connection. It is the caller's responsibility to close the Connection after the Sql instance has been used. Depending on which features you are using, you may be able to do this on the connection object directly but the preferred approach is to call the  {@link #close()} method which will close the connection but alsofree any caches resources.
 * @param connection the Connection to use
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Sql</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>Sql</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Sql</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query, which should return a single &lt;code&gt;ResultSet&lt;/code&gt; object. The given closure is called with the &lt;code&gt;ResultSet&lt;/code&gt; as its argument. &lt;p&gt; Example usages: &lt;pre&gt; sql.query("select * from PERSON where firstname like 'S%'") { ResultSet rs -&gt; while (rs.next()) println rs.getString('firstname') + ' ' + rs.getString(3) } sql.query("call get_people_places()") { ResultSet rs -&gt; while (rs.next()) println rs.toRowResult().firstname } &lt;/pre&gt; &lt;p&gt; All resources including the ResultSet are closed automatically after the closure is called.
 * @param sql     the sql statement
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=getStatement(connection,sql)]</InnerVar>
                <InnerVar>ResultSet [results=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query, which should return a single &lt;code&gt;ResultSet&lt;/code&gt; object. The given closure is called with the &lt;code&gt;ResultSet&lt;/code&gt; as its argument. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usage: &lt;pre&gt; sql.query('select * from PERSON where lastname like ?', ['%a%']) { ResultSet rs -&gt; while (rs.next()) println rs.getString('lastname') } &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; All resources including the ResultSet are closed automatically after the closure is called.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
                <InnerVar>ResultSet [results=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #query(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql     the sql statement
 * @param map     a map containing the named parameters
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;query;[sql, singletonList(map), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #query(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param map     a map containing the named parameters
 * @param sql     the sql statement
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;query;[sql, singletonList(map), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>singletonList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>item</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Object&gt; [params=new ArrayList&lt;Object&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>params;add;[item]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query, which should return a single &lt;code&gt;ResultSet&lt;/code&gt; object. The given closure is called with the &lt;code&gt;ResultSet&lt;/code&gt; as its argument. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 sql.query "select * from PERSON where location_id &lt; $location", { ResultSet rs -&gt; while (rs.next()) println rs.getString('firstname') } &lt;/pre&gt; &lt;p&gt; All resources including the ResultSet are closed automatically after the closure is called.
 * @param gstring a GString containing the SQL query with embedded params
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;query;[sql, params, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given Closure with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. &lt;p&gt; Example usages: &lt;pre&gt; sql.eachRow("select * from PERSON where firstname like 'S%'") { row -&gt; println "$row.firstname ${row[2]}}" } sql.eachRow "call my_stored_proc_returning_resultset()", { println it.firstname } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, (Closure)null, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;closure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, (Closure)null, offset, maxRows, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;rowClosure&lt;/code&gt; with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. &lt;p&gt; Example usage: &lt;pre&gt; def printColNames = { meta -&gt; (1..meta.columnCount).each { print meta.getColumnLabel(it).padRight(20) } println() } def printRow = { row -&gt; row.toRowResult().values().each{ print it.toString().padRight(20) } println() } sql.eachRow("select * from PERSON", printColNames, printRow) &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the sql statement
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, metaClosure, 0, 0, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;rowClosure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. &lt;p&gt; In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the sql statement
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=getStatement(connection,sql)]</InnerVar>
                <InnerVar>ResultSet [results=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>moveCursor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>results</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [cursorAtRow=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;rowClosure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. &lt;p&gt; In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type.
 * @param sql         the sql statement
 * @param params      a list of parameters
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
                <InnerVar>ResultSet [results=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure,int,int,groovy.lang.Closure)}allowing the named parameters to be supplied in a map.
 * @param sql         the sql statement
 * @param map         a map containing the named parameters
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(map), metaClosure, offset, maxRows, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure,int,int,groovy.lang.Closure)}allowing the named parameters to be supplied as named arguments.
 * @param map         a map containing the named parameters
 * @param sql         the sql statement
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(map), metaClosure, offset, maxRows, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given Closure with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usage: &lt;pre&gt; def printColNames = { meta -&gt; (1..meta.columnCount).each { print meta.getColumnLabel(it).padRight(20) } println() } def printRow = { row -&gt; row.toRowResult().values().each{ print it.toString().padRight(20) } println() } sql.eachRow("select * from PERSON where lastname like ?", ['%a%'], printColNames, printRow) &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the sql statement
 * @param params      a list of parameters
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, metaClosure, 0, 0, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql         the sql statement
 * @param params      a map of named parameters
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), metaClosure, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param params      a map of named parameters
 * @param sql         the sql statement
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), metaClosure, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given Closure with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usage: &lt;pre&gt; sql.eachRow("select * from PERSON where lastname like ?", ['%a%']) { row -&gt; println "${row[1]} $row.lastname" } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, null, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql     the sql statement
 * @param params  a map of named parameters
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param params  a map of named parameters
 * @param sql     the sql statement
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;closure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, null, offset, maxRows, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,int,int,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql     the sql statement
 * @param params  a map of named parameters
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), offset, maxRows, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #eachRow(String,java.util.List,int,int,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param params  a map of named parameters
 * @param sql     the sql statement
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, singletonList(params), offset, maxRows, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given Closure with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. &lt;p&gt; In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 def printColNames = { meta -&gt; (1..meta.columnCount).each { print meta.getColumnLabel(it).padRight(20) } println() } def printRow = { row -&gt; row.toRowResult().values().each{ print it.toString().padRight(20) } println() } sql.eachRow("select * from PERSON where location_id &lt; $location", printColNames, printRow) &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring     a GString containing the SQL query with embedded params
 * @param metaClosure called for meta data (only once after sql execution)
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, metaClosure, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;closure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain GString expressions. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type.
 * @param gstring     a GString containing the SQL query with embedded params
 * @param metaClosure called for meta data (only once after sql execution)
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param rowClosure  called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, metaClosure, offset, maxRows, rowClosure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given &lt;code&gt;closure&lt;/code&gt; with each row of the result set starting at the provided &lt;code&gt;offset&lt;/code&gt;, and including up to &lt;code&gt;maxRows&lt;/code&gt; number of rows. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. The query may contain GString expressions. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type.
 * @param gstring a GString containing the SQL query with embedded params
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[sql, params, offset, maxRows, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query calling the given Closure with each row of the result set. The row will be a &lt;code&gt;GroovyResultSet&lt;/code&gt; which is a &lt;code&gt;ResultSet&lt;/code&gt; that supports accessing the fields using property style notation and ordinal index values. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 sql.eachRow("select * from PERSON where location_id &lt; $location") { row -&gt; println row.firstname } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachRow;[gstring, null, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. &lt;p&gt; Example usage: &lt;pre&gt; def ans = sql.rows("select * from PERSON where firstname like 'S%'") println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql the SQL statement
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the SQL statement
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. &lt;p&gt; Example usage: &lt;pre&gt; def printNumCols = { meta -&gt; println "Found $meta.columnCount columns" } def ans = sql.rows("select * from PERSON", printNumCols) println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the SQL statement
 * @param metaClosure called with meta data of the ResultSet
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the SQL statement
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AbstractQueryCommand [command=createQueryCommand(sql)]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>command;setMaxRows;[offset + maxRows]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usage: &lt;pre&gt; def ans = sql.rows("select * from PERSON where lastname like ?", ['%a%']) println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    the SQL statement
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the SQL statement
 * @param params  a list of parameters
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,int,int)}useful when providing the named parameters as a map.
 * @param sql     the SQL statement
 * @param params  a map of named parameters
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,int,int)}useful when providing the named parameters as named arguments.
 * @param params  a map of named parameters
 * @param sql     the SQL statement
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details. &lt;p&gt; An Object array variant of  {@link #rows(String,List)}.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details. &lt;p&gt; An Object array variant of  {@link #rows(String,List,int,int)}.
 * @param sql     the SQL statement
 * @param params  an array of parameters
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usage: &lt;pre&gt; def printNumCols = { meta -&gt; println "Found $meta.columnCount columns" } def ans = sql.rows("select * from PERSON where lastname like ?", ['%a%'], printNumCols) println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. Here is an example: &lt;pre&gt; def printNumCols = { meta -&gt; println "Found $meta.columnCount columns" } def mapParam = [foo: 'Smith'] def domainParam = new MyDomainClass(bar: 'John') def qry = 'select * from PERSON where lastname=?1.foo and firstname=?2.bar' def ans = sql.rows(qry, [mapParam, domainParam], printNumCols) println "Found ${ans.size()} rows" def qry2 = 'select * from PERSON where firstname=:first and lastname=:last' def ans2 = sql.rows(qry2, [[last:'Smith', first:'John']], printNumCols) println "Found ${ans2.size()} rows" &lt;/pre&gt; See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the SQL statement
 * @param params      a list of parameters
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql         the SQL statement
 * @param params      a map of named parameters
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param params      a map of named parameters
 * @param sql         the SQL statement
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql         the SQL statement
 * @param params      a list of parameters
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AbstractQueryCommand [command=createPreparedQueryCommand(sql,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>command;setMaxRows;[offset + maxRows]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,int,int,groovy.lang.Closure)}useful when providing the named parameters as a map.
 * @param sql         the SQL statement
 * @param params      a map of named parameters
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #rows(String,java.util.List,int,int,groovy.lang.Closure)}useful when providing the named parameters as named arguments.
 * @param params      a map of named parameters
 * @param sql         the SQL statement
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. The query may contain GString expressions. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the SQL statement
 * @param offset  the 1-based offset for the first row to be processed
 * @param maxRows the maximum number of rows to be processed
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 def ans = sql.rows("select * from PERSON where location_id &lt; $location") println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the rows of the result set. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 def printNumCols = { meta -&gt; println "Found $meta.columnCount columns" } def ans = sql.rows("select * from PERSON where location_id &lt; $location", printNumCols) println "Found ${ans.size()} rows" &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring     a GString containing the SQL query with embedded params
 * @param metaClosure called with meta data of the ResultSet
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rows</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return a "page" of rows from the result set.  A page is defined as starting at a 1-based offset, and containing a maximum number of rows. In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain GString expressions. &lt;p&gt; Note that the underlying implementation is based on either invoking &lt;code&gt;ResultSet.absolute()&lt;/code&gt;, or if the ResultSet type is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, the &lt;code&gt;ResultSet.next()&lt;/code&gt; method is invoked equivalently.  The first row of a ResultSet is 1, so passing in an offset of 1 or less has no effect on the initial positioning within the result set. &lt;p&gt; Note that different database and JDBC driver implementations may work differently with respect to this method. Specifically, one should expect that &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; may be less efficient than a "scrollable" type. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring     the SQL statement
 * @param offset      the 1-based offset for the first row to be processed
 * @param maxRows     the maximum number of rows to be processed
 * @param metaClosure called for meta data (only once after sql execution)
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the first row of the result set. &lt;p&gt; Example usage: &lt;pre&gt; def ans = sql.firstRow("select * from PERSON where firstname like 'S%'") println ans.firstname &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql the SQL statement
 * @return a GroovyRowResult object or &lt;code&gt;null&lt;/code&gt; if no row is found
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;GroovyRowResult&gt; [rows=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the first row of the result set. The query may contain GString expressions. &lt;p&gt; Example usage: &lt;pre&gt; def location = 25 def ans = sql.firstRow("select * from PERSON where location_id &lt; $location") println ans.firstname &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return a GroovyRowResult object or &lt;code&gt;null&lt;/code&gt; if no row is found
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the first row of the result set. The query may contain placeholder question marks which match the given list of parameters. &lt;p&gt; Example usages: &lt;pre&gt; def ans = sql.firstRow("select * from PERSON where lastname like ?", ['%a%']) println ans.firstname &lt;/pre&gt; If your database returns scalar functions as ResultSets, you can also use firstRow to gain access to stored procedure results, e.g. using hsqldb 1.9 RC4: &lt;pre&gt; sql.execute """ create function FullName(p_firstname VARCHAR(40)) returns VARCHAR(80) BEGIN atomic DECLARE ans VARCHAR(80); SET ans = (SELECT firstname || ' ' || lastname FROM PERSON WHERE firstname = p_firstname); RETURN ans; END """ assert sql.firstRow("{call FullName(?)}", ['Sam'])[0] == 'Sam Pullara' &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @return a GroovyRowResult object or &lt;code&gt;null&lt;/code&gt; if no row is found
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;GroovyRowResult&gt; [rows=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstRow</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #firstRow(String,java.util.List)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    the SQL statement
 * @return a GroovyRowResult object or &lt;code&gt;null&lt;/code&gt; if no row is found
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstRow</MethodName>
            <MethodComment>/** 
 * Performs the given SQL query and return the first row of the result set. &lt;p&gt; An Object array variant of  {@link #firstRow(String,List)}. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @return a GroovyRowResult object or &lt;code&gt;null&lt;/code&gt; if no row is found
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL. Also saves the updateCount, if any, for subsequent examination. &lt;p&gt; Example usages: &lt;pre&gt; sql.execute "DROP TABLE IF EXISTS person" sql.execute """ CREATE TABLE person ( id INTEGER NOT NULL, firstname VARCHAR(100), lastname VARCHAR(100), location_id INTEGER ) """ sql.execute """ INSERT INTO person (id, firstname, lastname, location_id) VALUES (4, 'Paul', 'King', 40) """ assert sql.updateCount == 1 &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql the SQL to execute
 * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are no results
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL. Also calls the provided processResults Closure to process any ResultSet or UpdateCount results that executing the SQL might produce. &lt;p&gt; Example usages: &lt;pre&gt; boolean first = true sql.execute "{call FindAllByFirst('J')}", { isResultSet, result -&gt; if (first) { first = false assert !isResultSet &amp;&amp; result == 0 } else { assert isResultSet &amp;&amp; result == [[ID:1, FIRSTNAME:'James', LASTNAME:'Strachan'], [ID:4, FIRSTNAME:'Jean', LASTNAME:'Gabin']] } } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql the SQL to execute
 * @param processResults a Closure which will be passed two parameters: either {@code true} plus a list of GroovyRowResult valuesderived from  {@code statement.getResultSet()} or {@code false} plus the update count from {@code statement.getUpdateCount()}. The closure will be called for each result produced from executing the SQL.
 * @throws SQLException if a database access error occurs
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResults</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL with parameters. Also saves the updateCount, if any, for subsequent examination. &lt;p&gt; Example usage: &lt;pre&gt; sql.execute """ insert into PERSON (id, firstname, lastname, location_id) values (?, ?, ?, ?) """, [1, "Guillaume", "Laforge", 10] assert sql.updateCount == 1 &lt;/pre&gt; &lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are no results
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL with parameters. Also calls the provided processResults Closure to process any ResultSet or UpdateCount results that executing the SQL might produce. &lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @param processResults a Closure which will be passed two parameters: either {@code true} plus a list of GroovyRowResult valuesderived from  {@code statement.getResultSet()} or {@code false} plus the update count from {@code statement.getUpdateCount()}. The closure will be called for each result produced from executing the SQL.
 * @throws SQLException if a database access error occurs
 * @see #execute(String,Closure)
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResults</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #execute(String,java.util.List)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    the SQL statement
 * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are no results
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #execute(String,java.util.List,Closure)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    the SQL statement
 * @param processResults a Closure which will be passed two parameters: either {@code true} plus a list of GroovyRowResult valuesderived from  {@code statement.getResultSet()} or {@code false} plus the update count from {@code statement.getUpdateCount()}. The closure will be called for each result produced from executing the SQL.
 * @throws SQLException if a database access error occurs
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResults</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, singletonList(params), processResults]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL with parameters. &lt;p&gt; An Object array variant of  {@link #execute(String,List)}. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are no results
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given piece of SQL with parameters. &lt;p&gt; An Object array variant of  {@link #execute(String,List,Closure)}. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @param processResults a Closure which will be passed two parameters: either {@code true} plus a list of GroovyRowResult valuesderived from  {@code statement.getResultSet()} or {@code false} plus the update count from {@code statement.getUpdateCount()}. The closure will be called for each result produced from executing the SQL.
 * @throws SQLException if a database access error occurs
 * @see #execute(String,List,Closure)
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResults</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, Arrays.asList(params), processResults]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given SQL with embedded expressions inside. Also saves the updateCount, if any, for subsequent examination. &lt;p&gt; Example usage: &lt;pre&gt; def scott = [firstname: "Scott", lastname: "Davis", id: 5, location_id: 50] sql.execute """ insert into PERSON (id, firstname, lastname, location_id) values ($scott.id, $scott.firstname, $scott.lastname, $scott.location_id) """ assert sql.updateCount == 1 &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are no results
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Executes the given SQL with embedded expressions inside. Also calls the provided processResults Closure to process any ResultSet or UpdateCount results that executing the SQL might produce. Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @param processResults a Closure which will be passed two parameters: either {@code true} plus a list of GroovyRowResult valuesderived from  {@code statement.getResultSet()} or {@code false} plus the update count from {@code statement.getUpdateCount()}. The closure will be called for each result produced from executing the SQL.
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 * @see #execute(String,List,Closure)
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResults</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, params, processResults]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). Use this variant when you want to receive the values of any auto-generated columns, such as an autoincrement ID field. See  {@link #executeInsert(GString)} for more details.&lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql The SQL statement to execute
 * @return A list of the auto-generated column values for eachinserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). Use this variant when you want to receive the values of any auto-generated columns, such as an autoincrement ID field. The query may contain placeholder question marks which match the given list of parameters. See  {@link #executeInsert(GString)} for more details.&lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    The SQL statement to execute
 * @param params The parameter values that will be substitutedinto the SQL statement's parameter slots
 * @return A list of the auto-generated column values for eachinserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). Use this variant when you want to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) and you know the column name(s) of the ID field(s). The query may contain placeholder question marks which match the given list of parameters. See  {@link #executeInsert(GString)} for more details.&lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql            The SQL statement to execute
 * @param params         The parameter values that will be substitutedinto the SQL statement's parameter slots
 * @param keyColumnNames a list of column names indicating the columns that should be returned from theinserted row or rows (some drivers may be case sensitive, e.g. may require uppercase names)
 * @return A list of the auto-generated row results for each inserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @see Connection#prepareStatement(String,String[])
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColumnNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #executeInsert(String,java.util.List)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    The SQL statement to execute
 * @return A list of the auto-generated column values for eachinserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #executeInsert(String,List,List)}useful when providing the named parameters as named arguments. This variant allows you to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) when you know the column name(s) of the ID field(s).
 * @param params         a map containing the named parameters
 * @param sql            The SQL statement to execute
 * @param keyColumnNames a list of column names indicating the columns that should be returned from theinserted row or rows (some drivers may be case sensitive, e.g. may require uppercase names)
 * @return A list of the auto-generated row results for each inserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @see Connection#prepareStatement(String,String[])
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColumnNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). &lt;p&gt; An Object array variant of  {@link #executeInsert(String,List)}. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql    The SQL statement to execute
 * @param params The parameter values that will be substitutedinto the SQL statement's parameter slots
 * @return A list of the auto-generated column values for eachinserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). This variant allows you to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) when you know the column name(s) of the ID field(s). &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql            The SQL statement to execute
 * @param keyColumnNames an array of column names indicating the columns that should be returned from theinserted row or rows (some drivers may be case sensitive, e.g. may require uppercase names)
 * @return A list of the auto-generated row results for each inserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColumnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). This variant allows you to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) when you know the column name(s) of the ID field(s). &lt;p&gt; An array variant of  {@link #executeInsert(String,List,List)}. &lt;p&gt; This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.
 * @param sql            The SQL statement to execute
 * @param keyColumnNames an array of column names indicating the columns that should be returned from theinserted row or rows (some drivers may be case sensitive, e.g. may require uppercase names)
 * @param params         The parameter values that will be substitutedinto the SQL statement's parameter slots
 * @return A list of the auto-generated row results for each inserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColumnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). Use this variant when you want to receive the values of any auto-generated columns, such as an autoincrement ID field. The query may contain GString expressions. &lt;p&gt; Generated key values can be accessed using array notation. For example, to return the second auto-generated column value of the third row, use &lt;code&gt;keys[3][1]&lt;/code&gt;. The method is designed to be used with SQL INSERT statements, but is not limited to them. &lt;p&gt; The standard use for this method is when a table has an autoincrement ID column and you want to know what the ID is for a newly inserted row. In this example, we insert a single row into a table in which the first column contains the autoincrement ID: &lt;pre&gt; def sql = Sql.newInstance("jdbc:mysql://localhost:3306/groovy", "user", "password", "com.mysql.jdbc.Driver") def keys = sql.executeInsert("insert into test_table (INT_DATA, STRING_DATA) " + "VALUES (1, 'Key Largo')") def id = keys[0][0] // 'id' now contains the value of the new row's ID column. // It can be used to update an object representation's // id attribute for example. ... &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return A list of the auto-generated column values for eachinserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeInsert</MethodName>
            <MethodComment>/** 
 * Executes the given SQL statement (typically an INSERT statement). Use this variant when you want to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) and you know the column name(s) of the ID field(s). &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring        a GString containing the SQL query with embedded params
 * @param keyColumnNames a list of column names indicating the columns that should be returned from theinserted row or rows (some drivers may be case sensitive, e.g. may require uppercase names)
 * @return A list of the auto-generated row results for each inserted row (typically auto-generated keys)
 * @throws SQLException if a database access error occurs
 * @see Connection#prepareStatement(String,String[])
 * @see #expand(Object)
 * @since 2.3.2
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColumnNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * Executes the given SQL update. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql the SQL to execute
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>Statement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * Executes the given SQL update with parameters. &lt;p&gt; This method supports named and named ordinal parameters. See the class Javadoc for more details. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>PreparedStatement [statement=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * A variant of  {@link #executeUpdate(String,java.util.List)}useful when providing the named parameters as named arguments.
 * @param params a map containing the named parameters
 * @param sql    the SQL statement
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 * @since 1.8.7
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * Executes the given SQL update with parameters. &lt;p&gt; An Object array variant of  {@link #executeUpdate(String,List)}.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * Executes the given SQL update with embedded expressions inside. &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call. &lt;p&gt; Example usage (tested with MySQL) - suppose we have the following stored procedure: &lt;pre&gt; sql.execute """ CREATE PROCEDURE HouseSwap(_first1 VARCHAR(50), _first2 VARCHAR(50)) BEGIN DECLARE _loc1 INT; DECLARE _loc2 INT; SELECT location_id into _loc1 FROM PERSON where firstname = _first1; SELECT location_id into _loc2 FROM PERSON where firstname = _first2; UPDATE PERSON set location_id = case firstname when _first1 then _loc2 when _first2 then _loc1 end where (firstname = _first1 OR firstname = _first2); END """ &lt;/pre&gt; then you can invoke the procedure as follows: &lt;pre&gt; def rowsChanged = sql.call("{call HouseSwap('Guillaume', 'Paul')}") assert rowsChanged == 2 &lt;/pre&gt;
 * @param sql the SQL statement
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given embedded parameters. &lt;p&gt; Example usage - see  {@link #call(String)} for more details aboutcreating a &lt;code&gt;HouseSwap(IN name1, IN name2)&lt;/code&gt; stored procedure. Once created, it can be called like this: &lt;pre&gt; def p1 = 'Paul' def p2 = 'Guillaume' def rowsChanged = sql.call("{call HouseSwap($p1, $p2)}") assert rowsChanged == 2 &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 * @see #expand(Object)
 * @see #call(String)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters. &lt;p&gt; Example usage - see  {@link #call(String)} for more details aboutcreating a &lt;code&gt;HouseSwap(IN name1, IN name2)&lt;/code&gt; stored procedure. Once created, it can be called like this: &lt;pre&gt; def rowsChanged = sql.call("{call HouseSwap(?, ?)}", ['Guillaume', 'Paul']) assert rowsChanged == 2 &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql    the SQL statement
 * @param params a list of parameters
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 * @see #call(String)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>CallableStatement [statement=connection.prepareCall(sql)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters. &lt;p&gt; An Object array variant of  {@link #call(String,List)}.
 * @param sql    the SQL statement
 * @param params an array of parameters
 * @return the number of rows updated or 0 for SQL statements that return nothing
 * @throws SQLException if a database access error occurs
 * @see #call(String)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters.  The closure is called once with all the out parameters. &lt;p&gt; Example usage - suppose we create a stored procedure (ignore its simplistic implementation): &lt;pre&gt; // Tested with MySql 5.0.75 sql.execute """ CREATE PROCEDURE Hemisphere( IN p_firstname VARCHAR(50), IN p_lastname VARCHAR(50), OUT ans VARCHAR(50)) BEGIN DECLARE loc INT; SELECT location_id into loc FROM PERSON where firstname = p_firstname and lastname = p_lastname; CASE loc WHEN 40 THEN SET ans = 'Southern Hemisphere'; ELSE SET ans = 'Northern Hemisphere'; END CASE; END; """ &lt;/pre&gt; we can now call the stored procedure as follows: &lt;pre&gt; sql.call '{call Hemisphere(?, ?, ?)}', ['Guillaume', 'Laforge', Sql.VARCHAR], { dwells -&gt; println dwells } &lt;/pre&gt; which will output '&lt;code&gt;Northern Hemisphere&lt;/code&gt;'. &lt;p&gt; We can also access stored functions with scalar return values where the return value will be treated as an OUT parameter. Here are examples for various databases for creating such a procedure: &lt;pre&gt; // Tested with MySql 5.0.75 sql.execute """ create function FullName(p_firstname VARCHAR(40)) returns VARCHAR(80) begin declare ans VARCHAR(80); SELECT CONCAT(firstname, ' ', lastname) INTO ans FROM PERSON WHERE firstname = p_firstname; return ans; end """ // Tested with MS SQLServer Express 2008 sql.execute """ {@code create function FullName(@firstname VARCHAR(40)) returns VARCHAR(80)}begin declare  {@code @ans} VARCHAR(80){@code SET @ans = (SELECT firstname + ' ' + lastname FROM PERSON WHERE firstname = @firstname)}return  {@code @ans}end """ // Tested with Oracle XE 10g sql.execute """ create function FullName(p_firstname VARCHAR) return VARCHAR is ans VARCHAR(80); begin SELECT CONCAT(CONCAT(firstname, ' '), lastname) INTO ans FROM PERSON WHERE firstname = p_firstname; return ans; end; """ &lt;/pre&gt; and here is how you access the stored function for all databases: &lt;pre&gt; sql.call("{? = call FullName(?)}", [Sql.VARCHAR, 'Sam']) { name -&gt; assert name == 'Sam Pullara' } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;callWithRows;[sql, params, NO_RESULT_SETS, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>call</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters, calling the closure once with all result objects. &lt;p&gt; See  {@link #call(String,List,Closure)} for more details aboutcreating a &lt;code&gt;Hemisphere(IN first, IN last, OUT dwells)&lt;/code&gt; stored procedure. Once created, it can be called like this: &lt;pre&gt; def first = 'Scott' def last = 'Davis' sql.call "{call Hemisphere($first, $last, ${Sql.VARCHAR})}", { dwells -&gt; println dwells } &lt;/pre&gt; &lt;p&gt; As another example, see  {@link #call(String,List,Closure)} for more details aboutcreating a &lt;code&gt;FullName(IN first)&lt;/code&gt; stored function. Once created, it can be called like this: &lt;pre&gt; def first = 'Sam' sql.call("{$Sql.VARCHAR = call FullName($first)}") { name -&gt; assert name == 'Sam Pullara' } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @param closure called for each row with a GroovyResultSet
 * @throws SQLException if a database access error occurs
 * @see #call(String,List,Closure)
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;call;[sql, params, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithRows</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters, calling the closure once with all result objects, and also returning the rows of the ResultSet. &lt;p&gt; Use this when calling a stored procedure that utilizes both output parameters and returns a single ResultSet. &lt;p&gt; Once created, the stored procedure can be called like this: &lt;pre&gt; def first = 'Jeff' def last = 'Sheets' def rows = sql.callWithRows "{call Hemisphere2($first, $last, ${Sql.VARCHAR})}", { dwells -&gt; println dwells } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @param closure called once with all out parameter results
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #callWithRows(String,List,Closure)
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithRows</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters, calling the closure once with all result objects, and also returning the rows of the ResultSet. &lt;p&gt; Use this when calling a stored procedure that utilizes both output parameters and returns a single ResultSet. &lt;p&gt; Once created, the stored procedure can be called like this: &lt;pre&gt; def rows = sql.callWithRows '{call Hemisphere2(?, ?, ?)}', ['Guillaume', 'Laforge', Sql.VARCHAR], { dwells -&gt; println dwells } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param closure called once with all out parameter results
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #callWithRows(GString,Closure)
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithAllRows</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters, calling the closure once with all result objects, and also returning a list of lists with the rows of the ResultSet(s). &lt;p&gt; Use this when calling a stored procedure that utilizes both output parameters and returns multiple ResultSets. &lt;p&gt; Once created, the stored procedure can be called like this: &lt;pre&gt; def first = 'Jeff' def last = 'Sheets' def rowsList = sql.callWithAllRows "{call Hemisphere2($first, $last, ${Sql.VARCHAR})}", { dwells -&gt; println dwells } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param gstring a GString containing the SQL query with embedded params
 * @param closure called once with all out parameter results
 * @return a list containing lists of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #callWithAllRows(String,List,Closure)
 */
</MethodComment>
            <ReturnType>List&lt;GroovyRowResult&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [params=getParameters(gstring)]</InnerVar>
                <InnerVar>String [sql=asSql(gstring,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithAllRows</MethodName>
            <MethodComment>/** 
 * Performs a stored procedure call with the given parameters, calling the closure once with all result objects, and also returning a list of lists with the rows of the ResultSet(s). &lt;p&gt; Use this when calling a stored procedure that utilizes both output parameters and returns multiple ResultSets. &lt;p&gt; Once created, the stored procedure can be called like this: &lt;pre&gt; def rowsList = sql.callWithAllRows '{call Hemisphere2(?, ?, ?)}', ['Guillaume', 'Laforge', Sql.VARCHAR], { dwells -&gt; println dwells } &lt;/pre&gt; &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param closure called once with all out parameter results
 * @return a list containing lists of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #callWithRows(GString,Closure)
 */
</MethodComment>
            <ReturnType>List&lt;GroovyRowResult&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callWithRows</MethodName>
            <MethodComment>/** 
 * Base internal method for call(), callWithRows(), and callWithAllRows() style of methods. &lt;p&gt; Performs a stored procedure call with the given parameters, calling the closure once with all result objects, and also returning the rows of the ResultSet(s) (if processResultSets is set to Sql.FIRST_RESULT_SET, Sql.ALL_RESULT_SETS) &lt;p&gt; Main purpose of processResultSets param is to retain original call() method performance when this is set to Sql.NO_RESULT_SETS &lt;p&gt; Resource handling is performed automatically where appropriate.
 * @param sql     the sql statement
 * @param params  a list of parameters
 * @param processResultsSets the result sets to process, either Sql.NO_RESULT_SETS, Sql.FIRST_RESULT_SET, or Sql.ALL_RESULT_SETS
 * @param closure called once with all out parameter results
 * @return a list of GroovyRowResult objects
 * @throws SQLException if a database access error occurs
 * @see #callWithRows(String,List,Closure)
 */
</MethodComment>
            <ReturnType>List&lt;GroovyRowResult&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>processResultsSets</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>CallableStatement [statement=null]</InnerVar>
                <InnerVar>List&lt;GroovyResultSet&gt; [resultSetResources=new ArrayList&lt;GroovyResultSet&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * If this SQL object was created with a Connection then this method closes the connection. If this SQL object was created from a DataSource then this method only frees any cached objects (statements in particular).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>namedParamSqlCache;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>namedParamIndexPropCache;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearStatementCache;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataSource</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataSource</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commit</MethodName>
            <MethodComment>/** 
 * If this SQL object was created with a Connection then this method commits the connection. If this SQL object was created from a DataSource then this method does nothing.
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rollback</MethodName>
            <MethodComment>/** 
 * If this SQL object was created with a Connection then this method rolls back the connection. If this SQL object was created from a DataSource then this method does nothing.
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateCount</MethodName>
            <MethodComment>/** 
 * @return Returns the updateCount.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConnection</MethodName>
            <MethodComment>/** 
 * If this instance was created with a single Connection then the connection is returned. Otherwise if this instance was created with a DataSource then this method returns null
 * @return the connection wired into this object, or null if this objectuses a DataSource
 */
</MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConnection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withStatement</MethodName>
            <MethodComment>/** 
 * Allows a closure to be passed in to configure the JDBC statements before they are executed. It can be used to do things like set the query size etc. When this method is invoked, the supplied closure is saved. Statements subsequently created from other methods will then be configured using this closure. The statement being configured is passed into the closure as its single argument, e.g.: &lt;pre&gt; sql.withStatement{ stmt -&gt; stmt.maxRows = 10 } def firstTenRows = sql.rows("select * from table") &lt;/pre&gt;
 * @param configureStatement the closure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>configureStatement</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCacheStatements</MethodName>
            <MethodComment>/** 
 * Enables statement caching.&lt;br&gt; if &lt;i&gt;cacheStatements&lt;/i&gt; is true, cache is created and all created prepared statements will be cached. if &lt;i&gt;cacheStatements&lt;/i&gt; is false, all cached statements will be properly closed.
 * @param cacheStatements the new value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheStatements</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCacheStatements</MethodName>
            <MethodComment>/** 
 * @return boolean true if cache is enabled (default is false)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cacheConnection</MethodName>
            <MethodComment>/** 
 * Caches the connection used while the closure is active. If the closure takes a single argument, it will be called with the connection, otherwise it will be called with no arguments.
 * @param closure the given closure
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [savedCacheConnection=cacheConnection]</InnerVar>
                <InnerVar>Connection [connection=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withTransaction</MethodName>
            <MethodComment>/** 
 * Performs the closure within a transaction using a cached connection. If the closure takes a single argument, it will be called with the connection, otherwise it will be called with no arguments.
 * @param closure the given closure
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [savedCacheConnection=cacheConnection]</InnerVar>
                <InnerVar>Connection [connection=null]</InnerVar>
                <InnerVar>boolean [savedAutoCommit=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isWithinBatch</MethodName>
            <MethodComment>/** 
 * Returns true if the current Sql object is currently executing a withBatch method call.
 * @return true if a withBatch call is currently being executed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withBatch</MethodName>
            <MethodComment>/** 
 * Performs the closure (containing batch operations) within a batch. Uses a batch size of zero, i.e. no automatic partitioning of batches. &lt;p&gt; This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch. &lt;p&gt; The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch. &lt;p&gt; Use it like this: &lt;pre&gt; def updateCounts = sql.withBatch { stmt -&gt; stmt.addBatch("insert into TABLENAME ...") stmt.addBatch("insert into TABLENAME ...") stmt.addBatch("insert into TABLENAME ...") ... } &lt;/pre&gt; For integrity and performance reasons, you may wish to consider executing your batch command(s) within a transaction: &lt;pre&gt; sql.withTransaction { def result1 = sql.withBatch { ... } ... } &lt;/pre&gt;
 * @param closure the closure containing batch and optionally other statements
 * @return an array of update counts containing one element for eachcommand in the batch.  The elements of the array are ordered according to the order in which commands were added to the batch.
 * @throws SQLException if a database access error occurs,or this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, or the driver does not support batch statements. Throws  {@link java.sql.BatchUpdateException}(a subclass of &lt;code&gt;SQLException&lt;/code&gt;) if one of the commands sent to the database fails to execute properly or attempts to return a result set.
 * @see #withBatch(int,Closure)
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withBatch</MethodName>
            <MethodComment>/** 
 * Performs the closure (containing batch operations) within a batch using a given batch size. &lt;p&gt; After every &lt;code&gt;batchSize&lt;/code&gt; &lt;code&gt;addBatch(sqlBatchOperation)&lt;/code&gt; operations, automatically calls an &lt;code&gt;executeBatch()&lt;/code&gt; operation to "chunk" up the database operations into partitions. Though not normally needed, you can also explicitly call &lt;code&gt;executeBatch()&lt;/code&gt; which after executing the current batch, resets the batch count back to zero. &lt;p&gt; The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch. &lt;p&gt; Use it like this for batchSize of 20: &lt;pre&gt; def updateCounts = sql.withBatch(20) { stmt -&gt; stmt.addBatch("insert into TABLENAME ...") stmt.addBatch("insert into TABLENAME ...") stmt.addBatch("insert into TABLENAME ...") ... } &lt;/pre&gt; For integrity and performance reasons, you may wish to consider executing your batch command(s) within a transaction: &lt;pre&gt; sql.withTransaction { def result1 = sql.withBatch { ... } ... } &lt;/pre&gt;
 * @param batchSize partition the batch into batchSize pieces, i.e. after batchSize&lt;code&gt;addBatch()&lt;/code&gt; invocations, call &lt;code&gt;executeBatch()&lt;/code&gt; automatically; 0 means manual calls to executeBatch are required
 * @param closure   the closure containing batch and optionally other statements
 * @return an array of update counts containing one element for eachcommand in the batch.  The elements of the array are ordered according to the order in which commands were added to the batch.
 * @throws SQLException if a database access error occurs,or this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, or the driver does not support batch statements. Throws  {@link java.sql.BatchUpdateException}(a subclass of &lt;code&gt;SQLException&lt;/code&gt;) if one of the commands sent to the database fails to execute properly or attempts to return a result set.
 * @see #withBatch(Closure)
 * @see BatchingStatementWrapper
 * @see Statement
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>batchSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>BatchingStatementWrapper [statement=null]</InnerVar>
                <InnerVar>boolean [savedWithinBatch=withinBatch]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withBatch</MethodName>
            <MethodComment>/** 
 * Performs the closure (containing batch operations specific to an associated prepared statement) within a batch. Uses a batch size of zero, i.e. no automatic partitioning of batches. &lt;p&gt; This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch. &lt;p&gt; The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch. &lt;p&gt; An example: &lt;pre&gt; def updateCounts = sql.withBatch('insert into TABLENAME(a, b, c) values (?, ?, ?)') { ps -&gt; ps.addBatch([10, 12, 5]) ps.addBatch([7, 3, 98]) ps.addBatch(22, 67, 11) def partialUpdateCounts = ps.executeBatch() // optional interim batching ps.addBatch(30, 40, 50) ... } &lt;/pre&gt; For integrity and performance reasons, you may wish to consider executing your batch command(s) within a transaction: &lt;pre&gt; sql.withTransaction { def result1 = sql.withBatch { ... } ... } &lt;/pre&gt;
 * @param sql     batch update statement
 * @param closure the closure containing batch statements (to bind parameters) and optionally other statements
 * @return an array of update counts containing one element for eachbinding in the batch.  The elements of the array are ordered according to the order in which commands were executed.
 * @throws SQLException if a database access error occurs,or this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, or the driver does not support batch statements. Throws  {@link java.sql.BatchUpdateException}(a subclass of &lt;code&gt;SQLException&lt;/code&gt;) if one of the commands sent to the database fails to execute properly or attempts to return a result set.
 * @see #withBatch(int,String,Closure)
 * @see BatchingPreparedStatementWrapper
 * @see PreparedStatement
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withBatch</MethodName>
            <MethodComment>/** 
 * Performs the closure (containing batch operations specific to an associated prepared statement) within a batch using a given batch size. &lt;p&gt; After every &lt;code&gt;batchSize&lt;/code&gt; &lt;code&gt;addBatch(params)&lt;/code&gt; operations, automatically calls an &lt;code&gt;executeBatch()&lt;/code&gt; operation to "chunk" up the database operations into partitions. Though not normally needed, you can also explicitly call &lt;code&gt;executeBatch()&lt;/code&gt; which after executing the current batch, resets the batch count back to zero. &lt;p&gt; The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch. &lt;p&gt; Below is an example using a batchSize of 20: &lt;pre&gt; def updateCounts = sql.withBatch(20, 'insert into TABLENAME(a, b, c) values (?, ?, ?)') { ps -&gt; ps.addBatch(10, 12, 5)      // varargs style ps.addBatch([7, 3, 98])     // list ps.addBatch([22, 67, 11]) ... } &lt;/pre&gt; Named parameters (into maps or domain objects) are also supported: &lt;pre&gt; def updateCounts = sql.withBatch(20, 'insert into TABLENAME(a, b, c) values (:foo, :bar, :baz)') { ps -&gt; ps.addBatch([foo:10, bar:12, baz:5])  // map ps.addBatch(foo:7, bar:3, baz:98)     // Groovy named args allow outer brackets to be dropped ... } &lt;/pre&gt; Named ordinal parameters (into maps or domain objects) are also supported: &lt;pre&gt; def updateCounts = sql.withBatch(20, 'insert into TABLENAME(a, b, c) values (?1.foo, ?2.bar, ?2.baz)') { ps -&gt; ps.addBatch([[foo:22], [bar:67, baz:11]])  // list of maps or domain objects ps.addBatch([foo:10], [bar:12, baz:5])     // varargs allows outer brackets to be dropped ps.addBatch([foo:7], [bar:3, baz:98]) ... } // swap to batch size of 5 and illustrate simple and domain object cases ... class Person { String first, last } def updateCounts2 = sql.withBatch(5, 'insert into PERSON(id, first, last) values (?1, ?2.first, ?2.last)') { ps -&gt; ps.addBatch(1, new Person(first:'Peter', last:'Pan')) ps.addBatch(2, new Person(first:'Snow', last:'White')) ... } &lt;/pre&gt; For integrity and performance reasons, you may wish to consider executing your batch command(s) within a transaction: &lt;pre&gt; sql.withTransaction { def result1 = sql.withBatch { ... } ... } &lt;/pre&gt;
 * @param batchSize partition the batch into batchSize pieces, i.e. after batchSize&lt;code&gt;addBatch()&lt;/code&gt; invocations, call &lt;code&gt;executeBatch()&lt;/code&gt; automatically; 0 means manual calls to executeBatch are required if additional partitioning of the batch is required
 * @param sql       batch update statement
 * @param closure   the closure containing batch statements (to bind parameters) and optionally other statements
 * @return an array of update counts containing one element for eachbinding in the batch.  The elements of the array are ordered according to the order in which commands were executed.
 * @throws SQLException if a database access error occurs,or this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, or the driver does not support batch statements. Throws  {@link java.sql.BatchUpdateException}(a subclass of &lt;code&gt;SQLException&lt;/code&gt;) if one of the commands sent to the database fails to execute properly or attempts to return a result set.
 * @see BatchingPreparedStatementWrapper
 * @see PreparedStatement
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>batchSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [connection=createConnection()]</InnerVar>
                <InnerVar>List&lt;Tuple&gt; [indexPropList=null]</InnerVar>
                <InnerVar>SqlWithParams [preCheck=buildSqlWithIndexedProps(sql)]</InnerVar>
                <InnerVar>boolean [savedWithinBatch=withinBatch]</InnerVar>
                <InnerVar>BatchingPreparedStatementWrapper [psWrapper=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cacheStatements</MethodName>
            <MethodComment>/** 
 * Caches every created preparedStatement in Closure &lt;i&gt;closure&lt;/i&gt; Every cached preparedStatement is closed after closure has been called. If the closure takes a single argument, it will be called with the connection, otherwise it will be called with no arguments.
 * @param closure the given closure
 * @throws SQLException if a database error occurs
 * @see #setCacheStatements(boolean)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [savedCacheStatements=cacheStatements]</InnerVar>
                <InnerVar>Connection [connection=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeQuery</MethodName>
            <MethodComment>/** 
 * Useful helper method which handles resource management when executing a query which returns a result set. Derived classes of Sql can override "createQueryCommand" and then call this method to access the ResultSet returned from the provided query or alternatively can use the higher-level method of Sql which return result sets which are funnelled through this method, e.g. eachRow, query.
 * @param sql query to execute
 * @return the resulting ResultSet
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AbstractQueryCommand [command=createQueryCommand(sql)]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executePreparedQuery</MethodName>
            <MethodComment>/** 
 * Useful helper method which handles resource management when executing a prepared query which returns a result set. Derived classes of Sql can override "createPreparedQueryCommand" and then call this method to access the ResultSet returned from the provided query.
 * @param sql    query to execute
 * @param params parameters matching question mark placeholders in the query
 * @return the resulting ResultSet
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AbstractQueryCommand [command=createPreparedQueryCommand(sql,params)]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asList</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override list of result collection behavior. The default behavior is to return a list of GroovyRowResult objects corresponding to each row in the ResultSet.
 * @param sql query to execute
 * @param rs  the ResultSet to process
 * @return the resulting list of rows
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asList</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override list of result collection behavior. The default behavior is to return a list of GroovyRowResult objects corresponding to each row in the ResultSet.
 * @param sql         query to execute
 * @param rs          the ResultSet to process
 * @param metaClosure called for meta data (only once after sql execution)
 * @return the resulting list of rows
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroovyRowResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaClosure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;GroovyRowResult&gt; [results=new ArrayList&lt;GroovyRowResult&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asSql</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override sql generation from GStrings.
 * @param gstring a GString containing the SQL query with embedded params
 * @param values  the values to embed
 * @return the SQL version of the given query using ? instead of any parameter
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>values</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [strings=gstring.getStrings()]</InnerVar>
                <InnerVar>boolean [nulls=false]</InnerVar>
                <InnerVar>StringBuilder [buffer=new StringBuilder()]</InnerVar>
                <InnerVar>boolean [warned=false]</InnerVar>
                <InnerVar>Iterator&lt;Object&gt; [iter=values.iterator()]</InnerVar>
                <InnerVar>String [sql=buffer.toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullify</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override null handling. Default behavior is to replace ?'"? references with NULLish
 * @param sql the SQL statement
 * @return the modified SQL String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstWhere=findWhereKeyword(sql)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findWhereKeyword</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override where clause sniffing. Default behavior is to find the first 'where' keyword in the sql doing simple avoidance of the word 'where' within quotes.
 * @param sql the SQL statement
 * @return the index of the found keyword or -1 if not found
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char[] [chars=sql.toLowerCase().toCharArray()]</InnerVar>
                <InnerVar>char[] [whereChars="where".toCharArray()]</InnerVar>
                <InnerVar>int [i=0]</InnerVar>
                <InnerVar>boolean [inString=false]</InnerVar>
                <InnerVar>int [inWhere=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameters</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override behavior associated with extracting params from a GString.
 * @param gstring a GString containing the SQL query with embedded params
 * @return extracts the parameters from the expression as a List
 * @see #expand(Object)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gstring</ParamName>
                    <ParamType>GString</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setParameters</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override behavior associated with setting params for a prepared statement. Default behavior is to append the parameters to the given statement using &lt;code&gt;setObject&lt;/code&gt;.
 * @param params    the parameters to append
 * @param statement the statement
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setObject</MethodName>
            <MethodComment>/** 
 * Strategy method allowing derived classes to handle types differently such as for CLOBs etc.
 * @param statement the statement of interest
 * @param i         the index of the object of interest
 * @param value     the new object value
 * @throws SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConnection</MethodName>
            <MethodComment>/** 
 * An extension point allowing derived classes to change the behavior of connection creation. The default behavior is to either use the supplied connection or obtain it from the supplied datasource.
 * @return the connection associated with this Sql
 * @throws java.sql.SQLException if a SQL error occurs
 */
</MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment>/** 
 * An extension point allowing derived classes to change the behavior of resource closing.
 * @param connection the connection to close
 * @param statement  the statement to close
 * @param results    the results to close
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>results</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeResources;[connection, statement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment>/** 
 * An extension point allowing the behavior of resource closing to be overridden in derived classes.
 * @param connection the connection to close
 * @param statement  the statement to close
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeResources;[connection]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>BatchingStatementWrapper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment>/** 
 * An extension point allowing the behavior of resource closing to be overridden in derived classes.
 * @param connection the connection to close
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>configure</MethodName>
            <MethodComment>/** 
 * Provides a hook for derived classes to be able to configure JDBC statements. Default behavior is to call a previously saved closure, if any, using the statement as a parameter.
 * @param statement the statement to configure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Closure [configureStatement=this.configureStatement]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>calculateKeys</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>List&lt;Object&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>keys</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;List&lt;Object&gt;&gt; [autoKeys=new ArrayList&lt;List&lt;Object&gt;&gt;()]</InnerVar>
                <InnerVar>int [count=keys.getMetaData().getColumnCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Statement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callClosurePossiblyWithConnection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearStatementCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [statements[]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAbstractStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Statement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cmd</ParamName>
                    <ParamType>AbstractStatementCommand</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Statement [stmt]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Statement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Statement [stmt=getAbstractStatement(new CreateStatementCommand(),connection,sql)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>LOG;fine;[sql]</InnerMethodInvoke>
                <InnerMethodInvoke>null;configure;[stmt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SqlWithParams [updated=checkForNamedParams(sql,params)]</InnerVar>
                <InnerVar>PreparedStatement [statement=(PreparedStatement)getAbstractStatement(new CreatePreparedStatementCommand(returnGeneratedKeys),connection,updated.getSql())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>LOG;fine;[updated.getSql() + " | " + updated.getParams()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setParameters;[updated.getParams(), statement]</InnerMethodInvoke>
                <InnerMethodInvoke>null;configure;[statement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkForNamedParams</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SqlWithParams</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SqlWithParams [preCheck=buildSqlWithIndexedProps(sql)]</InnerVar>
                <InnerVar>List&lt;Tuple&gt; [indexPropList=new ArrayList&lt;Tuple&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preCheckForNamedParams</MethodName>
            <MethodComment>/** 
 * @deprecated Use {@link #buildSqlWithIndexedProps(String)} instead
 */
</MethodComment>
            <ReturnType>SqlWithParams</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildSqlWithIndexedProps</MethodName>
            <MethodComment>/** 
 * Hook to allow derived classes to override behavior associated with the parsing and indexing of parameters from a given sql statement.
 * @param sql the sql statement to process
 * @return a {@link SqlWithParams} instance containing the parsed sqland parameters containing the indexed location and property name of parameters or  {@code null} if no parsing ofthe sql was performed.
 */
</MethodComment>
            <ReturnType>SqlWithParams</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [newSql]</InnerVar>
                <InnerVar>List&lt;Tuple&gt; [propList]</InnerVar>
                <InnerVar>List&lt;Object&gt; [indexPropList=new ArrayList&lt;Object&gt;(propList)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdatedParams</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexPropList</ParamName>
                    <ParamType>Tuple</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Object&gt; [updatedParams=new ArrayList&lt;Object&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCacheNamedQueries</MethodName>
            <MethodComment>/** 
 * @return boolean    true if caching is enabled (the default is true)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCacheNamedQueries</MethodName>
            <MethodComment>/** 
 * Enables named query caching.&lt;br&gt; if &lt;i&gt;cacheNamedQueries&lt;/i&gt; is true, cache is created and processed named queries will be cached. if &lt;i&gt;cacheNamedQueries&lt;/i&gt; is false, no caching will occur saving memory at the cost of additional processing time.
 * @param cacheNamedQueries the new value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cacheNamedQueries</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEnableNamedQueries</MethodName>
            <MethodComment>/** 
 * @return boolean    true if named query processing is enabled (the default is true)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEnableNamedQueries</MethodName>
            <MethodComment>/** 
 * Enables named query support: &lt;ul&gt; &lt;li&gt;if &lt;i&gt;enableNamedQueries&lt;/i&gt; is true, queries with ':propname' and '?1.propname' style placeholders will be processed.&lt;/li&gt; &lt;li&gt;if &lt;i&gt;enableNamedQueries&lt;/i&gt; is false, this feature will be turned off.&lt;/li&gt; &lt;/ul&gt;
 * @param enableNamedQueries the new value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>enableNamedQueries</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Execute the command that's defined by the subclass following the Command pattern.  Specialized parameters are held in the command instances.
 * @param conn all commands accept a connection
 * @param sql  all commands accept an SQL statement
 * @return statement that can be cached, etc.
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>Statement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CreatePreparedStatementCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appearsLikeStoredProc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Statement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AbstractQueryCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Execute the command that's defined by the subclass following the Command pattern.  Specialized parameters are held in the command instances.
 * @return ResultSet from executing a query
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setInternalConnection;[connection]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment>/** 
 * After performing the execute operation and making use of its return, it's necessary to free the resources allocated for the statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Sql.this;closeResources;[connection, statement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeResources</MethodName>
            <MethodComment>/** 
 * After performing the execute operation and making use of its return, it's necessary to free the resources allocated for the statement.
 * @param rs allows the caller to conveniently close its resource as well
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Sql.this;closeResources;[connection, statement, rs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runQuery</MethodName>
            <MethodComment>/** 
 * Perform the query. Must set statement field so that the main ( {@link #execute()}) method can clean up. This is the method that encloses the variant part of the code.
 * @param connection the connection to use
 * @return ResultSet from an executeQuery method.
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMaxRows</MethodName>
            <MethodComment>/** 
 * Set the maximum number of rows to return in the ResultSet
 * @param maxRows the maximum number of rows
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maxRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxRows</MethodName>
            <MethodComment>/** 
 * Get the maximum number of rows to return in the ResultSet
 * @return the maximum number of rows
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PreparedQueryCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryParams</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runQuery</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedStatement(connection,sql,params)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>QueryCommand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runQuery</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createQueryCommand</MethodName>
            <MethodComment>/** 
 * Factory for the QueryCommand command pattern object allows subclasses to supply implementations of the command class. The factory will be used in a pattern similar to: &lt;pre&gt; AbstractQueryCommand q = createQueryCommand("update TABLE set count = 0) where count is null"); try { ResultSet rs = q.execute(); return asList(rs); } finally { q.closeResources(); } &lt;/pre&gt;
 * @param sql statement to be executed
 * @return a command - invoke its execute() and closeResource() methods
 */
</MethodComment>
            <ReturnType>AbstractQueryCommand</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPreparedQueryCommand</MethodName>
            <MethodComment>/** 
 * Factory for the PreparedQueryCommand command pattern object allows subclass to supply implementations of the command class.
 * @param sql         statement to be executed, including optional parameter placeholders (?)
 * @param queryParams List of parameter values corresponding to parameter placeholders
 * @return a command - invoke its execute() and closeResource() methods
 * @see #createQueryCommand(String)
 */
</MethodComment>
            <ReturnType>AbstractQueryCommand</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryParams</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInternalConnection</MethodName>
            <MethodComment>/** 
 * Stub needed for testing.  Called when a connection is opened by one of the command-pattern classes so that a test case can monitor the state of the connection through its subclass.
 * @param conn the connection that is about to be used by a command
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>