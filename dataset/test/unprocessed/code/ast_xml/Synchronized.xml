<Class>
    <Id>187</Id>
    <Package>groovy.transform</Package>
    <ClassName>Synchronized</ClassName>
    <ClassComment>Synchronized  /** 
 * Method annotation to make a method call synchronized for concurrency handling with some useful baked-in conventions. &lt;p&gt; {@code @Synchronized} is a safer variant of the &lt;code&gt;synchronized&lt;/code&gt; method modifier.The annotation can only be used on static and instance methods. It operates similarly to the &lt;code&gt;synchronized&lt;/code&gt; keyword, but it locks on different objects. When used with an instance method, the &lt;code&gt;synchronized&lt;/code&gt; keyword locks on &lt;code&gt;this&lt;/code&gt;, but the annotation locks on a (by default automatically generated) field named &lt;code&gt;$lock&lt;/code&gt;. If the field does not exist, it is created for you. If you annotate a static method, the annotation locks on a static field named &lt;code&gt;$LOCK&lt;/code&gt; instead. &lt;p&gt; If you want, you can create these locks yourself. The &lt;code&gt;$lock&lt;/code&gt; and &lt;code&gt;$LOCK&lt;/code&gt; fields will not be generated if you create them yourself. You can also choose to lock on another field, by specifying its name as parameter to the  {@code @Synchronized} annotation. In this usage variant, the lock fieldwill not be created automatically, and you must explicitly create it yourself. &lt;p&gt; &lt;em&gt;Rationale:&lt;/em&gt; Locking on &lt;code&gt;this&lt;/code&gt; or your own class object can have unfortunate side-effects, as other code not under your control can lock on these objects as well, which can cause race conditions and other nasty threading-related bugs. &lt;p&gt; &lt;em&gt;Example usage:&lt;/em&gt; &lt;pre&gt; class SynchronizedExample { private final myLock = new Object() {@code @}Synchronized static void greet() { println "world" } {@code @}Synchronized int answerToEverything() { return 42 } {@code @}Synchronized("myLock") void foo() { println "bar" } } &lt;/pre&gt; which becomes: &lt;pre&gt; class SynchronizedExample { private static final $LOCK = new Object[0] private final $lock = new Object[0] private final myLock = new Object() static void greet() { synchronized($LOCK) { println "world" } } int answerToEverything() { synchronized($lock) { return 42 } } void foo() { synchronized(myLock) { println "bar" } } } &lt;/pre&gt; &lt;em&gt;Credits:&lt;/em&gt; this annotation is inspired by the Project Lombok annotation of the same name. The functionality has been kept similar to ease the learning curve when swapping between these two tools. &lt;p&gt; &lt;em&gt;Details:&lt;/em&gt; If &lt;code&gt;$lock&lt;/code&gt; and/or &lt;code&gt;$LOCK&lt;/code&gt; are auto-generated, the fields are initialized with an empty &lt;code&gt;Object[]&lt;/code&gt; array, and not just a new &lt;code&gt;Object()&lt;/code&gt; as many snippets using this pattern tend to use. This is because a new &lt;code&gt;Object&lt;/code&gt; is NOT serializable, but a 0-size array is. Therefore, using  {@code @Synchronized} will not prevent yourobject from being serialized.
 * @author Paul King
 * @since 1.7.3
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>