<Class>
    <Id>687</Id>
    <Package>org.codehaus.groovy.transform.stc</Package>
    <ClassName>StaticTypeCheckingSupport</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StaticTypeCheckingSupport  /** 
 * Static support methods for  {@link StaticTypeCheckingVisitor}.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>Collection_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>Deprecated_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>Matcher_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>ArrayList_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>EXTENSION_METHOD_CACHE</FieldName>
            <FieldType>ExtensionMethodCache</FieldType>
        </Field>
        <Field>
            <FieldName>NUMBER_TYPES</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>NUMBER_TYPES</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>GSTRING_STRING_CLASSNODE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>UNKNOWN_PARAMETER_TYPE</FieldName>
            <FieldType>ClassNode</FieldType>
        </Field>
        <Field>
            <FieldName>DGM_METHOD_NODE_COMPARATOR</FieldName>
            <FieldType>Comparator</FieldType>
        </Field>
        <Field>
            <FieldName>DGM_METHOD_NODE_COMPARATOR</FieldName>
            <FieldType>MethodNode</FieldType>
        </Field>
        <Field>
            <FieldName>lock</FieldName>
            <FieldType>ReentrantReadWriteLock</FieldType>
        </Field>
        <Field>
            <FieldName>modules</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>modules</FieldName>
            <FieldType>ExtensionModule</FieldType>
        </Field>
        <Field>
            <FieldName>cachedMethods</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>cachedMethods</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>origin</FieldName>
            <FieldType>WeakReference</FieldType>
        </Field>
        <Field>
            <FieldName>origin</FieldName>
            <FieldType>ClassLoader</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isArrayAccessExpression</MethodName>
            <MethodComment>/** 
 * Returns true for expressions of the form x[...]
 * @param expression an expression
 * @return true for array access expressions
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isWithCall</MethodName>
            <MethodComment>/** 
 * Called on method call checks in order to determine if a method call corresponds to the idiomatic o.with { ... } structure
 * @param name name of the method called
 * @param callArguments arguments of the method
 * @return true if the name is "with" and arguments consist of a single closure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>callArguments</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isWithCall="with".equals(name) &amp;&amp; callArguments instanceof ArgumentListExpression]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTargetVariable</MethodName>
            <MethodComment>/** 
 * Given a variable expression, returns the ultimately accessed variable.
 * @param ve a variable expression
 * @return the target variable
 */
</MethodComment>
            <ReturnType>Variable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ve</ParamName>
                    <ParamType>VariableExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Variable [accessedVariable=ve.getAccessedVariable() != null ? ve.getAccessedVariable() : ve]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsForClassNode</MethodName>
            <MethodComment>/** 
 * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader,ClassNode,String)} instead
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clazz</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsForClassNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>clazz</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TreeSet&lt;MethodNode&gt; [accumulator=new TreeSet&lt;MethodNode&gt;(DGM_METHOD_NODE_COMPARATOR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findDGMMethodsForClassNode;[loader, clazz, name, accumulator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsForClassNode</MethodName>
            <MethodComment>/** 
 * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader,ClassNode,String,TreeSet)} instead
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clazz</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulator</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findDGMMethodsForClassNode;[MetaClassRegistryImpl.class.getClassLoader(), clazz, name, accumulator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsForClassNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>clazz</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulator</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [fromDGM=EXTENSION_METHOD_CACHE.getExtensionMethods(loader).get(clazz.getName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allParametersAndArgumentsMatch</MethodName>
            <MethodComment>/** 
 * Checks that arguments and parameter types match.
 * @param params method parameters
 * @param args type arguments
 * @return -1 if arguments do not match, 0 if arguments are of the exact type and &gt;0 when one or more argument isnot of the exact type but still match
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [dist=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allParametersAndArgumentsMatchWithDefaultParams</MethodName>
            <MethodComment>/** 
 * Checks that arguments and parameter types match, expecting that the number of parameters is strictly greater than the number of arguments, allowing possible inclusion of default parameters.
 * @param params method parameters
 * @param args type arguments
 * @return -1 if arguments do not match, 0 if arguments are of the exact type and &gt;0 when one or more argument isnot of the exact type but still match
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [dist=0]</InnerVar>
                <InnerVar>ClassNode [ptype=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>excessArgumentsMatchesVargsParameter</MethodName>
            <MethodComment>/** 
 * Checks that excess arguments match the vararg signature parameter.
 * @param params
 * @param args
 * @return -1 if no match, 0 if all arguments matches the vararg type and &gt;0 if one or more vararg argument isassignable to the vararg type, but still not an exact match
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [dist=0]</InnerVar>
                <InnerVar>ClassNode [vargsBase=params[params.length - 1].getType().getComponentType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lastArgMatchesVarg</MethodName>
            <MethodComment>/** 
 * Checks if the last argument matches the vararg type.
 * @param params
 * @param args
 * @return -1 if no match, 0 if the last argument is exactly the vararg type and 1 if of an assignable type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [lastParamType=params[params.length - 1].getType()]</InnerVar>
                <InnerVar>ClassNode [ptype=lastParamType.getComponentType()]</InnerVar>
                <InnerVar>ClassNode [arg=args[args.length - 1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAssignableTo</MethodName>
            <MethodComment>/** 
 * Checks if a class node is assignable to another. This is used for example in assignment checks where you want to verify that the assignment is valid.
 * @param type
 * @param toBeAssignedTo
 * @return true if the class node is assignable to the other class node, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toBeAssignedTo</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isVargs</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCompareToBoolean</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isArrayOp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBoolIntrinsicOp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPowerOperator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperationName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isShiftOperation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOperationInGroup</MethodName>
            <MethodComment>/** 
 * Returns true for operations that are of the class, that given a common type class for left and right, the operation "left op right" will have a result in the same type class In Groovy on numbers that is +,-,* as well as their variants with equals.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBitOperator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAssignment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCompatibleAssignmentTypes</MethodName>
            <MethodComment>/** 
 * Returns true or false depending on whether the right classnode can be assigned to the left classnode. This method should not add errors by itself: we let the caller decide what to do if an incompatible assignment is found.
 * @param left  the class to be assigned to
 * @param right the assignee class
 * @return false if types are incompatible
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCompatibleAssignmentTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCompatibleAssignmentTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowConstructorCoercion</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [leftRedirect=left.redirect()]</InnerVar>
                <InnerVar>ClassNode [rightRedirect=right.redirect()]</InnerVar>
                <InnerVar>boolean [rightExpressionIsNull=rightExpression instanceof ConstantExpression &amp;&amp; ((ConstantExpression)rightExpression).getValue() == null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGroovyConstructorCompatible</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rightExpression</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isWildcardLeftHandSide</MethodName>
            <MethodComment>/** 
 * Tells if a class is one of the "accept all" classes as the left hand side of an assignment.
 * @param node the classnode to test
 * @return true if it's an Object, String, boolean, Boolean or Class.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBeingCompiled</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkPossibleLooseOfPrecision</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightExpr</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [leftIndex=NUMBER_TYPES.get(left)]</InnerVar>
                <InnerVar>int [rightIndex=NUMBER_TYPES.get(right)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toMethodParametersString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb.append(methodName);append;["("]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[")"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prettyPrintType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>implementsInterfaceOrIsSubclassOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>superOrInterface</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [result=type.equals(superOrInterface) || type.isDerivedFrom(superOrInterface) || type.implementsInterface(superOrInterface)|| type == UNKNOWN_PARAMETER_TYPE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrimitiveDistance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>primA</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primB</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDistance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compare</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [dist=0]</InnerVar>
                <InnerVar>ClassNode [unwrapReceiver=ClassHelper.getUnwrapper(receiver)]</InnerVar>
                <InnerVar>ClassNode [unwrapCompare=ClassHelper.getUnwrapper(compare)]</InnerVar>
                <InnerVar>ClassNode [ref=receiver]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumInterfaceDistance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>interfaceClass</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode[] [interfaces=c.getInterfaces()]</InnerVar>
                <InnerVar>int [max=-1]</InnerVar>
                <InnerVar>int [superClassMax=getMaximumInterfaceDistance(c.getSuperClass(),interfaceClass)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsByNameAndArguments</MethodName>
            <MethodComment>/** 
 * @deprecated Use {@link #findDGMMethodsByNameAndArguments(ClassLoader,org.codehaus.groovy.ast.ClassNode,String,org.codehaus.groovy.ast.ClassNode[],java.util.List)} instead
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsByNameAndArguments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsByNameAndArguments</MethodName>
            <MethodComment>/** 
 * @deprecated Use {@link #findDGMMethodsByNameAndArguments(ClassLoader,org.codehaus.groovy.ast.ClassNode,String,org.codehaus.groovy.ast.ClassNode[],List)} instead
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDGMMethodsByNameAndArguments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [chosen]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methods;addAll;[findDGMMethodsForClassNode(loader,receiver,name)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUsingUncheckedGenerics</MethodName>
            <MethodComment>/** 
 * Returns true if the provided class node, when considered as a receiver of a message or as a parameter, is using a placeholder in its generics type. In this case, we're facing unchecked generics and type checking is limited (ex: void foo(Set s) { s.keySet() }
 * @param node the node to test
 * @return true if it is using any placeholder in generics types
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseBestMethod</MethodName>
            <MethodComment>/** 
 * Given a list of candidate methods, returns the one which best matches the argument types
 * @param receiver
 * @param methods candidate methods
 * @param args argument types
 * @return the list of methods which best matches the argument types. It is still possible that multiplemethods match the argument types.
 */
</MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [bestChoices=new LinkedList&lt;MethodNode&gt;()]</InnerVar>
                <InnerVar>int [bestDist=Integer.MAX_VALUE]</InnerVar>
                <InnerVar>Collection&lt;MethodNode&gt; [choicesLeft=removeCovariants(methods)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeRawTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Parameter[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parameter[] [newParam=new Parameter[params.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeRawType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [raw=receiver.getPlainNodeReference()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>raw;setUsingGenerics;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>raw;setGenericsTypes;[null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeCovariants</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collection</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [toBeRemoved=new LinkedList&lt;MethodNode&gt;()]</InnerVar>
                <InnerVar>List&lt;MethodNode&gt; [list=new LinkedList&lt;MethodNode&gt;(new HashSet&lt;MethodNode&gt;(collection))]</InnerVar>
                <InnerVar>List&lt;MethodNode&gt; [result=new LinkedList&lt;MethodNode&gt;(list)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;removeAll;[toBeRemoved]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parameterizeArguments</MethodName>
            <MethodComment>/** 
 * Given a receiver and a method node, parameterize the method arguments using available generic type information.
 * @param receiver the class
 * @param m the method
 * @return the parameterized arguments
 */
</MethodComment>
            <ReturnType>Parameter[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>m</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [genericFromReceiver=GenericsUtils.extractPlaceholders(receiver)]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [contextPlaceholders=extractGenericsParameterMapOfThis(m)]</InnerVar>
                <InnerVar>Parameter[] [methodParameters=m.getParameters()]</InnerVar>
                <InnerVar>Parameter[] [params=new Parameter[methodParameters.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildParameter</MethodName>
            <MethodComment>/** 
 * Given a parameter, builds a new parameter for which the known generics placeholders are resolved.
 * @param genericFromReceiver resolved generics from the receiver of the message
 * @param placeholdersFromContext, resolved generics from the method context
 * @param methodParameter the method parameter for which we want to resolve generic types
 * @param paramType the (unresolved) type of the method parameter
 * @return a new parameter with the same name and type as the original one, but with resolved generic types
 */
</MethodComment>
            <ReturnType>Parameter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>genericFromReceiver</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholdersFromContext</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodParameter</ParamName>
                    <ParamType>Parameter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [resolved=resolveClassNodeGenerics(genericFromReceiver,placeholdersFromContext,paramType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUsingGenericsOrIsArrayUsingGenerics</MethodName>
            <MethodComment>/** 
 * Returns true if a class node makes use of generic types. If the class node represents an array type, then checks if the component type is using generics.
 * @param cn a class node for which to check if it is using generics
 * @return true if the type (or component type) is using generics
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fullyResolve</MethodName>
            <MethodComment>/** 
 * Given a generics type representing SomeClass&amp;lt;T,V&amp;gt; and a resolved placeholder map, returns a new generics type for which placeholders are resolved recursively.
 */
</MethodComment>
            <ReturnType>GenericsType</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gt</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType [fromMap=placeholders.get(gt.getName())]</InnerVar>
                <InnerVar>ClassNode [type=fullyResolveType(gt.getType(),placeholders)]</InnerVar>
                <InnerVar>ClassNode [lowerBound=gt.getLowerBound()]</InnerVar>
                <InnerVar>ClassNode[] [upperBounds=gt.getUpperBounds()]</InnerVar>
                <InnerVar>GenericsType [genericsType=new GenericsType(type,upperBounds,lowerBound)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>genericsType;setWildcard;[gt.isWildcard()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fullyResolveType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMethodArgumentWithGenerics</MethodName>
            <MethodComment>/** 
 * Checks that the parameterized generics of an argument are compatible with the generics of the parameter.
 * @param parameterType the parameter type of a method
 * @param argumentType  the type of the argument passed to the method
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>argumentType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lastArg</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMethodLevelDeclaredGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [dummy=OBJECT_TYPE.getPlainNodeReference()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dummy;setGenericsTypes;[method.getGenericsTypes()]</InnerMethodInvoke>
                <InnerMethodInvoke>GenericsUtils;extractPlaceholders;[dummy, resolvedPlaceholders]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMethodsWithGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>candidateMethod</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parameter[] [parameters=candidateMethod.getParameters()]</InnerVar>
                <InnerVar>GenericsType[] [genericsTypes=candidateMethod.getGenericsTypes()]</InnerVar>
                <InnerVar>boolean [methodUsesGenerics=(genericsTypes != null &amp;&amp; genericsTypes.length &gt; 0)]</InnerVar>
                <InnerVar>boolean [isExtensionMethod=candidateMethod instanceof ExtensionMethodNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeCheckMethodsWithGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arguments</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>candidateMethod</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isExtensionMethod</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [failure=false]</InnerVar>
                <InnerVar>boolean [skipBecauseOfInnerClassNotReceiver=isOuterClassOf(receiver,candidateMethod.getDeclaringClass())]</InnerVar>
                <InnerVar>Parameter[] [parameters=candidateMethod.getParameters()]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [classGTs]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [resolvedMethodGenerics=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
                <InnerVar>Set&lt;String&gt; [fixedGenericsPlaceHolders=extractResolvedPlaceHolders(resolvedMethodGenerics)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;applyGenericsConnections;[classGTs, resolvedMethodGenerics]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOuterClassOf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractResolvedPlaceHolders</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedMethodGenerics</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;String&gt; [result=new HashSet&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inferenceCheck</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fixedGenericsPlaceHolders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedMethodGenerics</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wrappedArgument</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lastArg</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [connections=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
                <InnerVar>boolean [failure=!compatibleConnections(connections,resolvedMethodGenerics,fixedGenericsPlaceHolders)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;extractGenericsConnections;[connections, wrappedArgument, type]</InnerMethodInvoke>
                <InnerMethodInvoke>null;applyGenericsConnections;[connections, resolvedMethodGenerics]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addMissingEntries;[connections, resolvedMethodGenerics]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildWildcardType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GenericsType</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>origin</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [lowerBound=origin.getType().getPlainNodeReference()]</InnerVar>
                <InnerVar>ClassNode [base=ClassHelper.makeWithoutCaching("?")]</InnerVar>
                <InnerVar>GenericsType [gt=new GenericsType(base,null,lowerBound)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>gt;setWildcard;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compatibleConnections</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedMethodGenerics</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fixedGenericsPlaceHolders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compatibleConnection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolved</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType [gt=connection]</InnerVar>
                <InnerVar>ClassNode [compareNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMissingEntries</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolved</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveClassNodeGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholdersFromContext</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [target=currentType.redirect()]</InnerVar>
                <InnerVar>Map&lt;String,GenericsType&gt; [connections=new HashMap&lt;String,GenericsType&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;applyContextGenerics;[resolvedPlaceholders, placeholdersFromContext]</InnerMethodInvoke>
                <InnerMethodInvoke>null;extractGenericsConnections;[connections, currentType, target]</InnerMethodInvoke>
                <InnerMethodInvoke>null;applyGenericsConnections;[connections, resolvedPlaceholders]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsConnections</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalIncludingGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>orig</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copy</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [lower1=orig.getLowerBound()]</InnerVar>
                <InnerVar>ClassNode [lower2=copy.getLowerBound()]</InnerVar>
                <InnerVar>ClassNode[] [upper1=orig.getUpperBounds()]</InnerVar>
                <InnerVar>ClassNode[] [upper2=copy.getUpperBounds()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalIncludingGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>orig</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copy</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [gt1=orig.getGenericsTypes()]</InnerVar>
                <InnerVar>GenericsType[] [gt2=orig.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractGenericsConnections</MethodName>
            <MethodComment>/** 
 * use supplied type to make a connection from usage to declaration The method operates in two modes.  * For type !instanceof target a structural compare will be done  (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R)  * If type equals target, a structural match is done as well  (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E) * otherwise we climb the hierarchy to find a case of type equals target to then execute the structural match, while applying possibly existing generics contexts on the way (for example for IntRange and Collection&lt;E&gt; to get E=Integer, since IntRange is an AbstractList&lt;Integer&gt;) Should the target not have any generics this method does nothing.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractGenericsConnections</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>usage</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>declaration</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractGenericsConnections</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connections</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>usage</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>declaration</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsWithoutArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GenericsType[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsContextToParameterClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spec</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterUsage</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [gts=parameterUsage.getGenericsTypes()]</InnerVar>
                <InnerVar>GenericsType[] [newGTs=applyGenericsContext(spec,gts)]</InnerVar>
                <InnerVar>ClassNode [newTarget=parameterUsage.redirect().getPlainNodeReference()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newTarget;setGenericsTypes;[newGTs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GenericsType[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spec</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gts</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [newGTs=new GenericsType[gts.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GenericsType</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spec</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gt</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [type=gt.getType()]</InnerVar>
                <InnerVar>ClassNode [newType=type.getPlainNodeReference()]</InnerVar>
                <InnerVar>GenericsType [newGT=new GenericsType(newType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newType;setGenericsPlaceHolder;[type.isGenericsPlaceHolder()]</InnerMethodInvoke>
                <InnerMethodInvoke>newType;setGenericsTypes;[applyGenericsContext(spec,type.getGenericsTypes())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spec</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bounds</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode[] [newBounds=new ClassNode[bounds.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyGenericsContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spec</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bound</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [newBound=bound.getPlainNodeReference()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newBound;setGenericsTypes;[applyGenericsContext(spec,bound.getGenericsTypes())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCombinedBoundType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>genericsType</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyContextGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedPlaceholders</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>placeholdersFromContext</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsParameterMapOfThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [map=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractGenericsParameterMapOfThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mn</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,GenericsType&gt; [map=getGenericsParameterMapOfThis(mn.getDeclaringClass())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>current</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newGenerics</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arr</ParamName>
                    <ParamType>T[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arr</ParamName>
                    <ParamType>T[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>object</ParamName>
                    <ParamType>U</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExtensionMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lock.readLock();lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onModule</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>module</ParamName>
                    <ParamType>ExtensionModule</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [skip=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDGMMethods</MethodName>
            <MethodComment>/** 
 * Returns a map which contains, as the key, the name of a class. The value consists of a list of MethodNode, one for each default groovy method found which is applicable for this class.
 * @return
 * @param modules
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>modules</ParamName>
                    <ParamType>ExtensionModule</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;Class&gt; [instanceExtClasses=new LinkedHashSet&lt;Class&gt;()]</InnerVar>
                <InnerVar>Set&lt;Class&gt; [staticExtClasses=new LinkedHashSet&lt;Class&gt;()]</InnerVar>
                <InnerVar>Map&lt;String,List&lt;MethodNode&gt;&gt; [methods=new HashMap&lt;String,List&lt;MethodNode&gt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Collections;addAll;[instanceExtClasses, DefaultGroovyMethods.DGM_LIKE_CLASSES]</InnerMethodInvoke>
                <InnerMethodInvoke>Collections;addAll;[instanceExtClasses, DefaultGroovyMethods.additionals]</InnerMethodInvoke>
                <InnerMethodInvoke>staticExtClasses;add;[DefaultGroovyStaticMethods.class]</InnerMethodInvoke>
                <InnerMethodInvoke>instanceExtClasses;add;[ObjectArrayStaticTypesHelper.class]</InnerMethodInvoke>
                <InnerMethodInvoke>null;scanClassesForDGMMethods;[methods, staticExtClasses, true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;scanClassesForDGMMethods;[methods, instanceExtClasses, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>scanClassesForDGMMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>accumulator</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allClasses</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGStringOrGStringStringLUB</MethodName>
            <MethodComment>/** 
 * @return true if the class node is either a GString or the LUB of String and GString.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isParameterizedWithGStringOrGStringString</MethodName>
            <MethodComment>/** 
 * @param node the node to be tested
 * @return true if the node is using generics types and one of those types is a gstring or string/gstring lub
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isParameterizedWithString</MethodName>
            <MethodComment>/** 
 * @param node the node to be tested
 * @return true if the node is using generics types and one of those types is a string
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>missesGenericsTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [cnTypes=cn.getGenericsTypes()]</InnerVar>
                <InnerVar>GenericsType[] [rnTypes=cn.redirect().getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>evaluateExpression</MethodName>
            <MethodComment>/** 
 * A helper method that can be used to evaluate expressions as found in annotation parameters. For example, it will evaluate a constant, be it referenced directly as an integer or as a reference to a field. If this method throws an exception, then the expression cannot be evaluated on its own.
 * @param expr the expression to be evaluated
 * @param config the compiler configuration
 * @return the result of the expression
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>config</ParamName>
                    <ParamType>CompilerConfiguration</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [className="Expression$" + UUID.randomUUID().toString().replace('-','$')]</InnerVar>
                <InnerVar>ClassNode [node=new ClassNode(className,Opcodes.ACC_PUBLIC,ClassHelper.OBJECT_TYPE)]</InnerVar>
                <InnerVar>ReturnStatement [code=new ReturnStatement(expr)]</InnerVar>
                <InnerVar>CompilerConfiguration [copyConf=new CompilerConfiguration(config)]</InnerVar>
                <InnerVar>CompilationUnit [cu=new CompilationUnit(copyConf)]</InnerVar>
                <InnerVar>List&lt;GroovyClass&gt; [classes=(List&lt;GroovyClass&gt;)cu.getClasses()]</InnerVar>
                <InnerVar>Class [aClass=cu.getClassLoader().defineClass(className,classes.get(0).getBytes())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>node;addMethod;[new MethodNode("eval",Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC,ClassHelper.OBJECT_TYPE,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,code)]</InnerMethodInvoke>
                <InnerMethodInvoke>cu;addClassNode;[node]</InnerMethodInvoke>
                <InnerMethodInvoke>cu;compile;[Phases.CLASS_GENERATION]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAllInterfaces</MethodName>
            <MethodComment>/** 
 * Collects all interfaces of a class node, including those defined by the super class.
 * @param node a class for which we want to retrieve all interfaces
 * @return a set of interfaces implemented by this class node
 */
</MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashSet&lt;ClassNode&gt; [result=new HashSet&lt;ClassNode&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;collectAllInterfaces;[node, result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAllInterfaces</MethodName>
            <MethodComment>/** 
 * Collects all interfaces of a class node, including those defined by the super class.
 * @param node a class for which we want to retrieve all interfaces
 * @param out the set where to collect interfaces
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Set&lt;ClassNode&gt; [allInterfaces=node.getAllInterfaces()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;addAll;[allInterfaces]</InnerMethodInvoke>
                <InnerMethodInvoke>null;collectAllInterfaces;[node.getSuperClass(), out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClassClassNodeWrappingConcreteType</MethodName>
            <MethodComment>/** 
 * Returns true if the class node represents a the class node for the Class class and if the parametrized type is a neither a placeholder or a wildcard. For example, the class node Class&amp;lt;Foo&amp;gt; where Foo is a class would return true, but the class node for Class&amp;lt;?&amp;gt; would return false.
 * @param classNode a class node to be tested
 * @return true if it is the class node for Class and its generic type is a real class
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>classNode</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [genericsTypes=classNode.getGenericsTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findSetters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cn</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>setterName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>voidOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MethodNode&gt; [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTraitSelf</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vexp</ParamName>
                    <ParamType>VariableExpression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>