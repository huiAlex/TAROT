<Class>
    <Id>91</Id>
    <Package>groovy.transform</Package>
    <ClassName>AnnotationCollector</ClassName>
    <ClassComment>AnnotationCollector  /** 
 * The AnnotationCollector can be used to define aliases for groups of  annotations. The Alias needs to be a class or annotation annotated with  AnnotationCollector, otherwise nothing is required. The alias will be  replaced on the AST level and will never appear in later. Any members of the  class or annotation will be ignored, but could be used by a custom processor. Annotation arguments are mapped to the aliased annotations if existing. Should the default processor not be able to map one of the arguments and error will be given. Is this not wished or if you want a  different mapping a custom processor has to be used. There are two ways of  using the alias. The first way is by providing the annotations as list/array: &lt;pre&gt; import groovy.transform. &amp;#64;AnnotationCollector([ToString, EqualsAndHashCode, Immutable]) &amp;#64;interface Alias {} &amp;#64;Alias(excludes=["a"]) class Foo { Integer a, b } assert Foo.class.annotations.size()==3  assert new Foo(1,2).toString() == "Foo(2)" &lt;/pre&gt; In the example above we have Alias as the alias annotation and an argument excludes which will be mapped to ToString and EqualsAndHashCode. Immutable  doesn't have excludes, thus nothing will be done there.&lt;br&gt; The other way is to add annotations to the alias: &lt;pre&gt; import groovy.transform. &amp;#64;ToString(excludes=["a"]) &amp;#64;EqualsAndHashCode &amp;#64;Immutable &amp;#64;AnnotationCollector &amp;#64;interface Alias {} &amp;#64;Alias class Foo { Integer a, b } assert Foo.class.annotations.size()==3 assert new Foo(1,2).toString() == "Foo(2)" &lt;/pre&gt; In the example above we have again Alias as the alias annotation, but this time the argument is part of the alias. Instead of mapping excludes to ToString as well as EqualsAndHashCode, only ToString will have the excludes. Again the alias can have an argument excludes, which would overwrite the  excludes given in from the definition and be mapped to ToString as well as EqualsAndHashCode. If both ways are combined, then the list overwrites annotation usage. NOTE: The aliasing does not support aliasing of aliased annotations. 
 * @author &lt;a href="mailto:blackdrag@gmx.org"&gt;Jochen "blackdrag" Theodorou&lt;/a&gt;
 * @see org.codehaus.groovy.transform.AnnotationCollectorTransform
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>