<Class>
    <Id>429</Id>
    <Package>groovy.transform</Package>
    <ClassName>Canonical</ClassName>
    <ClassComment>Canonical  /** 
 * Class annotation used to assist in the creation of mutable classes. &lt;p&gt; It allows you to write classes in this shortened form: &lt;pre&gt; {@code @Canonical} class Customer {String first, last int age Date since Collection favItems = ['Food'] def object  } def d = new Date() def anyObject = new Object() def c1 = new Customer(first:'Tom', last:'Jones', age:21, since:d, favItems:['Books', 'Games'], object: anyObject) def c2 = new Customer('Tom', 'Jones', 21, d, ['Books', 'Games'], anyObject) assert c1 == c2 &lt;/pre&gt; You don't need to provide all arguments in constructor calls. If using named parameters, any property names not referenced will be given their default value (as per Java's default unless an explicit initialization constant is provided when defining the property). If using a tuple constructor, parameters are supplied in the order in which the properties are defined. Supplied parameters fill the tuple from the left. Any parameters missing on the right are given their default value. &lt;pre&gt; def c3 = new Customer(last: 'Jones', age: 21) def c4 = new Customer('Tom', 'Jones') assert null == c3.since assert 0 == c4.age assert c3.favItems == ['Food'] &amp;&amp; c4.favItems == ['Food'] &lt;/pre&gt; The  {@code @Canonical} annotation instructs the compiler to execute anAST transformation which adds positional constructors, equals, hashCode and a pretty print toString to your class. There are additional annotations if you only need some of the functionality:  {@code @EqualsAndHashCode}, {@code @ToString} and {@code @TupleConstructor}. In addition, you can add one of the other annotations if you need to further customize the behavior of the AST transformation. &lt;p&gt; A class created in this way has the following characteristics: &lt;ul&gt; &lt;li&gt;A no-arg constructor is provided which allows you to set properties by name using Groovy's normal bean conventions. &lt;li&gt;Tuple-style constructors are provided which allow you to set properties in the same order as they are defined. &lt;li&gt;Default  {@code equals},  {@code hashCode} and {@code toString} methods are provided based on the property values.Though not normally required, you may write your own implementations of these methods. For  {@code equals} and {@code hashCode}, if you do write your own method, it is up to you to obey the general contract for  {@code equals} methods and supplya corresponding matching  {@code hashCode} method.If you do provide one of these methods explicitly, the default implementation will be made available in a private "underscore" variant which you can call. E.g., you could provide a (not very elegant) multi-line formatted {@code toString} method for {@code Customer} above as follows:&lt;pre&gt; String toString() { _toString().replaceAll(/\(/, '(\n\t').replaceAll(/\)/, '\n)').replaceAll(/, /, '\n\t') } &lt;/pre&gt; If an "underscore" version of the respective method already exists, then no default implementation is provided. &lt;/ul&gt; &lt;p&gt; If you want similar functionality to what this annotation provides but also require immutability, see the {@code @}{@link Immutable} annotation.&lt;p&gt; Limitations: &lt;ul&gt; &lt;li&gt;If you explicitly add your own constructors, then the transformation will not add any other constructor to the class&lt;/li&gt; &lt;li&gt;Groovy's normal map-style naming conventions will not be available if the first property has type  {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property&lt;/li&gt;&lt;/ul&gt;
 * @author Paulo Poiati
 * @author Paul King
 * @see groovy.transform.EqualsAndHashCode
 * @see groovy.transform.ToString
 * @see groovy.transform.TupleConstructor
 * @see groovy.transform.Immutable
 * @since 1.8.0
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>