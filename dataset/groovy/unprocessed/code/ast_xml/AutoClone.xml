<Class>
    <Id>536</Id>
    <Package>groovy.transform</Package>
    <ClassName>AutoClone</ClassName>
    <ClassComment>AutoClone  /** 
 * Class annotation used to assist in the creation of  {@code Cloneable} classes.The  {@code @AutoClone} annotation instructs the compiler to execute anAST transformation which adds a public  {@code clone()} method and adds{@code Cloneable} to the list of interfaces which the class implements.&lt;p&gt; Because the JVM doesn't have a one-size fits all cloning strategy, several customizations exist for the cloning implementation. By default, the  {@code clone()}method will call  {@code super.clone()} before calling {@code clone()} on each{@code Cloneable} property of the class.&lt;p&gt; Example usage: &lt;pre&gt; import groovy.transform.AutoClone {@code @AutoClone}class Person { String first, last List favItems Date since } &lt;/pre&gt; Which will create a class equivalent to the following: &lt;pre&gt; class Person implements Cloneable { ... public Person clone() throws CloneNotSupportedException { Person result = (Person) super.clone() result.favItems = favItems instanceof Cloneable ? (List) favItems.clone() : favItems result.since = (Date) since.clone() return result } ... } &lt;/pre&gt; Which can be used as follows: &lt;pre&gt; def p = new Person(first:'John', last:'Smith', favItems:['ipod', 'shiraz'], since:new Date()) def p2 = p.clone() assert p instanceof Cloneable assert p.favItems instanceof Cloneable assert p.since instanceof Cloneable assert !(p.first instanceof Cloneable) assert !p.is(p2) assert !p.favItems.is(p2.favItems) assert !p.since.is(p2.since) assert p.first.is(p2.first) &lt;/pre&gt; In the above example,  {@code super.clone()} is called which in this casecalls  {@code clone()} from {@code java.lang.Object}. This does a bit-wise copy of all the properties (references and primitive values). Properties like  {@code first} has type {@code String} which is not {@code Cloneable}so it is left as the bit-wise copy. Both  {@code Date} and {@code ArrayList}are  {@code Cloneable} so the {@code clone()} method on each of those propertieswill be called. For the list, a shallow copy is made during its  {@code clone()} method.&lt;p&gt; If your classes require deep cloning, it is up to you to provide the appropriate deep cloning logic in the respective  {@code clone()} method for your class.&lt;p&gt; If one of your properties contains an object that doesn't support cloning or attempts deep copying of a data structure containing an object that doesn't support cloning, then a  {@code CloneNotSupportedException} may occurat runtime. &lt;p&gt; Another popular cloning strategy is known as the copy constructor pattern. If any of your fields are  {@code final} and {@code Cloneable} you should set{@code style=COPY_CONSTRUCTOR} which will then use the copy constructor pattern.Here is an example making use of the copy constructor pattern: &lt;pre&gt; import groovy.transform.AutoClone import static groovy.transform.AutoCloneStyle. {@code @AutoClone(style=COPY_CONSTRUCTOR)}class Person { final String first, last final Date birthday } {@code @AutoClone(style=COPY_CONSTRUCTOR)}class Customer extends Person { final int numPurchases final List favItems } &lt;/pre&gt; Which will create classes equivalent to the following: &lt;pre&gt; class Person implements Cloneable { ... protected Person(Person other) throws CloneNotSupportedException { first = other.first last = other.last birthday = (Date) other.birthday.clone() } public Person clone() throws CloneNotSupportedException { return new Person(this) } ... } class Customer extends Person { ... protected Customer(Customer other) throws CloneNotSupportedException { super(other) numPurchases = other.numPurchases favItems = other.favItems instanceof Cloneable ? (List) other.favItems.clone() : other.favItems } public Customer clone() throws CloneNotSupportedException { return new Customer(this) } ... } &lt;/pre&gt; If you use this style on a child class, the parent class must also have a copy constructor (created using this annotation or by hand). This approach can be slightly slower than the traditional cloning approach but the  {@code Cloneable} fields of your class can be final. When using the copy constructor style,you can provide your own custom constructor by hand if you wish. If you do so, it is up to you to correctly copy, clone or deep clone the properties of your class. &lt;p&gt; As a variation of the last two styles, if you set  {@code style=SIMPLE}then the no-arg constructor will be called followed by setting the individual properties (and/or fields) calling  {@code clone()} if theproperty/field implements  {@code Cloneable}. Here is an example: &lt;pre&gt; import groovy.transform.AutoClone import static groovy.transform.AutoCloneStyle. {@code @AutoClone(style=SIMPLE)}class Person { final String first, last final Date birthday } {@code @AutoClone(style=SIMPLE)}class Customer { final List favItems } &lt;/pre&gt; Which will create classes equivalent to the following: &lt;pre&gt; class Person implements Cloneable { ... public Person clone() throws CloneNotSupportedException { def result = new Person() copyOrCloneMembers(result) return result } protected void copyOrCloneMembers(Person other) { other.first = first other.last = last other.birthday = (Date) birthday.clone() } ... } class Customer extends Person { ... public Customer clone() throws CloneNotSupportedException { def result = new Customer() copyOrCloneMembers(result) return result } protected void copyOrCloneMembers(Customer other) { super.copyOrCloneMembers(other) other.favItems = favItems instanceof Cloneable ? (List) favItems.clone() : favItems } ... } &lt;/pre&gt; You would typically use this style only for base classes where you didn't want the normal  {@code Object} {@code clone()} method to be called andyou would typically need to use the  {@code SIMPLE} style for any child classes.&lt;p&gt; As a final example, if your class already implements the  {@code Serializable}or  {@code Externalizable} interface, you can choose the following cloning style:&lt;pre&gt; {@code @AutoClone(style=SERIALIZATION)}class Person implements Serializable { String first, last Date birthday } &lt;/pre&gt; which outputs a class with the following form: &lt;pre&gt; class Person implements Cloneable, Serializable { ... Person clone() throws CloneNotSupportedException { def baos = new ByteArrayOutputStream() baos.withObjectOutputStream{ it.writeObject(this) } def bais = new ByteArrayInputStream(baos.toByteArray()) bais.withObjectInputStream(getClass().classLoader){ (Person) it.readObject() } } ... } &lt;/pre&gt; This will output an error if your class doesn't implement one of {@code Serializable} or {@code Externalizable}, will typically be significantly slower than the other approaches, also doesn't allow fields to be final, will take up more memory as even immutable classes like String will be cloned but does have the advantage that it performs deep cloning automatically. &lt;p&gt; Further references on cloning: &lt;ul&gt; &lt;li&gt;&lt;a href="http://www.codeguru.com/java/tij/tij0128.shtml"&gt;http://www.codeguru.com/java/tij/tij0128.shtml&lt;/a&gt; &lt;li&gt;&lt;a href="http://www.artima.com/objectsandjava/webuscript/ClonCollInner1.html"&gt;http://www.artima.com/objectsandjava/webuscript/ClonCollInner1.html&lt;/a&gt; &lt;li&gt;&lt;a href="http://courses.dce.harvard.edu/~cscie160/JDCTipsCloning"&gt;http://courses.dce.harvard.edu/~cscie160/JDCTipsCloning&lt;/a&gt; &lt;li&gt;&lt;a href="http://www.agiledeveloper.com/articles/cloning072002.htm"&gt;http://www.agiledeveloper.com/articles/cloning072002.htm&lt;/a&gt; &lt;/ul&gt;
 * @author Paul King
 * @see AutoCloneStyle
 * @see ExternalizeMethods
 * @since 1.8.0
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>