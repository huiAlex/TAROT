<Class>
    <Id>212</Id>
    <Package>org.codehaus.groovy.classgen.asm</Package>
    <ClassName>CompileStack</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Opcodes</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>CompileStack  /** 
 * This class is a helper for AsmClassGenerator. It manages different aspects of the code of a code block like handling labels, defining variables, and scopes. After a MethodNode is visited clear should be called, for initialization the method init should be used. &lt;p&gt; Some Notes: &lt;ul&gt; &lt;li&gt; every push method will require a later pop call &lt;li&gt; method parameters may define a category 2 variable, so don't ignore the type stored in the variable object &lt;li&gt; the index of the variable may not be as assumed when the variable is a parameter of a method because the parameter may be used in a closure, so don't ignore the stored variable index &lt;li&gt; the names of temporary variables can be ignored. The names are only used for debugging and do not conflict with each other or normal variables. For accessing, the index of the variable must be used. &lt;li&gt; never mix temporary and normal variables by changes to this class. While the name is very important for a normal variable, it is only a helper construct for temporary variables. That means for example a name for a temporary variable can be used multiple times without conflict. So mixing them both may lead to the problem that a normal or temporary variable is hidden or even removed.  That must not happen! &lt;/ul&gt;
 * @see org.codehaus.groovy.classgen.AsmClassGenerator
 * @author Jochen Theodorou
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>clear</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>scope</FieldName>
            <FieldType>VariableScope</FieldType>
        </Field>
        <Field>
            <FieldName>continueLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>breakLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>stackVariables</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>currentVariableIndex</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextVariableIndex</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>temporaryVariables</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>usedVariables</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>superBlockNamedLabels</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>currentBlockNamedLabels</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>finallyBlocks</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>finallyBlocks</FieldName>
            <FieldType>BlockRecorder</FieldType>
        </Field>
        <Field>
            <FieldName>visitedBlocks</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>visitedBlocks</FieldName>
            <FieldType>BlockRecorder</FieldType>
        </Field>
        <Field>
            <FieldName>thisStartLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>thisEndLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>stateStack</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>implicitThisStack</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>implicitThisStack</FieldName>
            <FieldType>Boolean</FieldType>
        </Field>
        <Field>
            <FieldName>lhsStack</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>lhsStack</FieldName>
            <FieldType>Boolean</FieldType>
        </Field>
        <Field>
            <FieldName>localVariableOffset</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>namedLoopBreakLabel</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>namedLoopContinueLabel</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>className</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>typedExceptions</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>typedExceptions</FieldName>
            <FieldType>ExceptionTableEntry</FieldType>
        </Field>
        <Field>
            <FieldName>untypedExceptions</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>untypedExceptions</FieldName>
            <FieldType>ExceptionTableEntry</FieldType>
        </Field>
        <Field>
            <FieldName>lhs</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>implicitThis</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>controller</FieldName>
            <FieldType>WriterController</FieldType>
        </Field>
        <Field>
            <FieldName>inSpecialConstructallCall</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>start</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>end</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>isEmpty</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>excludedStatement</FieldName>
            <FieldType>Runnable</FieldType>
        </Field>
        <Field>
            <FieldName>ranges</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>ranges</FieldName>
            <FieldType>LabelRange</FieldType>
        </Field>
        <Field>
            <FieldName>start</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>end</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>goal</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>sig</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>scope</FieldName>
            <FieldType>VariableScope</FieldType>
        </Field>
        <Field>
            <FieldName>continueLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>breakLabel</FieldName>
            <FieldType>Label</FieldType>
        </Field>
        <Field>
            <FieldName>stackVariables</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>currentBlockNamedLabels</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>finallyBlocks</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>finallyBlocks</FieldName>
            <FieldType>BlockRecorder</FieldType>
        </Field>
        <Field>
            <FieldName>inSpecialConstructallCall</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>excludedStatement</ParamName>
                    <ParamType>Runnable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startRange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LabelRange [range=new LabelRange()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ranges;add;[range]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeRange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StateStackElement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CompileStack</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>wc</ParamName>
                    <ParamType>WriterController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stateStack;add;[new StateStackElement()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StateStackElement [element=(StateStackElement)stateStack.removeLast()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContinueLabel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBreakLabel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeVar</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tempIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BytecodeVariable [head=(BytecodeVariable)temporaryVariables.removeFirst()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEndLabels</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Label [endLabel=new Label()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>controller.getMethodVisitor();visitLabel;[endLabel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setEndLabels;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;popState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScope</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>VariableScope</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineTemporaryVariable</MethodName>
            <MethodComment>/** 
 * creates a temporary variable.
 * @param var defines type and name
 * @param store defines if the toplevel argument of the stack should be stored
 * @return the index used for this temporary variable
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>var</ParamName>
                    <ParamType>org.codehaus.groovy.ast.Variable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>store</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVariable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BytecodeVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>variableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVariable</MethodName>
            <MethodComment>/** 
 * Returns a normal variable. &lt;p&gt; If &lt;code&gt;mustExist&lt;/code&gt; is true and the normal variable doesn't exist, then this method will throw a GroovyBugError. It is not the intention of this method to let this happen! And the exception should not be used for flow control - it is just acting as an assertion. If the exception is thrown then it indicates a bug in the class using CompileStack. This method can also not be used to return a temporary variable. Temporary variables are not normal variables.
 * @param variableName name of the variable
 * @param mustExist    throw exception if variable does not exist
 * @return the normal variable or null if not found (and &lt;code&gt;mustExist&lt;/code&gt; not true)
 */
</MethodComment>
            <ReturnType>BytecodeVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>variableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mustExist</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BytecodeVariable [v=(BytecodeVariable)stackVariables.get(variableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineTemporaryVariable</MethodName>
            <MethodComment>/** 
 * creates a temporary variable.
 * @param name defines type and name
 * @param store defines if the top-level argument of the stack should be stored
 * @return the index used for this temporary variable
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>store</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineTemporaryVariable</MethodName>
            <MethodComment>/** 
 * creates a temporary variable.
 * @param name defines the name
 * @param node defines the node
 * @param store defines if the top-level argument of the stack should be stored
 * @return the index used for this temporary variable
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>store</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BytecodeVariable [answer=defineVar(name,node,false,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>temporaryVariables;addFirst;[answer]</InnerMethodInvoke>
                <InnerMethodInvoke>usedVariables;removeLast;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetVariableIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>temporaryVariables;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Clears the state of the class. This method should be called after a MethodNode is visited. Note that a call to init will fail if clear is not called before
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MethodVisitor [mv=controller.getMethodVisitor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pop;[]</InnerMethodInvoke>
                <InnerMethodInvoke>typedExceptions;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>untypedExceptions;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stackVariables;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>usedVariables;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>finallyBlocks;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;resetVariableIndex;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>superBlockNamedLabels;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>currentBlockNamedLabels;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>namedLoopBreakLabel;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>namedLoopContinueLabel;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addExceptionBlock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>goal</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sig</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExceptionTableEntry [ep=new ExceptionTableEntry()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * initializes this class for a MethodNode. This method will automatically define variables for the method parameters and will create references if needed.  The created variables can be accessed by calling getVariable().
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>el</ParamName>
                    <ParamType>VariableScope</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushVariableScope;[el]</InnerMethodInvoke>
                <InnerMethodInvoke>null;defineMethodVariables;[parameters, el.isInStaticContext()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushVariableScope</MethodName>
            <MethodComment>/** 
 * Causes the state-stack to add an element and sets the given scope as new current variable scope. Creates a element for the state stack so pop has to be called later
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>el</ParamName>
                    <ParamType>VariableScope</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>superBlockNamedLabels;putAll;[currentBlockNamedLabels]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushLoop</MethodName>
            <MethodComment>/** 
 * Should be called when descending into a loop that defines also a scope. Calls pushVariableScope and prepares labels for a loop structure. Creates a element for the state stack so pop has to be called later, TODO: @Deprecate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>el</ParamName>
                    <ParamType>VariableScope</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>labelName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushVariableScope;[el]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushLoop</MethodName>
            <MethodComment>/** 
 * Should be called when descending into a loop that defines also a scope. Calls pushVariableScope and prepares labels for a loop structure. Creates a element for the state stack so pop has to be called later
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>el</ParamName>
                    <ParamType>VariableScope</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>labelNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushVariableScope;[el]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initLoopLabels</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>labelName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>namedLoopBreakLabel;put;[labelName, breakLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>namedLoopContinueLabel;put;[labelName, continueLabel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushLoop</MethodName>
            <MethodComment>/** 
 * Should be called when descending into a loop that does not define a scope. Creates a element for the state stack so pop has to be called later, TODO: @Deprecate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>labelName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initLoopLabels;[labelName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushLoop</MethodName>
            <MethodComment>/** 
 * Should be called when descending into a loop that does not define a scope. Creates a element for the state stack so pop has to be called later
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>labelNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNamedBreakLabel</MethodName>
            <MethodComment>/** 
 * Used for &lt;code&gt;break foo&lt;/code&gt; inside a loop to end the execution of the marked loop. This method will return the break label of the loop if there is one found for the name. If not, the current break label is returned.
 */
</MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [label=getBreakLabel()]</InnerVar>
                <InnerVar>Label [endLabel=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNamedContinueLabel</MethodName>
            <MethodComment>/** 
 * Used for &lt;code&gt;continue foo&lt;/code&gt; inside a loop to continue the execution of the marked loop. This method will return the break label of the loop if there is one found for the name. If not, getLabel is used.
 */
</MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [label=getLabel(name)]</InnerVar>
                <InnerVar>Label [endLabel=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushSwitch</MethodName>
            <MethodComment>/** 
 * Creates a new break label and a element for the state stack so pop has to be called later
 */
</MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushBooleanExpression</MethodName>
            <MethodComment>/** 
 * because a boolean Expression may not be evaluated completely it is important to keep the registers clean
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineVar</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BytecodeVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>holder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useReferenceDirectly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [prevCurrent=currentVariableIndex]</InnerVar>
                <InnerVar>int [index=currentVariableIndex]</InnerVar>
                <InnerVar>BytecodeVariable [answer=new BytecodeVariable(index,type,name,prevCurrent)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;makeNextVariableID;[type, useReferenceDirectly]</InnerMethodInvoke>
                <InnerMethodInvoke>usedVariables;add;[answer]</InnerMethodInvoke>
                <InnerMethodInvoke>answer;setHolder;[holder]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeLocalVariablesOffset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>paras</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInStaticContext</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetVariableIndex;[isInStaticContext]</InnerMethodInvoke>
                <InnerMethodInvoke>null;resetVariableIndex;[isInStaticContext]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineMethodVariables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>paras</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInStaticContext</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [startLabel=new Label()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>controller.getMethodVisitor();visitLabel;[startLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>null;makeLocalVariablesOffset;[paras, isInStaticContext]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createReference</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reference</ParamName>
                    <ParamType>BytecodeVariable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodVisitor [mv=controller.getMethodVisitor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mv;visitTypeInsn;[NEW, "groovy/lang/Reference"]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitInsn;[DUP_X1]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitInsn;[SWAP]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitMethodInsn;[INVOKESPECIAL, "groovy/lang/Reference", "&lt;init&gt;", "(Ljava/lang/Object;)V", false]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitVarInsn;[ASTORE, reference.getIndex()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushInitValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineVariable</MethodName>
            <MethodComment>/** 
 * Defines a new Variable using an AST variable.
 * @param initFromStack if true the last element of thestack will be used to initialize the new variable. If false null will be used.
 */
</MethodComment>
            <ReturnType>BytecodeVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Variable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initFromStack</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defineVariable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BytecodeVariable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Variable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>variableType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initFromStack</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [name=v.getName()]</InnerVar>
                <InnerVar>BytecodeVariable [answer=defineVar(name,variableType,v.isClosureSharedVariable(),v.isClosureSharedVariable())]</InnerVar>
                <InnerVar>MethodVisitor [mv=controller.getMethodVisitor()]</InnerVar>
                <InnerVar>Label [startLabel=new Label()]</InnerVar>
                <InnerVar>ClassNode [type=answer.getType().redirect()]</InnerVar>
                <InnerVar>OperandStack [operandStack=controller.getOperandStack()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stackVariables;put;[name, answer]</InnerMethodInvoke>
                <InnerMethodInvoke>answer;setStartLabel;[startLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>operandStack;push;[answer.getType()]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitLabel;[startLabel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsVariable</MethodName>
            <MethodComment>/** 
 * @param name the name of the variable of interest
 * @return true if a variable is already defined
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeNextVariableID</MethodName>
            <MethodComment>/** 
 * Calculates the index of the next free register stores it and sets the current variable index to the old value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useReferenceDirectly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLabel</MethodName>
            <MethodComment>/** 
 * Returns the label for the given name
 */
</MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [l=(Label)superBlockNamedLabels.get(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createLocalLabel</MethodName>
            <MethodComment>/** 
 * creates a new named label
 */
</MethodComment>
            <ReturnType>Label</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [l=(Label)currentBlockNamedLabels.get(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyFinallyBlocks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>label</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isBreakLabel</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StateStackElement [result=null]</InnerVar>
                <InnerVar>List&lt;BlockRecorder&gt; [blocksToRemove]</InnerVar>
                <InnerVar>List&lt;BlockRecorder&gt; [blocks=new LinkedList&lt;BlockRecorder&gt;(finallyBlocks)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>blocks;removeAll;[blocksToRemove]</InnerMethodInvoke>
                <InnerMethodInvoke>null;applyBlockRecorder;[blocks]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyBlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>blocks</ParamName>
                    <ParamType>BlockRecorder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodVisitor [mv=controller.getMethodVisitor()]</InnerVar>
                <InnerVar>Label [end=new Label()]</InnerVar>
                <InnerVar>Label [newStart=new Label()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mv;visitInsn;[NOP]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitLabel;[end]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitInsn;[NOP]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitLabel;[newStart]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyBlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;applyBlockRecorder;[finallyBlocks]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasBlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushBlockRecorder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recorder</ParamName>
                    <ParamType>BlockRecorder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>finallyBlocks;addFirst;[recorder]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushBlockRecorderVisit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>finallyBlock</ParamName>
                    <ParamType>BlockRecorder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>visitedBlocks;add;[finallyBlock]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popBlockRecorderVisit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>finallyBlock</ParamName>
                    <ParamType>BlockRecorder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>visitedBlocks;remove;[finallyBlock]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExceptionTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>block</ParamName>
                    <ParamType>BlockRecorder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>goal</ParamName>
                    <ParamType>Label</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sig</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodVisitor [mv=controller.getMethodVisitor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLHS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushLHS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lhs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lhsStack;add;[lhs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popLHS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lhsStack;removeLast;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushImplicitThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implicitThis</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>implicitThisStack;add;[implicitThis]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isImplicitThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popImplicitThis</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>implicitThisStack;removeLast;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInSpecialConstructorCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushInSpecialConstructorCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;pushState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>