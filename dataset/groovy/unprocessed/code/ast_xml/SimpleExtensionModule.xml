<Class>
    <Id>992</Id>
    <Package>org.codehaus.groovy.runtime.m12n</Package>
    <ClassName>SimpleExtensionModule</ClassName>
    <SuperClass>ExtensionModule</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SimpleExtensionModule  /** 
 * An extension module which provides extension methods using a  {@link org.codehaus.groovy.runtime.DefaultGroovyMethods}-like implementation, that is to say using static methods defined in an "extension class". &lt;p&gt; For commodity, multiple extension classes may be defined in a single module, including classes used to define new static methods. &lt;p&gt; Modules are required to implement the  {@link #getInstanceMethodsExtensionClasses} for classes defining new instancemethods, and  {@link #getStaticMethodsExtensionClasses()} for classes defining static methods.&lt;p&gt; For example, to define a module adding methods to the  {@link String} class, you can write a helper class:&lt;pre&gt; class StringExtension { public static int count(String self, char c) { int result = 0; for (int i=0;i&amp;lt;self.length(); i++) { if (self.charAt(i)==c) result++; } return result; } } &lt;/pre&gt; &lt;p&gt; This class defines a single static method taking the string instance as first argument, allowing to define a new instance method on the String class: &lt;pre&gt;String#count(char c)&lt;/pre&gt;. &lt;p&gt; To define a new static method on a class, as the static modifier is already used for instance methods, you must use another helper class, for example: &lt;p&gt; &lt;pre&gt; class StaticStringExtension { public static void foo(String self) { System.out.println("foo"); } } &lt;/pre&gt; &lt;p&gt; The first argument of the method is only used to tell the class for which we add a static method. You can now define an extension module: &lt;p&gt; &lt;pre&gt; class MyStringModule extends SimpleExtensionModule { // ... public List&amp;lt;Class&amp;gt; getInstanceMethodsExtensionClasses() { return Collections.singletonList(StringExtension.class); } public List&amp;lt;Class&amp;gt; getStaticMethodsExtensionClasses() { return Collections.singletonList(StaticStringExtension.class); } } &lt;/pre&gt;
 * @author Cedric Champeau
 * @since 2.0.0
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SimpleExtensionModule</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>moduleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>moduleVersion</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaMethod</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [metaMethods=new LinkedList&lt;MetaMethod&gt;()]</InnerVar>
                <InnerVar>List&lt;Class&gt; [extensionClasses=getInstanceMethodsExtensionClasses()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createMetaMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>extensionClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>metaMethods</ParamName>
                    <ParamType>MetaMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CachedClass [cachedClass=ReflectionCache.getCachedClass(extensionClass)]</InnerVar>
                <InnerVar>CachedMethod[] [methods=cachedClass.getMethods()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstanceMethodsExtensionClasses</MethodName>
            <MethodComment>/** 
 * @return the list of classes defining new instance methods.
 */
</MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStaticMethodsExtensionClasses</MethodName>
            <MethodComment>/** 
 * @return the list of classes defining new static methods.
 */
</MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>