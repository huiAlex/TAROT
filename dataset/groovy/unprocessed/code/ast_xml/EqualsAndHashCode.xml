<Class>
    <Id>983</Id>
    <Package>groovy.transform</Package>
    <ClassName>EqualsAndHashCode</ClassName>
    <ClassComment>EqualsAndHashCode  /** 
 * Class annotation used to assist in creating appropriate  {@code equals()} and {@code hashCode()} methods.&lt;p&gt; It allows you to write classes in this shortened form: &lt;pre&gt; import groovy.transform.EqualsAndHashCode {@code @EqualsAndHashCode}class Person { String first, last int age } def p1 = new Person(first:'John', last:'Smith', age:21) def p2 = new Person(first:'John', last:'Smith', age:21) assert p1 == p2 def map = [:] map[p1] = 45 assert map[p2] == 45 &lt;/pre&gt; The  {@code @EqualsAndHashCode} annotation instructs the compiler to execute anAST transformation which adds the necessary equals and hashCode methods to the class. &lt;p&gt; The  {@code hashCode()} method is calculated using Groovy's {@code HashCodeHelper} classwhich implements an algorithm similar to the one outlined in the book &lt;em&gt;Effective Java&lt;/em&gt;. &lt;p&gt; The  {@code equals()} method compares the values of the individual properties (and optionally fields)of the class.  It can also optionally call equals on the super class. Two different equals method implementations are supported both of which support the equals contract outlined in the javadoc for &lt;code&gt;java.lang.Object&lt;/code&gt; &lt;p&gt; To illustrate the 'canEqual' implementation style (see http://www.artima.com/lejava/articles/equality.html for further details), consider this class: &lt;pre&gt; {@code @EqualsAndHashCode}class IntPair { int x, y } &lt;/pre&gt; The generated &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; methods will be something like below: &lt;pre&gt; public boolean equals(java.lang.Object other) if (other == null) return false if (this.is(other)) return true if (!(other instanceof IntPair)) return false if (!other.canEqual(this)) return false if (x != other.x) return false if (y != other.y) return false return true } public boolean canEqual(java.lang.Object other) { return other instanceof IntPair } &lt;/pre&gt; If no further options are specified, this is the default style for  {@code @Canonical} and{@code @EqualsAndHashCode} annotated classes. The advantage of this style is that it allows inheritanceto be used in limited cases where its purpose is for overriding implementation details rather than creating a derived type with different behavior. This is useful when using JPA Proxies for example or as shown in the following examples: &lt;pre&gt; {@code @Canonical} class IntPair { int x, y }def p1 = new IntPair(1, 2) // overridden getter but deemed an IntPair as far as domain is concerned def p2 = new IntPair(1, 1) { int getY() { 2 } } // additional helper method added through inheritance but // deemed an IntPair as far as our domain is concerned {@code @InheritConstructors} class IntPairWithSum extends IntPair {def sum() { x + y } } def p3 = new IntPairWithSum(1, 2) assert p1 == p2 &amp;&amp; p2 == p1 assert p1 == p3 &amp;&amp; p3 == p1 assert p3 == p2 &amp;&amp; p2 == p3 &lt;/pre&gt; Note that if you create any domain classes which don't have exactly the same contract as &lt;code&gt;IntPair&lt;/code&gt; then you should provide an appropriate &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; method. The easiest way to achieve this would be to use the  {@code @Canonical} or{@code @EqualsAndHashCode} annotations as shown below:&lt;pre&gt; {@code @EqualsAndHashCode}{@code @TupleConstructor(includeSuperProperties=true)}class IntTriple extends IntPair { int z } def t1 = new IntTriple(1, 2, 3) assert p1 != t1 &amp;&amp; p2 != t1 &amp;&amp; t1 != p3 &lt;/pre&gt; The alternative supported style regards any kind of inheritance as creation of a new type and is illustrated in the following example: &lt;pre&gt; {@code @EqualsAndHashCode(useCanEqual=false)}class IntPair { int x, y } &lt;/pre&gt; The generated equals method will be something like below: &lt;pre&gt; public boolean equals(java.lang.Object other) if (other == null) return false if (this.is(other)) return true if (IntPair != other.getClass()) return false if (x != other.x) return false if (y != other.y) return false return true } &lt;/pre&gt; This style is appropriate for final classes (where inheritance is not allowed) which have only &lt;code&gt;java.lang.Object&lt;/code&gt; as a super class. Most  {@code @Immutable} classes fall in to this category. For such classes,there is no need to introduce the &lt;code&gt;canEqual()&lt;/code&gt; method. &lt;p&gt; Note that if you explicitly set &lt;code&gt;useCanEqual=false&lt;/code&gt; for child nodes in a class hierarchy but have it &lt;code&gt;true&lt;/code&gt; for parent nodes and you also have &lt;code&gt;callSuper=true&lt;/code&gt; in the child, then your generated equals methods will not strictly follow the equals contract. &lt;p&gt; Note that when used in the recommended fashion, the two implementations supported adhere to the equals contract. You can provide your own equivalence relationships if you need, e.g. for comparing instances of the &lt;code&gt;IntPair&lt;/code&gt; and &lt;code&gt;IntTriple&lt;/code&gt; classes discussed earlier, you could provide the following method in &lt;code&gt;IntPair&lt;/code&gt;: &lt;pre&gt; boolean hasEqualXY(other) { other.x == getX() &amp;&amp; other.y == getY() } &lt;/pre&gt; Then for the objects defined earlier, the following would be true: &lt;pre&gt; assert p1.hasEqualXY(t1) &amp;&amp; t1.hasEqualXY(p1) assert p2.hasEqualXY(t1) &amp;&amp; t1.hasEqualXY(p2) assert p3.hasEqualXY(t1) &amp;&amp; t1.hasEqualXY(p3) &lt;/pre&gt; There is also support for including or excluding fields/properties by name when constructing the equals and hashCode methods as shown here: &lt;pre&gt; import groovy.transform. {@code @EqualsAndHashCode}(excludes="z") {@code @TupleConstructor}public class Point2D { int x, y, z } assert  new Point2D(1, 1, 1).equals(new Point2D(1, 1, 2)) assert !new Point2D(1, 1, 1).equals(new Point2D(2, 1, 1)) {@code @EqualsAndHashCode}(excludes=["y", "z"]) {@code @TupleConstructor}public class Point2D { int x, y, z } assert  new Point1D(1, 1, 1).equals(new Point1D(1, 1, 2)) assert  new Point1D(1, 1, 1).equals(new Point1D(1, 2, 1)) assert !new Point1D(1, 1, 1).equals(new Point1D(2, 1, 1)) &lt;/pre&gt; &lt;b&gt;Note:&lt;/b&gt;  {@code @EqualsAndHashCode} is a transform to help reduce boilerplatein the common cases. It provides a useful implementation of  {@code equals()}and  {@code hashCode()} but not necessarily the most appropriate orefficient one for every use case. You should write custom versions if your scenario demands it. In particular, if you have mutually-referential classes, the implementations provided may not be suitable and may recurse infinitely (leading to a  {@code StackOverflowError}). In such cases, you need to remove the infinite loop from your data structures or write your own custom methods. If your data structures are self-referencing, the code generated by this transform will try to avoid infinite recursion but the algorithm used may not suit your scenario, so use with caution if you have such structures. A future version of this transform may better handle some additional recursive scenarios.
 * @see org.codehaus.groovy.util.HashCodeHelper
 * @author Paul King
 * @since 1.8.0
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>