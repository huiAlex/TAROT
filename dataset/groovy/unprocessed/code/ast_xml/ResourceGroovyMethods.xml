<Class>
    <Id>1096</Id>
    <Package>org.codehaus.groovy.runtime</Package>
    <ClassName>ResourceGroovyMethods</ClassName>
    <SuperClass>DefaultGroovyMethodsSupport</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ResourceGroovyMethods  /** 
 * This class defines new groovy methods for Readers, Writers, InputStreams and OutputStreams which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; provides a &lt;code&gt;eachLine(Closure c)&lt;/code&gt; method for &lt;code&gt;InputStream&lt;/code&gt;. &lt;p&gt; NOTE: While this class contains many 'public' static methods, it is primarily regarded as an internal class (its internal package name suggests this also). We value backwards compatibility of these methods when used within Groovy but value less backwards compatibility at the Java method call level. I.e. future versions of Groovy may remove or move a method call in this file but would normally aim to keep the method available from within Groovy.
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author Jeremy Rayner
 * @author Sam Pullara
 * @author Rod Cope
 * @author Guillaume Laforge
 * @author John Wilson
 * @author Hein Meling
 * @author Dierk Koenig
 * @author Pilho Kim
 * @author Marc Guillemot
 * @author Russel Winder
 * @author bing ran
 * @author Jochen Theodorou
 * @author Paul King
 * @author Michael Baehr
 * @author Joachim Baumann
 * @author Alex Tkachman
 * @author Ted Naleid
 * @author Brad Long
 * @author Jim Jagielski
 * @author Rodolfo Velasco
 * @author jeremi Joslin
 * @author Hamlet D'Arcy
 * @author Cedric Champeau
 * @author Tim Yates
 * @author Dinko Srkoc
 * @author Sergei Egorov
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Provide the standard Groovy &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;.
 * @param self a file object
 * @return the file's size (length)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>directorySize</MethodName>
            <MethodComment>/** 
 * Calculates directory size as total size of all its files, recursively.
 * @param self a file object
 * @return directory size (length)
 * @since 2.1
 * @throws IOException if File object specified does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long[] [size={0L}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFileRecurse;[self, FileType.FILES, new Closure&lt;Void&gt;(null){
  public void doCall(  Object[] args){
    size[0]+=((File)args[0]).length();
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectOutputStream</MethodName>
            <MethodComment>/** 
 * Create an object output stream for this file.
 * @param file a file
 * @return an object output stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectOutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectOutputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectOutputStream for this file and then pass it to the closure.  This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.OutputStream,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create an object input stream for this file.
 * @param file a file
 * @return an object input stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create an object input stream for this file using the given class loader.
 * @param file        a file
 * @param classLoader the class loader to use when loading the class
 * @return an object input stream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>ObjectInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachObject</MethodName>
            <MethodComment>/** 
 * Iterates through the given file object by object.
 * @param self    a File
 * @param closure a closure
 * @throws IOException            if an IOException occurs.
 * @throws ClassNotFoundException if the class  is not found.
 * @see IOGroovyMethods#eachObject(java.io.ObjectInputStream,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;eachObject;[newObjectInputStream(self), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectInputStream for this file and pass it to the closure. This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withObjectInputStream</MethodName>
            <MethodComment>/** 
 * Create a new ObjectInputStream for this file associated with the given class loader and pass it to the closure. This method ensures the stream is closed after the closure returns.
 * @param file        a File
 * @param classLoader the class loader to use when loading the class
 * @param closure     a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line.  Each line is passed to the given 1 or 2 arg closure.  The file is read using a reader which is closed before this method returns.
 * @param self    a File
 * @param closure a closure (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.File,int,groovy.lang.Closure)
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line.  Each line is passed to the given 1 or 2 arg closure.  The file is read using a reader which is closed before this method returns.
 * @param self    a File
 * @param charset opens the file with a specified charset
 * @param closure a closure (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.io.File,java.lang.String,int,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line.  Each line is passed to the given 1 or 2 arg closure.  The file is read using a reader which is closed before this method returns.
 * @param self      a File
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line.  Each line is passed to the given 1 or 2 arg closure.  The file is read using a reader which is closed before this method returns.
 * @param self      a File
 * @param charset   opens the file with a specified charset
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the lines read from the URL's associated input stream passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param url     a URL to open and read
 * @param closure a closure to apply on each line (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.net.URL,int,groovy.lang.Closure)
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the lines read from the URL's associated input stream passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param url       a URL to open and read
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure to apply on each line (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachLine(java.io.InputStream,int,groovy.lang.Closure)
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the lines read from the URL's associated input stream passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param url     a URL to open and read
 * @param charset opens the stream with a specified charset
 * @param closure a closure to apply on each line (arg 1 is line, optional arg 2 is line number starting at line 1)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see #eachLine(java.net.URL,java.lang.String,int,groovy.lang.Closure)
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the lines read from the URL's associated input stream passing each line to the given 1 or 2 arg closure. The stream is closed before this method returns.
 * @param url       a URL to open and read
 * @param charset   opens the stream with a specified charset
 * @param firstLine the line number value used for the first line (default is 1, set to 0 to start counting from 0)
 * @param closure   a closure to apply on each line (arg 1 is line, optional arg 2 is line number)
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachLine(java.io.Reader,int,groovy.lang.Closure)
 * @since 1.5.7
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstLine</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line, splitting each line using the given regex separator. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the file are closed.
 * @param self    a File
 * @param regex   the delimiting regular expression
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line, splitting each line using the given separator Pattern. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression Pattern. Finally the resources used for processing the file are closed.
 * @param self    a File
 * @param pattern the regular expression Pattern for the delimiter
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line, splitting each line using the given regex separator. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the file are closed.
 * @param self    a File
 * @param regex   the delimiting regular expression
 * @param charset opens the file with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through this file line by line, splitting each line using the given regex separator Pattern. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the file are closed.
 * @param self    a File
 * @param pattern the regular expression Pattern for the delimiter
 * @param charset opens the file with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the input stream associated with this URL line by line, splitting each line using the given regex separator. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the URL are closed.
 * @param self    a URL to open and read
 * @param regex   the delimiting regular expression
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the input stream associated with this URL line by line, splitting each line using the given regex separator Pattern. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the URL are closed.
 * @param self    a URL to open and read
 * @param pattern the regular expression Pattern for the delimiter
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the input stream associated with this URL line by line, splitting each line using the given regex separator. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the URL are closed.
 * @param self    a URL to open and read
 * @param regex   the delimiting regular expression
 * @param charset opens the file with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @throws java.util.regex.PatternSyntaxException if the regular expression's syntax is invalid
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.lang.String,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>regex</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitEachLine</MethodName>
            <MethodComment>/** 
 * Iterates through the input stream associated with this URL line by line, splitting each line using the given regex separator Pattern. For each line, the given closure is called with a single parameter being the list of strings computed by splitting the line around matches of the given regular expression. Finally the resources used for processing the URL are closed.
 * @param self    a URL to open and read
 * @param pattern the regular expression Pattern for the delimiter
 * @param charset opens the file with a specified charset
 * @param closure a closure
 * @return the last value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#splitEachLine(java.io.Reader,java.util.regex.Pattern,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the file into a list of Strings, with one item for each line.
 * @param file a File
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#readLines(java.io.Reader)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the file into a list of Strings, with one item for each line.
 * @param file    a File
 * @param charset opens the file with a specified charset
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#readLines(java.io.Reader)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the URL contents into a list, with one element for each line.
 * @param self a URL
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#readLines(java.io.Reader)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLines</MethodName>
            <MethodComment>/** 
 * Reads the URL contents into a list, with one element for each line.
 * @param self    a URL
 * @param charset opens the URL with a specified charset
 * @return a List of lines
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#readLines(java.io.Reader)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of the File using the specified encoding and return it as a String.
 * @param file    the file whose content we want to read
 * @param charset the charset used to read the content of the file
 * @return a String containing the content of the file
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of the File and returns it as a String.
 * @param file the file whose content we want to read
 * @return a String containing the content of the file
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of this URL and returns it as a String.
 * @param url URL to read content from
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the content of this URL and returns it as a String. The default connection parameters can be modified by adding keys to the &lt;i&gt;parameters map&lt;/i&gt;: &lt;ul&gt; &lt;li&gt;connectTimeout : the connection timeout&lt;/li&gt; &lt;li&gt;readTimeout : the read timeout&lt;/li&gt; &lt;li&gt;useCaches : set the use cache property for the URL connection&lt;/li&gt; &lt;li&gt;allowUserInteraction : set the user interaction flag for the URL connection&lt;/li&gt; &lt;li&gt;requestProperties : a map of properties to be passed to the URL connection&lt;/li&gt; &lt;/ul&gt;
 * @param url        URL to read content from
 * @param parameters connection parameters
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the data from this URL and return it as a String.  The connection stream is closed before this method returns.
 * @param url     URL to read content from
 * @param charset opens the stream with a specified charset
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @see java.net.URLConnection#getInputStream()
 * @since 1.0
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [reader=newReader(url,charset)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Read the data from this URL and return it as a String.  The connection stream is closed before this method returns.
 * @param url        URL to read content from
 * @param parameters connection parameters
 * @param charset    opens the stream with a specified charset
 * @return the text from that URL
 * @throws IOException if an IOException occurs.
 * @see java.net.URLConnection#getInputStream()
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedReader [reader=newReader(url,parameters,charset)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytes</MethodName>
            <MethodComment>/** 
 * Read the content of the File and returns it as a byte[].
 * @param file the file whose content we want to read
 * @return a String containing the content of the file
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytes</MethodName>
            <MethodComment>/** 
 * Read the content of this URL and returns it as a byte[].
 * @param url URL to read content from
 * @return the byte[] from that URL
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBytes</MethodName>
            <MethodComment>/** 
 * Write the bytes from the byte array to the File.
 * @param file  the file to write to
 * @param bytes the byte[] to write to the file
 * @throws IOException if an IOException occurs.
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;setBytes;[new FileOutputStream(file), bytes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * Write the text to the File.
 * @param file a File
 * @param text the text to write to the File
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setText</MethodName>
            <MethodComment>/** 
 * Synonym for write(text) allowing file.text = 'foo'.
 * @param file a File
 * @param text the text to write to the File
 * @throws IOException if an IOException occurs.
 * @see #write(java.io.File,java.lang.String)
 * @since 1.5.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;write;[file, text]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setText</MethodName>
            <MethodComment>/** 
 * Synonym for write(text, charset) allowing: &lt;pre&gt; myFile.setText('some text', charset) &lt;/pre&gt; or with some help from &lt;code&gt;ExpandoMetaClass&lt;/code&gt;, you could do something like: &lt;pre&gt; myFile.metaClass.setText = { String s -&gt; delegate.setText(s, 'UTF-8') } myfile.text = 'some text' &lt;/pre&gt;
 * @param file    A File
 * @param charset The charset used when writing to the file
 * @param text    The text to write to the File
 * @throws IOException if an IOException occurs.
 * @see #write(java.io.File,java.lang.String,java.lang.String)
 * @since 1.7.3
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;write;[file, text, charset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Write the text to the File.
 * @param file a File
 * @param text the text to write to the File
 * @return the original file
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>File</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[file, text]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Write bytes to a File.
 * @param file  a File
 * @param bytes the byte array to append to the end of the File
 * @return the original file
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>File</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[file, bytes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>leftShift</MethodName>
            <MethodComment>/** 
 * Append binary data to the file.  See  {@link #append(java.io.File,java.io.InputStream)}
 * @param file a File
 * @param data an InputStream of data to write to the file
 * @return the file
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>File</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;append;[file, data]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * Write the text to the File, using the specified encoding.
 * @param file    a File
 * @param text    the text to write to the File
 * @param charset the charset used
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text at the end of the File.
 * @param file a File
 * @param text the text to append at the end of the File
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text supplied by the Writer at the end of the File.
 * @param file a File
 * @param reader the Reader supplying the text to append at the end of the File
 * @throws IOException if an IOException occurs.
 * @since 2.3
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;appendBuffered;[file, reader]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text supplied by the Writer at the end of the File.
 * @param file a File
 * @param writer the Writer supplying the text to append at the end of the File
 * @throws IOException if an IOException occurs.
 * @since 2.3
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;appendBuffered;[file, writer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendBuffered</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedWriter [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append bytes to the end of a File.
 * @param file  a File
 * @param bytes the byte array to append to the end of the File
 * @throws IOException if an IOException occurs.
 * @since 1.5.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OutputStream [stream=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append binary data to the file.  It &lt;strong&gt;will not&lt;/strong&gt; be interpreted as text.
 * @param self   a File
 * @param stream stream to read data from.
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OutputStream [out=new FileOutputStream(self,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text at the end of the File, using a specified encoding.
 * @param file    a File
 * @param text    the text to append at the end of the File
 * @param charset the charset used
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Writer [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text supplied by the Writer at the end of the File, using a specified encoding.
 * @param file a File
 * @param writer the Writer supplying the text to append at the end of the File
 * @param charset the charset used
 * @throws IOException if an IOException occurs.
 * @since 2.3
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;appendBuffered;[file, writer, charset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>append</MethodName>
            <MethodComment>/** 
 * Append the text supplied by the Reader at the end of the File, using a specified encoding.
 * @param file a File
 * @param reader the Reader supplying the text to append at the end of the File
 * @param charset the charset used
 * @throws IOException if an IOException occurs.
 * @since 2.3
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;appendBuffered;[file, reader, charset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendBuffered</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedWriter [writer=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkDir</MethodName>
            <MethodComment>/** 
 * This method is used to throw useful exceptions when the eachFile* and eachDir closure methods are used incorrectly.
 * @param dir The directory to check
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dir</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFile</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each 'child' file in this 'parent' folder/directory. Both regular files and subfolders/subdirectories can be processed depending on the fileType enum value.
 * @param self     a file object
 * @param fileType if normal files or directories or both should be processed
 * @param closure  the closure to invoke
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileType</ParamName>
                    <ParamType>FileType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>File[] [files=self.listFiles()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkDir;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFile</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each 'child' file in this 'parent' folder/directory. Both regular files and subfolders/subdirectories are processed.
 * @param self    a File (that happens to be a folder/directory)
 * @param closure a closure (first parameter is the 'child' file)
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see java.io.File#listFiles()
 * @see #eachFile(java.io.File,groovy.io.FileType,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFile;[self, FileType.ANY, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachDir</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each subdirectory in this directory, ignoring regular files.
 * @param self    a File (that happens to be a folder/directory)
 * @param closure a closure (first parameter is the subdirectory file)
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see java.io.File#listFiles()
 * @see #eachFile(java.io.File,groovy.io.FileType,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFile;[self, FileType.DIRECTORIES, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFileRecurse</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each descendant file in this directory. Sub-directories are recursively searched in a depth-first fashion. Both regular files and subdirectories may be passed to the closure depending on the value of fileType.
 * @param self     a file object
 * @param fileType if normal files or directories or both should be processed
 * @param closure  the closure to invoke on each file
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileType</ParamName>
                    <ParamType>FileType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>File[] [files=self.listFiles()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkDir;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traverse</MethodName>
            <MethodComment>/** 
 * Invokes &lt;code&gt;closure&lt;/code&gt; for each descendant file in this directory tree. Sub-directories are recursively traversed as found. The traversal can be adapted by providing various options in the &lt;code&gt;options&lt;/code&gt; Map according to the following keys:&lt;dl&gt; &lt;dt&gt;type&lt;/dt&gt;&lt;dd&gt;A  {@link groovy.io.FileType} enum to determine if normal files or directories or both are processed&lt;/dd&gt;&lt;dt&gt;preDir&lt;/dt&gt;&lt;dd&gt;A  {@link groovy.lang.Closure} run before each directory is processed and optionally returning a {@link groovy.io.FileVisitResult} valuewhich can be used to control subsequent processing.&lt;/dd&gt; &lt;dt&gt;preRoot&lt;/dt&gt;&lt;dd&gt;A boolean indicating that the 'preDir' closure should be applied at the root level&lt;/dd&gt; &lt;dt&gt;postDir&lt;/dt&gt;&lt;dd&gt;A  {@link groovy.lang.Closure} run after each directory is processed and optionally returning a {@link groovy.io.FileVisitResult} valuewhich can be used to control subsequent processing.&lt;/dd&gt; &lt;dt&gt;postRoot&lt;/dt&gt;&lt;dd&gt;A boolean indicating that the 'postDir' closure should be applied at the root level&lt;/dd&gt; &lt;dt&gt;visitRoot&lt;/dt&gt;&lt;dd&gt;A boolean indicating that the given closure should be applied for the root dir (not applicable if the 'type' is set to  {@link groovy.io.FileType#FILES})&lt;/dd&gt; &lt;dt&gt;maxDepth&lt;/dt&gt;&lt;dd&gt;The maximum number of directory levels when recursing (default is -1 which means infinite, set to 0 for no recursion)&lt;/dd&gt; &lt;dt&gt;filter&lt;/dt&gt;&lt;dd&gt;A filter to perform on traversed files/directories (using the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method). If set,only files/dirs which match are candidates for visiting.&lt;/dd&gt; &lt;dt&gt;nameFilter&lt;/dt&gt;&lt;dd&gt;A filter to perform on the name of traversed files/directories (using the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method). If set,only files/dirs which match are candidates for visiting. (Must not be set if 'filter' is set)&lt;/dd&gt; &lt;dt&gt;excludeFilter&lt;/dt&gt;&lt;dd&gt;A filter to perform on traversed files/directories (using the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method).If set, any candidates which match won't be visited.&lt;/dd&gt; &lt;dt&gt;excludeNameFilter&lt;/dt&gt;&lt;dd&gt;A filter to perform on the names of traversed files/directories (using the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method).If set, any candidates which match won't be visited. (Must not be set if 'excludeFilter' is set)&lt;/dd&gt; &lt;dt&gt;sort&lt;/dt&gt;&lt;dd&gt;A  {@link groovy.lang.Closure} which if set causes the files and subdirectories for each directory to be processed in sorted order.Note that even when processing only files, the order of visited subdirectories will be affected by this parameter.&lt;/dd&gt; &lt;/dl&gt; This example prints out file counts and size aggregates for groovy source files within a directory tree: &lt;pre&gt; def totalSize = 0 def count = 0 def sortByTypeThenName = { a, b -&gt; a.isFile() != b.isFile() ? a.isFile() &lt;=&gt; b.isFile() : a.name &lt;=&gt; b.name } rootDir.traverse( type         : FILES, nameFilter   : ~/.*\.groovy/, preDir       : { if (it.name == '.svn') return SKIP_SUBTREE }, postDir      : { println "Found $count files in $it.name totalling $totalSize bytes" totalSize = 0; count = 0 }, postRoot     : true sort         : sortByTypeThenName ) {it -&gt; totalSize += it.size(); count++ } &lt;/pre&gt;
 * @param self    a File
 * @param options a Map of options to alter the traversal behavior
 * @param closure the Closure to invoke on each file/directory and optionally returning a {@link groovy.io.FileVisitResult} valuewhich can be used to control subsequent processing
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory or illegal filter combinations are supplied
 * @see DefaultGroovyMethods#sort(java.util.Collection,groovy.lang.Closure)
 * @see groovy.io.FileVisitResult
 * @see groovy.io.FileType
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Number [maxDepthNumber=DefaultGroovyMethods.asType(options.remove("maxDepth"),Number.class)]</InnerVar>
                <InnerVar>int [maxDepth=maxDepthNumber == null ? -1 : maxDepthNumber.intValue()]</InnerVar>
                <InnerVar>Boolean [visitRoot=DefaultGroovyMethods.asType(get(options,"visitRoot",false),Boolean.class)]</InnerVar>
                <InnerVar>Boolean [preRoot=DefaultGroovyMethods.asType(get(options,"preRoot",false),Boolean.class)]</InnerVar>
                <InnerVar>Boolean [postRoot=DefaultGroovyMethods.asType(get(options,"postRoot",false),Boolean.class)]</InnerVar>
                <InnerVar>Closure [pre=(Closure)options.get("preDir")]</InnerVar>
                <InnerVar>Closure [post=(Closure)options.get("postDir")]</InnerVar>
                <InnerVar>FileType [type=(FileType)options.get("type")]</InnerVar>
                <InnerVar>Object [filter=options.get("filter")]</InnerVar>
                <InnerVar>Object [nameFilter=options.get("nameFilter")]</InnerVar>
                <InnerVar>Object [excludeFilter=options.get("excludeFilter")]</InnerVar>
                <InnerVar>Object [excludeNameFilter=options.get("excludeNameFilter")]</InnerVar>
                <InnerVar>Object [preResult=null]</InnerVar>
                <InnerVar>FileVisitResult [terminated=traverse(self,options,closure,maxDepth)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notFiltered</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludeFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>excludeNameFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [filterToUse=null]</InnerVar>
                <InnerVar>Object [filterParam=null]</InnerVar>
                <InnerVar>Object [excludeFilterToUse=null]</InnerVar>
                <InnerVar>Object [excludeParam=null]</InnerVar>
                <InnerVar>MetaClass [filterMC=filterToUse == null ? null : InvokerHelper.getMetaClass(filterToUse)]</InnerVar>
                <InnerVar>MetaClass [excludeMC=excludeFilterToUse == null ? null : InvokerHelper.getMetaClass(excludeFilterToUse)]</InnerVar>
                <InnerVar>boolean [included=filterToUse == null || DefaultTypeTransformation.castToBoolean(filterMC.invokeMethod(filterToUse,"isCase",filterParam))]</InnerVar>
                <InnerVar>boolean [excluded=excludeFilterToUse != null &amp;&amp; DefaultTypeTransformation.castToBoolean(excludeMC.invokeMethod(excludeFilterToUse,"isCase",excludeParam))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traverse</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each descendant file in this directory tree. Sub-directories are recursively traversed in a depth-first fashion. Convenience method for  {@link #traverse(java.io.File,java.util.Map,groovy.lang.Closure)} whenno options to alter the traversal behavior are required.
 * @param self    a File
 * @param closure the Closure to invoke on each file/directory and optionally returning a {@link groovy.io.FileVisitResult} valuewhich can be used to control subsequent processing
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see #traverse(java.io.File,java.util.Map,groovy.lang.Closure)
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;traverse;[self, new HashMap&lt;String,Object&gt;(), closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traverse</MethodName>
            <MethodComment>/** 
 * Invokes the closure specified with key 'visit' in the options Map for each descendant file in this directory tree. Convenience method for  {@link #traverse(java.io.File,java.util.Map,groovy.lang.Closure)} allowing the 'visit' closureto be included in the options Map rather than as a parameter.
 * @param self    a File
 * @param options a Map of options to alter the traversal behavior
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory or illegal filter combinations are supplied
 * @see #traverse(java.io.File,java.util.Map,groovy.lang.Closure)
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Closure [visit=(Closure)options.remove("visit")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;traverse;[self, options, visit]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traverse</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileVisitResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxDepth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Closure [pre=(Closure)options.get("preDir")]</InnerVar>
                <InnerVar>Closure [post=(Closure)options.get("postDir")]</InnerVar>
                <InnerVar>FileType [type=(FileType)options.get("type")]</InnerVar>
                <InnerVar>Object [filter=options.get("filter")]</InnerVar>
                <InnerVar>Object [nameFilter=options.get("nameFilter")]</InnerVar>
                <InnerVar>Object [excludeFilter=options.get("excludeFilter")]</InnerVar>
                <InnerVar>Object [excludeNameFilter=options.get("excludeNameFilter")]</InnerVar>
                <InnerVar>Closure [sort=(Closure)options.get("sort")]</InnerVar>
                <InnerVar>File[] [origFiles=self.listFiles()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkDir;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFileRecurse</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each descendant file in this directory. Sub-directories are recursively searched in a depth-first fashion. Both regular files and subdirectories are passed to the closure.
 * @param self    a File
 * @param closure a closure
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see #eachFileRecurse(java.io.File,groovy.io.FileType,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFileRecurse;[self, FileType.ANY, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachDirRecurse</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each descendant directory of this directory. Sub-directories are recursively searched in a depth-first fashion. Only subdirectories are passed to the closure; regular files are ignored.
 * @param self    a directory
 * @param closure a closure
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see #eachFileRecurse(java.io.File,groovy.io.FileType,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFileRecurse;[self, FileType.DIRECTORIES, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFileMatch</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method to determine if a match occurs.  This method can be usedwith different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories may be candidates for matching depending on the value of fileType. &lt;pre&gt; // collect names of files in baseDir matching supplied regex pattern import static groovy.io.FileType. def names = [] baseDir.eachFileMatch FILES, ~/foo\d\.txt/, { names &lt;&lt; it.name } assert names == ['foo1.txt', 'foo2.txt'] // remove all *.bak files in baseDir baseDir.eachFileMatch FILES, ~/.*\.bak/, { File bak -&gt; bak.delete() } // print out files &gt; 4K in size from baseDir baseDir.eachFileMatch FILES, { new File(baseDir, it).size() &gt; 4096 }, { println "$it.name ${it.size()}" } &lt;/pre&gt;
 * @param self       a file
 * @param fileType   whether normal files or directories or both should be processed
 * @param nameFilter the filter to perform on the name of the file/directory (using the {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method)
 * @param closure    the closure to invoke
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @since 1.7.1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileType</ParamName>
                    <ParamType>FileType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>File[] [files=self.listFiles()]</InnerVar>
                <InnerVar>BooleanReturningMethodInvoker [bmi=new BooleanReturningMethodInvoker("isCase")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkDir;[self]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachFileMatch</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method to determine if a match occurs.  This method can be usedwith different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories are matched.
 * @param self       a file
 * @param nameFilter the nameFilter to perform on the name of the file (using the {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method)
 * @param closure    the closure to invoke
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see #eachFileMatch(java.io.File,groovy.io.FileType,java.lang.Object,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFileMatch;[self, FileType.ANY, nameFilter, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachDirMatch</MethodName>
            <MethodComment>/** 
 * Invokes the closure for each subdirectory whose name (dir.name) matches the given nameFilter in the given directory - calling the  {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method to determine if a match occurs.  This method can be usedwith different kinds of filters like regular expressions, classes, ranges etc. Only subdirectories are matched; regular files are ignored.
 * @param self       a file
 * @param nameFilter the nameFilter to perform on the name of the directory (using the {@link DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)} method)
 * @param closure    the closure to invoke
 * @throws FileNotFoundException    if the given directory does not exist
 * @throws IllegalArgumentException if the provided File object does not represent a directory
 * @see #eachFileMatch(java.io.File,groovy.io.FileType,java.lang.Object,groovy.lang.Closure)
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameFilter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;eachFileMatch;[self, FileType.DIRECTORIES, nameFilter, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>IllegalArgumentException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteDir</MethodName>
            <MethodComment>/** 
 * Deletes a directory with all contained files and subdirectories. &lt;p&gt;The method returns &lt;ul&gt; &lt;li&gt;true, when deletion was successful&lt;/li&gt; &lt;li&gt;true, when it is called for a non existing directory&lt;/li&gt; &lt;li&gt;false, when it is called for a file which isn't a directory&lt;/li&gt; &lt;li&gt;false, when directory couldn't be deleted&lt;/li&gt; &lt;/ul&gt;
 * @param self a File
 * @return true if the file doesn't exist or deletion was successful
 * @since 1.6.0
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>File[] [files=self.listFiles()]</InnerVar>
                <InnerVar>boolean [result=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>renameTo</MethodName>
            <MethodComment>/** 
 * Renames the file. It's a shortcut for  {@link java.io.File#renameTo(File)}
 * @param self        a File
 * @param newPathName The new pathname for the named file
 * @return &lt;code&gt;true&lt;/code&gt; if and only if the renaming succeeded;&lt;code&gt;false&lt;/code&gt; otherwise
 * @since 1.7.4
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPathName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>relativePath</MethodName>
            <MethodComment>/** 
 * Relative path to file. Implementation was borrowed from  {@link org.apache.tools.ant.util.FileUtils#getRelativePath(File,File)}
 * @param self  the &lt;code&gt;File&lt;/code&gt; to calculate the path from
 * @param to    the &lt;code&gt;File&lt;/code&gt; to calculate the path to
 * @return the relative path between the files
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [fromPath=self.getCanonicalPath()]</InnerVar>
                <InnerVar>String [toPath=to.getCanonicalPath()]</InnerVar>
                <InnerVar>String[] [fromPathStack=getPathStack(fromPath)]</InnerVar>
                <InnerVar>String[] [toPathStack=getPathStack(toPath)]</InnerVar>
                <InnerVar>int [minLength=Math.min(fromPathStack.length,toPathStack.length)]</InnerVar>
                <InnerVar>int [same=1]</InnerVar>
                <InnerVar>List&lt;String&gt; [relativePathStack=new ArrayList&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asWritable</MethodName>
            <MethodComment>/** 
 * Converts this File to a  {@link groovy.lang.Writable}.
 * @param file a File
 * @return a File which wraps the input file and which implements Writable
 * @since 1.0
 */
</MethodComment>
            <ReturnType>File</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asType</MethodName>
            <MethodComment>/** 
 * Converts this File to a  {@link groovy.lang.Writable} or delegates to default{@link DefaultGroovyMethods#asType(java.lang.Object,java.lang.Class)}.
 * @param f a File
 * @param c the desired class
 * @return the converted object
 * @since 1.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>f</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asWritable</MethodName>
            <MethodComment>/** 
 * Allows a file to return a Writable implementation that can output itself to a Writer stream.
 * @param file     a File
 * @param encoding the encoding to be used when reading the file's contents
 * @return File which wraps the input file and which implements Writable
 * @since 1.0
 */
</MethodComment>
            <ReturnType>File</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encoding</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Create a buffered reader for this file.
 * @param file a File
 * @return a BufferedReader
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CharsetToolkit [toolkit=new CharsetToolkit(file)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Create a buffered reader for this file, using the specified charset as the encoding.
 * @param file    a File
 * @param charset the charset for this File
 * @return a BufferedReader
 * @throws FileNotFoundException        if the File was not found
 * @throws UnsupportedEncodingException if the encoding specified is not supported
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
                <ExceptionType>UnsupportedEncodingException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Create a new BufferedReader for this file and then passes it into the closure, ensuring the reader is closed after the closure returns.
 * @param file    a file object
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Create a new BufferedReader for this file using the specified charset and then passes it into the closure, ensuring the reader is closed after the closure returns.
 * @param file    a file object
 * @param charset the charset for this input stream
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.6.0
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newOutputStream</MethodName>
            <MethodComment>/** 
 * Create a buffered output stream for this file.
 * @param file a file object
 * @return the created OutputStream
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedOutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newDataOutputStream</MethodName>
            <MethodComment>/** 
 * Creates a new data output stream for this file.
 * @param file a file object
 * @return the created DataOutputStream
 * @throws IOException if an IOException occurs.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>DataOutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withOutputStream</MethodName>
            <MethodComment>/** 
 * Creates a new OutputStream for this file and passes it into the closure. This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.OutputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInputStream</MethodName>
            <MethodComment>/** 
 * Create a new InputStream for this file and passes it into the closure. This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withInputStream</MethodName>
            <MethodComment>/** 
 * Creates a new InputStream for this URL and passes it into the closure. This method ensures the stream is closed after the closure returns.
 * @param url     a URL
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withDataOutputStream</MethodName>
            <MethodComment>/** 
 * Create a new DataOutputStream for this file and passes it into the closure. This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.OutputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withDataInputStream</MethodName>
            <MethodComment>/** 
 * Create a new DataInputStream for this file and passes it into the closure. This method ensures the stream is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#withStream(java.io.InputStream,groovy.lang.Closure)
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Create a buffered writer for this file.
 * @param file a File
 * @return a BufferedWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Creates a buffered writer for this file, optionally appending to the existing file content.
 * @param file   a File
 * @param append true if data should be appended to the file
 * @return a BufferedWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>append</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Helper method to create a buffered writer for a file.  If the given charset is "UTF-16BE" or "UTF-16LE", the requisite byte order mark is written to the stream before the writer is returned.
 * @param file    a File
 * @param charset the name of the encoding used to write in this file
 * @param append  true if in append mode
 * @return a BufferedWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>append</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeUTF16BomIfRequired</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newWriter</MethodName>
            <MethodComment>/** 
 * Creates a buffered writer for this file, writing data using the given encoding.
 * @param file    a File
 * @param charset the name of the encoding used to write in this file
 * @return a BufferedWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeUtf16Bom</MethodName>
            <MethodComment>/** 
 * Write a Byte Order Mark at the beginning of the file
 * @param stream    the FileOutputStream to write the BOM to
 * @param bigEndian true if UTF 16 Big Endian or false if Low Endian
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bigEndian</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Creates a new BufferedWriter for this file, passes it to the closure, and ensures the stream is flushed and closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriter</MethodName>
            <MethodComment>/** 
 * Creates a new BufferedWriter for this file, passes it to the closure, and ensures the stream is flushed and closed after the closure returns. The writer will use the given charset encoding.
 * @param file    a File
 * @param charset the charset used
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriterAppend</MethodName>
            <MethodComment>/** 
 * Create a new BufferedWriter which will append to this file.  The writer is passed to the closure and will be closed before this method returns.
 * @param file    a File
 * @param charset the charset used
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withWriterAppend</MethodName>
            <MethodComment>/** 
 * Create a new BufferedWriter for this file in append mode.  The writer is passed to the closure and is closed after the closure returns.
 * @param file    a File
 * @param closure a closure
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this file.
 * @param file a File
 * @return the created PrintWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>PrintWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this file, using specified charset.
 * @param file    a File
 * @param charset the charset
 * @return a PrintWriter
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>PrintWriter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter for this file which is then passed it into the given closure.  This method ensures its the writer is closed after the closure returns.
 * @param file    a File
 * @param closure the closure to invoke with the PrintWriter
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withPrintWriter</MethodName>
            <MethodComment>/** 
 * Create a new PrintWriter with a specified charset for this file.  The writer is passed to the closure, and will be closed before this method returns.
 * @param file    a File
 * @param charset the charset
 * @param closure the closure to invoke with the PrintWriter
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Helper method to create a new BufferedReader for a URL and then passes it to the closure.  The reader is closed after the closure returns.
 * @param url     a URL
 * @param closure the closure to invoke with the reader
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>withReader</MethodName>
            <MethodComment>/** 
 * Helper method to create a new Reader for a URL and then passes it to the closure.  The reader is closed after the closure returns.
 * @param url     a URL
 * @param charset the charset used
 * @param closure the closure to invoke with the reader
 * @return the value returned by the closure
 * @throws IOException if an IOException occurs.
 * @since 1.5.6
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInputStream</MethodName>
            <MethodComment>/** 
 * Creates a buffered input stream for this file.
 * @param file a File
 * @return a BufferedInputStream of the file
 * @throws FileNotFoundException if the file is not found.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>BufferedInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>configuredInputStream</MethodName>
            <MethodComment>/** 
 * Creates an inputstream for this URL, with the possibility to set different connection parameters using the &lt;i&gt;parameters map&lt;/i&gt;: &lt;ul&gt; &lt;li&gt;connectTimeout : the connection timeout&lt;/li&gt; &lt;li&gt;readTimeout : the read timeout&lt;/li&gt; &lt;li&gt;useCaches : set the use cache property for the URL connection&lt;/li&gt; &lt;li&gt;allowUserInteraction : set the user interaction flag for the URL connection&lt;/li&gt; &lt;li&gt;requestProperties : a map of properties to be passed to the URL connection&lt;/li&gt; &lt;/ul&gt;
 * @param parameters an optional map specifying part or all of supported connection parameters
 * @param url        the url for which to create the inputstream
 * @return an InputStream from the underlying URLConnection
 * @throws IOException if an I/O error occurs while creating the input stream
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>URLConnection [connection=url.openConnection()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInputStream</MethodName>
            <MethodComment>/** 
 * Creates a buffered input stream for this URL.
 * @param url a URL
 * @return a BufferedInputStream for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.5.2
 */
</MethodComment>
            <ReturnType>BufferedInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newInputStream</MethodName>
            <MethodComment>/** 
 * Creates a buffered input stream for this URL. The default connection parameters can be modified by adding keys to the &lt;i&gt;parameters map&lt;/i&gt;: &lt;ul&gt; &lt;li&gt;connectTimeout : the connection timeout&lt;/li&gt; &lt;li&gt;readTimeout : the read timeout&lt;/li&gt; &lt;li&gt;useCaches : set the use cache property for the URL connection&lt;/li&gt; &lt;li&gt;allowUserInteraction : set the user interaction flag for the URL connection&lt;/li&gt; &lt;li&gt;requestProperties : a map of properties to be passed to the URL connection&lt;/li&gt; &lt;/ul&gt;
 * @param url        a URL
 * @param parameters connection parameters
 * @return a BufferedInputStream for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>BufferedInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a buffered reader for this URL.
 * @param url a URL
 * @return a BufferedReader for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a buffered reader for this URL. The default connection parameters can be modified by adding keys to the &lt;i&gt;parameters map&lt;/i&gt;: &lt;ul&gt; &lt;li&gt;connectTimeout : the connection timeout&lt;/li&gt; &lt;li&gt;readTimeout : the read timeout&lt;/li&gt; &lt;li&gt;useCaches : set the use cache property for the URL connection&lt;/li&gt; &lt;li&gt;allowUserInteraction : set the user interaction flag for the URL connection&lt;/li&gt; &lt;li&gt;requestProperties : a map of properties to be passed to the URL connection&lt;/li&gt; &lt;/ul&gt;
 * @param url        a URL
 * @param parameters connection parameters
 * @return a BufferedReader for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a buffered reader for this URL using the given encoding.
 * @param url     a URL
 * @param charset opens the stream with a specified charset
 * @return a BufferedReader for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.5.5
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newReader</MethodName>
            <MethodComment>/** 
 * Creates a buffered reader for this URL using the given encoding.
 * @param url        a URL
 * @param parameters connection parameters
 * @param charset    opens the stream with a specified charset
 * @return a BufferedReader for the URL
 * @throws MalformedURLException is thrown if the URL is not well formed
 * @throws IOException           if an I/O error occurs while creating the input stream
 * @since 1.8.1
 */
</MethodComment>
            <ReturnType>BufferedReader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Map</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newDataInputStream</MethodName>
            <MethodComment>/** 
 * Create a data input stream for this file
 * @param file a File
 * @return a DataInputStream of the file
 * @throws FileNotFoundException if the file is not found.
 * @since 1.5.0
 */
</MethodComment>
            <ReturnType>DataInputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Traverse through each byte of this File
 * @param self    a File
 * @param closure a closure
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachByte(java.io.InputStream,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedInputStream [is=newInputStream(self)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;eachByte;[is, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Traverse through the bytes of this File, bufferLen bytes at a time.
 * @param self      a File
 * @param bufferLen the length of the buffer to use.
 * @param closure   a 2 parameter closure which is passed the byte[] and a number of bytes successfully read.
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachByte(java.io.InputStream,int,groovy.lang.Closure)
 * @since 1.7.4
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bufferLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BufferedInputStream [is=newInputStream(self)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;eachByte;[is, bufferLen, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Reads the InputStream from this URL, passing each byte to the given closure.  The URL stream will be closed before this method returns.
 * @param url     url to iterate over
 * @param closure closure to apply to each byte
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachByte(java.io.InputStream,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InputStream [is=url.openConnection().getInputStream()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;eachByte;[is, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eachByte</MethodName>
            <MethodComment>/** 
 * Reads the InputStream from this URL, passing a byte[] and a number of bytes to the given closure.  The URL stream will be closed before this method returns.
 * @param url       url to iterate over
 * @param bufferLen the length of the buffer to use.
 * @param closure   a 2 parameter closure which is passed the byte[] and a number of bytes successfully read.
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#eachByte(java.io.InputStream,int,groovy.lang.Closure)
 * @since 1.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bufferLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InputStream [is=url.openConnection().getInputStream()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;eachByte;[is, bufferLen, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filters the lines of a File and creates a Writable in return to stream the filtered lines.
 * @param self    a File
 * @param closure a closure which returns a boolean indicating to filterthe line or not
 * @return a Writable closure
 * @throws IOException if &lt;code&gt;self&lt;/code&gt; is not readable
 * @see IOGroovyMethods#filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filters the lines of a File and creates a Writable in return to stream the filtered lines.
 * @param self    a File
 * @param charset opens the file with a specified charset
 * @param closure a closure which returns a boolean indicating to filterthe line or not
 * @return a Writable closure
 * @throws IOException if an IOException occurs
 * @see IOGroovyMethods#filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter the lines from this File, and write them to the given writer based on the given closure predicate.
 * @param self    a File
 * @param writer  a writer destination to write filtered lines to
 * @param closure a closure which takes each line as a parameter and returns&lt;code&gt;true&lt;/code&gt; if the line should be written to this writer.
 * @throws IOException if &lt;code&gt;self&lt;/code&gt; is not readable
 * @see IOGroovyMethods#filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;filterLine;[newReader(self), writer, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter the lines from this File, and write them to the given writer based on the given closure predicate.
 * @param self    a File
 * @param writer  a writer destination to write filtered lines to
 * @param charset opens the file with a specified charset
 * @param closure a closure which takes each line as a parameter and returns&lt;code&gt;true&lt;/code&gt; if the line should be written to this writer.
 * @throws IOException if an IO error occurs
 * @see IOGroovyMethods#filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>closure</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;filterLine;[newReader(self,charset), writer, closure]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter lines from a URL using a closure predicate.  The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      a URL
 * @param predicate a closure which returns boolean and takes a line
 * @return a writable which writes out the filtered lines
 * @throws IOException if an IO exception occurs
 * @see IOGroovyMethods#filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Filter lines from a URL using a closure predicate.  The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      the URL
 * @param charset   opens the URL with a specified charset
 * @param predicate a closure which returns boolean and takes a line
 * @return a writable which writes out the filtered lines
 * @throws IOException if an IO exception occurs
 * @see IOGroovyMethods#filterLine(java.io.Reader,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>Writable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Uses a closure to filter lines from this URL and pass them to the given writer. The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      the URL
 * @param writer    a writer to write output to
 * @param predicate a closure which returns true if a line should be accepted
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;filterLine;[newReader(self), writer, predicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterLine</MethodName>
            <MethodComment>/** 
 * Uses a closure to filter lines from this URL and pass them to the given writer. The closure will be passed each line as a String, and it should return &lt;code&gt;true&lt;/code&gt; if the line should be passed to the writer.
 * @param self      the URL
 * @param writer    a writer to write output to
 * @param charset   opens the URL with a specified charset
 * @param predicate a closure which returns true if a line should be accepted
 * @throws IOException if an IOException occurs.
 * @see IOGroovyMethods#filterLine(java.io.Reader,java.io.Writer,groovy.lang.Closure)
 * @since 1.6.8
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>URL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writer</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Closure</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>IOGroovyMethods;filterLine;[newReader(self,charset), writer, predicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readBytes</MethodName>
            <MethodComment>/** 
 * Reads the content of the file into a byte array.
 * @param file a File
 * @return a byte array with the contents of the file.
 * @throws IOException if an IOException occurs.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [bytes=new byte[(int)file.length()]]</InnerVar>
                <InnerVar>FileInputStream [fileInputStream=new FileInputStream(file)]</InnerVar>
                <InnerVar>DataInputStream [dis=new DataInputStream(fileInputStream)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toURI</MethodName>
            <MethodComment>/** 
 * Transforms a CharSequence representing a URI into a URI object.
 * @param self the CharSequence representing a URI
 * @return a URI
 * @throws java.net.URISyntaxException is thrown if the URI is not well formed.
 * @since 1.8.2
 */
</MethodComment>
            <ReturnType>URI</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>URISyntaxException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toURI</MethodName>
            <MethodComment>/** 
 * Transforms a String representing a URI into a URI object.
 * @param self the String representing a URI
 * @return a URI
 * @throws java.net.URISyntaxException is thrown if the URI is not well formed.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>URI</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>URISyntaxException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toURL</MethodName>
            <MethodComment>/** 
 * Transforms a CharSequence representing a URL into a URL object.
 * @param self the CharSequence representing a URL
 * @return a URL
 * @throws java.net.MalformedURLException is thrown if the URL is not well formed.
 * @since 1.8.2
 */
</MethodComment>
            <ReturnType>URL</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toURL</MethodName>
            <MethodComment>/** 
 * Transforms a String representing a URL into a URL object.
 * @param self the String representing a URL
 * @return a URL
 * @throws java.net.MalformedURLException is thrown if the URL is not well formed.
 * @since 1.0
 */
</MethodComment>
            <ReturnType>URL</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>self</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MalformedURLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPathStack</MethodName>
            <MethodComment>/** 
 * Gets all names of the path as an array of &lt;code&gt;String&lt;/code&gt;s.
 * @param path to get names from
 * @return &lt;code&gt;String&lt;/code&gt;s, never &lt;code&gt;null&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [normalizedPath=path.replace(File.separatorChar,'/')]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPath</MethodName>
            <MethodComment>/** 
 * Gets path from a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s.
 * @param pathStack &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s to be concatenated as a path.
 * @return &lt;code&gt;String&lt;/code&gt;, never &lt;code&gt;null&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pathStack</ParamName>
                    <ParamType>List</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPath</MethodName>
            <MethodComment>/** 
 * Gets path from a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s.
 * @param pathStack     &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s to be concated as a path.
 * @param separatorChar &lt;code&gt;char&lt;/code&gt; to be used as separator between names in path
 * @return &lt;code&gt;String&lt;/code&gt;, never &lt;code&gt;null&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pathStack</ParamName>
                    <ParamType>List</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>separatorChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [buffer=new StringBuilder()]</InnerVar>
                <InnerVar>Iterator [iter=pathStack.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>