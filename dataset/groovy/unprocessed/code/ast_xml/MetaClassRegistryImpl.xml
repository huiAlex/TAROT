<Class>
    <Id>182</Id>
    <Package>org.codehaus.groovy.runtime.metaclass</Package>
    <ClassName>MetaClassRegistryImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>MetaClassRegistry</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MetaClassRegistryImpl  /** 
 * A registry of MetaClass instances which caches introspection &amp; reflection information and allows methods to be dynamically added to existing classes at runtime
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author John Wilson
 * @author &lt;a href="mailto:blackdrag@gmx.org"&gt;Jochen Theodorou&lt;/a&gt;
 * @author Graeme Rocher
 * @author Alex Tkachman
 * @version $Revision$
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MODULE_META_INF_FILE</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>useAccessible</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>instanceMethods</FieldName>
            <FieldType>FastArray</FieldType>
        </Field>
        <Field>
            <FieldName>staticMethods</FieldName>
            <FieldType>FastArray</FieldType>
        </Field>
        <Field>
            <FieldName>changeListenerList</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>changeListenerList</FieldName>
            <FieldType>MetaClassRegistryChangeEventListener</FieldType>
        </Field>
        <Field>
            <FieldName>nonRemoveableChangeListenerList</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>nonRemoveableChangeListenerList</FieldName>
            <FieldType>MetaClassRegistryChangeEventListener</FieldType>
        </Field>
        <Field>
            <FieldName>metaClassInfo</FieldName>
            <FieldType>ManagedLinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>moduleRegistry</FieldName>
            <FieldType>ExtensionModuleRegistry</FieldType>
        </Field>
        <Field>
            <FieldName>LOAD_DEFAULT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DONT_LOAD_DEFAULT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>instanceInclude</FieldName>
            <FieldType>MetaClassRegistry</FieldType>
        </Field>
        <Field>
            <FieldName>instanceExclude</FieldName>
            <FieldType>MetaClassRegistry</FieldType>
        </Field>
        <Field>
            <FieldName>metaClassCreationHandle</FieldName>
            <FieldType>MetaClassCreationHandle</FieldType>
        </Field>
        <Field>
            <FieldName>index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentMeta</FieldName>
            <FieldType>MetaClass</FieldType>
        </Field>
        <Field>
            <FieldName>hasNextCalled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>hasNext</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>map</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>map</FieldName>
            <FieldType>CachedClass</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MetaClassRegistryImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MetaClassRegistryImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loadDefault</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MetaClassRegistryImpl</MethodName>
            <MethodComment>/** 
 * @param useAccessible defines whether or not the {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)}method will be called to enable access to all methods when using reflection
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>useAccessible</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MetaClassRegistryImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loadDefault</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useAccessible</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MetaClass [emcMetaClass=metaClassCreationHandle.create(ExpandoMetaClass.class,this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;installMetaClassCreationHandle;[]</InnerMethodInvoke>
                <InnerMethodInvoke>emcMetaClass;initialize;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ClassInfo.getClassInfo(ExpandoMetaClass.class);setStrongMetaClass;[emcMetaClass]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addNonRemovableMetaClassRegistryChangeEventListener;[new MetaClassRegistryChangeEventListener(){
  public void updateConstantMetaClass(  MetaClassRegistryChangeEvent cmcu){
synchronized (metaClassInfo) {
      metaClassInfo.add(cmcu.getNewMetaClass());
      DefaultMetaClassInfo.getNewConstantMetaClassVersioning();
      Class c=cmcu.getClassToUpdate();
      DefaultMetaClassInfo.setPrimitiveMeta(c,cmcu.getNewMetaClass() == null);
      Field sdyn;
      try {
        sdyn=c.getDeclaredField(Verifier.STATIC_METACLASS_BOOL);
        sdyn.setBoolean(null,cmcu.getNewMetaClass() != null);
      }
 catch (      Throwable e) {
      }
    }
  }
}
]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConstantMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cmcu</ParamName>
                    <ParamType>MetaClassRegistryChangeEvent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>refreshMopMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>CachedClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerExtensionModuleFromProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classLoader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>CachedClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExtensionModuleScanner [scanner=new ExtensionModuleScanner(new DefaultModuleListener(map),classLoader)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanner;scanExtensionModuleFromProperties;[properties]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getModuleRegistry</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExtensionModuleRegistry</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>installMetaClassCreationHandle</MethodName>
            <MethodComment>/** 
 * Looks for a class called 'groovy.runtime.metaclass.CustomMetaClassCreationHandle' and if it exists uses it as the MetaClassCreationHandle otherwise uses the default
 * @see groovy.lang.MetaClassRegistry.MetaClassCreationHandle
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useMethodWrapper</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useInstanceMethods</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>CachedClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createMetaMethodFromClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>CachedClass</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MetaClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClass</MethodName>
            <MethodComment>/** 
 * if oldMc is null, newMc will replace whatever meta class was used before. if oldMc is not null, then newMc will be used only if he stored mc is the same as oldMc
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldMc</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newMc</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassInfo [info=ClassInfo.getClassInfo(theClass)]</InnerVar>
                <InnerVar>MetaClass [mc=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>info;lock;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setMetaClass;[theClass, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClass</MethodName>
            <MethodComment>/** 
 * Registers a new MetaClass in the registry to customize the type
 * @param theClass
 * @param theMetaClass
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>theMetaClass</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setMetaClass;[theClass, null, theMetaClass]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClass</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>theMetaClass</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [theClass=obj.getClass()]</InnerVar>
                <InnerVar>ClassInfo [info=ClassInfo.getClassInfo(theClass)]</InnerVar>
                <InnerVar>MetaClass [oldMC=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>info;lock;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;fireConstantMetaClassUpdate;[obj, theClass, oldMC, theMetaClass]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>useAccessible</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClassCreationHandler</MethodName>
            <MethodComment>/** 
 * Gets a handle internally used to create MetaClass implementations WARNING: experimental code, likely to change soon
 * @return the handle
 */
</MethodComment>
            <ReturnType>MetaClassCreationHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMetaClassCreationHandle</MethodName>
            <MethodComment>/** 
 * Sets a handle internally used to create MetaClass implementations. When replacing the handle with a custom version, you should reuse the old handle to keep custom logic and to use the default logic as fall back. WARNING: experimental code, likely to change soon
 * @param handle the handle
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>MetaClassCreationHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ClassInfo;clearModifiedExpandos;[]</InnerMethodInvoke>
                <InnerMethodInvoke>handle;setDisableCustomMetaClassLookup;[metaClassCreationHandle.isDisableCustomMetaClassLookup()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addMetaClassRegistryChangeEventListener</MethodName>
            <MethodComment>/** 
 * Adds a listener for constant meta classes.
 * @param listener the listener
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>MetaClassRegistryChangeEventListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNonRemovableMetaClassRegistryChangeEventListener</MethodName>
            <MethodComment>/** 
 * Adds a listener for constant meta classes. This listener cannot be removed!
 * @param listener the listener
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>MetaClassRegistryChangeEventListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeMetaClassRegistryChangeEventListener</MethodName>
            <MethodComment>/** 
 * Removes a constant meta class listener.
 * @param listener the listener
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listener</ParamName>
                    <ParamType>MetaClassRegistryChangeEventListener</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fireConstantMetaClassUpdate</MethodName>
            <MethodComment>/** 
 * Causes the execution of all registered listeners. This method is used mostly internal to kick of the listener notification. It can also be used by subclasses to achieve the same.
 * @param obj object instance if the MetaClass change is on a per-instance metaclass (or null if global)
 * @param c the class
 * @param oldMC the old MetaClass
 * @param newMc the new MetaClass
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldMC</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newMc</ParamName>
                    <ParamType>MetaClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MetaClassRegistryChangeEventListener[] [listener=getMetaClassRegistryChangeEventListeners()]</InnerVar>
                <InnerVar>MetaClassRegistryChangeEvent [cmcu=new MetaClassRegistryChangeEvent(this,obj,c,oldMC,newMc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMetaClassRegistryChangeEventListeners</MethodName>
            <MethodComment>/** 
 * Gets an array of of all registered ConstantMetaClassListener instances.
 */
</MethodComment>
            <ReturnType>MetaClassRegistryChangeEventListener[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstance</MethodName>
            <MethodComment>/** 
 * Singleton of MetaClassRegistry. 
 * @param includeExtension
 * @return the registry
 */
</MethodComment>
            <ReturnType>MetaClassRegistry</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>includeExtension</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstanceMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FastArray</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStaticMethods</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FastArray</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iterator</MethodName>
            <MethodComment>/** 
 * Returns an iterator to iterate over all constant meta classes. This iterator can be seen as making a snapshot of the current state of the registry. The snapshot will include all meta classes that has been used unless they are already collected. Collected meta classes  will be skipped automatically, so you can expect that each element of the iteration is not null. Calling this method is thread safe, the usage of the iterator is not.
 * @return the iterator.
 */
</MethodComment>
            <ReturnType>Iterator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MetaClass[] [refs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;hasNext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureNext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureNext;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setMetaClass;[currentMeta.getTheClass(), currentMeta, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DefaultModuleListener</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>CachedClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onModule</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>module</ParamName>
                    <ParamType>ExtensionModule</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;MetaMethod&gt; [metaMethods=module.getMetaMethods()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>moduleRegistry;addModule;[module]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>