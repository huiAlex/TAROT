<Class>
    <Id>826</Id>
    <Package>org.codehaus.groovy.classgen.asm</Package>
    <ClassName>BytecodeHelper</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Opcodes</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BytecodeHelper  /** 
 * A helper class for bytecode generation with AsmClassGenerator.
 * @author &lt;a href="mailto:james@coredevelopers.net"&gt;James Strachan&lt;/a&gt;
 * @author &lt;a href="mailto:b55r@sina.com"&gt;Bing Ran&lt;/a&gt;
 * @author &lt;a href="mailto:blackdrag@gmx.org"&gt;Jochen Theodorou&lt;/a&gt;
 * @version $Revision$
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>DTT_CLASSNAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getClassInternalName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassInternalName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassInternalName</MethodName>
            <MethodComment>/** 
 * @return the ASM internal name of the type
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameters</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [buffer=new StringBuilder("(")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;[")"]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[getTypeDescription(returnType)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodDescriptor</MethodName>
            <MethodComment>/** 
 * Returns a method descriptor for the given  {@link org.codehaus.groovy.ast.MethodNode}.
 * @param methodNode the method node for which to create the descriptor
 * @return a method descriptor as defined in section JVMS section 4.3.3
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodNode</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodDescriptor</MethodName>
            <MethodComment>/** 
 * @return the ASM method type descriptor
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramTypes</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [buffer=new StringBuilder("(")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;[")"]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[getTypeDescription(returnType)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeDescription</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassLoadingTypeDescription</MethodName>
            <MethodComment>/** 
 * array types are special: eg.: String[]: classname: [Ljava.lang.String; Object:   classname: java.lang.Object int[] :   classname: [I unlike getTypeDescription '.' is not replaced by '/'. it seems that makes problems for the class loading if '.' is replaced by '/'
 * @return the ASM type description for class loading
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [buf=new StringBuilder()]</InnerVar>
                <InnerVar>boolean [array=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeDescription</MethodName>
            <MethodComment>/** 
 * array types are special: eg.: String[]: classname: [Ljava/lang/String; int[]: [I
 * @return the ASM type description
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeDescription</MethodName>
            <MethodComment>/** 
 * array types are special: eg.: String[]: classname: [Ljava/lang/String; int[]: [I
 * @return the ASM type description
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [buf=new StringBuilder()]</InnerVar>
                <InnerVar>ClassNode [d=c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassInternalNames</MethodName>
            <MethodComment>/** 
 * @return an array of ASM internal names of the type
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>names</ParamName>
                    <ParamType>ClassNode[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=names.length]</InnerVar>
                <InnerVar>String[] [answer=new String[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushConstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>negateBoolean</MethodName>
            <MethodComment>/** 
 * negate a boolean on stack. true-&gt;false, false-&gt;true
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Label [endLabel=new Label()]</InnerVar>
                <InnerVar>Label [falseLabel=new Label()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mv;visitJumpInsn;[IFNE, falseLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitInsn;[ICONST_1]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitJumpInsn;[GOTO, endLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitLabel;[falseLabel]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitInsn;[ICONST_0]</InnerMethodInvoke>
                <InnerMethodInvoke>mv;visitLabel;[endLabel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatNameForClassLoading</MethodName>
            <MethodComment>/** 
 * returns a name that Class.forName() can take. Notably for arrays: [I, [Ljava.lang.String; etc Regular object type:  java.lang.String
 * @param name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [prefix=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doReturn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>param</ParamName>
                    <ParamType>Parameter[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasGenerics</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsMethodSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>MethodNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [generics=node.getGenericsTypes()]</InnerVar>
                <InnerVar>Parameter[] [param=node.getParameters()]</InnerVar>
                <InnerVar>ClassNode [returnType=node.getReturnType()]</InnerVar>
                <InnerVar>StringBuilder [ret=new StringBuilder(100)]</InnerVar>
                <InnerVar>GenericsType[] [paramTypes=new GenericsType[param.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getGenericsTypeSpec;[ret, generics]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSubTypes;[ret, paramTypes, "(", ")"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSubTypes;[ret, new GenericsType[]{new GenericsType(returnType)}, "", ""]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesGenericsInClassSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassNode [sclass=node.getUnresolvedSuperClass(false)]</InnerVar>
                <InnerVar>ClassNode[] [interfaces=node.getInterfaces()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [genericsTypes=node.getGenericsTypes()]</InnerVar>
                <InnerVar>StringBuilder [ret=new StringBuilder(100)]</InnerVar>
                <InnerVar>GenericsType [extendsPart=new GenericsType(node.getUnresolvedSuperClass(false))]</InnerVar>
                <InnerVar>ClassNode[] [interfaces=node.getInterfaces()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getGenericsTypeSpec;[ret, genericsTypes]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeGenericsBounds;[ret, extendsPart, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsTypeSpec</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ret</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>genericsTypes</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ret;append;['&lt;']</InnerMethodInvoke>
                <InnerMethodInvoke>ret;append;['&gt;']</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericsBounds</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GenericsType[] [genericsTypes=type.getGenericsTypes()]</InnerVar>
                <InnerVar>StringBuilder [ret=new StringBuilder(100)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeGenericsBoundType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ret</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>printType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writeInterfaceMarker</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeGenericsBounds</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ret</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>GenericsType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writeInterfaceMarker</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSubTypes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ret</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>types</ParamName>
                    <ParamType>GenericsType[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ret;append;[start]</InnerMethodInvoke>
                <InnerMethodInvoke>ret;append;[end]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>load</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>idx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCast</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCastToPrimitive</MethodName>
            <MethodComment>/** 
 * Given a wrapped number type (Byte, Integer, Short, ...), generates bytecode to convert it to a primitive number (int, long, double) using calls to wrapped.[targetType]Value()
 * @param mv method visitor
 * @param sourceType the wrapped number type
 * @param targetType the primitive target type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mv;visitMethodInsn;[INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(sourceType), targetType.getName() + "Value", "()" + BytecodeHelper.getTypeDescription(targetType), false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCastToWrappedType</MethodName>
            <MethodComment>/** 
 * Given a primitive number type (byte, integer, short, ...), generates bytecode to convert it to a wrapped number (Integer, Long, Double) using calls to [WrappedType].valueOf
 * @param mv method visitor
 * @param sourceType the primitive number type
 * @param targetType the wrapped target type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mv;visitMethodInsn;[INVOKESTATIC, getClassInternalName(targetType), "valueOf", "(" + getTypeDescription(sourceType) + ")"+ getTypeDescription(targetType), false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCast</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unbox</MethodName>
            <MethodComment>/** 
 * Generates the bytecode to unbox the current value on the stack
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unbox</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;unbox;[mv, type.getTypeClass()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>box</MethodName>
            <MethodComment>/** 
 * box top level operand
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>box</MethodName>
            <MethodComment>/** 
 * Generates the bytecode to autobox the current value on the stack
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitClassLiteral</MethodName>
            <MethodComment>/** 
 * Visits a class literal. If the type of the classnode is a primitive type, the generated bytecode will be a GETSTATIC Integer.TYPE. If the classnode is not a primitive type, we will generate a LDC instruction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mv</ParamName>
                    <ParamType>MethodVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>classNode</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClassLiteralPossible</MethodName>
            <MethodComment>/** 
 * Tells if a class node is candidate for class literal bytecode optimization. If so, bytecode may use LDC instructions instead of static constant Class fields to retrieve class literals.
 * @param classNode the classnode for which we want to know if bytecode optimization is possible
 * @return true if the bytecode can be optimized
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>classNode</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSameCompilationUnit</MethodName>
            <MethodComment>/** 
 * Returns true if the two classes share the same compilation unit.
 * @param a class a
 * @param b class b
 * @return true if both classes share the same compilation unit
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>ClassNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompileUnit [cu1=a.getCompileUnit()]</InnerVar>
                <InnerVar>CompileUnit [cu2=b.getCompileUnit()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment>/** 
 * Computes a hash code for a string. The purpose of this hashcode is to be constant independently of the JDK being used.
 * @param str the string for which to compute the hashcode
 * @return hashcode of the string
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char[] [chars=str.toCharArray()]</InnerVar>
                <InnerVar>int [h=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>