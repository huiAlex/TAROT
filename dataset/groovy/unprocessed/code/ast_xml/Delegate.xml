<Class>
    <Id>658</Id>
    <Package>groovy.lang</Package>
    <ClassName>Delegate</ClassName>
    <ClassComment>Delegate  /** 
 * Field annotation to automatically delegate part of the functionality of an owner class to the annotated field. &lt;p&gt; All public instance methods present in the type of the annotated field and not present in the owner class will be added to owner class at compile time. The implementation of such automatically added methods is code which calls through to the delegate as per the normal delegate pattern. &lt;p&gt; As an example, consider this code: &lt;pre&gt; class Event { {@code @Delegate} Date whenString title, url } def gr8conf = new Event(title: "GR8 Conference", url: "http://www.gr8conf.org", when: Date.parse("yyyy/MM/dd", "2009/05/18")) def javaOne = new Event(title: "JavaOne", url: "http://java.sun.com/javaone/", when: Date.parse("yyyy/MM/dd", "2009/06/02")) assert gr8conf.before(javaOne.when) &lt;/pre&gt; In this example, the  {@code Event} class will have a method called{@code before(Date otherDate)} as well as other public methods of the{@code Date} class.The implementation of the  {@code before()} method will look like this:&lt;pre&gt; public boolean before(Date otherDate) { return when.before(otherDate); } &lt;/pre&gt; By default, the owner class will also be modified to implement any interfaces implemented by the field. So, in the example above, because  {@code Date}implements  {@code Cloneable} the following will be true:&lt;pre&gt; assert gr8conf instanceof Cloneable &lt;/pre&gt; This behavior can be disabled by setting the annotation's  {@code interfaces} element to false,i.e.  {@code @Delegate(interfaces = false)}, e.g. in the above example, the delegate definition would become: &lt;pre&gt; {@code @Delegate}(interfaces = false) Date when &lt;/pre&gt; and the following would be true: &lt;pre&gt; assert !(gr8conf instanceof Cloneable) &lt;/pre&gt; If multiple delegate fields are used and the same method signature occurs in more than one of the respective field types, then the delegate will be made to the first defined field having that signature. If this does occur, it might be regarded as a smell (or at least poor style) and it might be clearer to do the delegation by long hand. &lt;p&gt; By default, methods of the delegate type marked as  {@code @Deprecated} arenot automatically added to the owner class (but see the technical note about interfaces below). You can force these methods to be added by setting the annotation's  {@code deprecated} element to true,i.e.  {@code @Delegate(deprecated = true)}. &lt;p&gt; For example, in the example above if we change the delegate definition to: &lt;pre&gt; {@code @Delegate}(deprecated = true) Date when &lt;/pre&gt; then the following additional lines will execute successfully (during 2009): &lt;pre&gt; assert gr8conf.year + 1900 == 2009 assert gr8conf.toGMTString().contains(" 2009 ") &lt;/pre&gt; Otherwise these lines produce a groovy.lang.MissingPropertyException or groovy.lang.MissingMethodException respectively as those two methods are {@code @Deprecated} in {@code Date}. &lt;p&gt; &lt;b&gt;Technical notes&lt;/b&gt;: &lt;ul&gt; &lt;li&gt;Static methods, synthetic methods or methods from the &lt;code&gt;GroovyObject&lt;/code&gt; interface are not candidates for delegation&lt;/li&gt; &lt;li&gt;Non-abstract non-static methods defined in the owner class or its superclasses take precedence over methods with identical signatures from a  {@code @Delegate} field&lt;/li&gt;&lt;li&gt;All methods defined in the owner class (including static, abstract or private etc.) take precedence over methods with identical signatures from a  {@code @Delegate} field&lt;/li&gt;&lt;li&gt;Recursive delegation to your own class is not allowed&lt;/li&gt; &lt;li&gt;Mixing of  {@code @Delegate} with default method arguments is known not to work in some cases.We recommend not using these features together.&lt;/li&gt; &lt;li&gt;When the type of the delegate field is an interface, the  {@code deprecated} attribute will beignored if the owner class implements that interface (i.e. you must set  {@code interfaces=false}if you want the  {@code deprecated} attribute to be used). Otherwise, the resulting class wouldnot compile anyway without manually adding in any deprecated methods in the interface.&lt;/li&gt; &lt;/ul&gt;
 * @author Alex Tkachman
 * @author Paul King
 */
</ClassComment>
    <FieldList/>
    <MethodList/>
</Class>