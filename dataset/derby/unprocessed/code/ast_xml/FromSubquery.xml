<Class>
    <Id>551</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>FromSubquery</ClassName>
    <SuperClass>FromTable</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FromSubquery  /** 
 * A FromSubquery represents a subquery in the FROM list of a DML statement. The current implementation of this class is only sufficient for Insert's need to push a new select on top of the one the user specified, to make the selected structure match that of the insert target table.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>subquery</FieldName>
            <FieldType>ResultSetNode</FieldType>
        </Field>
        <Field>
            <FieldName>orderByList</FieldName>
            <FieldType>OrderByList</FieldType>
        </Field>
        <Field>
            <FieldName>offset</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>fetchFirst</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>hasJDBClimitClause</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>origCompilationSchema</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FromSubquery</MethodName>
            <MethodComment>/** 
 * Constructor for a table in a FROM list.
 * @param subquery		The subquery
 * @param orderByList   ORDER BY list if any, or null
 * @param offset        OFFSET if any, or null
 * @param fetchFirst    FETCH FIRST if any, or null
 * @param hasJDBClimitClause True if the offset/fetchFirst clauses comefrom JDBC limit/offset escape syntax
 * @param correlationName	The correlation name
 * @param derivedRCL		The derived column list
 * @param tableProperties	Properties list associated with the table
 * @param cm            The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>subquery</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderByList</ParamName>
                    <ParamType>OrderByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchFirst</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasJDBClimitClause</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>correlationName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>derivedRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setResultColumns;[derivedRCL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubquery</MethodName>
            <MethodComment>/** 
 * Return the "subquery" from this node.
 * @return ResultSetNode	The "subquery" from this node.
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromTableByName</MethodName>
            <MethodComment>/** 
 * Determine whether or not the specified name is an exposed name in the current query block.
 * @param name	The specified name to search for as an exposed name.
 * @param schemaName	Schema name, if non-null.
 * @param exactMatch	Whether or not we need an exact match on specified schema and tablenames or match on table id.
 * @return The FromTable, if any, with the exposed name.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exactMatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindNonVTITables</MethodName>
            <MethodComment>/** 
 * Bind this subquery that appears in the FROM list.
 * @param dataDictionary	The DataDictionary to use for binding
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode		The bound FromSubquery.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindVTITables</MethodName>
            <MethodComment>/** 
 * Bind this subquery that appears in the FROM list.
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode		The bound FromSubquery.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rejectParameters</MethodName>
            <MethodComment>/** 
 * Check for (and reject) ? parameters directly under the ResultColumns. This is done for SELECT statements.  For FromSubquery, we simply pass the check through to the subquery.
 * @exception StandardException		Thrown if a ? parameter founddirectly under a ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;rejectParameters;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressions</MethodName>
            <MethodComment>/** 
 * Bind the expressions in this FromSubquery.  This means  binding the sub-expressions, as well as figuring out what the return  type is for each expression.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromList [emptyFromList=new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerVar>
                <InnerVar>ResultColumnList [derivedRCL=getResultColumns()]</InnerVar>
                <InnerVar>ResultColumnList [subqueryRCL]</InnerVar>
                <InnerVar>FromList [nestedFromList]</InnerVar>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
                <InnerVar>CollectNodesVisitor&lt;FromVTI&gt; [nestedVTIs=new CollectNodesVisitor&lt;FromVTI&gt;(FromVTI.class)]</InnerVar>
                <InnerVar>ResultColumnList [newRcl=subqueryRCL.copyListAndObjects()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;accept;[nestedVTIs]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindOffsetFetch;[offset, fetchFirst]</InnerMethodInvoke>
                <InnerMethodInvoke>newRcl;genVirtualColumnNodes;[subquery, subquery.getResultColumns()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setResultColumns;[newRcl]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMatchingColumn</MethodName>
            <MethodComment>/** 
 * Try to find a ResultColumn in the table represented by this FromBaseTable that matches the name in the given ColumnReference.
 * @param columnReference	The columnReference whose name we're lookingfor in the given table.
 * @return	A ResultColumn whose expression is the ColumnNodethat matches the ColumnReference. Returns null if there is no match.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnReference</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [resultColumn=null]</InnerVar>
                <InnerVar>String [columnsTableName]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess a ResultSetNode - this currently means: o  Generating a referenced table map for each ResultSetNode. o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF). o  Converting the WHERE and HAVING clauses into PredicateLists and classifying them. o  Ensuring that a ProjectRestrictNode is generated on top of every  FromBaseTable and generated in place of every FromSubquery.   o  Pushing single table predicates down to the new ProjectRestrictNodes.
 * @param numTables			The number of tables in the DML Statement
 * @param gbl				The group by list, if any
 * @param fromList			The from list, if any
 * @return ResultSetNode at top of preprocessed tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;pushQueryExpressionSuffix;[]</InnerMethodInvoke>
                <InnerMethodInvoke>subquery;pushOffsetFetchFirst;[offset, fetchFirst, hasJDBClimitClause]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractSubquery</MethodName>
            <MethodComment>/** 
 * Extract out and return the subquery, with a PRN on top. (See FromSubquery.preprocess() for more details.)
 * @param numTables			The number of tables in the DML Statement
 * @return ResultSetNode at top of extracted tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JBitSet [newJBS]</InnerVar>
                <InnerVar>ResultSetNode [newPRN]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newJBS;set;[tableNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>newPRN;setReferencedTableMap;[newJBS]</InnerMethodInvoke>
                <InnerMethodInvoke>((FromTable)newPRN);setTableNumber;[tableNumber]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flatten</MethodName>
            <MethodComment>/** 
 * Flatten this FSqry into the outer query block. The steps in flattening are: o  Mark all ResultColumns as redundant, so that they are "skipped over" at generate(). o  Append the wherePredicates to the outer list. o  Return the fromList so that the caller will merge the 2 lists  RESOLVE - FSqrys with subqueries are currently not flattenable.  Some of them can be flattened, however.  We need to merge the subquery list when we relax this restriction. NOTE: This method returns NULL when flattening RowResultSetNodes (the node for a VALUES clause).  The reason is that no reference is left to the RowResultSetNode after flattening is done - the expressions point directly to the ValueNodes in the RowResultSetNode's ResultColumnList.
 * @param rcl				The RCL from the outer query
 * @param outerPList	PredicateList to append wherePredicates to.
 * @param sql				The SubqueryList from the outer query
 * @param gbl				The group by list, if any
 * @param havingClause      The HAVING clause, if any
 * @return FromList		The fromList from the underlying SelectNode.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerPList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>havingClause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromList [fromList=null]</InnerVar>
                <InnerVar>SelectNode [selectNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getResultColumns();setRedundant;[]</InnerMethodInvoke>
                <InnerMethodInvoke>subquery.getResultColumns();setRedundant;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rcl;remapColumnReferencesToExpressions;[]</InnerMethodInvoke>
                <InnerMethodInvoke>outerPList;remapColumnReferencesToExpressions;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExposedName</MethodName>
            <MethodComment>/** 
 * Get the exposed name for this table, which is the name that can be used to refer to it in the rest of the query.
 * @return	The exposed name for this table.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllResultColumns</MethodName>
            <MethodComment>/** 
 * Expand a "*" into a ResultColumnList with all of the result columns from the subquery.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [exposedName]</InnerVar>
                <InnerVar>TableName [toCompare]</InnerVar>
                <InnerVar>ResultColumnList [rcList=new ResultColumnList((getContextManager()))]</InnerVar>
                <InnerVar>int [rclSize=getResultColumns().visibleSize()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesTarget</MethodName>
            <MethodComment>/** 
 * Search to see if a query references the specifed table name.
 * @param name		Table name (String) to search for.
 * @param baseTable	Whether or not name is for a base table
 * @return	true if found, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUntypedNullsToResultColumns</MethodName>
            <MethodComment>/** 
 * Bind any untyped null nodes to the types in the given ResultColumnList.
 * @param bindingRCL	The ResultColumnList with the types to bind to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bindingRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;bindUntypedNullsToResultColumns;[bindingRCL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementLevel</MethodName>
            <MethodComment>/** 
 * Decrement (query block) level (0-based) for this FromTable. This is useful when flattening a subquery.
 * @param decrement	The amount to decrement by.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>decrement</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;decrementLevel;[decrement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOrigCompilationSchema</MethodName>
            <MethodComment>/** 
 * Associate this subquery with the original compilation schema of a view.
 * @param sd schema descriptor of the original compilation schema of theview.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * @see QueryTreeNode#acceptChildren
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subquery;accept;[v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>