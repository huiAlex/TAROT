<Class>
    <Id>244</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>StringDataValue</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ConcatableDataValue</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>BOTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TRAILING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LEADING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_DERIVATION_NONE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_DERIVATION_IMPLICIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_DERIVATION_EXPLICIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_UCS_BASIC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_TERRITORY_BASED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_TERRITORY_BASED_PRIMARY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_TERRITORY_BASED_SECONDARY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_TERRITORY_BASED_TERTIARY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLLATION_TYPE_TERRITORY_BASED_IDENTICAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>concatenate</MethodName>
            <MethodComment>/** 
 * The SQL concatenation '||' operator.
 * @param leftOperand	String on the left hand side of '||'
 * @param rightOperand	String on the right hand side of '||'
 * @param result	The result of a previous call to this method,null if not called yet.
 * @return	A ConcatableDataValue containing the result of the '||'
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>like</MethodName>
            <MethodComment>/** 
 * The SQL like() function with out escape clause.
 * @param pattern	the pattern to use
 * @return	A BooleanDataValue containing the result of the like
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>like</MethodName>
            <MethodComment>/** 
 * The SQL like() function WITH escape clause.
 * @param pattern	the pattern to use
 * @param escape	the escape character
 * @return	A BooleanDataValue containing the result of the like
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ansiTrim</MethodName>
            <MethodComment>/** 
 * The SQL Ansi trim function.
 * @param trimType type of trim. Possible values are {@link #LEADING},  {@link #TRAILING}or  {@link #BOTH}.
 * @param trimChar  The character to trim from &lt;em&gt;this&lt;/em&gt;
 * @param result The result of a previous call to this method,null if not called yet.
 * @return A StringDataValue containing the result of the trim().
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>trimType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>trimChar</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upper</MethodName>
            <MethodComment>/** 
 * Convert the string to upper case.
 * @param result	The result (reusable - allocate if null).
 * @return	The string converted to upper case.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lower</MethodName>
            <MethodComment>/** 
 * Convert the string to lower case.
 * @param result	The result (reusable - allocate if null).
 * @return	The string converted to lower case.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locate</MethodName>
            <MethodComment>/** 
 * Position in searchFrom of the first occurrence of this.value. The search begins from position start.  0 is returned if searchFrom does not contain this.value.  Position 1 is the first character in searchFrom.
 * @param searchFrom    - The string to search from
 * @param start         - The position to search from in string searchFrom
 * @param result        - The object to return
 * @return  The position in searchFrom the fist occurrence of this.value.0 is returned if searchFrom does not contain this.value.
 * @exception StandardException     Thrown on error
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchFrom</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCharArray</MethodName>
            <MethodComment>/** 
 * Get a char array.  Typically, this is a simple getter that is cheaper than getString() because we always need to create a char array when doing I/O.  Use this instead of getString() where reasonable. &lt;p&gt; &lt;b&gt;WARNING&lt;/b&gt;: may return a character array that has spare characters at the end.  MUST be used in conjunction with getLength() to be safe.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>char[]</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValue</MethodName>
            <MethodComment>/** 
 * Gets either SQLChar/SQLVarchar/SQLLongvarchar/SQLClob(base classes) or  CollatorSQLChar/CollatorSQLVarchar/CollatorSQLLongvarch/CollatorSQLClob (subclasses). Whether this method returns the base class or the subclass  depends on the value of the RuleBasedCollator. If RuleBasedCollator is  null, then the object returned would be baseclass otherwise it would be  subcalss.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collatorForComparison</ParamName>
                    <ParamType>RuleBasedCollator</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStreamHeaderGenerator</MethodName>
            <MethodComment>/** 
 * Returns the stream header generator for the string data value. &lt;p&gt; The generator writes the correct header into the destination buffer or stream and also keeps track of whether appending an end-of-stream marker is required or not. &lt;p&gt; Note that the generator may fail to generate a header if there is no context at the time the header is asked for, and the mode hasn't been set explicitly.
 * @see #setStreamHeaderFormat
 */
</MethodComment>
            <ReturnType>StreamHeaderGenerator</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStreamHeaderFormat</MethodName>
            <MethodComment>/** 
 * Tells the data value descriptor which CLOB stream header format to use.
 * @param usePreTenFiveHdrFormat {@code true} if the database accessed isprior to version 10.5,  {@code false} if the version is 10.5 ornewer, and  {@code null} if unknown at this time
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>usePreTenFiveHdrFormat</ParamName>
                    <ParamType>Boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStreamWithDescriptor</MethodName>
            <MethodComment>/** 
 * Returns a descriptor for the input stream for this data value. &lt;p&gt; The descriptor contains information about header data, current positions, length, whether the stream should be buffered or not, and if the stream is capable of repositioning itself.
 * @return A descriptor for the stream, which includes a reference to thestream itself.
 * @throws StandardException if obtaining the descriptor fails, or if thevalue isn't represented as a stream.
 */
</MethodComment>
            <ReturnType>CharacterStreamDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Stuff a StringDataValue with a Clob.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Clob</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>