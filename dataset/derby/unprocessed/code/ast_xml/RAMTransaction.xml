<Class>
    <Id>1782</Id>
    <Package>org.apache.derby.impl.store.access</Package>
    <ClassName>RAMTransaction</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>XATransactionController</SuperInterface>
        <SuperInterface>TransactionManager</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>rawtran</FieldName>
            <FieldType>Transaction</FieldType>
        </Field>
        <Field>
            <FieldName>accessmanager</FieldName>
            <FieldType>RAMAccessManager</FieldType>
        </Field>
        <Field>
            <FieldName>context</FieldName>
            <FieldType>RAMTransactionContext</FieldType>
        </Field>
        <Field>
            <FieldName>parent_tran</FieldName>
            <FieldType>RAMTransaction</FieldType>
        </Field>
        <Field>
            <FieldName>scanControllers</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>scanControllers</FieldName>
            <FieldType>ScanManager</FieldType>
        </Field>
        <Field>
            <FieldName>conglomerateControllers</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>conglomerateControllers</FieldName>
            <FieldType>ConglomerateController</FieldType>
        </Field>
        <Field>
            <FieldName>sorts</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>sorts</FieldName>
            <FieldType>Sort</FieldType>
        </Field>
        <Field>
            <FieldName>sortControllers</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>sortControllers</FieldName>
            <FieldType>SortController</FieldType>
        </Field>
        <Field>
            <FieldName>freeSortIds</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>freeSortIds</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>tempCongloms</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>tempCongloms</FieldName>
            <FieldType>Long</FieldType>
        </Field>
        <Field>
            <FieldName>nextTempConglomId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>alterTableCallMade</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>transaction_lock_level</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * Constructors for This class:
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myaccessmanager</ParamName>
                    <ParamType>RAMAccessManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>theRawTran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent_tran</ParamName>
                    <ParamType>RAMTransaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RAMTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myaccessmanager</ParamName>
                    <ParamType>RAMAccessManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>theRawTran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent_transaction</ParamName>
                    <ParamType>RAMTransaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;init;[myaccessmanager, theRawTran, parent_transaction]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RAMTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myaccessmanager</ParamName>
                    <ParamType>RAMAccessManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>RAMTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>format_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>global_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>branch_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;init;[myaccessmanager, tc.getRawStoreXact(), null]</InnerMethodInvoke>
                <InnerMethodInvoke>this.context;setTransaction;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>this.rawtran;createXATransactionFromLocalTransaction;[format_id, global_id, branch_id]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RAMTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeControllers</MethodName>
            <MethodComment>/** 
 * Private/Protected methods of This class:
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closeHeldControllers</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>determine_locking_policy</MethodName>
            <MethodComment>/** 
 * Determine correct locking policy for a conglomerate open. &lt;p&gt; Determine from the following table whether to table or record lock the conglomerate we are opening. &lt;p&gt; System level override ------------------------------- user requests                       table locking    record locking -------------                       -------------    -------------- TransactionController.MODE_TABLE     TABLE             TABLE TransactionController.MODE_RECORD    TABLE             RECORD
 */
</MethodComment>
            <ReturnType>LockingPolicy</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requested_lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LockingPolicy [ret_locking_policy]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>determine_lock_level</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requested_lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ret_lock_level]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findExistingConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findConglomerate(conglomId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rtc</ParamName>
                    <ParamType>RAMTransactionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglom</ParamName>
                    <ParamType>Conglomerate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [cc=conglom.open(this,rawtran,hold,open_mode,determine_lock_level(lock_level),determine_locking_policy(lock_level,isolation_level),static_info,dynamic_info)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglomerateControllers;add;[cc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglom</ParamName>
                    <ParamType>Conglomerate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanManager [sm=conglom.openScan(this,rawtran,hold,open_mode,determine_lock_level(lock_level),determine_locking_policy(lock_level,isolation_level),isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator,static_info,dynamic_info)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;add;[sm]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateConglomerateCache</MethodName>
            <MethodComment>/** 
 * Invalidate the conglomerate cache, if necessary.  If an alter table call has been made then invalidate the cache.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addColumnToConglomerate</MethodName>
            <MethodComment>/** 
 * Add a column to a conglomerate.  The conglomerate must not be open in the current transaction.  This also means that there must not be any active scans on it. The column can only be added at the spot just after the current set of columns. The template_column must be nullable. After this call has been made, all fetches of this column from rows that existed in the table prior to this call will return "null".
 * @param conglomId        The identifier of the conglomerate to drop.
 * @param column_id        The column number to add this column at.
 * @param template_column  An instance of the column to be added to table.
 * @param collation_id     collation id of the added column.
 * @exception StandardException Only some types of conglomerates can supportadding a column, for instance "heap" conglomerates support adding a column while "btree" conglomerates do not.  If the column can not be added an exception will be thrown.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template_column</ParamName>
                    <ParamType>Storable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collation_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [is_temporary=(conglomId &lt; 0)]</InnerVar>
                <InnerVar>Conglomerate [conglom=findConglomerate(conglomId)]</InnerVar>
                <InnerVar>ConglomerateController [cc=conglom.open(this,rawtran,false,OPENMODE_FORUPDATE,MODE_TABLE,accessmanager.table_level_policy[TransactionController.ISOLATION_SERIALIZABLE],(StaticCompiledOpenConglomInfo)null,(DynamicCompiledOpenConglomInfo)null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglom;addColumn;[this, column_id, template_column, collation_id]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStaticCompiledConglomInfo</MethodName>
            <MethodComment>/** 
 * Return static information about the conglomerate to be included in a a compiled plan. &lt;p&gt; The static info would be valid until any ddl was executed on the conglomid, and would be up to the caller to throw away when that happened.  This ties in with what language already does for other invalidation of static info.  The type of info in this would be containerid and array of format id's from which templates can be created. The info in this object is read only and can be shared among as many threads as necessary. &lt;p&gt;
 * @return The static compiled information.
 * @param conglomId The identifier of the conglomerate to open.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>StaticCompiledOpenConglomInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDynamicCompiledConglomInfo</MethodName>
            <MethodComment>/** 
 * Return dynamic information about the conglomerate to be dynamically reused in repeated execution of a statement. &lt;p&gt; The dynamic info is a set of variables to be used in a given ScanController or ConglomerateController.  It can only be used in one controller at a time.  It is up to the caller to insure the correct thread access to this info.  The type of info in this is a scratch template for btree traversal, other scratch variables for qualifier evaluation, ... &lt;p&gt;
 * @return The dynamic information.
 * @param conglomId The identifier of the conglomerate to open.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DynamicCompiledOpenConglomInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countCreatedSorts</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [ret_val=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countOpens</MethodName>
            <MethodComment>/** 
 * Report on the number of open conglomerates in the transaction. &lt;p&gt; There are 4 types of open "conglomerates" that can be tracked, those opened by each of the following: openConglomerate(), openScan(),  openSort(), and openSortScan().  This routine can be used to either report on the number of all opens, or may be used to track one  particular type of open. This routine is expected to be used for debugging only.  An  implementation may only track this info under SanityManager.DEBUG mode. If the implementation does not track the info it will return -1 (so code using this call to verify that no congloms are open should check for return &amp;lt;= 0 rather than == 0). The return value depends on the "which_to_count" parameter as follows: OPEN_CONGLOMERATE  - return # of openConglomerate() calls not close()'d. OPEN_SCAN          - return # of openScan() calls not close()'d. OPEN_CREATED_SORTS - return # of sorts created (createSort()) in  current xact.  There is currently no way to get rid of these sorts before end of transaction. OPEN_SORT          - return # of openSort() calls not close()'d. OPEN_TOTAL         - return total # of all above calls not close()'d. - note an implementation may return -1 if it does not track the above information.
 * @return The nunber of open's of a type indicated by "which_to_count"parameter.
 * @param which_to_count Which kind of open to report on.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>which_to_count</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ret_val=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConglomerate</MethodName>
            <MethodComment>/** 
 * Create a new conglomerate. &lt;p&gt;
 * @see TransactionController#createConglomerate
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implementation</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrder</ParamName>
                    <ParamType>ColumnOrdering[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodFactory [mfactory]</InnerVar>
                <InnerVar>ConglomerateFactory [cfactory=(ConglomerateFactory)mfactory]</InnerVar>
                <InnerVar>int [segment]</InnerVar>
                <InnerVar>long [conglomid]</InnerVar>
                <InnerVar>Conglomerate [conglom=cfactory.createConglomerate(this,segment,conglomid,template,columnOrder,collationIds,properties,temporaryFlag)]</InnerVar>
                <InnerVar>long [conglomId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createAndLoadConglomerate</MethodName>
            <MethodComment>/** 
 * Create a conglomerate and populate it with rows from rowSource.
 * @see TransactionController#createAndLoadConglomerate
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implementation</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrder</ParamName>
                    <ParamType>ColumnOrdering[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowLocationRetRowSource</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recreateAndLoadConglomerate</MethodName>
            <MethodComment>/** 
 * recreate a conglomerate and populate it with rows from rowSource.
 * @see TransactionController#createAndLoadConglomerate
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implementation</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recreate_ifempty</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrder</ParamName>
                    <ParamType>ColumnOrdering[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orig_conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowLocationRetRowSource</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [conglomId=createConglomerate(implementation,template,columnOrder,collationIds,properties,temporaryFlag)]</InnerVar>
                <InnerVar>long [rows_loaded=loadConglomerate(conglomId,true,rowSource)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugOpened</MethodName>
            <MethodComment>/** 
 * Return a string with debug information about opened congloms/scans/sorts. &lt;p&gt; Return a string with debugging information about current opened congloms/scans/sorts which have not been close()'d. Calls to this routine are only valid under code which is conditional on SanityManager.DEBUG. &lt;p&gt;
 * @return String with debugging information.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [str=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomerateExists</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findConglomerate(conglomId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglom;drop;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchMaxOnBtree</MethodName>
            <MethodComment>/** 
 * Retrieve the maximum value row in an ordered conglomerate. &lt;p&gt; Returns true and fetches the rightmost row of an ordered conglomerate  into "fetchRow" if there is at least one row in the conglomerate.  If there are no rows in the conglomerate it returns false. &lt;p&gt; Non-ordered conglomerates will not implement this interface, calls will generate a StandardException. &lt;p&gt; RESOLVE - this interface is temporary, long term equivalent (and more)  functionality will be provided by the openBackwardScan() interface.  
 * @param conglomId       The identifier of the conglomerateto open the scan for.
 * @param open_mode       Specifiy flags to control opening of table.  OPENMODE_FORUPDATE - if set open the table for update otherwise open table shared.
 * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
 * @param isolation_level The isolation level to lock the conglomerate at.One of (ISOLATION_READ_COMMITTED or  ISOLATION_SERIALIZABLE).
 * @param scanColumnList  A description of which columns to return from every fetch in the scan.  template,  and scanColumnList work together to describe the row to be returned by the scan -  see RowUtil for description of how these three  parameters work together to describe a "row".
 * @param fetchRow        The row to retrieve the maximum value into.
 * @return boolean indicating if a row was found and retrieved or not.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserCreateConglomPropList</MethodName>
            <MethodComment>/** 
 * A superset of properties that "users" can specify. &lt;p&gt; A superset of properties that "users" (ie. from sql) can specify.  Store may implement other properties which should not be specified by users. Layers above access may implement properties which are not known at all to Access. &lt;p&gt; This list is a superset, as some properties may not be implemented by certain types of conglomerates.  For instant an in-memory store may not implement a pageSize property.  Or some conglomerates may not support pre-allocation. &lt;p&gt; This interface is meant to be used by the SQL parser to do validation of properties passsed to the create table statement, and also by the various user interfaces which present table information back to the  user. &lt;p&gt; Currently this routine returns the following list: derby.storage.initialPages derby.storage.minimumRecordSize derby.storage.pageReservedSpace derby.storage.pageSize
 * @return The superset of properties that "users" can specify.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Properties [ret_properties=ConglomerateUtil.createUserRawStorePropertySet((Properties)null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIdle</MethodName>
            <MethodComment>/** 
 * Reveals whether the transaction has ever read or written data.
 * @return true If the transaction has never read or written data.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGlobal</MethodName>
            <MethodComment>/** 
 * Reveals whether the transaction is a global or local transaction.
 * @return true If the transaction was either started by AccessFactory.startXATransaction() or was morphed to a global transaction by calling  AccessFactory.createXATransactionFromLocalTransaction().
 * @see AccessFactory#startXATransaction
 * @see TransactionController#createXATransactionFromLocalTransaction
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPristine</MethodName>
            <MethodComment>/** 
 * Reveals whether the transaction is currently pristine.
 * @return true If the transaction is Pristine.
 * @see TransactionController#isPristine
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXATransactionFromLocalTransaction</MethodName>
            <MethodComment>/** 
 * Convert a local transaction to a global transaction. &lt;p&gt; Get a transaction controller with which to manipulate data within the access manager.  Tbis controller allows one to manipulate a  global XA conforming transaction. &lt;p&gt; Must only be called a previous local transaction was created and exists in the context.  Can only be called if the current transaction is in the idle state.  Upon return from this call the old tc will be unusable, and all references to it should be dropped (it will have been implicitly destroy()'d by this call. &lt;p&gt; The (format_id, global_id, branch_id) triplet is meant to come exactly from a javax.transaction.xa.Xid.  We don't use Xid so that the system can be delivered on a non-1.2 vm system and not require the javax classes in the path.  
 * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
 * @param global_id the global transaction identifier part of XID - ie.Xid.getGlobalTransactionId().
 * @param branch_id The branch qualifier of the Xid - ie. Xid.getBranchQaulifier()
 * @exception StandardException Standard exception policy.
 * @see TransactionController
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>format_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>global_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>branch_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getRawStoreXact();createXATransactionFromLocalTransaction;[format_id, global_id, branch_id]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadConglomerate</MethodName>
            <MethodComment>/** 
 * Bulk load into the conglomerate.  Rows being loaded into the conglomerate are not logged.
 * @param conglomId The conglomerate Id.
 * @param createConglom If true, the conglomerate is being created in thesame operation as the loadConglomerate.  The enables further optimization as recovery does not require page allocation to be logged. 
 * @param rowSource Where the rows come from.
 * @return true The number of rows loaded.
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createConglom</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowLocationRetRowSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadConglomerate</MethodName>
            <MethodComment>/** 
 * Use this for incremental load in the future.  
 * @param conglomId the conglomerate Id
 * @param rowSource where the rows to be loaded comes from 
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowLocationRetRowSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadConglomerate;[conglomId, false, rowSource]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logAndDo</MethodName>
            <MethodComment>/** 
 * Log an operation and then action it in the context of this transaction. &lt;p&gt; This simply passes the operation to the RawStore which logs and does it. &lt;p&gt;
 * @param operation the operation that is to be applied
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operation</ParamName>
                    <ParamType>Loggable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;logAndDo;[operation]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openCompiledConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findConglomid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>container_id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findContainerid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglom_id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createBackingStoreHashtableFromScan</MethodName>
            <MethodComment>/** 
 * Create a BackingStoreHashtable which contains all rows that qualify for the described scan.
 */
</MethodComment>
            <ReturnType>BackingStoreHashtable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key_column_numbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remove_duplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>estimated_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_inmemory_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadFactor</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collect_runtimestats</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>skipNullKeyColumns</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keepAfterCommit</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>includeRowLocations</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openGroupFetchScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroupFetchScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
                <InnerVar>ScanManager [sm=conglom.openScan(this,rawtran,hold,open_mode,determine_lock_level(lock_level),determine_locking_policy(lock_level,isolation_level),isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator,(StaticCompiledOpenConglomInfo)null,(DynamicCompiledOpenConglomInfo)null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;add;[sm]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeConglomerate</MethodName>
            <MethodComment>/** 
 * Purge all committed deleted rows from the conglomerate. &lt;p&gt; This call will purge committed deleted rows from the conglomerate, that space will be available for future inserts into the conglomerate. &lt;p&gt;
 * @param conglomId Id of the conglomerate to purge.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>findExistingConglomerate(conglomId);purgeConglomerate;[this, rawtran]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressConglomerate</MethodName>
            <MethodComment>/** 
 * Return free space from the conglomerate back to the OS. &lt;p&gt; Returns free space from the conglomerate back to the OS.  Currently only the sequential free pages at the "end" of the conglomerate can be returned to the OS. &lt;p&gt;
 * @param conglomId Id of the conglomerate to purge.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>findExistingConglomerate(conglomId);compressConglomerate;[this, rawtran]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defragmentConglomerate</MethodName>
            <MethodComment>/** 
 * Compress table in place. &lt;p&gt; Returns a GroupFetchScanController which can be used to move rows around in a table, creating a block of free pages at the end of the table.  The process will move rows from the end of the table toward the beginning.  The GroupFetchScanController will return the  old row location, the new row location, and the actual data of any row moved.  Note that this scan only returns moved rows, not an entire set of rows, the scan is designed specifically to be used by either explicit user call of the SYSCS_ONLINE_COMPRESS_TABLE() procedure, or internal background calls to compress the table. The old and new row locations are returned so that the caller can update any indexes necessary. This scan always returns all collumns of the row. All inputs work exactly as in openScan().  The return is  a GroupFetchScanController, which only allows fetches of groups of rows from the conglomerate. &lt;p&gt;
 * @return The GroupFetchScanController to be used to fetch the rows.
 * @param conglomId             see openScan()
 * @param hold                  see openScan()
 * @param open_mode             see openScan()
 * @param lock_level            see openScan()
 * @param isolation_level       see openScan()
 * @exception StandardException  Standard exception policy.
 * @see ScanController
 * @see GroupFetchScanController
 */
</MethodComment>
            <ReturnType>GroupFetchScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>online</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
                <InnerVar>ScanManager [sm=conglom.defragmentConglomerate(this,rawtran,hold,open_mode,determine_lock_level(lock_level),determine_locking_policy(lock_level,isolation_level),isolation_level)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;add;[sm]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openCompiledScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openStoreCost</MethodName>
            <MethodComment>/** 
 * Return an open StoreCostController for the given conglomid. &lt;p&gt; Return an open StoreCostController which can be used to ask about  the estimated row counts and costs of ScanController and  ConglomerateController operations, on the given conglomerate. &lt;p&gt;
 * @return The open StoreCostController.
 * @param conglomId The identifier of the conglomerate to open.
 * @exception StandardException  Standard exception policy.
 * @see StoreCostController
 */
</MethodComment>
            <ReturnType>StoreCostController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=findExistingConglomerate(conglomId)]</InnerVar>
                <InnerVar>StoreCostController [scc=conglom.openStoreCost(this,rawtran)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSort</MethodName>
            <MethodComment>/** 
 * @see TransactionController#createSort
 * @exception StandardException Standard error policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implParameters</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrdering</ParamName>
                    <ParamType>ColumnOrdering</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sortObserver</ParamName>
                    <ParamType>SortObserver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alreadyInOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>estimatedRows</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>estimatedRowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [implementation=null]</InnerVar>
                <InnerVar>MethodFactory [mfactory]</InnerVar>
                <InnerVar>SortFactory [sfactory=(SortFactory)mfactory]</InnerVar>
                <InnerVar>int [segment=0]</InnerVar>
                <InnerVar>Sort [sort=sfactory.createSort(this,segment,implParameters,template,columnOrdering,sortObserver,alreadyInOrder,estimatedRows,estimatedRowSize)]</InnerVar>
                <InnerVar>int [sortid]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSort</MethodName>
            <MethodComment>/** 
 * Drop a sort.  &lt;p&gt; Drop a sort created by a call to createSort() within the current  transaction (sorts are automatically "dropped" at the end of a  transaction.  This call should only be made after all openSortScan()'s and openSort()'s have been closed. &lt;p&gt;
 * @param sortid The identifier of the sort to drop, as returned from createSort.
 * @exception StandardException From a lower-level exception.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sortid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sort [sort=sorts.get((int)sortid)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment>/** 
 * @see TransactionController#getProperty
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Serializable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPropertyDefault</MethodName>
            <MethodComment>/** 
 * @see TransactionController#getPropertyDefault
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Serializable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperty</MethodName>
            <MethodComment>/** 
 * @see TransactionController#setProperty
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dbOnlyProperty</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>accessmanager.getTransactionalProperties();setProperty;[this, key, value, dbOnlyProperty]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPropertyDefault</MethodName>
            <MethodComment>/** 
 * @see TransactionController#setProperty
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>accessmanager.getTransactionalProperties();setPropertyDefault;[this, key, value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>propertyDefaultIsVisible</MethodName>
            <MethodComment>/** 
 * @see TransactionController#propertyDefaultIsVisible
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperties</MethodName>
            <MethodComment>/** 
 * @see TransactionController#getProperties
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openSort</MethodName>
            <MethodComment>/** 
 * @see TransactionController#openSort
 * @exception StandardException Standard error policy.
 */
</MethodComment>
            <ReturnType>SortController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sort [sort]</InnerVar>
                <InnerVar>SortController [sc=sort.open(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sortControllers;add;[sc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openSortCostController</MethodName>
            <MethodComment>/** 
 * Return an open SortCostController. &lt;p&gt; Return an open SortCostController which can be used to ask about  the estimated costs of SortController() operations. &lt;p&gt;
 * @return The open StoreCostController.
 * @exception StandardException  Standard exception policy.
 * @see StoreCostController
 */
</MethodComment>
            <ReturnType>SortCostController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [implementation=null]</InnerVar>
                <InnerVar>MethodFactory [mfactory]</InnerVar>
                <InnerVar>SortFactory [sfactory=(SortFactory)mfactory]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openSortScan</MethodName>
            <MethodComment>/** 
 * @see TransactionController#openSortScan
 * @exception StandardException Standard error policy.
 */
</MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sort [sort]</InnerVar>
                <InnerVar>ScanManager [sc=sort.openSortScan(this,hold)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;add;[sc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openSortRowSource</MethodName>
            <MethodComment>/** 
 * @see TransactionController#openSortRowSource
 * @exception StandardException Standard error policy.
 */
</MethodComment>
            <ReturnType>RowLocationRetRowSource</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Sort [sort]</InnerVar>
                <InnerVar>ScanControllerRowSource [sc=sort.openSortRowSource(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;add;[(ScanManager)sc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this;closeControllers;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>rawtran;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commitNoSync</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DatabaseInstant</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this;closeControllers;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>abort</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invalidateConglomerateCache;[]</InnerMethodInvoke>
                <InnerMethodInvoke>this;closeControllers;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>rawtran;abort;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextManager</MethodName>
            <MethodComment>/** 
 * Get the context manager that the transaction was created with. &lt;p&gt;
 * @return The context manager that the transaction was created with.
 */
</MethodComment>
            <ReturnType>ContextManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSavePoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseSavePoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rollbackToSavePoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>close_controllers</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>destroy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>anyoneBlocked</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_commit</MethodName>
            <MethodComment>/** 
 * This method is called to commit the current XA global transaction. &lt;p&gt; RESOLVE - how do we map to the "right" XAExceptions. &lt;p&gt;
 * @param onePhase If true, the resource manager should use a one-phasecommit protocol to commit the work done on behalf of  current xid.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onePhase</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;xa_commit;[onePhase]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_prepare</MethodName>
            <MethodComment>/** 
 * This method is called to ask the resource manager to prepare for a transaction commit of the transaction specified in xid. &lt;p&gt;
 * @return         A value indicating the resource manager's vote on thethe outcome of the transaction.  The possible values are:  XA_RDONLY or XA_OK.  If the resource manager wants to roll back the transaction, it should do so by  throwing an appropriate XAException in the prepare method.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_rollback</MethodName>
            <MethodComment>/** 
 * rollback the current global transaction. &lt;p&gt; The given transaction is roll'ed back and it's history is not maintained in the transaction table or long term log. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;xa_rollback;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findExistingConglomerateFromKey</MethodName>
            <MethodComment>/** 
 * Return existing Conglomerate after doing lookup by ContainerKey &lt;p&gt; Throws exception if it can't find a matching conglomerate for the  ContainerKey.
 * @return If successful returns 
 * @param container_key  container key of target conglomerate.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>container_key</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPostCommitWork</MethodName>
            <MethodComment>/** 
 * Add to the list of post commit work. &lt;p&gt; Add to the list of post commit work that may be processed after this transaction commits.  If this transaction aborts, then the post commit work list will be thrown away.  No post commit work will be taken out on a rollback to save point. &lt;p&gt; This routine simply delegates the work to the Rawstore transaction.
 * @param work  The post commit work to do.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;addPostCommitWork;[work]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkVersion</MethodName>
            <MethodComment>/** 
 * Check to see if a database has been upgraded to the required level in order to use a store feature.
 * @param requiredMajorVersion  required database Engine major version
 * @param requiredMinorVersion  required database Engine minor version
 * @param feature               Non-null to throw an exception, null to return the state of the version match.
 * @return &lt;code&gt; true &lt;/code&gt; if the database has been upgraded to the required level, &lt;code&gt; false &lt;/code&gt; otherwise.
 * @exception StandardException if the database is not at the require version  when &lt;code&gt;feature&lt;/code&gt; feature is  not &lt;code&gt; null &lt;/code&gt;. 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requiredMajorVersion</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requiredMinorVersion</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>feature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeMe</MethodName>
            <MethodComment>/** 
 * The ConglomerateController.close() method has been called on  "conglom_control". &lt;p&gt; Take whatever cleanup action is appropriate to a closed  conglomerateController.  It is likely this routine will remove references to the ConglomerateController object that it was maintaining for cleanup purposes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglom_control</ParamName>
                    <ParamType>ConglomerateController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglomerateControllers;remove;[conglom_control]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeMe</MethodName>
            <MethodComment>/** 
 * The SortController.close() method has been called on "sort_control". &lt;p&gt; Take whatever cleanup action is appropriate to a closed  sortController.  It is likely this routine will remove references to the SortController object that it was maintaining for cleanup purposes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sort_control</ParamName>
                    <ParamType>SortController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sortControllers;remove;[sort_control]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeMe</MethodName>
            <MethodComment>/** 
 * The ScanManager.close() method has been called on "scan". &lt;p&gt; Take whatever cleanup action is appropriate to a closed scan.  It is likely this routine will remove references to the scan object that it was maintaining for cleanup purposes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scan</ParamName>
                    <ParamType>ScanManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanControllers;remove;[scan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAccessManager</MethodName>
            <MethodComment>/** 
 * Get reference to access factory which started this transaction. &lt;p&gt;
 * @return The AccessFactory which started this transaction.
 */
</MethodComment>
            <ReturnType>AccessFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInternalTransaction</MethodName>
            <MethodComment>/** 
 * Get an Internal transaction. &lt;p&gt; Start an internal transaction.  An internal transaction is a completely separate transaction from the current user transaction.  All work done in the internal transaction must be physical (ie. it can be undone  physically by the rawstore at the page level, rather than logically  undone like btree insert/delete operations).  The rawstore guarantee's that in the case of a system failure all open Internal transactions are first undone in reverse order, and then other transactions are undone in reverse order. &lt;p&gt; Internal transactions are meant to implement operations which, if  interupted before completion will cause logical operations like tree searches to fail.  This special undo order insures that the state of the tree is restored to a consistent state before any logical undo  operation which may need to search the tree is performed. &lt;p&gt;
 * @return The new internal transaction.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>TransactionManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ContextManager [cm=getContextManager()]</InnerVar>
                <InnerVar>Transaction [rawtran=accessmanager.getRawStore().startInternalTransaction(cm)]</InnerVar>
                <InnerVar>RAMTransaction [rt=new RAMTransaction(accessmanager,rawtran,null)]</InnerVar>
                <InnerVar>RAMTransactionContext [rtc=new RAMTransactionContext(cm,AccessFactoryGlobals.RAMXACT_INTERNAL_CONTEXT_ID,rt,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;setDefaultLockingPolicy;[accessmanager.getDefaultLockingPolicy()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startNestedUserTransaction</MethodName>
            <MethodComment>/** 
 * Get an nested user transaction. &lt;p&gt; A nested user can be used exactly as any other TransactionController, except as follows.  For this discussion let the parent transaction  be the transaction used to make the getNestedUserTransaction(), and let the child transaction be the transaction returned by the  getNestedUserTransaction() call. &lt;p&gt; The nesting is limited to one level deep.  An exception will be thrown if a subsequent getNestedUserTransaction() is called on the child transaction. &lt;p&gt; The locks in the child transaction will be compatible with the locks of the parent transaction. &lt;p&gt; A commit in the child transaction will release locks associated with the child transaction only, work can continue in the parent transaction at this point.   &lt;p&gt; Any abort of the child transaction will result in an abort of both the child transaction and parent transaction. &lt;p&gt; A TransactionController.destroy() call should be made on the child transaction once all child work is done, and the caller wishes to  continue work in the parent transaction. &lt;p&gt; Nested internal transactions are meant to be used to implement  system work necessary to commit as part of implementing a user's request, but where holding the lock for the duration of the user transaction is not acceptable.  2 examples of this are system catalog read locks accumulated while compiling a plan, and auto-increment. &lt;p&gt;
 * @param readOnly                 Is transaction readonly?  Only 1 non-readonly nested transaction is allowed per  transaction.
 * @param flush_log_on_xact_end    By default should the transaction commitand abort be synced to the log.  Normal usage should pick true, unless there is specific performance need and usage  works correctly if a commit can be lost on system crash.
 * @return The new nested user transaction.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>readOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flush_log_on_xact_end</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContextManager [cm=getContextManager()]</InnerVar>
                <InnerVar>Transaction [child_rawtran=((readOnly) ? accessmanager.getRawStore().startNestedReadOnlyUserTransaction(rawtran,getLockSpace(),cm,AccessFactoryGlobals.NESTED_READONLY_USER_TRANS) : accessmanager.getRawStore().startNestedUpdateUserTransaction(rawtran,cm,AccessFactoryGlobals.NESTED_UPDATE_USER_TRANS,flush_log_on_xact_end))]</InnerVar>
                <InnerVar>RAMTransaction [rt=new RAMTransaction(accessmanager,child_rawtran,this)]</InnerVar>
                <InnerVar>RAMTransactionContext [rtc=new RAMTransactionContext(cm,AccessFactoryGlobals.RAMXACT_CHILD_CONTEXT_ID,rt,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>child_rawtran;setDefaultLockingPolicy;[accessmanager.getDefaultLockingPolicy()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawStoreXact</MethodName>
            <MethodComment>/** 
 * Get the Transaction from the Transaction manager. &lt;p&gt; Access methods often need direct access to the "Transaction" - ie. the raw store transaction, so give access to it.
 * @return The raw store transaction.
 */
</MethodComment>
            <ReturnType>Transaction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileHandler</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileResource</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockSpace</MethodName>
            <MethodComment>/** 
 * Return an object that when used as the compatibility space, &lt;strong&gt;and&lt;/strong&gt; the object returned when calling &lt;code&gt;getOwner()&lt;/code&gt; on that object is used as group for a lock request, guarantees that the lock will be removed on a commit or an abort.
 */
</MethodComment>
            <ReturnType>CompatibilitySpace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNoLockWait</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}&lt;p&gt; For now, this only works if the transaction has its own compatibility space. If it has inherited the compatibility space from its parent, the request will be ignored (or cause a failure in debug builds).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>noWait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawtran;setNoLockWait;[noWait]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionIdString</MethodName>
            <MethodComment>/** 
 * Get string id of the transaction. &lt;p&gt; This transaction "name" will be the same id which is returned in the TransactionInfo information, used by the lock and transaction vti's to identify transactions. &lt;p&gt; Although implementation specific, the transaction id is usually a number which is bumped every time a commit or abort is issued. &lt;p&gt; For now return the toString() method, which does what we want.  Later if that is not good enough we can add public raw tran interfaces to get exactly what we want.
 * @return The a string which identifies the transaction.  
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActiveStateTxIdString</MethodName>
            <MethodComment>/** 
 * Get string id of the transaction that would be when the Transaction is IN active state.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [str=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>