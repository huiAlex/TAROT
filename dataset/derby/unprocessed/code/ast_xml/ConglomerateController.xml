<Class>
    <Id>1704</Id>
    <Package>org.apache.derby.iapi.store.access</Package>
    <ClassName>ConglomerateController</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ConglomPropertyQueryable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ConglomerateController  /** 
 * A conglomerate is an abstract storage structure (they correspond to access methods).  The ConglomerateController interface is the interface that access manager clients can use to manipulate the contents of the underlying conglomerate. &lt;p&gt; Each conglomerate holds a set of rows.  Each row has a row location. The conglomerate provides methods for: &lt;ul&gt; &lt;li&gt; Inserting rows, &lt;li&gt; Fetching, deleting, and replacing entire rows by row location, and &lt;li&gt; fetching and updating individual columns of a row identified by row location. &lt;/ul&gt; &lt;p&gt; Conglomerates do not provide any mechanism for associative access to rows within the conglomerate; this type of access is provided by scans via the ScanController interface. &lt;p&gt; Although all conglomerates have the same interface, they have different implementations.  The implementation of a conglomerate determines some of its user-visible semantics; for example whether the rows are ordered or what the types of the rows' columns must be.  The implementation is specified by an implementation id.  Currently there are two implementations, "heap", and "btree".  The details of their behavior are specified in their implementation documentation.  (Currently, only "heap" is implemented). &lt;p&gt; All conglomerate operations are subject to the transactional isolation of the transaction they were opened from.  Transaction rollback will close all conglomerates.  Transaction commit will close all non-held conglomerates. &lt;p&gt; Scans are opened from a TransactionController. &lt;P&gt; A ConglomerateController can handle partial rows. Partial rows are described in RowUtil.
 * @see TransactionController#openConglomerate
 * @see RowUtil
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>ROWISDUPLICATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOCK_READ</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOCK_UPD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOCK_INS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOCK_INS_PREVKEY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOCK_UPDATE_LOCKS</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the conglomerate controller. &lt;p&gt; Close the conglomerate controller.  Callers must not use the conglomerate controller after calling close.  It is strongly recommended that callers clear out the reference after closing, e.g.,  &lt;p&gt; &lt;blockquote&gt;&lt;pre&gt; ConglomerateController cc; cc.close; cc = null; &lt;/pre&gt;&lt;/blockquote&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeForEndTransaction</MethodName>
            <MethodComment>/** 
 * Close conglomerate controller as part of terminating a transaction. &lt;p&gt; Use this call to close the conglomerate controller resources as part of committing or aborting a transaction.  The normal close() routine may  do some cleanup that is either unnecessary, or not correct due to the  unknown condition of the controller following a transaction ending error. Use this call when closing all controllers as part of an abort of a  transaction. &lt;p&gt; This call is meant to only be used internally by the Storage system, clients of the storage system should use the simple close() interface. &lt;p&gt; RESOLVE (mikem) - move this call to ConglomerateManager so it is obvious that non-access clients should not call this.
 * @param closeHeldScan           If true, means to close controller even ifit has been opened to be kept opened  across commit.  This is used to close these controllers on abort.
 * @return boolean indicating that the close has resulted in a real closeof the controller.  A held scan will return false if  called by closeForEndTransaction(false), otherwise it  will return true.  A non-held scan will always return  true.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closeHeldScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkConsistency</MethodName>
            <MethodComment>/** 
 * Check consistency of a conglomerate. Checks the consistency of the data within a given conglomerate, does not check consistency external to the conglomerate (ie. does not check that  base table row pointed at by a secondary index actually exists). Raises a StandardException on first consistency problem. 
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delete</MethodName>
            <MethodComment>/** 
 * Delete a row from the conglomerate.  
 * @return Returns true if delete was successful, false if the record pointedat no longer represents a valid record.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetch</MethodName>
            <MethodComment>/** 
 * Fetch the (partial) row at the given location. &lt;p&gt;
 * @param loc             The "RowLocation" which describes the exact rowto fetch from the table.
 * @param destRow         The row to read the data into.
 * @param validColumns    A description of which columns to return fromrow on the page into "destRow."  destRow and validColumns work together to describe the row to be returned by the fetch -  see RowUtil for description of how these three  parameters work together to describe a fetched  "row".
 * @return Returns true if fetch was successful, false if the record pointed at no longer represents a valid record.
 * @exception StandardException  Standard exception policy.
 * @see RowUtil
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>destRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetch</MethodName>
            <MethodComment>/** 
 * Fetch the (partial) row at the given location. &lt;p&gt;
 * @param loc             The "RowLocation" which describes the exact rowto fetch from the table.
 * @param destRow         The row to read the data into.
 * @param validColumns    A description of which columns to return fromrow on the page into "destRow."  destRow and validColumns work together to describe the row to be returned by the fetch -  see RowUtil for description of how these three  parameters work together to describe a fetched  "row".
 * @param waitForLock     If false, then the call will throw a lock timeoutexception immediately, if the lock can not be granted without waiting.  If true call will  act exactly as fetch() interface with no  waitForLock parameter.
 * @return Returns true if fetch was successful, false if the record pointed at no longer represents a valid record.
 * @exception StandardException  Standard exception policy.
 * @see RowUtil
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>destRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>waitForLock</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insert</MethodName>
            <MethodComment>/** 
 * Insert a row into the conglomerate.
 * @param row The row to insert into the conglomerate.  The storedrepresentations of the row's columns are copied into a new row somewhere in the conglomerate.
 * @return Returns 0 if insert succeeded.  Returns ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness checks and has been created to disallow duplicates, and the row inserted had key columns which were duplicate of a row already in the table.  Other insert failures will raise StandardException's.
 * @exception StandardException Standard exception policy.
 * @see RowUtil
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAndFetchLocation</MethodName>
            <MethodComment>/** 
 * insert row and fetch it's row location in one operation. &lt;p&gt; Insert a row into the conglomerate, and store its location in  the provided destination row location.  The row location must be of the correct type for this conglomerate (a new row location of the correct  type can be obtained from newRowLocationTemplate()).
 * @param row           The row to insert into the conglomerate.  The stored representations of the row's columns are  copied into a new row somewhere in the conglomerate.
 * @param destRowLocation The rowlocation to read the inserted row locationinto.
 * @exception StandardException  Standard exception policy.
 * @see RowUtil
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>destRowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isKeyed</MethodName>
            <MethodComment>/** 
 * Return whether this is a keyed conglomerate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockRow</MethodName>
            <MethodComment>/** 
 * Lock the given row location. &lt;p&gt; Should only be called by access. &lt;p&gt; This call can be made on a ConglomerateController that was opened for locking only. &lt;p&gt; RESOLVE (mikem) - move this call to ConglomerateManager so it is obvious that non-access clients should not call this.
 * @return true if lock was granted, only can be false if wait was false.
 * @param loc           The "RowLocation" of the exact row to lock.
 * @param lock_oper     For what operation are we requesting the lock, thisshould be one of the following 4 options: LOCK_READ [read lock],  (LOCK_INS | LOCK_UPD) [ lock for insert],  (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for  previous key to insert], (LOCK_UPD) [lock for delete or replace] (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for  update, will upgrade lock later if actual update is take place]
 * @param wait          Should the lock call wait to be granted?
 * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,then lock will be released immediately after being granted.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_oper</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_duration</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockRow</MethodName>
            <MethodComment>/** 
 * Lock the given record id/page num pair. &lt;p&gt; Should only be called by access, to lock "special" locks formed from the Recordhandle.* reserved constants for page specific locks. &lt;p&gt; This call can be made on a ConglomerateController that was opened for locking only. &lt;p&gt; RESOLVE (mikem) - move this call to ConglomerateManager so it is obvious that non-access clients should not call this.
 * @return true if lock was granted, only can be false if wait was false.
 * @param page_num      page number of record to lock.
 * @param record_id     record id of record to lock.
 * @param lock_oper     For what operation are we requesting the lock, thisshould be one of the following 4 options: LOCK_READ [read lock],  (LOCK_INS | LOCK_UPD) [ lock for insert],  (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for  previous key to insert], (LOCK_UPD) [lock for delete or replace] (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for  update, will upgrade lock later if actual update is take place]
 * @param wait          Should the lock call wait to be granted?
 * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,then lock will be released immediately after being granted.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>page_num</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>record_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_oper</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_duration</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unlockRowAfterRead</MethodName>
            <MethodComment>/** 
 * UnLock the given row location. &lt;p&gt; Should only be called by access. &lt;p&gt; This call can be made on a ConglomerateController that was opened for locking only. &lt;p&gt; RESOLVE (mikem) - move this call to ConglomerateManager so it is obvious that non-access clients should not call this.
 * @param loc           The "RowLocation" which describes the row to unlock.
 * @param forUpdate     Row was locked for read or update.
 * @param row_qualified Row was qualified and returned to the user.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row_qualified</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRowLocationTemplate</MethodName>
            <MethodComment>/** 
 * Return a row location object of the correct type to be used in calls to insertAndFetchLocation.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * Replace the (partial) row at the given location.  
 * @return true if update was successful, returns false if the update fails because the record pointed at no longer represents a valid record.
 * @exception StandardException Standard exception policy.
 * @see RowUtil
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpaceInfo</MethodName>
            <MethodComment>/** 
 * Get information about space used by the conglomerate.
 */
</MethodComment>
            <ReturnType>SpaceInfo</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugConglomerate</MethodName>
            <MethodComment>/** 
 * Dump debugging output to error log. &lt;p&gt; Dump information about the conglomerate to error log. This is only for debugging purposes, does nothing in a delivered  system, currently.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>