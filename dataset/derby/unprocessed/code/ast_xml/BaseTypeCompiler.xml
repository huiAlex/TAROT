<Class>
    <Id>1961</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>BaseTypeCompiler</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>TypeCompiler</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BaseTypeCompiler  /** 
 * This is the base implementation of TypeCompiler
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>correspondingTypeId</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getPrimitiveMethodName</MethodName>
            <MethodComment>/** 
 * Get the method name for getting out the corresponding primitive Java type.
 * @return String		The method call name for getting thecorresponding primitive Java type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveArithmeticOperation</MethodName>
            <MethodComment>/** 
 * @see TypeCompiler#resolveArithmeticOperation
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateNull</MethodName>
            <MethodComment>/** 
 * The caller will have pushed a DataValueFactory and a null or a value of the correct type (interfaceName()). Thus upon entry the stack looks like on of: ...,dvf,ref ...,dvf,null This method then sets up to call the required method on DataValueFactory using the nullMethodName(). The value left on the stack will be a DataValueDescriptor of the correct type: ...,dvd
 * @see TypeCompiler#generateNull(MethodBuilder,int)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [argCount]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, nullMethodName(), interfaceName(), argCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateDataValue</MethodName>
            <MethodComment>/** 
 * The caller will have pushed a DataValueFactory and  value of that can be converted to the correct type, e.g. int for a SQL INTEGER. Thus upon entry the stack looks like: ...,dvf,value If field is not null then it is used as the holder of the generated DataValueDescriptor to avoid object creations on multiple passes through this code. The field may contain null or a valid value. This method then sets up to call the required method on DataValueFactory using the dataValueMethodName(). The value left on the stack will be a DataValueDescriptor of the correct type: If the field contained a valid value then generated code will return that value rather than a newly created object. If field was not-null then the generated code will set the value of field to be the return from the DataValueFactory method call. Thus if the field was empty (set to null) when this code is executed it will contain the newly generated value, otherwise it will be reset to the same value. ...,dvd
 * @see TypeCompiler#generateDataValue(MethodBuilder,int,LocalField)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [interfaceName=interfaceName()]</InnerVar>
                <InnerVar>int [argCount]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, dataValueMethodName(), interfaceName, argCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullMethodName</MethodName>
            <MethodComment>/** 
 * Return the method name to get a Derby DataValueDescriptor object of the correct type set to SQL NULL. The method named will be called with one argument: a holder object if pushCollationForDataValue() returns false, otherwise two arguments, the second being the collationType.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataValueMethodName</MethodName>
            <MethodComment>/** 
 * Return the method name to get a Derby DataValueDescriptor object of the correct type and set it to a specific value. The method named will be called with two arguments, a value to set the returned value to and a holder object if pushCollationForDataValue() returns false. Otherwise three arguments, the third being the collationType. This implementation returns "getDataValue" to map to the overloaded methods DataValueFactory.getDataValue(type, dvd type)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCollationForDataValue</MethodName>
            <MethodComment>/** 
 * Return true if the collationType is to be passed to the methods generated by generateNull and generateDataValue.
 * @param collationType Collation type of character values.
 * @return true collationType will be pushed, false collationType will be ignored.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userTypeStorable</MethodName>
            <MethodComment>/** 
 * Determine whether thisType is storable in otherType due to otherType being a user type.
 * @param thisType	The TypeId of the value to be stored
 * @param otherType	The TypeId of the value to be stored in
 * @return	true if thisType is storable in otherType
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>thisType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numberConvertible</MethodName>
            <MethodComment>/** 
 * Tell whether this numeric type can be converted to the given type.
 * @param otherType	The TypeId of the other type.
 * @param forDataTypeFunction  was this called from a scalarFunction likeCHAR() or DOUBLE()
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forDataTypeFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=((otherType.isNumericTypeId()) || (otherType.userType()))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numberStorable</MethodName>
            <MethodComment>/** 
 * Tell whether this numeric type can be stored into from the given type.
 * @param thisType	The TypeId of this type
 * @param otherType	The TypeId of the other type.
 * @param cf		A ClassFactory
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>thisType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeId</MethodName>
            <MethodComment>/** 
 * Get the TypeId that corresponds to this TypeCompiler.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCompiler</MethodName>
            <MethodComment>/** 
 * Get the TypeCompiler that corresponds to the given TypeId.
 */
</MethodComment>
            <ReturnType>TypeCompiler</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTypeId</MethodName>
            <MethodComment>/** 
 * Set the TypeCompiler that corresponds to the given TypeId.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStoredFormatIdFromTypeId</MethodName>
            <MethodComment>/** 
 * Get the StoredFormatId from the corresponding TypeId.
 * @return The StoredFormatId from the correspondingTypeId.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>