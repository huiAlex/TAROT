<Class>
    <Id>919</Id>
    <Package>org.apache.derby.iapi.services.context</Package>
    <ClassName>ContextManager</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ContextManager  /** 
 * The ContextManager collects contexts as they are created. It maintains stacks of contexts by named ids, so that the top context of a given type can be returned. It also maintains a global stack so that contexts can be traversed in the order they were created. &lt;p&gt; The first implementation of the context manager assumes there is only one thread to worry about and that the user(s) of the class only create one instance of ContextManager.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>stack_</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>stack_</FieldName>
            <FieldType>Context</FieldType>
        </Field>
        <Field>
            <FieldName>view_</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>view_</FieldName>
            <FieldType>Context</FieldType>
        </Field>
        <Field>
            <FieldName>top_</FieldName>
            <FieldType>Context</FieldType>
        </Field>
        <Field>
            <FieldName>ctxTable</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>ctxTable</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>holder</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>holder</FieldName>
            <FieldType>Context</FieldType>
        </Field>
        <Field>
            <FieldName>messageLocale</FieldName>
            <FieldType>Locale</FieldType>
        </Field>
        <Field>
            <FieldName>owningCsf</FieldName>
            <FieldType>ContextService</FieldType>
        </Field>
        <Field>
            <FieldName>logSeverityLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>extDiagSeverityLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>errorStream</FieldName>
            <FieldType>HeaderPrintWriter</FieldType>
        </Field>
        <Field>
            <FieldName>errorStringBuilder</FieldName>
            <FieldType>ErrorStringBuilder</FieldType>
        </Field>
        <Field>
            <FieldName>threadDump</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>shutdown</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>finder</FieldName>
            <FieldType>LocaleFinder</FieldType>
        </Field>
        <Field>
            <FieldName>activeThread</FieldName>
            <FieldType>Thread</FieldType>
        </Field>
        <Field>
            <FieldName>activeCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>Context</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stack_;add;[context]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stack_;remove;[stack_.size() - 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>Context</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stack_;remove;[stack_.lastIndexOf(context)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>top</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnmodifiableList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushContext</MethodName>
            <MethodComment>/** 
 * Add a Context object to the ContextManager. The object is added both to the holder list and to a stack for the specific type of Context.
 * @param newContext the new Context object
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newContext</ParamName>
                    <ParamType>Context</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [contextId=newContext.getIdName()]</InnerVar>
                <InnerVar>CtxStack [idStack=ctxTable.get(contextId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkInterrupt;[]</InnerMethodInvoke>
                <InnerMethodInvoke>idStack;push;[newContext]</InnerMethodInvoke>
                <InnerMethodInvoke>holder;add;[newContext]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContext</MethodName>
            <MethodComment>/** 
 * Obtain the last pushed Context object of the type indicated by the contextId argument.
 * @param contextId a String identifying the type of Context
 * @return The Context object with the corresponding contextId, or null if not found
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CtxStack [idStack=ctxTable.get(contextId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkInterrupt;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popContext</MethodName>
            <MethodComment>/** 
 * Remove the last pushed Context object, regardless of type. If there are no Context objects, no action is taken.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Context [theContext=holder.remove(holder.size() - 1)]</InnerVar>
                <InnerVar>String [contextId=theContext.getIdName()]</InnerVar>
                <InnerVar>CtxStack [idStack=ctxTable.get(contextId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkInterrupt;[]</InnerMethodInvoke>
                <InnerMethodInvoke>idStack;pop;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popContext</MethodName>
            <MethodComment>/** 
 * Removes the specified Context object. If the specified Context object does not exist, the call will fail.
 * @param theContext the Context object to remove.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theContext</ParamName>
                    <ParamType>Context</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [contextId=theContext.getIdName()]</InnerVar>
                <InnerVar>CtxStack [idStack=ctxTable.get(contextId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkInterrupt;[]</InnerMethodInvoke>
                <InnerMethodInvoke>holder;remove;[holder.lastIndexOf(theContext)]</InnerMethodInvoke>
                <InnerMethodInvoke>idStack;remove;[theContext]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * Is the ContextManager empty containing no Contexts.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextStack</MethodName>
            <MethodComment>/** 
 * Return an unmodifiable list reference to the ArrayList backing CtxStack object for this type of Contexts. This method allows fast traversal of all Contexts on that stack. The first element in the List corresponds to the bottom of the stack. The assumption is that the Stack will not be modified while it is being traversed.
 * @param contextId the type of Context stack to return.
 * @return an unmodifiable "view" of the ArrayList backing the stack
 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#resetSavepoints()
 * @see org.apache.derby.iapi.sql.conn.StatementContext#resetSavePoint()
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CtxStack [cs=ctxTable.get(contextId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnError</MethodName>
            <MethodComment>/** 
 * clean up error and print it to derby.log. Extended diagnosis including thread dump to derby.log and javaDump if available, will print if the database is active and severity is greater than or equals to SESSTION_SEVERITY or as configured by derby.stream.error.extendedDiagSeverityLevel property
 * @param error the error we want to clean up
 * @param diagActive true if extended diagnostics should be considered,  false not interested of extended diagnostic information
 * @return true if the context manager is shutdown, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>error</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>diagActive</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ThreadDeath [seenThreadDeath=null]</InnerVar>
                <InnerVar>boolean [reportError=reportError(error)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterrupted</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Context</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [interruptMe=(c == null) || holder.contains(c)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkInterrupt</MethodName>
            <MethodComment>/** 
 * Check to see if we have been interrupted. If we have then a ShutdownException will be thrown. This will be either the one passed to interrupt or a generic one if some outside source interrupted the thread.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLocaleFinder</MethodName>
            <MethodComment>/** 
 * Set the locale for this context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>finder</ParamName>
                    <ParamType>LocaleFinder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMessageLocale</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>localeID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMessageLocale</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Locale</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushErrorString</MethodName>
            <MethodComment>/** 
 * Flush the built up error string to whereever it is supposed to go, and reset the error string
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>errorStream;print;[errorStringBuilder.get().toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>errorStream;flush;[]</InnerMethodInvoke>
                <InnerMethodInvoke>errorStringBuilder;reset;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reportError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getErrorSeverity</MethodName>
            <MethodComment>/** 
 * return the severity of the exception. Currently, this method  does not determine a severity that is not StandardException  or SQLException.
 * @param error - Throwable error
 * @return int vendorcode/severity for the Throwable error- error/exception to extract vendorcode/severity.  For error that we can not get severity,  NO_APPLICABLE_SEVERITY will return.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>error</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ContextManager</MethodName>
            <MethodComment>/** 
 * Constructs a new instance. No CtxStacks are inserted into the hashMap as they will be allocated on demand.
 * @param csf the ContextService owning this ContextManager
 * @param stream error stream for reporting errors
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>csf</ParamName>
                    <ParamType>ContextService</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>HeaderPrintWriter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>