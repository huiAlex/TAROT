<Class>
    <Id>524</Id>
    <Package>org.apache.derbyTesting.system.oe.direct</Package>
    <ClassName>SimpleNonStandardOperations</ClassName>
    <SuperClass>StatementHelper</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SimpleNonStandardOperations  /** 
 * Collection of simple transactions that can be executed against an order-entry database. These are not part of any standard TPC-C specification but are useful for running specific performance tests against Derby. Since they are not standard operations there is no ability to display the information. Any data selected by a query is always fetched by processing all the rows and all the columns using getXXX.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>customer</FieldName>
            <FieldType>Customer</FieldType>
        </Field>
        <Field>
            <FieldName>address</FieldName>
            <FieldType>Address</FieldType>
        </Field>
        <Field>
            <FieldName>rand</FieldName>
            <FieldType>OERandom</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SimpleNonStandardOperations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noReset</MethodName>
            <MethodComment>/** 
 * Return an SimpleNonStandardOperations implementation based upon SimpleNonStandardOperations with a single difference. In this implementation the reset() executed after each PreparedStatement execute does nothing. Sees if there is any performance impact of explicitly closing each ResultSet and clearing the parameters. &lt;P&gt; Each ResultSet will be closed implicitly either at commit time or at the next execution of the same PreparedStatement object.
 */
</MethodComment>
            <ReturnType>SimpleNonStandardOperations</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ps</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>customerInquiry</MethodName>
            <MethodComment>/** 
 * Execute customerInquiry() with random parameters.
 * @throws SQLException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;customerInquiry;[(short)rand.randomInt(1,scale), (short)rand.district(), rand.NURand1023()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>customerInquiry</MethodName>
            <MethodComment>/** 
 * Lookup a customer's information (name, address, balance) fetching it by the identifier. &lt;BR&gt; Primary key lookup against the CUSTOMER table (which of course can be arbitrarily large depending on the scale of the database. The cardinality of the CUSTOMER is 30,000 rows per warehouse, for example with a 20 warehouse system this test would perform a primary key lookup against 600,000 rows.
 * @param w Warehouse for customer
 * @param d District for customer
 * @param c Customer identifier
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>w</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [customerInquiry=prepareStatement("SELECT C_BALANCE, C_FIRST, C_MIDDLE, C_LAST, " + "C_STREET_1, C_STREET_2, C_CITY, C_STATE, C_ZIP, " + "C_PHONE "+ "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?")]</InnerVar>
                <InnerVar>ResultSet [rs=customerInquiry.executeQuery()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>customerInquiry;setShort;[1, w]</InnerMethodInvoke>
                <InnerMethodInvoke>customerInquiry;setShort;[2, d]</InnerMethodInvoke>
                <InnerMethodInvoke>customerInquiry;setInt;[3, c]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setBalance;[rs.getString("C_BALANCE")]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setFirst;[rs.getString("C_FIRST")]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setMiddle;[rs.getString("C_MIDDLE")]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setLast;[rs.getString("C_LAST")]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setAddress;[getAddress(address,rs,"C_STREET_1")]</InnerMethodInvoke>
                <InnerMethodInvoke>customer;setPhone;[rs.getString("C_PHONE")]</InnerMethodInvoke>
                <InnerMethodInvoke>null;reset;[customerInquiry]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>customerAddressChange</MethodName>
            <MethodComment>/** 
 * Execute customerAddressChange() with random parameters.
 * @throws SQLException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;customerAddressChange;[(short)rand.randomInt(1,scale), (short)rand.district(), rand.NURand1023()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>customerAddressChange</MethodName>
            <MethodComment>/** 
 * Update a customers address with a new random value. Update of a single row through a primary key. &lt;BR&gt; Primary key update against the CUSTOMER table (which of course can be arbitrarily large depending on the scale of the database. The cardinality of the CUSTOMER is 30,000 rows per warehouse, for example with a 20 warehouse system this test would perform a primary key lookup against 600,000 rows.
 * @param w Warehouse for customer
 * @param d District for customer
 * @param c Customer identifier
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>w</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [customerAddressChange=prepareStatement("UPDATE CUSTOMER " + "SET C_STREET_1 = ?, C_STREET_2 = ?, " + "C_CITY = ?, C_STATE = ?, C_ZIP = ? "+ "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>customerAddressChange;setString;[1, rand.randomAString10_20()]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setString;[2, rand.randomAString10_20()]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setString;[3, rand.randomAString10_20()]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setString;[4, rand.randomState()]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setString;[5, rand.randomZIP()]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setShort;[6, w]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setShort;[7, d]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;setInt;[8, c]</InnerMethodInvoke>
                <InnerMethodInvoke>customerAddressChange;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;reset;[customerAddressChange]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>