<Class>
    <Id>725</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>PredicateList</ClassName>
    <SuperClass>QueryTreeNodeVector</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>OptimizablePredicateList</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>PredicateList  /** 
 * A PredicateList represents the list of top level predicates. Each top level predicate consists of an AndNode whose leftOperand is the top level predicate and whose rightOperand is true.  It extends  QueryTreeNodeVector.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>numberOfStartPredicates</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numberOfStopPredicates</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numberOfQualifiers</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_ORDER_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_ORDER_OTHER_RELOP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_ORDER_NOT_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_ORDER_NON_QUAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_ORDER_OR_CLAUSE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>QUALIFIER_NUM_CATEGORIES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>indexPosition</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>pred</FieldName>
            <FieldType>Predicate</FieldType>
        </Field>
        <Field>
            <FieldName>predicateID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>pwList</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>pwList</FieldName>
            <FieldType>PredicateWrapper</FieldType>
        </Field>
        <Field>
            <FieldName>numPreds</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numDuplicates</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>weight</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>PredicateList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptPredicate</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicateList#getOptPredicate
 */
</MethodComment>
            <ReturnType>OptimizablePredicate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeOptPredicate</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicateList#removeOptPredicate
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predCtr</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Predicate [predicate=removeElementAt(predCtr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeOptPredicate</MethodName>
            <MethodComment>/** 
 * Another version of removeOptPredicate that takes the Predicate to be removed, rather than the position of the Predicate.  This is not part any interface (yet).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pred</ParamName>
                    <ParamType>OptimizablePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;removeElement;[(Predicate)pred]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOptPredicate</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#addOptPredicate 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optPredicate</ParamName>
                    <ParamType>OptimizablePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addElement;[(Predicate)optPredicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOptPredicate</MethodName>
            <MethodComment>/** 
 * Another flavor of addOptPredicate that inserts the given predicate at a given position.  This is not yet part of any interface.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optPredicate</ParamName>
                    <ParamType>OptimizablePredicate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;insertElementAt;[(Predicate)optPredicate, position]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>useful</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#useful
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushUsefulPredicates</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#pushUsefulPredicates
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AccessPath [ap=optTable.getTrulyTheBestAccessPath()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;orderUsefulPredicates;[optTable, ap.getConglomerateDescriptor(), true, ap.getNonMatchingIndexScan(), ap.getCoveringIndexScan()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>classify</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#classify
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;orderUsefulPredicates;[optTable, cd, false, false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAllPredicatesQualifiers</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#markAllPredicatesQualifiers 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasEqualityPredicateOnOrderedColumn</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#hasEqualityPredicateOnOrderedColumn
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullOkay</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [opNode]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasOptimizableEqualityPredicate</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#hasOptimizableEqualityPredicate
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullOkay</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasOptimizableEquijoin</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#hasOptimizableEquijoin
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putOptimizableEqualityPredicateFirst</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#putOptimizableEqualityPredicateFirst
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orderUsefulPredicates</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pushPreds</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nonMatchingIndexScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>coveringIndexScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [baseColumnPositions]</InnerVar>
                <InnerVar>boolean[] [isAscending]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
                <InnerVar>Predicate[] [usefulPredicates=new Predicate[size]]</InnerVar>
                <InnerVar>int [usefulCount=0]</InnerVar>
                <InnerVar>boolean [skipProbePreds=pushPreds &amp;&amp; optTable.getTrulyTheBestAccessPath().getJoinStrategy().isHashJoin()]</InnerVar>
                <InnerVar>int [currentStartPosition=-1]</InnerVar>
                <InnerVar>boolean [gapInStartPositions=false]</InnerVar>
                <InnerVar>int [currentStopPosition=-1]</InnerVar>
                <InnerVar>boolean [gapInStopPositions=false]</InnerVar>
                <InnerVar>boolean [seenNonEquals=false]</InnerVar>
                <InnerVar>int [firstNonEqualsPosition=-1]</InnerVar>
                <InnerVar>int [lastStartEqualsPosition=-1]</InnerVar>
                <InnerVar>boolean [seenGE=false, seenGT=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>java.util.Arrays;sort;[usefulPredicates]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPredicate</MethodName>
            <MethodComment>/** 
 * Add a Predicate to the list.
 * @param predicate	A Predicate to add to the list
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addElement;[predicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transferNonQualifiers</MethodName>
            <MethodComment>/** 
 * Transfer the non-qualifiers from this predicate list to the specified  predicate list. This is useful for arbitrary hash join, where we need to separate the 2  as the qualifiers get applied when probing the hash table and the  non-qualifiers get * applied afterwards.
 * @param optTable	The optimizable that we want qualifiers for
 * @param otherPL	ParameterList for non-qualifiers
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherPL</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;markAllPredicatesQualifiers;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize the predicates in the list.  Initially, this means building a bit map of the referenced tables for each predicate.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eliminateBooleanTrueAndBooleanTrue</MethodName>
            <MethodComment>/** 
 * Eliminate predicates of the form: AndNode /	   \ true BooleanConstantNode		true BooleanConstantNode This is useful when checking for a NOP PRN as the Like transformation on c1 like 'ASDF%' can leave one of these predicates in the list.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreConstantPredicates</MethodName>
            <MethodComment>/** 
 * Rebuild a constant expression tree from the remaining constant  predicates and delete those entries from the PredicateList. The rightOperand of every top level AndNode is always a true  BooleanConstantNode, so we can blindly overwrite that pointer. Optimizations: We take this opportunity to eliminate: AndNode /		   \ true BooleanConstantNode	true BooleanConstantNode We remove the AndNode if the predicate list is a single AndNode: AndNode /	   \ LeftOperand			RightOperand becomes: LeftOperand If the leftOperand of any AndNode is False, then the entire expression will be False.  The expression simple becomes: false BooleanConstantNode
 * @return ValueNode	The rebuilt expression tree.
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AndNode [nextAnd]</InnerVar>
                <InnerVar>AndNode [falseAnd=null]</InnerVar>
                <InnerVar>ValueNode [restriction=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restorePredicates</MethodName>
            <MethodComment>/** 
 * Rebuild an expression tree from the remaining predicates and delete those entries from the PredicateList. The rightOperand of every top level AndNode is always a true  BooleanConstantNode, so we can blindly overwrite that pointer. Optimizations: We take this opportunity to eliminate: AndNode /	   \ true BooleanConstantNode	true BooleanConstantNode We remove the AndNode if the predicate list is a single AndNode: AndNode /	   \ LeftOperand			RightOperand becomes: LeftOperand If the leftOperand of any AndNode is False, then the entire expression will be False.  The expression simple becomes: false BooleanConstantNode
 * @return ValueNode	The rebuilt expression tree.
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AndNode [nextAnd]</InnerVar>
                <InnerVar>AndNode [falseAnd=null]</InnerVar>
                <InnerVar>ValueNode [restriction=null]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;removeAllElements;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferencesToExpressions</MethodName>
            <MethodComment>/** 
 * Remap all ColumnReferences in this tree to be clones of the underlying expression.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pullExpressions</MethodName>
            <MethodComment>/** 
 * Break apart the search clause into matching a PredicateList where each top level predicate is a separate element in the list. Build a bit map to represent the FromTables referenced within each top level predicate. NOTE: We want the rightOperand of every AndNode to be true, in order to simplify the algorithm for putting the predicates back into the tree. (As we put an AndNode back into the tree, we can ignore it's rightOperand.)
 * @param numTables			Number of tables in the DML Statement
 * @param searchClause	The search clause to operate on.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>searchClause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AndNode [thisAnd]</InnerVar>
                <InnerVar>AndNode [topAnd]</InnerVar>
                <InnerVar>JBitSet [newJBitSet]</InnerVar>
                <InnerVar>Predicate [newPred]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xorReferencedSet</MethodName>
            <MethodComment>/** 
 * XOR fromMap with the referenced table map in every remaining Predicate in the list.  This is useful when pushing down  multi-table predicates.
 * @param fromMap	The JBitSet to XOR with.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countScanFlags</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstantOrParameterNode</MethodName>
            <MethodComment>/** 
 * Check if a node is representing a constant or a parameter.
 * @param node the node to check
 * @return {@code true} if the node is a constant or a parameter, {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushExpressionsIntoSelect</MethodName>
            <MethodComment>/** 
 * Push all predicates, which can be pushed, into the underlying select. A predicate can be pushed into an underlying select if the source of  every ColumnReference in the predicate is itself a ColumnReference. This is useful when attempting to push predicates into non-flattenable views or derived tables or into unions.
 * @param select			The underlying SelectNode.
 * @param copyPredicate		Whether to make a copy of the predicatebefore pushing
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>select</ParamName>
                    <ParamType>SelectNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copyPredicate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markReferencedColumns</MethodName>
            <MethodComment>/** 
 * Mark all of the RCs and the RCs in their RC/VCN chain referenced in the predicate list as referenced.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [collectCRs=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkTopPredicatesForEqualsConditions</MethodName>
            <MethodComment>/** 
 * Update the array of columns in = conditions with constants or correlation or join columns.  This is useful when doing subquery flattening on the basis of an equality condition.
 * @param tableNumber	The tableNumber of the table from whichthe columns of interest come from.
 * @param eqOuterCols	Array of booleans for noting which columnsare in = predicates with constants or correlation columns.
 * @param tableNumbers	Array of table numbers in this query block.
 * @param resultColTable tableNumber is the table the result columns arecoming from
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>eqOuterCols</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableColMap</ParamName>
                    <ParamType>JBitSet[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultColTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allPushable</MethodName>
            <MethodComment>/** 
 * Check if all of the predicates in the list are pushable.
 * @return Whether or not all of the predicates in the list are pushable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allReference</MethodName>
            <MethodComment>/** 
 * Check if all the predicates reference a given  {@code FromBaseTable}.
 * @param fbt the {@code FromBaseTable} to check for
 * @return {@code true} if the table is referenced by all predicates,{@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fbt</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [tableNumber=fbt.getTableNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPushablePredicates</MethodName>
            <MethodComment>/** 
 * Build a list of pushable predicates, if any, that satisfy the referencedTableMap.
 * @param referencedTableMap	The referenced table map
 * @return A list of pushable predicates, if any,that satisfy the referencedTableMap.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>PredicateList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PredicateList [pushPList=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementLevel</MethodName>
            <MethodComment>/** 
 * Decrement the level of any CRs from the subquery's FROM list that are interesting to transitive closure.
 * @param fromList	The subquery's FROM list.
 * @param decrement	Decrement size.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>decrement</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [tableNumbers=fromList.getTableNumbers()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>joinClauseTransitiveClosure</MethodName>
            <MethodComment>/** 
 * Perform transitive closure on join clauses.  For each table in the query, we build a list of equijoin clauses of the form: ColumnReference relop ColumnReference Each join clause is put on 2 lists since it joins 2 tables. We then walk the array of lists.  We first walk it as the outer list.   For each equijoin predicate, we assign an equivalence class if it does  not yet have one.  We then walk the predicate list (as middle) for the  other table, searching for other equijoins with the middle table number  and column number.  All such predicates are assigned the same  equivalence class. We then walk the predicate list (as inner) for the  other side of the middle predicate to see if we can find an equijoin  between outer and inner.  If so, then we simply assign it to the same  equivalence class.  If not, then we add the new equijoin clause. Note that an equijoin predicate between two tables CANNOT be used for transitive closure, if either of the tables is in the fromlist for NOT EXISTS. In that case, the join predicate actually specifies that the rows from the indicated table must NOT exist, and therefore those non-existent rows cannot be transitively joined to the other matching tables. See DERBY-3033 for a description of a situation in which this actually arises.
 * @param numTables	The number of tables in the query
 * @param fromList	The FromList in question.
 * @param cc		The CompilerContext to use
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cc</ParamName>
                    <ParamType>CompilerContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PredicateList[] [joinClauses=new PredicateList[numTables]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>searchClauseTransitiveClosure</MethodName>
            <MethodComment>/** 
 * Perform transitive closure on search clauses.  We build a list of search clauses of the form: &lt;ColumnReference&gt; &lt;RelationalOperator&gt; [&lt;ConstantNode&gt;] We also build a list of equijoin conditions of form: &lt;ColumnReference1&gt; = &lt;ColumnReference2&gt; where both columns are from different tables in the same query block. For each search clause in the list, we search the equijoin list to see if there is an equijoin clause on the same column.  If so, then we  search the search clause list for a search condition on the column  being joined against with the same relation operator and constant.  If  a match is found, then there is no need to add a new predicate.   Otherwise, we add a new search condition on the column being joined  with.  In either case, if the relational operator in the search clause is an "=" then we mark the equijoin clause as being redundant. Redundant equijoin clauses will be removed at the end of the search as  they are * unnecessary.
 * @param numTables			The number of tables in the query
 * @param hashJoinSpecified	Whether or not user specified a hash join
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hashJoinSpecified</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PredicateList [equijoinClauses=new PredicateList(getContextManager())]</InnerVar>
                <InnerVar>PredicateList [searchClauses=new PredicateList(getContextManager())]</InnerVar>
                <InnerVar>RelationalOperator [equalsNode=null]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeRedundantPredicates</MethodName>
            <MethodComment>/** 
 * Remove redundant predicates.  A redundant predicate has an equivalence class (!= -1) and there are other predicates in the same equivalence class after it in the list.  (Actually, we remove all of the predicates in the same equivalence class that appear after this one.)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [outer=size() - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transferPredicates</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#transferPredicates
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherList</ParamName>
                    <ParamType>OptimizablePredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Predicate [predicate]</InnerVar>
                <InnerVar>PredicateList [theOtherList=(PredicateList)otherList]</InnerVar>
                <InnerVar>AccessPath [ap=table.getTrulyTheBestAccessPath()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>theOtherList;orderUsefulPredicates;[table, ap.getConglomerateDescriptor(), false, ap.getNonMatchingIndexScan(), ap.getCoveringIndexScan()]</InnerMethodInvoke>
                <InnerMethodInvoke>theOtherList;countScanFlags;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transferAllPredicates</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#transferAllPredicates
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherList</ParamName>
                    <ParamType>OptimizablePredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PredicateList [theOtherList=(PredicateList)otherList]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;removeAllElements;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyPredicatesToOtherList</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#copyPredicatesToOtherList
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherList</ParamName>
                    <ParamType>OptimizablePredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRedundantPredicate</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#isRedundantPredicate
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Predicate [pred=elementAt(predNum)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPredicatesAndProperties</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#setPredicatesAndProperties
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherList</ParamName>
                    <ParamType>OptimizablePredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PredicateList [theOtherList=(PredicateList)otherList]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>theOtherList;removeAllElements;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startOperator</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#startOperator 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [startOperator]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateStopKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#generateStopKey
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acbi</ParamName>
                    <ParamType>ExpressionClassBuilderInterface</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExpressionClassBuilder [acb=(ExpressionClassBuilder)acbi]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;pushNull;[ClassName.GeneratedMethod]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stopOperator</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#stopOperator 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [stopOperator]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateSingleQualifierCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>consMB</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>absolute</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>or_node</ParamName>
                    <ParamType>RelationalOperator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualField</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>array_idx_1</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>array_idx_2</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>consMB;getField;[qualField]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;callMethod;[VMOpcode.INVOKEVIRTUAL, acb.getBaseClassName(), "getExecutionFactory", ExecutionFactory.MODULE, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>or_node;generateOperator;[consMB, optTable]</InnerMethodInvoke>
                <InnerMethodInvoke>or_node;generateQualMethod;[acb, consMB, optTable]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushThisAsActivation;[consMB]</InnerMethodInvoke>
                <InnerMethodInvoke>or_node;generateOrderedNulls;[consMB]</InnerMethodInvoke>
                <InnerMethodInvoke>or_node;generateNegate;[consMB, optTable]</InnerMethodInvoke>
                <InnerMethodInvoke>or_node;generateNegate;[consMB, optTable]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;push;[or_node.getOrderableVariantType(optTable)]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;callMethod;[VMOpcode.INVOKEINTERFACE, ExecutionFactory.MODULE, "getQualifier", ClassName.Qualifier, 8]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;push;[array_idx_1]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;push;[array_idx_2]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;callMethod;[VMOpcode.INVOKESTATIC, acb.getBaseClassName(), "setQualifier", "void", 4]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateInListValues</MethodName>
            <MethodComment>/** 
 * If there is an IN-list probe predicate in this list then generate the corresponding IN-list values as a DataValueDescriptor array, to be used for probing at execution time.  Also generate a boolean value indicating whether or not the values are already in sorted order. Assumption is that by the time we get here there is at most one IN-list probe predicate in this list.
 * @param acb The ActivationClassBuilder for the class we're building
 * @param mb The MethodBuilder for the method we're building
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateQualifiers</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#generateQualifiers
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acbi</ParamName>
                    <ParamType>ExpressionClassBuilderInterface</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>absolute</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [retvalType=ClassName.Qualifier + "[][]"]</InnerVar>
                <InnerVar>ExpressionClassBuilder [acb=(ExpressionClassBuilder)acbi]</InnerVar>
                <InnerVar>MethodBuilder [consMB=acb.getConstructor()]</InnerVar>
                <InnerVar>MethodBuilder [executeMB=acb.getExecuteMethod()]</InnerVar>
                <InnerVar>LocalField [qualField=acb.newFieldDeclaration(Modifier.PRIVATE,retvalType)]</InnerVar>
                <InnerVar>int [num_of_or_conjunctions=0]</InnerVar>
                <InnerVar>int [qualNum=0]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
                <InnerVar>boolean [gotOrQualifier=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>executeMB;getField;[qualField]</InnerMethodInvoke>
                <InnerMethodInvoke>executeMB;callMethod;[VMOpcode.INVOKESTATIC, acb.getBaseClassName(), "reinitializeQualifiers", "void", 1]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;pushNewArray;[ClassName.Qualifier + "[]", num_of_or_conjunctions + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;setField;[qualField]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;getField;[qualField]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;push;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;push;[numberOfQualifiers - num_of_or_conjunctions]</InnerMethodInvoke>
                <InnerMethodInvoke>consMB;callMethod;[VMOpcode.INVOKESTATIC, acb.getBaseClassName(), "allocateQualArray", "void", 3]</InnerMethodInvoke>
                <InnerMethodInvoke>null;orderQualifiers;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;getField;[qualField]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orderQualifiers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PredicateList[] [sortList=new PredicateList[QUALIFIER_NUM_CATEGORIES]]</InnerVar>
                <InnerVar>int [predIndex]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateStartKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#generateStartKey
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acbi</ParamName>
                    <ParamType>ExpressionClassBuilderInterface</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExpressionClassBuilder [acb=(ExpressionClassBuilder)acbi]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;pushNull;[ClassName.GeneratedMethod]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sameStartStopPosition</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#sameStartStopPosition
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateIndexableRow</MethodName>
            <MethodComment>/** 
 * Generate the indexable row for a start key or stop key.
 * @param acb	The ActivationClassBuilder for the class we're building
 * @param numberOfColumns	The number of columns in the key
 * @return	The field that holds the indexable row
 */
</MethodComment>
            <ReturnType>LocalField</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numberOfColumns</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [mb=acb.getConstructor()]</InnerVar>
                <InnerVar>LocalField [field=acb.newFieldDeclaration(Modifier.PRIVATE,ClassName.ExecIndexRow)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>acb;pushGetExecutionFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[numberOfColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, ClassName.ExecutionFactory, "getIndexableRow", ClassName.ExecIndexRow, 1]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;setField;[field]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateSetColumn</MethodName>
            <MethodComment>/** 
 * Generate the code to set the value from a predicate in an index column.
 * @param acb	The ActivationClassBuilder for the class we're building
 * @param exprFun	The MethodBuilder for the method we're building
 * @param columnNumber	The position number of the column we're settingthe value in (zero-based)
 * @param pred	The Predicate with the value to put in the index column
 * @param optTable	The Optimizable table the column is in
 * @param rowField	The field that holds the indexable row
 * @param isStartKey Are we generating start or stop key?  This informationis useful for "in"'s dynamic start/stop key, bug 3858
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exprFun</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pred</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowField</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isStartKey</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [mb]</InnerVar>
                <InnerVar>boolean [withKnownConstant=false]</InnerVar>
                <InnerVar>int[] [baseColumns=optTable.getTrulyTheBestAccessPath().getConglomerateDescriptor().getIndexDescriptor().baseColumnPositions()]</InnerVar>
                <InnerVar>boolean[] [isAscending=optTable.getTrulyTheBestAccessPath().getConglomerateDescriptor().getIndexDescriptor().isAscending()]</InnerVar>
                <InnerVar>boolean [isIn=pred.getAndNode().getLeftOperand() instanceof InListOperatorNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;getField;[rowField]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[columnNumber + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;upCast;[ClassName.DataValueDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, ClassName.Row, "setColumn", "void", 2]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishKey</MethodName>
            <MethodComment>/** 
 * Finish generating a start or stop key
 * @param acb	The ActivationClassBuilder for the class we're building
 * @param exprFun	The MethodBuilder for the method we're building
 * @param rowField	The name of the field that holds the indexable row
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exprFun</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowField</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exprFun;getField;[rowField]</InnerMethodInvoke>
                <InnerMethodInvoke>exprFun;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>exprFun;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushMethodReference;[mb, exprFun]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colRef</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#adjustForSortElimination Currently this method only accounts for IN list multi-probing predicates (DERBY-3279).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ordering</ParamName>
                    <ParamType>RequiredRowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OrderByList [orderBy=(OrderByList)ordering]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivity</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicateList#selectivity
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [td=optTable.getTableDescriptor()]</InnerVar>
                <InnerVar>ConglomerateDescriptor[] [conglomerates=td.getConglomerateDescriptors()]</InnerVar>
                <InnerVar>int [numPredicates=size()]</InnerVar>
                <InnerVar>int [numConglomerates=conglomerates.length]</InnerVar>
                <InnerVar>boolean [nothingYet=true]</InnerVar>
                <InnerVar>PredicateList [workingPredicates=new PredicateList(getContextManager())]</InnerVar>
                <InnerVar>int [numWorkingPredicates=workingPredicates.size()]</InnerVar>
                <InnerVar>PredicateWrapperList[] [predsForConglomerates=new PredicateWrapperList[numConglomerates]]</InnerVar>
                <InnerVar>int [maxOverlap=-1]</InnerVar>
                <InnerVar>double [selectivity=1.0]</InnerVar>
                <InnerVar>ArrayList&lt;Predicate&gt; [maxPreds=new ArrayList&lt;Predicate&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;calculateWeight;[predsForConglomerates, numWorkingPredicates]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>calculateWeight</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pwList</ParamName>
                    <ParamType>PredicateWrapperList[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numUsefulPredicates</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [s=new int[numUsefulPredicates]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chooseLongestMatch</MethodName>
            <MethodComment>/** 
 * choose the statistic which has the maximum match with the predicates. value is returned in ret.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predArray</ParamName>
                    <ParamType>PredicateWrapperList[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ret</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numWorkingPredicates</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [max=0, maxWeight=0]</InnerVar>
                <InnerVar>int [position=-1]</InnerVar>
                <InnerVar>PredicateWrapperList [pwl=predArray[position]]</InnerVar>
                <InnerVar>List&lt;PredicateWrapper&gt; [uniquepreds=pwl.createLeadingUnique()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;calculateWeight;[predArray, numWorkingPredicates]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivityNoStatistics</MethodName>
            <MethodComment>/** 
 * Compute selectivity the old fashioned way.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>double [selectivity=1.0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PredicateWrapper</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ip</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicateID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPredicate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Predicate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPredicateID</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>before</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>PredicateWrapper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>contiguous</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>PredicateWrapper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [otherIP=other.getIndexPosition()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PredicateWrapperList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maxValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeElement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeElementAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pwList;remove;[index]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>elementAt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PredicateWrapper</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insert</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pw</ParamName>
                    <ParamType>PredicateWrapper</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pwList;add;[i, pw]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>uniqueSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>retainLeadingContiguous</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [j]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createLeadingUnique</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PredicateWrapper</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [lastIndexPosition=elementAt(0).getIndexPosition()]</InnerVar>
                <InnerVar>ArrayList&lt;PredicateWrapper&gt; [scratch=new ArrayList&lt;PredicateWrapper&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scratch;add;[elementAt(0)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setWeight</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>weight</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWeight</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>