<Class>
    <Id>1127</Id>
    <Package>org.apache.derby.iapi.sql.dictionary</Package>
    <ClassName>DataDictionary</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataDictionary  /** 
 * The DataDictionary interface is used with the data dictionary to get descriptors for binding and compilation. Some descriptors (such as table and column descriptors) are added to and deleted from the data dictionary by other modules (like the object store). Other descriptors are added and deleted by the language module itself (e.g. the language module adds and deletes views, because views are too high-level for modules like the object store to know about).
 * @version 0.1
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MODULE</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CURRENT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CS_5_0</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CS_5_1</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CS_5_2</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CS_8_1</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_CS_10_0</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_1</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_2</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_3</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_4</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_5</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_6</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_7</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_8</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_9</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_10</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_11</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_12</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_13</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DD_VERSION_DERBY_10_14</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DATABASE_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CORE_DATA_DICTIONARY_VERSION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_DATA_DICTIONARY_VERSION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SOFT_DATA_DICTIONARY_VERSION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>PROPERTY_CONGLOMERATE_VERSION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TYPE_SYSTEM_IDENTIFIER</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>CATALOG_TYPE_SYSTEM_IDENTIFIER</FieldName>
            <FieldType>TypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCONGLOMERATES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSTABLES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCOLUMNS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSSCHEMAS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCONSTRAINTS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSKEYS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSDEPENDS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSALIASES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSVIEWS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCHECKS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFOREIGNKEYS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSSTATEMENTS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFILES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSTRIGGERS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSSTATISTICS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSDUMMY1_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSTABLEPERMS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCOLPERMS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSROUTINEPERMS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSROLES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSSEQUENCES_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSPERMS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSUSERS_CATALOG_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NOTNULL_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PRIMARYKEY_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>UNIQUE_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHECK_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FOREIGNKEY_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MODIFY_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMPILE_ONLY_MODE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DDL_MODE</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>clearCaches</MethodName>
            <MethodComment>/** 
 * Clear the DataDictionary caches, including the sequence caches if requested..
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clearSequenceCaches</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearCaches</MethodName>
            <MethodComment>/** 
 * Clear all of the DataDictionary caches.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearSequenceCaches</MethodName>
            <MethodComment>/** 
 * Clear all of the sequence number generators.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startReading</MethodName>
            <MethodComment>/** 
 * Inform this DataDictionary that we are about to start reading it.  This means using the various get methods in the DataDictionary. Generally, this is done during query compilation.
 * @param lcc	The LanguageConnectionContext to use.
 * @return	The mode that the reader will use, to be passed to doneReading()Either COMPILE_ONLY_MODE or DDL_MODE.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doneReading</MethodName>
            <MethodComment>/** 
 * Inform this DataDictionary that we have finished reading it.  This typically happens at the end of compilation.
 * @param mode	The mode that was returned by startReading().
 * @param lcc	The LanguageConnectionContext to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startWriting</MethodName>
            <MethodComment>/** 
 * Inform this DataDictionary that we are about to start writing to it. This means using the various add and drop methods in the DataDictionary. Generally, this is done during execution of DDL.
 * @param lcc	The LanguageConnectionContext to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transactionFinished</MethodName>
            <MethodComment>/** 
 * Inform this DataDictionary that the transaction in which writes have been done (or may have been done) has been committed or rolled back.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecutionFactory</MethodName>
            <MethodComment>/** 
 * Get the ExecutionFactory associated with this database.
 * @return	The ExecutionFactory
 */
</MethodComment>
            <ReturnType>ExecutionFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Get the DataValueFactory associated with this database.
 * @return	The ExecutionFactory
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDescriptorGenerator</MethodName>
            <MethodComment>/** 
 * Get a DataDescriptorGenerator, through which we can create objects to be stored in the DataDictionary.
 * @return	A DataDescriptorGenerator
 */
</MethodComment>
            <ReturnType>DataDescriptorGenerator</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuthorizationDatabaseOwner</MethodName>
            <MethodComment>/** 
 * Get authorizationID of Database Owner
 * @return	authorizationID
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesSqlAuthorization</MethodName>
            <MethodComment>/** 
 * Get authorization model in force, SqlStandard or legacy mode
 * @return	Whether sqlAuthorization is being used
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationTypeOfSystemSchemas</MethodName>
            <MethodComment>/** 
 * Return the collation type for SYSTEM schemas. In Derby 10.3, this will  always be UCS_BASIC 
 * @return the collation type for SYSTEM schemas
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationTypeOfUserSchemas</MethodName>
            <MethodComment>/** 
 * Return the collation type for user schemas. In Derby 10.3, this is either  UCS_BASIC or TERRITORY_BASED. The exact value is decided by what has  user asked for through JDBC url optional attribute COLLATION. If that atrribute is set to UCS_BASIC, the collation type for user schemas will be UCS_BASIC. If that attribute is set to TERRITORY_BASED, the  collation type for user schemas will be TERRITORY_BASED. If the user has not provided COLLATION attribute value in the JDBC url at database create time, then collation type of user schemas will default to  UCS_BASIC. Pre-10.3 databases after upgrade to Derby 10.3 will also use UCS_BASIC for collation type of user schemas. 
 * @return the collation type for user schemas
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named schema. Schema descriptors include authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.  Will check default schema for a match before scanning a system table.
 * @param schemaName	The name of the schema we're interested in. Must not be null.
 * @param tc			TransactionController
 * @param raiseError    whether an exception should be thrown if the schema does not exist.
 * @return	The descriptor for the schema. Can be null (not found) if raiseError is false.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>raiseError</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the SchemaDescriptor for the given schema identifier. 
 * @param schemaId	The id of the schema we're interested in.
 * @param tc		The transaction controller to us when scanningSYSSCHEMAS
 * @return	The descriptor for the schema, null if no such schema exists.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the SchemaDescriptor for the given schema identifier.
 * @param schemaId	The id of the schema we're interested in.
 * @param isolationLevel use this explicit isolation level
 * @param tc		The transaction controller to us when scanningSYSSCHEMAS
 * @return	The descriptor for the schema, null if no such schema exists.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsSchemaOwnedBy</MethodName>
            <MethodComment>/** 
 * Return true of there exists a schema whose authorizationId equals authid, i.e.  SYSSCHEMAS contains a row whose column AUTHORIZATIONID equals authid.
 * @param authid authorizationId
 * @param tc TransactionController
 * @return true iff there is a matching schema
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makePasswordHasher</MethodName>
            <MethodComment>/** 
 * Get the default password hasher for this database level. Returns null if the system is at rev level 10.5 or earlier.
 * @param props   The persistent properties used to configure password hashing.
 */
</MethodComment>
            <ReturnType>PasswordHasher</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the system schema. Schema descriptors include  authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSysIBMSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the SYSIBM schema. Schema descriptors include  authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeclaredGlobalTemporaryTablesSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the declared global temporary table schema which is always named "SESSION". SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSystemSchemaName</MethodName>
            <MethodComment>/** 
 * Determine whether a string is the name of the system schema.
 * @param name
 * @return	true or false
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrant</MethodName>
            <MethodComment>/** 
 * Drop a role grant
 * @param roleName	The name of the role to drop
 * @param grantee   The grantee
 * @param grantor   The grantor
 * @param tc        Transaction Controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrantsByGrantee</MethodName>
            <MethodComment>/** 
 * Drop all role grants corresponding to a grant of (any) role to a named authentication identifier
 * @param grantee   The grantee
 * @param tc        Transaction Controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrantsByName</MethodName>
            <MethodComment>/** 
 * Drop all role grants corresponding to a grant of the named role to any authentication identifier
 * @param roleName  The role name granted
 * @param tc        Transaction Controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createRoleClosureIterator</MethodName>
            <MethodComment>/** 
 * This method creates a new iterator over the closure of role grants starting or ending with a given role. This method will cause reading of dictionary, so should be called inside a transaction, after a  {@code dd.startReading()}or  {@code dd.startWriting()} call.
 * @param tc transaction controller
 * @param role name of starting point for closure
 * @param inverse If {@code true}, compute closure on inverse of relation GRANT role-a TO role-b that is, we look at closure of all roles granted &lt;bold&gt;to&lt;/bold&gt;  {@code role}. If {@code false}, we look at closure of all roles that have been granted  {@code role}.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>RoleClosureIterator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inverse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllPermsByGrantee</MethodName>
            <MethodComment>/** 
 * Drop all permission descriptors corresponding to a grant to the named authentication identifier
 * @param authid    The authentication identifier
 * @param tc        Transaction Controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Drop the descriptor for a schema, given the schema's name
 * @param schemaName	The name of the schema to drop
 * @param tc			Transaction Controller	
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSchemaEmpty</MethodName>
            <MethodComment>/** 
 * Indicate whether there is anything in the  particular schema.  Checks for tables in the the schema, on the assumption that there cannot be any other objects in a schema w/o a table.
 * @param sd schema descriptor
 * @return true/false
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named table within the given schema. If the schema parameter is NULL, it looks for the table in the current (default) schema. Table descriptors include object ids, object types (table, view, etc.)
 * @param tableName	The name of the table to get the descriptor for
 * @param schema	The descriptor for the schema the table lives in.If null, use the current (default) schema.
 * @param tc Transaction context.
 * @return	The descriptor for the table, null if table does notexiste.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the table with the given UUID. NOTE: I'm assuming that the object store will define an UUID for persistent objects. I'm also assuming that UUIDs are unique across schemas, and that the object store will be able to do efficient lookups across schemas (i.e. that no schema descriptor parameter is needed).
 * @param tableID	The UUID of the table to get the descriptor for
 * @return	The descriptor for the table, null if the table doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTableDescriptor</MethodName>
            <MethodComment>/** 
 * Drop the table descriptor.
 * @param td	The table descriptor to drop
 * @param schema		A descriptor for the schema the tableis a part of.  If this parameter is NULL, then the table is part of the current (default) schema
 * @param tc			TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateLockGranularity</MethodName>
            <MethodComment>/** 
 * Update the lockGranularity for the specified table.
 * @param td				The TableDescriptor for the table
 * @param schema			The SchemaDescriptor for the table
 * @param lockGranularity	The new lockGranularity
 * @param tc				The TransactionController to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockGranularity</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptorByDefaultId</MethodName>
            <MethodComment>/** 
 * Get a ColumnDescriptor given its Default ID.
 * @param uuid	The UUID of the default
 * @return The ColumnDescriptor for the column.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Given a column name and a table ID, drops the column descriptor from the table.
 * @param tableID	The UUID of the table to drop the column from
 * @param columnName	The name of the column to drop
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllColumnDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all column descriptors from the given table.  Useful for DROP TABLE.
 * @param tableID	The UUID of the table from which to dropall the column descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllTableAndColPermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all table and column permission descriptors for the given table.
 * @param tableID	The UUID of the table for which to dropall the table and column permission descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSYSCOLPERMSforAddColumnToUserTable</MethodName>
            <MethodComment>/** 
 * Need to update SYSCOLPERMS for a given table because a new column has  been added to that table. SYSCOLPERMS has a column called "COLUMNS" which is a bit map for all the columns in a given user table. Since ALTER TABLE .. ADD COLUMN .. has added one more column, we need to expand "COLUMNS" for that new column Currently, this code gets called during execution phase of ALTER TABLE .. ADD COLUMN .. 
 * @param tableID	The UUID of the table to which a column has been added
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSYSCOLPERMSforDropColumn</MethodName>
            <MethodComment>/** 
 * Update SYSCOLPERMS to reflect the dropping of a column from a table. This method rewrites SYSCOLPERMS rows to update the COLUMNS bitmap to reflect the removal of a column from a table. Currently, this code gets called during execution phase of ALTER TABLE .. DROP COLUMN .. 
 * @param tableID	The UUID of the table whose column has been dropped
 * @param tc		TransactionController for the transaction
 * @param columnDescriptor   Info about the dropped column
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDescriptor</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllRoutinePermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all routine permission descriptors for the given routine.
 * @param routineID	The UUID of the routine for which to dropall the permission descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routineID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the viewDescriptor for the view with the given UUID.
 * @param uuid	The UUID for the view
 * @return  A descriptor for the view
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the viewDescriptor for the view given its TableDescriptor.
 * @param td	The TableDescriptor for the view.
 * @return	A descriptor for the view
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropViewDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the view descriptor from the data dictionary.
 * @param viewDescriptor	A descriptor for the view to be dropped
 * @param tc				TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>viewDescriptor</ParamName>
                    <ParamType>ViewDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConstraintDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConstraintDescriptor given its name and schema ID.
 * @param constraintName	Constraint name.
 * @param schemaID			The schema UUID
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Load up the constraint descriptor list for this table descriptor (or all) and return it.  If the descriptor list is already loaded up, it is returned without further ado.
 * @param td The table descriptor.
 * @return   The ConstraintDescriptorList for the table. If null, returna list of all the constraint descriptors in all schemas.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActiveConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Convert a constraint descriptor list into a list of active constraints, that is, constraints which must be enforced. For the Core product, these are just the constraints on the original list. However, during REFRESH we may have deferred some constraints until statement end. This method returns the corresponding list of constraints which AREN'T deferred.
 * @param cdl	The constraint descriptor list to wrap withan Active constraint descriptor list.
 * @return The corresponding Active ConstraintDescriptorList
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>activeConstraint</MethodName>
            <MethodComment>/** 
 * Reports whether an individual constraint must be enforced. For the Core product, this routine always returns true. However, during REFRESH we may have deferred some constraints until statement end. This method returns false if the constraint deferred
 * @param constraint	the constraint to check
 * @return The corresponding Active ConstraintDescriptorList
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraint</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a table and the UUID String of the backing index.
 * @param td			The table descriptor.
 * @param uuid			The UUID  for the backing index.
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorById</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a table and the UUID String of the constraint
 * @param td			The table descriptor.
 * @param uuid			The UUID for the constraint
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorByName</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a TableDescriptor and the constraint name.
 * @param td				The table descriptor.
 * @param sd				The schema descriptor for the constraint
 * @param constraintName	The constraint name.
 * @param forUpdate			Whether or not access is for update
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintTableDescriptor</MethodName>
            <MethodComment>/** 
 * Return a table descriptor corresponding to the TABLEID field in SYSCONSTRAINTS where CONSTRAINTID matches the constraintId passed in.
 * @param constraintId	The id of the constraint
 * @return	the corresponding table descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getForeignKeys</MethodName>
            <MethodComment>/** 
 * Return a list of foreign keys constraints referencing this constraint.  Returns both enabled and disabled constraints.  
 * @param constraintId	The id of the referenced constraint
 * @return	list of constraints
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Adds the given ConstraintDescriptor to the data dictionary, associated with the given table and constraint type.
 * @param descriptor	The descriptor to add
 * @param tc			The transaction controller
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given ConstraintDescriptor from the data dictionary. NOTE: Caller is responsible for dropping any backing index
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all ConstraintDescriptors from the data dictionary that are associated with the given table. NOTE: Caller is responsible for dropping any backing index
 * @param table	The table from which to drop allconstraint descriptors
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Update the constraint descriptor in question.  Updates every row in the base conglomerate.  
 * @param cd					The Constraintescriptor
 * @param formerUUID			The UUID for this column in SYSCONSTRAINTS,may differ from what is in cd if this is the column that is being set.
 * @param colsToSet 			Array of ints of columns to be modified,1 based.  May be null (all cols).
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToSet</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubKeyConstraint</MethodName>
            <MethodComment>/** 
 * Get a SubKeyConstraintDescriptor from syskeys or sysforeignkeys for the specified constraint id.  For primary foreign and and unique key constraints.
 * @param constraintId	The UUID for the constraint.
 * @param type	The type of the constraint (e.g. DataDictionary.FOREIGNKEY_CONSTRAINT)
 * @return SubKeyConstraintDescriptor	The Sub descriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SubKeyConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Get a SPSDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The SPSDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Get the stored prepared statement descriptor given  a sps name.
 * @param name	The sps name.
 * @param sd	The schema descriptor.
 * @return The SPSDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllSPSDescriptors</MethodName>
            <MethodComment>/** 
 * Get every statement in this database. Return the SPSDescriptors in an list.
 * @return the list of descriptors
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSParams</MethodName>
            <MethodComment>/** 
 * Get all the parameter descriptors for an SPS. Look up the params in SYSCOLUMNS and turn them into parameter descriptors.  
 * @param spsd	sps descriptor
 * @param defaults the parameter defaults.  If not null,all the parameter defaults will be stuffed in here.
 * @return array of data type descriptors
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaults</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Adds the given SPSDescriptor to the data dictionary, associated with the given table and constraint type.
 * @param descriptor	The descriptor to add
 * @param tc			The transaction controller
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSPS</MethodName>
            <MethodComment>/** 
 * Updates SYS.SYSSTATEMENTS with the info from the SPSD. 
 * @param spsd	The descriptor to add
 * @param tc			The transaction controller
 * @param recompile		whether to recompile or invalidate
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recompile</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given SPSDescriptor.
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given SPSDescriptor. 
 * @param uuid	the statement uuid
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateAllSPSPlans</MethodName>
            <MethodComment>/** 
 * Invalidate all the stored plans in SYS.SYSSTATEMENTS for the given language connection context.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateAllSPSPlans</MethodName>
            <MethodComment>/** 
 * Invalidate all the stored plans in SYS.SYSSTATEMENTS. 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Get a TriggerDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The TriggerDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Get the stored prepared statement descriptor given  a sps name.
 * @param name	The sps name.
 * @param sd	The schema descriptor.
 * @return The TriggerDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>examineTriggerNodeAndCols</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actionStmt</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerDefinition</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedColsInTriggerAction</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createTriggerTime</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerActionString</MethodName>
            <MethodComment>/** 
 * This method does the job of transforming the trigger action plan text as shown below.  DELETE FROM t WHERE c = old.c turns into DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory:: getTriggerExecutionContext().getOldRow(). getInt(columnNumberFor'C'inRuntimeResultset); In addition to that, for CREATE TRIGGER time, it does the job of  collecting the column positions of columns referenced in trigger  action plan through REFERENCEs clause. This information will get saved in SYSTRIGGERS table by the caller in CREATE TRIGGER case. It gets called either  1)at the trigger creation time for row level triggers or 2)if the trigger got invalidated by some other sql earlier and the  current sql needs that trigger to fire. For such a trigger firing  case, this method will get called only if it is row level trigger  with REFERENCES clause. This work was done as part of DERBY-4874.  Before DERBY-4874, once the stored prepared statement for trigger  action plan was generated, it was never updated ever again. But,  one case where the trigger action plan needs to be regenerated is say when the column length is changed for a column which is REFERENCEd as old or new column value. eg of such a case would be say the Alter table has changed the length of a varchar column from varchar(30) to varchar(64) but the stored prepared statement associated with the  trigger action plan continued to use varchar(30). To fix varchar(30)  in stored prepared statement for trigger action sql to varchar(64),  we need to regenerate the trigger action sql. This new trigger  action sql will then get updated into SYSSTATEMENTS table. If we are here for case 1) above, then we will collect all column  references in trigger action through new/old transition variables.  Information about them will be saved in SYSTRIGGERS table DERBY-1482 (if we are dealing with pre-10.7 db, then we will not put any  information about trigger action columns in the system table to ensure  backward compatibility). This information along with the trigger  columns will decide what columns from the trigger table will be fetched into memory during trigger execution. If we are here for case 2) above, then all the information about  column references in trigger action has already been collected during CREATE TRIGGER time and hence we can use that available information  about column positions to do the transformation of OLD/NEW transient  references. More information on case 1) above.  DERBY-1482 One of the work done by this method for row level triggers is to find the columns which are referenced in the trigger action  through the REFERENCES clause ie thro old/new transition variables. This information will be saved in SYSTRIGGERS so it can be retrieved during the trigger execution time. The purpose of this is to recognize what columns from the trigger table should be read in during trigger execution. Before these code changes, during trigger execution, Derby was opting to read all the columns from the trigger table even if they were not all referenced during the trigger execution. This caused Derby to run into OOM at times when it could really be avoided. We go through the trigger action text and collect the column positions of all the REFERENCEd columns through new/old transition variables. We keep that information in SYSTRIGGERS. At runtime, when the trigger is fired, we will look at this information along with trigger columns from the trigger definition and only fetch those columns into memory rather than all the columns from the trigger table. This is especially useful when the table has LOB columns and those columns are not referenced in the trigger action and are not recognized as trigger columns. For such cases, we can avoid reading large values of LOB columns into memory and thus avoiding possibly running into OOM errors. If there are no trigger columns defined on the trigger, we will read all the columns from the trigger table when the trigger fires because no specific columns were identified as trigger column by the user. The other case where we will opt to read all the columns are when trigger columns and REFERENCING clause is identified for the trigger but there is no trigger action column information in SYSTRIGGERS. This can happen for triggers created prior to 10.7 release and later that database got hard/soft-upgraded to 10.7 or higher release.
 * @param actionStmt This is needed to get access to the various nodesgenerated by the Parser for the trigger action sql. These nodes will be used to find REFERENCEs column nodes.
 * @param oldReferencingName The name specified by the user for REFERENCEsto old row columns
 * @param newReferencingName The name specified by the user for REFERENCEsto new row columns
 * @param triggerDefinition The original trigger action text provided bythe user during CREATE TRIGGER time.
 * @param referencedCols Trigger is defined on these columns (will be nullin case of INSERT AND DELETE Triggers. Can also be null for DELETE Triggers if UPDATE trigger is not defined on specific column(s))
 * @param referencedColsInTriggerAction	what columns does the trigger action reference through old/new transition variables (may be null)
 * @param actionOffset offset of start of action clause
 * @param triggerTableDescriptor Table descriptor for trigger table
 * @param triggerEventMask TriggerDescriptor.TRIGGER_EVENT_XXX
 * @param createTriggerTime True if here for CREATE TRIGGER,false if here because an invalidated row level trigger with  REFERENCEd columns has been fired and hence trigger action sql associated with SPSDescriptor may be invalid too.
 * @param replacements a list that will be populated with objects thatdescribe how  {@code triggerDefinition} has been transformed intothe returned SQL text. Each element in the list will contain four integers. The first two describe the begin and end offset of the replaced text in the  {@code triggerDefinition}. The last two describe the begin and end offset of the replacement text in the returned string. The begin offsets are inclusive, whereas the end offsets are exclusive. The list can be  {@code null} if the caller does not careabout this information.
 * @return Transformed trigger action sql
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actionStmt</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerDefinition</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedColsInTriggerAction</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createTriggerTime</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptors</MethodName>
            <MethodComment>/** 
 * Load up the trigger descriptor list for this table descriptor and return it.  If the descriptor list is already loaded up, it is returned without further ado. The descriptors are returned in the order in which the triggers were created, with the oldest first.
 * @param td			The table descriptor.
 * @return The ConstraintDescriptorList for the table
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Update the trigger descriptor in question.  Updates every row in the base conglomerate.  
 * @param triggerd				The Triggerescriptor
 * @param formerUUID			The UUID for this column in SYSTRIGGERS,may differ from what is in triggerd if this is the column that is being set.
 * @param colsToSet 			Array of ints of columns to be modified,1 based.  May be null (all cols).
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerd</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToSet</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given TriggerDescriptor that is associated with the given table and constraint type from the data dictionary.
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashAllConglomerateDescriptorsByNumber</MethodName>
            <MethodComment>/** 
 * Get all of the ConglomerateDescriptors in the database and hash them by conglomerate number. This is useful as a performance optimization for the locking VTIs. NOTE:  This method will scan SYS.SYSCONGLOMERATES at READ COMMITTED. It should really scan at READ UNCOMMITTED, but there is no such thing yet.
 * @param tc		TransactionController for the transaction
 * @return	A Hashtable with all of the ConglomerateDescriptorsin the database hashed by conglomerate number.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashAllTableDescriptorsByTableId</MethodName>
            <MethodComment>/** 
 * Get all of the TableDescriptors in the database and hash them by TableId This is useful as a performance optimization for the locking VTIs. NOTE:  This method will scan SYS.SYSTABLES at READ COMMITTED. It should really scan at READ UNCOMMITTED, but there is no such thing yet.
 * @param tc		TransactionController for the transaction
 * @return	A Hashtable with all of the Table descriptors in the databasehashed by TableId
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConglomerateDescriptor given its UUID.  If it is an index conglomerate shared by at least another duplicate index, this returns one of the ConglomerateDescriptors for those indexes. 
 * @param uuid	The UUID
 * @return A ConglomerateDescriptor for the conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Get an array of ConglomerateDescriptors given the UUID.  If it is a heap conglomerate or an index conglomerate not shared by a duplicate index, the size of the return array is 1. If the uuid argument is null, then this method retrieves descriptors for all of the conglomerates in the database.
 * @param uuid	The UUID
 * @return An array of ConglomerateDescriptors for the conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConglomerateDescriptor given its conglomerate number.  If it is an index conglomerate shared by at least another duplicate index, this returns one of the ConglomerateDescriptors for those indexes. 
 * @param conglomerateNumber	The conglomerate number.
 * @return A ConglomerateDescriptor for the conglomerate.  Returns NULL ifno such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Get an array of conglomerate descriptors for the given conglomerate number.  If it is a heap conglomerate or an index conglomerate not shared by a duplicate index, the size of the return array is 1.
 * @param conglomerateNumber	The number for the conglomeratewe're interested in
 * @return	An array of ConglomerateDescriptors that share the requestedconglomerate. Returns size 0 array if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Gets a conglomerate descriptor for the named index in the given schema, getting an exclusive row lock on the matching row in  sys.sysconglomerates (for DDL concurrency) if requested.
 * @param indexName	The name of the index we're looking for
 * @param sd		The schema descriptor
 * @param forUpdate	Whether or not to get an exclusive row lock on the row in sys.sysconglomerates.
 * @return	A ConglomerateDescriptor describing the requestedconglomerate. Returns NULL if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Drops a conglomerate descriptor
 * @param conglomerate	The ConglomerateDescriptor for the conglomerate
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerate</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all conglomerates associated with a table.
 * @param td		The TableDescriptor of the table 
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Update the conglomerateNumber for an array of ConglomerateDescriptors. In case of more than one ConglomerateDescriptor, they are for duplicate indexes sharing one conglomerate. This is useful, in 1.3, when doing a bulkInsert into an  empty table where we insert into a new conglomerate. (This will go away in 1.4.)
 * @param cds					The array of ConglomerateDescriptors
 * @param conglomerateNumber	The new conglomerate number
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cds</ParamName>
                    <ParamType>ConglomerateDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Update the conglomerateNumber for a ConglomerateDescriptor. This is useful, in 1.3, when doing a bulkInsert into an  empty table where we insert into a new conglomerate. (This will go away in 1.4.)
 * @param cd					The ConglomerateDescriptor
 * @param conglomerateNumber	The new conglomerate number
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependentsDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets a list of the dependency descriptors for the given dependent's id.
 * @param dependentID		The ID of the dependent we're interested in
 * @return	List			Returns a list of DependencyDescriptors. Returns an empty list if no stored dependencies for the dependent's ID.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>DependencyDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProvidersDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets a list of the dependency descriptors for the given provider's id.
 * @param providerID		The ID of the provider we're interested in
 * @return	List			Returns a list of DependencyDescriptors. Returns an empty List if no stored dependencies for the provider's ID.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>DependencyDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>providerID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllDependencyDescriptorsList</MethodName>
            <MethodComment>/** 
 * Build and return an List with DependencyDescriptors for all of the stored dependencies.   This is useful for consistency checking.
 * @return List		List of all DependencyDescriptors.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TupleDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStoredDependency</MethodName>
            <MethodComment>/** 
 * Drop a dependency from the data dictionary.
 * @param dd	The DependencyDescriptor.
 * @param tc	TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DependencyDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDependentsStoredDependencies</MethodName>
            <MethodComment>/** 
 * Remove all of the stored dependencies for a given dependent's ID  from the data dictionary.
 * @param dependentsUUID	Dependent's uuid
 * @param tc				TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUUIDFactory</MethodName>
            <MethodComment>/** 
 * Get the UUID Factory.  (No need to make the UUIDFactory a module.)
 * @return UUIDFactory	The UUID Factory for this DataDictionary.
 */
</MethodComment>
            <ReturnType>UUIDFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptorForUDT</MethodName>
            <MethodComment>/** 
 * Get the alias descriptor for an ANSI UDT.
 * @param tc The transaction to use: if null, use the compilation transaction
 * @param dtd The UDT's type descriptor
 * @return The UDT's alias descriptor if it is an ANSI UDT; null otherwise.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Get an AliasDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The AliasDescriptor for method alias.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Get a AliasDescriptor by alias name and name space. NOTE: caller responsible for handling no match.
 * @param schemaID		schema identifier
 * @param aliasName		The alias name.
 * @param nameSpace		The alias name space.
 * @return AliasDescriptor	AliasDescriptor for the alias name and name space
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aliasName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameSpace</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineList</MethodName>
            <MethodComment>/** 
 * Get the list of routines matching the schema and routine name.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>routineName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameSpace</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Drop an AliasDescriptor from the DataDictionary
 * @param ad	The AliasDescriptor to drop
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ad</ParamName>
                    <ParamType>AliasDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateUser</MethodName>
            <MethodComment>/** 
 * Update a user. Changes all columns in the corresponding SYSUSERS row except for the user name.
 * @param newDescriptor New values for columns in the SYSUSERS row.
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newDescriptor</ParamName>
                    <ParamType>UserDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUser</MethodName>
            <MethodComment>/** 
 * Return the credentials descriptor for the named user.
 * @param userName      Name of the user whose credentials we want.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>UserDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropUser</MethodName>
            <MethodComment>/** 
 * Drop a User from the DataDictionary
 * @param userName The user to drop.
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEngineType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * Get a FileInfoDescriptor given its id.
 * @param id The descriptor's id.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * Get a FileInfoDescriptor given its SQL name and schema name.  
 * @param sd        the schema that holds the FileInfoDescriptor.
 * @param name		SQL name of file.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * Drop a FileDescriptor from the datadictionary.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fid</ParamName>
                    <ParamType>FileInfoDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeAutoincRowLocations</MethodName>
            <MethodComment>/** 
 * returns an array of RowLocations corresponding to the autoincrement columns in the table. The RowLocation points to the  row in SYSCOLUMNS for this particular ai column. The array has as many elements as there are columns in the table. If a column is not an ai column, the entry is NULL.
 * @param tc		TransactionControler to use to compute the row location.
 * @param td		TableDescriptor
 * @return  array of row locations, null if table has no autoinc columns.
 * @exception StandardException if an error happens
 */
</MethodComment>
            <ReturnType>RowLocation[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowLocationTemplate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetAutoincrementValue</MethodName>
            <MethodComment>/** 
 * getSetAutoincrementValue fetches the autoincrement value from  SYSCOLUMNS given a row location. If doUpdate is true it updates the autoincrement column with the new value. the value returned by this routine is the new value and *NOT* the value in the system catalogs.
 * @param rl		RowLocation of the entry in SYSCOLUMNS.
 * @param tc		TransactionController to use.
 * @param doUpdate  Write the new value to disk if TRUE.
 * @param newValue	A NumberDataValue to use to return incremented value. Ifnull, then the caller simply wants the current value fromd disk.
 * @param wait		If true, then the caller wants to wait for locks. Whenusing a nested user xaction we want to timeout right away if the parent holds the lock.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrementValue</MethodName>
            <MethodComment>/** 
 * sets a new value in SYSCOLUMNS for a particular autoincrement column.
 * @param tc		 Transaction Controller to use.
 * @param tableUUID		 Table Descriptor
 * @param columnName Name of the column.
 * @param aiValue	 Value to write to SYSCOLUMNS.
 * @param incrementNeeded Whether we should increment the value passed in bythe user (aiValue) before writing the value to SYSCOLUMNS.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aiValue</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>incrementNeeded</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeSequenceRowLocation</MethodName>
            <MethodComment>/** 
 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also constructs the sequence descriptor.
 * @param tc			Transaction Controller to use.
 * @param sequenceIDstring UUID of the sequence as a string
 * @param rowLocation OUTPUT param for returing the row location
 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceIDstring</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceDescriptor</ParamName>
                    <ParamType>SequenceDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateCurrentSequenceValue</MethodName>
            <MethodComment>/** 
 * Set the current value of an ANSI/ISO sequence. This method does not perform any sanity checking but assumes that the caller knows what they are doing. If the old value on disk is not what we expect it to be, then we are in a race with another session. They won and we don't update the value on disk. However, if the old value is null, that is a signal to us that we should update the value on disk anyway.
 * @param tc			Transaction Controller to use.
 * @param rowLocation Row in SYSSEQUENCES to update.
 * @param wait True if we should wait for locks
 * @param oldValue What we expect to find in the CURRENTVALUE column.
 * @param newValue What to stuff into the CURRENTVALUE column.
 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentValueAndAdvance</MethodName>
            <MethodComment>/** 
 * Get the next number from an ANSI/ISO sequence generator which was created with the CREATE SEQUENCE statement. May raise an exception if the sequence was defined as NO CYCLE and the range of the sequence is exhausted. May allocate a range of sequence numbers and update the CURRENTVALUE column of the corresponding row in SYSSEQUENCES. This work is done in the execution transaction of the current session.
 * @param sequenceUUIDstring String value of the UUID which identifies the sequence
 * @param returnValue This is a data value to be stuffed with the next sequence number.
 * @throws StandardException if the sequence does not cycle and its range is exhausted
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDstring</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekAtIdentity</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Peek at the next value which will be returned by an identity generator. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekAtSequence</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Peek at the next value which will be returned by a sequence generator. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatisticsDescriptors</MethodName>
            <MethodComment>/** 
 * Gets all statistics Descriptors for a given table.
 */
</MethodComment>
            <ReturnType>StatisticsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStatisticsDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all statistics descriptors for a given table/index column combination. If the index is not specified, then all statistics for the table are dropped.
 * @param tableUUID 	  UUID of the table 
 * @param referenceUUID UUID of the index. This can be null.
 * @param tc 			  Transcation Controller to use.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referenceUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependencyManager</MethodName>
            <MethodComment>/** 
 * Returns the dependency manager for this DataDictionary. Associated with each DataDictionary object there is a DependencyManager object which keeps track of both persistent and stored dependencies. 
 * @see org.apache.derby.iapi.sql.depend.DependencyManager
 */
</MethodComment>
            <ReturnType>DependencyManager</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCacheMode</MethodName>
            <MethodComment>/** 
 * Returns the cache mode of the data dictionary.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemSQLName</MethodName>
            <MethodComment>/** 
 * Returns a unique system generated name of the form SQLyymmddhhmmssxxn yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second, xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value, n - number between 0-9
 * @return	system generated unique name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDescriptor</MethodName>
            <MethodComment>/** 
 * Adds a descriptor to a system catalog identified by the catalogNumber. 
 * @param tuple			   descriptor to insert.
 * @param parent           parent descriptor; e.g for a column parent is thetabledescriptor to which the descriptor is beign inserted. for most other objects it is the schema descriptor.
 * @param catalogNumber	   a value which identifies the catalog into whichthe descriptor should be inserted. It is the users responsibility to ensure that the catalogNumber is consistent with the tuple being inserted. 
 * @see DataDictionary#SYSCONGLOMERATES_CATALOG_NUM
 * @param allowsDuplicates whether an exception should be thrown if theinsert results in a duplicate; if this parameter is FALSE then one of the following exception will be thrown; LANG_OBJECT_ALREADY_EXISTS (if parent is null) or LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT (if parent is not null). The error message is created by getting the name and type of the tuple and parent.
 * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#duplicateDescriptorException
 * @param tc	the transaction controller to use to do all of this.
 * @see #addDescriptorArray
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tuple</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowsDuplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDescriptorArray</MethodName>
            <MethodComment>/** 
 * array version of addDescriptor.
 * @see #addDescriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tuple</ParamName>
                    <ParamType>TupleDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowsDuplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkVersion</MethodName>
            <MethodComment>/** 
 * Check to see if a database has been upgraded to the required level in order to use a langauge feature that is. &lt;P&gt; This is used to ensure new functionality that would lead on disk information not understood by a previous release is not executed while in soft upgrade mode. Ideally this is called at compile time and the parser has a utility method to enable easy use at parse time. &lt;P&gt; To use this method, a feature implemented in a certain release (DataDictionary version) would call it with the constant matching the release. E.g. for a new feature added in 10.1, a call such as  &lt;PRE&gt; // check and throw an exception if the database is not at 10.1 dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "NEW FEATURE NAME"); &lt;/PRE&gt; This call would occur during the compile time, usually indirectly through the parser utility method, but direct calls can be made during QueryNode initialization, or even at bind time. &lt;BR&gt; It is not expected that this method would be called at execution time.
 * @param majorVersion Data Dictionary major version (DataDictionary.DD_ constant)
 * @param feature Non-null to throw an error, null to return the state of the version match.
 * @return True if the database has been upgraded to the required level, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>majorVersion</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>feature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnlyUpgrade</MethodName>
            <MethodComment>/** 
 * Check if the database is read only and requires some form of upgrade that makes the stored prepared statements invalid.
 * @return {@code true} if the stored prepared statements are invalidbecause of an upgrade and the database is read only,  {@code false}otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRemovePermissionsDescriptor</MethodName>
            <MethodComment>/** 
 * Add or remove a permission to the permission database.
 * @param add if true then add the permission, if false remove it.
 * @param perm
 * @param grantee
 * @param tc
 * @return True means revoke has removed a privilege from systemtable and hence the caller of this method should send invalidation  actions to PermssionDescriptor's dependents.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>add</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>perm</ParamName>
                    <ParamType>PermissionsDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges on a table using tableUUID and authorizationid
 * @param tableUUID
 * @param authorizationId The user name
 * @return a TablePermsDescriptor or null if the user has no permissions on the table.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>TablePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges on a table using tablePermsUUID
 * @param tablePermsUUID
 * @return a TablePermsDescriptor
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>TablePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tablePermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's column privileges for a table.
 * @param tableUUID
 * @param privType Authorizer.SELECT_PRIV, Authorizer.UPDATE_PRIV, or Authorizer.REFERENCES_PRIV
 * @param forGrant
 * @param authorizationId The user name
 * @return a ColPermsDescriptor or null if the user has no separate columnpermissions of the specified type on the table. Note that the user may have been granted permission on all the columns of the table (no column list), in which case this routine will return null. You must also call getTablePermissions to see if the user has permission on a set of columns.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forGrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's column privileges for a table. This routine gets called  during revoke privilege processing
 * @param tableUUID
 * @param privTypeStr (as String) Authorizer.SELECT_PRIV, Authorizer.UPDATE_PRIV, or Authorizer.REFERENCES_PRIV
 * @param forGrant
 * @param authorizationId The user name
 * @return a ColPermsDescriptor or null if the user has no separate columnpermissions of the specified type on the table. Note that the user may have been granted permission on all the columns of the table (no column list), in which case this routine will return null. You must also call getTablePermissions to see if the user has permission on a set of columns.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privTypeStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forGrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's column privileges on a table using colPermsUUID
 * @param colPermsUUID
 * @return a ColPermsDescriptor
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colPermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutinePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's permissions for a routine (function or procedure).
 * @param routineUUID
 * @param authorizationId The user's name
 * @return The descriptor of the users permissions for the routine.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>RoutinePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routineUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutinePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges for a routine using routinePermsUUID
 * @param routinePermsUUID
 * @return a RoutinePermsDescriptor
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>RoutinePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routinePermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVTIClass</MethodName>
            <MethodComment>/** 
 * Return the Java class to use for the VTI to which the received table descriptor maps. There are two kinds of VTI mappings that we do: the first is for "table names", the second is for "table function names".  Table names can only be mapped to VTIs that do not accept any arguments; any VTI that has at least one constructor which accepts one or more arguments must be mapped from a table *function* name. An example of a VTI "table name" is the following: select * from SYSCS_DIAG.LOCK_TABLE In this case "SYSCS_DIAG.LOCK_TABLE" is the table name that we want to map.  Since the corresonding VTI does not accept any arguments, this VTI table name can be used anywhere a normal base table name can be used. An example of a VTI "table function name" is the following: select * from TABLE(SYSCS_DIAG.SPACE_TABLE(?)) x In this case "SYSCS_DIAG.SPACE_TABLE" is the table function name that we want to map.  Since the corresponding VTI can take either one or two arguments we have to use the TABLE constructor syntax to pass the argument(s) in as if we were making a function call.  Hence the term "table function".
 * @param td Table descriptor used for the VTI look-up.
 * @param asTableFunction If false then treat td's descriptor name as aVTI "table name"; if true, treat the descriptor name as a VTI "table function name".
 * @return Java class name to which "td" maps, or null if no mappingis found.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>asTableFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltinVTIClass</MethodName>
            <MethodComment>/** 
 * Return the Java class to use for a builtin VTI to which the received table descriptor maps.
 * @param td Table descriptor used for the VTI look-up.
 * @param asTableFunction If false then treat td's descriptor name as aVTI "table name"; if true, treat the descriptor name as a VTI "table function name".
 * @return Java class name of builtin VTI to which "td" maps, or null if no mappingis found.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>asTableFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleDefinitionDescriptor</MethodName>
            <MethodComment>/** 
 * Get a role grant descriptor for a role definition.
 * @param roleName The name of the role whose definition we seek
 * @throws StandardException error
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleGrantDescriptor</MethodName>
            <MethodComment>/** 
 * Get the role grant descriptor corresponding to the uuid provided
 * @param uuid
 * @return The descriptor for the role grant descriptor
 * @exception StandardException  Thrown on error
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleGrantDescriptor</MethodName>
            <MethodComment>/** 
 * Get a descriptor for a role grant
 * @param roleName The name of the role whose definition we seek
 * @param grantee  The grantee
 * @param grantor  The grantor
 * @throws StandardException error
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDependentsStoredDependencies</MethodName>
            <MethodComment>/** 
 * Remove all of the stored dependencies for a given dependent's ID  from the data dictionary.
 * @param dependentsUUID	Dependent's uuid
 * @param tc				TransactionController for the transaction
 * @param wait  If true, then the caller wants to wait for locks. False willbe when we using a nested user xaction - we want to timeout  right away if the parent holds the lock. 
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsGrantToAuthid</MethodName>
            <MethodComment>/** 
 * Check all dictionary tables and return true if there is any GRANT descriptor containing &lt;code&gt;authId&lt;/code&gt; as its grantee.
 * @param authId grantee for which a grant exists or not
 * @param tc TransactionController for the transaction
 * @return boolean true if such a grant exists
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateMetadataSPSes</MethodName>
            <MethodComment>/** 
 * Drop and recreate metadata stored prepared statements.
 * @param tc the xact
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSequenceDescriptor</MethodName>
            <MethodComment>/** 
 * Drop a sequence descriptor.
 * @param sequenceDescriptor
 * @param tc
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceDescriptor</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSequenceDescriptor</MethodName>
            <MethodComment>/** 
 * get a descriptor for a Sequence by uuid
 * @param uuid uuid of the sequence
 * @return the SequenceDescriptor
 * @throws StandardException error
 */
</MethodComment>
            <ReturnType>SequenceDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSequenceDescriptor</MethodName>
            <MethodComment>/** 
 * get a descriptor for a Sequence by sequence name
 * @param sequenceName Name of the sequence
 * @param sd The scemadescriptor teh sequence belongs to
 * @return The SequenceDescriptor
 * @throws StandardException error
 */
</MethodComment>
            <ReturnType>SequenceDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericPermissions</MethodName>
            <MethodComment>/** 
 * Get permissions granted to one user for an object using the object's Id and the user's authorization Id.
 * @param objectUUID ID of the object being protected
 * @param objectType Type of the object (e.g., PermDescriptor.SEQUENCE_TYPE)
 * @param privilege The kind of privilege needed (e.g., PermDescriptor.USAGE_PRIV)
 * @param granteeAuthId The user who needs the permission
 * @return The descriptor of the permissions for the object
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>PermDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>objectType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privilege</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>granteeAuthId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges for an object using the permUUID
 * @param permUUID
 * @return a PermDescriptor
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>PermDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>permUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllPermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all permission descriptors for the given object
 * @param objectID The UUID of the object from which to dropall permissions
 * @param tc        TransactionController for the transaction
 * @throws StandardException Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCreateIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * Tells if an index statistics refresher should be created for this database. &lt;p&gt; The only reason not to create an index statistics refresher is if one already exists.
 * @return {@code true} if an index statistics refresher should be created,{@code false} if one already exists.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * Creates an index statistics refresher for this data dictionary. &lt;p&gt; The index statistics refresher is used to create and refresh index cardinality statistics, either automatically or on user demand (i.e. by invoking SYSCS_UTIL.SYSCS_UPDATE_STATISTICS).
 * @param db the database object associated with this data dictionary
 * @param databaseName the name of the database
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>db</ParamName>
                    <ParamType>Database</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>databaseName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * Returns the index statistics refresher.
 * @param asDaemon whether the usage is automatic ({@code true}) or explicit ( {@code false})
 * @return The index statistics refresher instance, or {@code null} ifdisabled. If  {@code asDaemon} is {@code false}, an instance will always be returned.
 */
</MethodComment>
            <ReturnType>IndexStatisticsDaemon</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>asDaemon</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disableIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * Disables automatic refresh/creation of index statistics at runtime. &lt;p&gt; If the daemon is disabled, it can only be enabled again by rebooting the database. Note that this method concerns diabling the daemon at runtime, and only the automatic updates of statistics. If wanted, the user would disable the daemon at boot-time by setting a property (system-wide or database property). &lt;p&gt; &lt;em&gt;Usage note:&lt;/em&gt; This method was added to allow the index refresher itself to notify the data dictionary that it should be disabled. This only happens if the refresher/daemon experiences severe errors, or a large amount of errors. It would then disable itself to avoid eating up system resources and potentially cause side-effects due to the errors.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependableFinder</MethodName>
            <MethodComment>/** 
 * Get a  {@code DependableFinder} instance.
 * @param formatId the format id
 * @return an instance capable of finding {@code Dependable}s with the specified format id
 */
</MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDependableFinder</MethodName>
            <MethodComment>/** 
 * Get a  {@code DependableFinder} instance for referenced columns ina table.
 * @param formatId the format id
 * @param columnBitMap byte array encoding the bitmap of referenced columns
 * @return an instance capable of finding {@code Dependable}s with the specified format id
 */
</MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnBitMap</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBulkInsertCounter</MethodName>
            <MethodComment>/** 
 * Get the identity generator used to support the bulk-insert optimization in InsertResultSet.
 * @param sequenceUUIDString UUID of the sequence which backs the identity column.
 * @param restart   True if the counter should be re-initialized to its start position.
 */
</MethodComment>
            <ReturnType>BulkInsertCounter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restart</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushBulkInsertCounter</MethodName>
            <MethodComment>/** 
 * Flush the updated values of the BulkInsertCounter to disk and to the original, cached SequenceUpdater. This is used for the bulk-insert optimization in InsertResultSet.
 * @param sequenceUUIDString UUID of the sequence which backs the identity column.
 * @param bic   the BulkInsertCounter which generates identities for bulk insert
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bic</ParamName>
                    <ParamType>BulkInsertCounter</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>