<Class>
    <Id>330</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>DeleteNode</ClassName>
    <SuperClass>DMLModStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DeleteNode  /** 
 * A DeleteNode represents a DELETE statement. It is the top-level node for the statement. For positioned delete, there may be no from table specified. The from table will be derived from the cursor specification of the named cursor.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>COLUMNNAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>deferred</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>targetTable</FieldName>
            <FieldType>FromTable</FieldType>
        </Field>
        <Field>
            <FieldName>readColsBitSet</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>dependentConstantActions</FieldName>
            <FieldType>ConstantAction[]</FieldType>
        </Field>
        <Field>
            <FieldName>cascadeDelete</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dependentNodes</FieldName>
            <FieldType>StatementNode[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DeleteNode</MethodName>
            <MethodComment>/** 
 * Constructor for a DeleteNode.
 * @param targetTableName	The name of the table to delete from
 * @param queryExpression	The query expression that will generatethe rows to delete from the given table
 * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
 * @param cm                The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryExpression</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>matchingClause</ParamName>
                    <ParamType>MatchingClauseNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment>/** 
 * Bind this DeleteNode.  This means looking up tables and columns and getting their types, and figuring out the result types of all expressions, as well as doing view resolution, permissions checking, etc. &lt;p&gt; If any indexes need to be updated, we add all the columns in the base table to the result column list, so that we can use the column values as look-up keys for the index rows to be deleted.  Binding a delete will also massage the tree so that the ResultSetNode has  column containing the RowLocation of the base row.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();pushCurrentPrivType;[Authorizer.SELECT_PRIV]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrivType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment>/** 
 * Compile constants that Execution will use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Code generation for delete. The generated code will contain: o  A static member for the (xxx)ResultSet with the RowLocations o  The static member will be assigned the appropriate ResultSet within the nested calls to get the ResultSets.  (The appropriate cast to the (xxx)ResultSet will be generated.) o  The CurrentRowLocation() in SelectNode's select list will generate a new method for returning the RowLocation as well as a call to that method which will be stuffed in the call to the  ProjectRestrictResultSet. o In case of referential actions, this function generate an array of resultsets on its dependent tables.
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb	The execute() method to be built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [resultSetGetter]</InnerVar>
                <InnerVar>int [argCount]</InnerVar>
                <InnerVar>String [parentResultSetId]</InnerVar>
                <InnerVar>String [resultSetArrayType=ClassName.ResultSet + "[]"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateCodeForTemporaryTable;[acb]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;newRowLocationScanResultSetName;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, resultSetGetter, ClassName.ResultSet, argCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementType</MethodName>
            <MethodComment>/** 
 * Return the type of statement, something from StatementType.
 * @return the type of statement
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReadMap</MethodName>
            <MethodComment>/** 
 * Gets the map of all columns which must be read out of the base table. These are the columns needed to: o	maintain indices o	maintain foreign keys The returned map is a FormatableBitSet with 1 bit for each column in the table plus an extra, unsued 0-bit. If a 1-based column id must be read from the base table, then the corresponding 1-based bit is turned ON in the returned FormatableBitSet.
 * @param dd				the data dictionary to look in
 * @param baseTable		the base table descriptor
 * @return	a FormatableBitSet of columns to be read out of the base table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean[] [needsDeferredProcessing=new boolean[1]]</InnerVar>
                <InnerVar>ArrayList&lt;ConglomerateDescriptor&gt; [conglomerates=new ArrayList&lt;ConglomerateDescriptor&gt;()]</InnerVar>
                <InnerVar>FormatableBitSet [columnMap=DeleteNode.getDeleteReadMap(baseTable,conglomerates,relevantTriggers,needsDeferredProcessing)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;markAffectedIndexes;[conglomerates]</InnerMethodInvoke>
                <InnerMethodInvoke>null;adjustDeferredFlag;[needsDeferredProcessing[0]]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependentTableNode</MethodName>
            <MethodComment>/** 
 * In case of referential actions, we require to perform DML (UPDATE or DELETE) on the dependent tables.  Following function returns the DML Node for the dependent table.
 */
</MethodComment>
            <ReturnType>StatementNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refAction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DMLModStatementNode [node=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEmptyDeleteNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DeleteNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [whereClause=null]</InnerVar>
                <InnerVar>TableName [tableName=new TableName(schemaName,targetTableName,getContextManager())]</InnerVar>
                <InnerVar>FromList [fromList=new FromList(getContextManager())]</InnerVar>
                <InnerVar>FromTable [fromTable=new FromBaseTable(tableName,null,FromBaseTable.DELETE,null,getContextManager())]</InnerVar>
                <InnerVar>Properties [targetProperties=new FormatableProperties()]</InnerVar>
                <InnerVar>SelectNode [rs=new SelectNode(null,fromList,whereClause,null,null,null,null,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>targetProperties;put;["index", "null"]</InnerMethodInvoke>
                <InnerMethodInvoke>((FromBaseTable)fromTable);setTableProperties;[targetProperties]</InnerMethodInvoke>
                <InnerMethodInvoke>fromList;addFromTable;[fromTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEmptyUpdateNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>UpdateNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [whereClause=null]</InnerVar>
                <InnerVar>TableName [tableName=new TableName(schemaName,targetTableName,getContextManager())]</InnerVar>
                <InnerVar>FromList [fromList=new FromList(getContextManager())]</InnerVar>
                <InnerVar>FromTable [fromTable=new FromBaseTable(tableName,null,FromBaseTable.DELETE,null,getContextManager())]</InnerVar>
                <InnerVar>Properties [targetProperties=new FormatableProperties()]</InnerVar>
                <InnerVar>SelectNode [sn=new SelectNode(getSetClause(cdl),fromList,whereClause,null,null,null,null,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>targetProperties;put;["index", "null"]</InnerMethodInvoke>
                <InnerMethodInvoke>((FromBaseTable)fromTable);setTableProperties;[targetProperties]</InnerMethodInvoke>
                <InnerMethodInvoke>fromList;addFromTable;[fromTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [resultColumn]</InnerVar>
                <InnerVar>ValueNode [valueNode]</InnerVar>
                <InnerVar>ResultColumnList [columnList=new ResultColumnList(getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>IgnoreFilter [ignorePermissions=new IgnoreFilter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeleteReadMap</MethodName>
            <MethodComment>/** 
 * Builds a bitmap of all columns which should be read from the Store in order to satisfy an DELETE statement. 1)	finds all indices on this table 2)	adds the index columns to a bitmap of affected columns 3)	adds the index descriptors to a list of conglomerate descriptors. 4)	finds all DELETE triggers on the table 5)	if there are any DELETE triggers, then do one of the following a)If all of the triggers have MISSING referencing clause, then that means that the trigger actions do not have access to before and after values. In that case, there is no need to blanketly decide  to include all the columns in the read map just because there are triggers defined on the table. b)Since one/more triggers have REFERENCING clause on them, get all the columns because we don't know what the user will ultimately  reference. 6)	adds the triggers to an evolving list of triggers
 * @param conglomerates       OUT: list of affected indices
 * @param relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
 * @param needsDeferredProcessing			IN/OUT. true if the statement already needsdeferred processing. set while evaluating this routine if a trigger requires deferred processing
 * @return a FormatableBitSet of columns to be read out of the base table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerates</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relevantTriggers</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needsDeferredProcessing</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnCount=baseTable.getMaxColumnID()]</InnerVar>
                <InnerVar>FormatableBitSet [columnMap=new FormatableBitSet(columnCount + 1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DMLModStatementNode;getXAffectedIndexes;[baseTable, null, columnMap, conglomerates]</InnerMethodInvoke>
                <InnerMethodInvoke>baseTable;getAllRelevantTriggers;[StatementType.DELETE, (int[])null, relevantTriggers]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>correlateAddedColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [correlationName=fromTable.getCorrelationName()]</InnerVar>
                <InnerVar>TableName [correlationNameNode=makeTableName(null,correlationName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>