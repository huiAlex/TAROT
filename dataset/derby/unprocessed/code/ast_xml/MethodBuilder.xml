<Class>
    <Id>546</Id>
    <Package>org.apache.derby.iapi.services.compiler</Package>
    <ClassName>MethodBuilder</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MethodBuilder  /** 
 * MethodBuilder is used to generate the code for a method. &lt;P&gt; The code for a method is built in a way that corresponds to the layout of the stack machine that is the Java Virtual Machine. Values are pushed on the stack, moved about on the stack and then popped off the stack by operations such as method calls. An understanding of hoe the JVM operates is useful before using this class. &lt;P&gt; All the method descriptions below are generating bytecode to achieved the desired behaviour when the generated class is loaded. None of this class's methods calls actually invoke methods or create objects described by the callers.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>addThrownException</MethodName>
            <MethodComment>/** 
 * Declare the method throws an exception. Must be called before any code is added to the method.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>exceptionClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment>/** 
 * return the name of the method.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>complete</MethodName>
            <MethodComment>/** 
 * Indicate the method is complete. Once this call has been made the caller must discard the reference to this object.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameter</MethodName>
            <MethodComment>/** 
 * Push a parameter value. &lt;PRE&gt; Stack ...  =&amp;gt; ...,param_value &lt;/PRE&gt;
 * @param id position of the parameter (zero based).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a byte constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,byte_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a boolean constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,boolean_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a short constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,short_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a int constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,int_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a long constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,long_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a float constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,float_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a double constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,double_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment>/** 
 * Push a String constant onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,String_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNull</MethodName>
            <MethodComment>/** 
 * Push a typed null onto the stack &lt;PRE&gt; Stack ...  =&amp;gt; ...,null &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Push the contents of the local field onto the stack. This call pushes the this instance required to access the field itself. &lt;PRE&gt; Stack ...  =&amp;gt; ...,field_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getField</MethodName>
            <MethodComment>/** 
 * Push the contents of the described field onto the stack. This call requires the instance (reference) to be pushed by the caller. &lt;PRE&gt; Stack ...,field_ref  =&amp;gt; ...,field_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStaticField</MethodName>
            <MethodComment>/** 
 * Push the contents of the described static field onto the stack. &lt;PRE&gt; Stack ...  =&amp;gt; ...,field_value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setField</MethodName>
            <MethodComment>/** 
 * Pop the top stack value and store it in the local field.  This call pushes the this instance required to access the field itself. This call does not leave any value on the stack. &lt;PRE&gt; Stack ...,value  =&amp;gt; ... &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putField</MethodName>
            <MethodComment>/** 
 * Pop the top stack value and store it in the local field.  This call pushes the this instance required to access the field itself. Like the Java language 'field = value', this leaves the value on the stack. &lt;PRE&gt; Stack ...,value  =&amp;gt; ...,value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putField</MethodName>
            <MethodComment>/** 
 * Pop the top stack value and store it in the instance field of this class. This call pushes the this instance required to access the field itself. Like the Java language 'field = value', this leaves the value on the stack. &lt;PRE&gt; Stack ...,value  =&amp;gt; ...,value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putField</MethodName>
            <MethodComment>/** 
 * Pop the top stack value and store it in the field. This call requires the instance to be pushed by the caller. Like the Java language 'field = value', this leaves the value on the stack. &lt;PRE&gt; Stack ...,field_ref,value  =&amp;gt; ...,value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNewStart</MethodName>
            <MethodComment>/** 
 * Initiate a sequence that calls a constructor, equivalent to the new operator in Java. After this call, the caller must push any arguments and then complete the construction with a call to pushNewComplete(). Only arguments to the constructor can be pushed onto the stack between the pushNewStart() and pushNewComplete() method calls. &lt;PRE&gt; Stack ... =&amp;gt; [unchanged] ... &lt;/PRE&gt;
 * @param className class name of object to be created.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNewComplete</MethodName>
            <MethodComment>/** 
 * Complete the sequence that was started with pushNewStart(). Pop the arguments to the constructor and push the reference to the newly created object. &lt;PRE&gt; Stack ...,value* =&amp;gt; [numArgs number of values will be popped] ...,new_ref &lt;/PRE&gt;
 * @param numArgs number of arguments to the constructor (can be 0).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numArgs</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNewArray</MethodName>
            <MethodComment>/** 
 * Create an instance of an array and push it onto the stack.  &lt;PRE&gt; Stack ...  =&amp;gt; ...,array_ref &lt;/PRE&gt;
 * @param className - type of array.
 * @param size - number of elements in the array
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushThis</MethodName>
            <MethodComment>/** 
 * Push this onto the stack. &lt;PRE&gt; Stack ...  =&amp;gt; ...,this_ref &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upCast</MethodName>
            <MethodComment>/** 
 * Upcast the top stack value. This is used for correct method resolution by upcasting method parameters. It does not put any casting code into the byte code stream. Can only be used for refrences. &lt;PRE&gt; Stack ...,ref =&amp;gt; ...,ref &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cast</MethodName>
            <MethodComment>/** 
 * Cast the top stack value. Correctly down-casts a reference or casts a primitive type (e.g. int to short). &lt;PRE&gt; Stack ...,value =&amp;gt; ...,cast_value &lt;/PRE&gt;
 * @param className type (primitive, interface or class) to cast to.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInstanceOf</MethodName>
            <MethodComment>/** 
 * Pop the top stack value and push a boolean that is the result of an instanceof check on the popped reference. &lt;PRE&gt; Stack ...,ref =&amp;gt; ...,boolean_value &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pop</MethodName>
            <MethodComment>/** 
 * Pop the top value off the stack &lt;PRE&gt; Stack ..., value =&amp;gt; ... &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endStatement</MethodName>
            <MethodComment>/** 
 * End a statement. Pops the top-word of the stack, if any. Must only be called if zero or one item exists on the stack. &lt;PRE&gt; Stack value =&amp;gt; :empty: or Stack :empty: =&amp;gt; :empty: &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>methodReturn</MethodName>
            <MethodComment>/** 
 * Return from a method, optionally with a value. Must only be called if zero or one item exists on the stack. If the stack contains a single value then that is popped and used as the returned value. &lt;PRE&gt; Stack value =&amp;gt; :empty: or Stack :empty: =&amp;gt; :empty: &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conditionalIfNull</MethodName>
            <MethodComment>/** 
 * Initiate a conditional sequence. The top value on the stack (a reference) is popped and compared to 'null'. If the value is null then the code following this call until the startElseCode() will be executed at runtime, otherwise the code following startElseCode() until the completeConditional() is called. &lt;BR&gt; E.g.  &lt;PRE&gt; mb.callMethod(...); // pushes an object onto the stack mb.conditionalIfNull(); mb.push(3); mb.startElseCode(); mb.push(5); mb.completeConditional(); // at this point 3 or 5 will be on the stack &lt;/PRE&gt; Each path through the ?: statement must leave the stack at the same depth as the other. &lt;BR&gt; If the if or else code pops values from the stack that were before the conditional value, then they must use the same number of values from the stack. &lt;PRE&gt; Stack ...,ref =&amp;gt; ... &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conditionalIf</MethodName>
            <MethodComment>/** 
 * Initiate a conditional sequence. The top value on the stack must be a boolean and will be popped. If it is true then the code following this call until the startElseCode() will be executed at runtime, otherwise the code following startElseCode() until the completeConditional() is called. See conditionalIfNull() for example and restrictions. &lt;PRE&gt; Stack ...,boolean_value =&amp;gt; ... &lt;/PRE&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startElseCode</MethodName>
            <MethodComment>/** 
 * Complete the true code path of a conditional.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>completeConditional</MethodName>
            <MethodComment>/** 
 * Complete a conditional which completes the false code path.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callMethod</MethodName>
            <MethodComment>/** 
 * Call a method. The instance (receiver or reference) for non-static methods must be pushed by the caller. The instance (for non-static) and the arguments are popped of the stack, and the return value (if any) is pushed onto the stack. &lt;BR&gt; The type needs to be one of: &lt;UL&gt; &lt;LI&gt; VMOpcode.INVOKESTATIC - call a static method &lt;LI&gt; VMOpcode.INVOKEVIRTUAL - call method declared in the class or super-class. &lt;LI&gt; VMOpcode.INVOKEINTERFACE - call a method declared in an interface &lt;/UL&gt; &lt;PRE&gt; static methods Stack ...,value* =&amp;gt; [numArgs number of values will be popped] ...,return_value [void methods will not push a value] non-static methods Stack ...,ref,value* =&amp;gt; [numArgs number of values will be popped] ...,return_value [void methods will not push a value] &lt;/PRE&gt; &lt;BR&gt; The type of the arguments to the methods must exactly match the declared types of the parameters to the methods. If a argument is of the incorrect type the caller must up cast it or down cast it.
 * @param type type of method invocation
 * @param declaringClass Class or interface the method is declared in. If it is a non-staticmethod call then if declaringClass is null, the declared type is taken to be the type of the reference that will be popped.
 * @param methodName name of the method
 * @param returnType class name or primitive type (including "void") of the return type of the method, can not be null.
 * @param numArgs number of arguments to the method (can be 0).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numArgs</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>describeMethod</MethodName>
            <MethodComment>/** 
 * Return an object that efficiently (to the implementation) describes a zero-argument method and can be used with the single argument callMethod(). Descriptions for the parameters to this method are the same as the five argument callMethod(). This allows the caller to cache frequently used methods. The returned object is only valid for use by this MethodBuilder. &lt;BR&gt; This call does not affect the Stack.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>declaringClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callMethod</MethodName>
            <MethodComment>/** 
 * Call a method previously described by describeMethod(). &lt;PRE&gt; static methods Stack ...,value* =&amp;gt; [numArgs number of values will be popped] ...,return_value [void methods will not push a value] non-static methods Stack ...,ref,value* =&amp;gt; [numArgs number of values will be popped] ...,return_value [void methods will not push a value] &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodDescriptor</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>callSuper</MethodName>
            <MethodComment>/** 
 * Call super(). Caller must only add this to a constructor. &lt;PRE&gt; Stack ... =&amp;gt; ...  &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getArrayElement</MethodName>
            <MethodComment>/** 
 * Pop an array refrence off the stack and push an element from that array. &lt;PRE&gt; Stack ...,array_ref =&amp;gt; ...,value &lt;/PRE&gt;
 * @param element Offset into the array (zero based)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setArrayElement</MethodName>
            <MethodComment>/** 
 * Pop an array reference off the stack, store a value in the array at the passed in offset. &lt;PRE&gt; Stack ...,array_ref, value =&amp;gt; ... &lt;/PRE&gt;
 * @param element Offset into the array (zero based)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>swap</MethodName>
            <MethodComment>/** 
 * Swap the top two values on the stack. &lt;PRE&gt; Stack ...,valueA,valueB =&amp;gt; ...,valueB,valueA &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dup</MethodName>
            <MethodComment>/** 
 * Duplicate the top value on the stack. &lt;PRE&gt; Stack ...,value =&amp;gt; ...,value,value &lt;/PRE&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementNumHitLimit</MethodName>
            <MethodComment>/** 
 * Tell if statement number in this method builder hits limit.  This method builder keeps a counter of how many statements are added to it. Caller should call this function every time it tries to add a statement to this method builder (counter is increased by 1), then the function returns whether the accumulated statement number hits a limit. The reason of doing this is that Java compiler has a limit of 64K code size for each method.  We might hit this limit if an extremely long insert statement is issued, for example (see beetle 4293).  Counting statement number is an approximation without too much overhead.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>noStatementsAdded</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>