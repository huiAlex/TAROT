<Class>
    <Id>494</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ColumnReference</ClassName>
    <SuperClass>ValueNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ColumnReference  /** 
 * A ColumnReference represents a column in the query tree.  The parser generates a ColumnReference for each column reference.  A column reference could be a column in a base table, a column in a view (which could expand into a complex expression), or a column in a subquery in the FROM clause.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MERGE_UNKNOWN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MERGE_SOURCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MERGE_TARGET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>_columnName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_qualifiedTableName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>tableNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>columnNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>source</FieldName>
            <FieldType>ResultColumn</FieldType>
        </Field>
        <Field>
            <FieldName>_origSource</FieldName>
            <FieldType>ResultColumn</FieldType>
        </Field>
        <Field>
            <FieldName>origName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_origTableNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>_origColumnNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>tableNumberBeforeFlattening</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>columnNumberBeforeFlattening</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>replacesAggregate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>replacesWindowFunctionCall</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>nestingLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sourceLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>scoped</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>remaps</FieldName>
            <FieldType>java.util.ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>remaps</FieldName>
            <FieldType>RemapInfo</FieldType>
        </Field>
        <Field>
            <FieldName>_mergeTableID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>colNum</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>tableNum</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>colName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>source</FieldName>
            <FieldType>ResultColumn</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ColumnReference</MethodName>
            <MethodComment>/** 
 * Constructor. This one is called by the parser where we could be dealing with delimited identifiers.
 * @param columnName	The name of the column being referenced
 * @param tableName		The qualification for the column
 * @param tokBeginOffset begin position of token for the column name identifier from parser.
 * @param tokEndOffset	end position of token for the column name identifier from parser.
 * @param cm           The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tokBeginOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tokEndOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this;setBeginOffset;[tokBeginOffset]</InnerMethodInvoke>
                <InnerMethodInvoke>this;setEndOffset;[tokEndOffset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ColumnReference</MethodName>
            <MethodComment>/** 
 * Constructor.
 * @param columnName	The name of the column being referenced
 * @param tableName		The qualification for the column
 * @param cm           The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrelated</MethodName>
            <MethodComment>/** 
 * Return whether or not this CR is correlated.
 * @return Whether or not this CR is correlated.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNestingLevel</MethodName>
            <MethodComment>/** 
 * Set the nesting level for this CR.  (The nesting level at which the CR appears.)
 * @param nestingLevel	The Nesting level at which the CR appears.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nestingLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNestingLevel</MethodName>
            <MethodComment>/** 
 * Get the nesting level for this CR.
 * @return	The nesting level for this CR.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSourceLevel</MethodName>
            <MethodComment>/** 
 * Set the source level for this CR.  (The nesting level of the source of the CR.)
 * @param sourceLevel	The Nesting level of the source of the CR.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sourceLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceLevel</MethodName>
            <MethodComment>/** 
 * Get the source level for this CR.
 * @return	The source level for this CR.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markGeneratedToReplaceAggregate</MethodName>
            <MethodComment>/** 
 * Mark this node as being generated to replace an aggregate. (Useful for replacing aggregates in the HAVING clause with  column references to the matching aggregate in the  user's SELECT.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markGeneratedToReplaceWindowFunctionCall</MethodName>
            <MethodComment>/** 
 * Mark this node as being generated to replace a window function call.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedToReplaceAggregate</MethodName>
            <MethodComment>/** 
 * Determine whether or not this node was generated to replace an aggregate in the user's SELECT.
 * @return boolean	Whether or not this node was generated to replacean aggregate in the user's SELECT.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedToReplaceWindowFunctionCall</MethodName>
            <MethodComment>/** 
 * Determine whether or not this node was generated to replace a window function call in the user's SELECT.
 * @return boolean	Whether or not this node was generated to replacea window function call in the user's SELECT.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClone</MethodName>
            <MethodComment>/** 
 * Return a clone of this node.
 * @return ValueNode	A clone of this node.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ColumnReference [newCR=new ColumnReference(_columnName,_qualifiedTableName,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newCR;copyFields;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyFields</MethodName>
            <MethodComment>/** 
 * Copy all of the "appropriate fields" for a shallow copy.
 * @param oldCR		The ColumnReference to copy from.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldCR</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setQualifiedTableName;[oldCR.getQualifiedTableName()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;copyTagsFrom;[oldCR]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This means binding the sub-expressions, as well as figuring out what the return type is for this expression. NOTE: We must explicitly check for a null FromList here, column reference without a FROM list, as the grammar allows the following: insert into t1 values(c1)
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [matchingRC]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLColumnName</MethodName>
            <MethodComment>/** 
 * Get the column name for purposes of error messages or debugging. This returns the column name as used in the SQL statement. Thus if it was qualified with a table, alias name that will be included.
 * @return	The  column name in the form [[schema.]table.]column
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnName</MethodName>
            <MethodComment>/** 
 * Get the name of this column
 * @return	The name of this column
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableNumber</MethodName>
            <MethodComment>/** 
 * Get the table number for this ColumnReference.
 * @return	int The table number for this ColumnReference
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTableNumber</MethodName>
            <MethodComment>/** 
 * Set this ColumnReference to refer to the given table number.
 * @param tableNumber	The table number this ColumnReference will refer to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableName</MethodName>
            <MethodComment>/** 
 * Get the user-supplied table name of this column.  This will be null if the user did not supply a name (for example, select a from t). The method will return B for this example, select b.a from t as b The method will return T for this example, select t.a from t
 * @return	The user-supplied name of this column.  Null if no user-supplied name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceTableName</MethodName>
            <MethodComment>/** 
 * Get the name of the underlying(base) table this column comes from, if any. Following example queries will all return T select a from t select b.a from t as b select t.a from t
 * @return	The name of the base table that this column comes from.Null if not a ColumnReference.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceSchemaName</MethodName>
            <MethodComment>/** 
 * Get the name of the schema for the Column's base table, if any. Following example queries will all return APP (assuming user is in schema APP) select t.a from t select b.a from t as b select app.t.a from t
 * @return	The name of the schema for Column's base table. If the columnis not in a schema (i.e. is a derived column), it returns NULL.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatableByCursor</MethodName>
            <MethodComment>/** 
 * Is the column wirtable by the cursor or not. (ie, is it in the list of FOR UPDATE columns list)
 * @return TRUE, if the column is a base column of a table and is writable by cursor.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQualifiedTableName</MethodName>
            <MethodComment>/** 
 * Return the table name as the node it is.
 * @return the column's table name.
 */
</MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setQualifiedTableName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnNumber</MethodName>
            <MethodComment>/** 
 * Get the column number for this ColumnReference.
 * @return	int The column number for this ColumnReference
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setColumnNumber</MethodName>
            <MethodComment>/** 
 * Set the column number for this ColumnReference.  This is used when scoping predicates for pushdown.
 * @param colNum The new column number.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSource</MethodName>
            <MethodComment>/** 
 * Get the source this columnReference
 * @return	The source of this columnReference
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSource</MethodName>
            <MethodComment>/** 
 * Set the source this columnReference
 * @param source	The source of this columnReference
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAndsOnTop</MethodName>
            <MethodComment>/** 
 * Do the 1st step in putting an expression into conjunctive normal form.  This step ensures that the top level of the expression is a chain of AndNodes.
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryComparisonOperatorNode [equalsNode]</InnerVar>
                <InnerVar>BooleanConstantNode [trueNode]</InnerVar>
                <InnerVar>AndNode [andNode=new AndNode(equalsNode,trueNode,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>equalsNode;bindComparisonOperator;[]</InnerMethodInvoke>
                <InnerMethodInvoke>andNode;postBindFixup;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate. If the source of this ColumnReference (at the next underlying level)  is not a ColumnReference or a VirtualColumnNode then this predicate will not be pushed down. For example, in: select * from (select 1 from s) a (x) where x = 1 we will not push down x = 1. NOTE: It would be easy to handle the case of a constant, but if the inner SELECT returns an arbitrary expression, then we would have to copy that tree into the pushed predicate, and that tree could contain subqueries and method calls. Also, don't allow a predicate to be pushed down if it contains a ColumnReference that replaces an aggregate.  This can happen if the aggregate is in the HAVING clause.  In this case, we would be pushing the predicate into the SelectNode that evaluates the aggregate, which doesn't make sense, since the having clause is supposed to be applied to the result of the SelectNode. This also goes for column references that replaces a window function. RESOLVE - revisit this issue once we have views.
 * @param referencedTabs	JBitSet with bit map of referenced FromTables
 * @param simplePredsOnly	Whether or not to consider methodcalls, field references and conditional nodes when building bit map
 * @return boolean		Whether or not source.expression is a ColumnReferenceor a VirtualColumnNode or a ConstantNode.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTabs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>simplePredsOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>referencedTabs;set;[tableNumber]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferences</MethodName>
            <MethodComment>/** 
 * Remap all of the ColumnReferences in this expression tree to point to the ResultColumn that is 1 level under their current source ResultColumn. This is useful for pushing down single table predicates. RESOLVE: Once we start pushing join clauses, we will need to walk the ResultColumn/VirtualColumnNode chain for them to remap the references.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ValueNode [expression=source.getExpression()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unRemapColumnReferences</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasBeenRemapped</MethodName>
            <MethodComment>/** 
 * Returns true if this ColumnReference has been remapped; false otherwise.
 * @return Whether or not this ColumnReference has been remapped.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceResultColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferencesToExpressions</MethodName>
            <MethodComment>/** 
 * Remap all ColumnReferences in this tree to be clones of the underlying expression.
 * @return ValueNode			The remapped expression tree.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumn [rc]</InnerVar>
                <InnerVar>ResultColumn [sourceRC=source]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablesReferenced</MethodName>
            <MethodComment>/** 
 * Update the table map to reflect the source of this CR.
 * @param refs	The table map.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>refs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCloneable</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree is cloneable.
 * @return boolean	Whether or not this expression tree is cloneable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantExpression</MethodName>
            <MethodComment>/** 
 * @see ValueNode#constantExpression 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>whereClause</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * ColumnReference's are to the current row in the system. This lets us generate a faster get that simply returns the column from the current row, rather than getting the value out and returning that, only to have the caller (in the situations needed) stuffing it back into a new column holder object. We will assume the general generate() path is for getting the value out, and use generateColumn() when we want to keep the column wrapped.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [sourceResultSetNumber=source.getResultSetNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>acb;pushColumnReference;[mb, sourceResultSetNumber, source.getVirtualColumnId()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;cast;[getTypeCompiler().interfaceName()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaName</MethodName>
            <MethodComment>/** 
 * Get the user-supplied schema name of this column.  This will be null if the user did not supply a name (for example, select t.a from t). Another example for null return value (for example, select b.a from t as b). But for following query select app.t.a from t, this will return APP Code generation of aggregate functions relies on this method
 * @return	The user-supplied schema name of this column.  Null if no user-supplied name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. The variant type can be: VARIANT				- variant within a scan (method calls and non-static field access) SCAN_INVARIANT		- invariant within a scan (column references from outer tables) QUERY_INVARIANT		- invariant within the life of a query (constant expressions)
 * @return	The variant type for the underlying expression.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pointsToColumnReference</MethodName>
            <MethodComment>/** 
 * Return whether or not the source of this ColumnReference is itself a ColumnReference.
 * @return Whether or not the source of this ColumnReference is itself a ColumnReference.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeServices</MethodName>
            <MethodComment>/** 
 * The type of a ColumnReference is the type of its source unless the source is null then it is the type that has been set on this node.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceResultSet</MethodName>
            <MethodComment>/** 
 * Find the source result set for this ColumnReference and return it.  Also, when the source result set is found, return the position (within the source result set's RCL) of the column referenced by this ColumnReference.  The position is returned vai the colNum parameter.
 * @param colNum Place to store the position of the columnto which this ColumnReference points (position is w.r.t the source result set).
 * @return The source result set for this ColumnReference;null if there is no source result set.
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colNum</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [rc=getSource()]</InnerVar>
                <InnerVar>ValueNode [rcExpr=rc.getExpression()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [other=(ColumnReference)o]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsScoped</MethodName>
            <MethodComment>/** 
 * Mark this column reference as "scoped", which means that it was created (as a clone of another ColumnReference) to serve as the left or right operand of a scoped predicate.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isScoped</MethodName>
            <MethodComment>/** 
 * Return whether or not this ColumnReference is scoped.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMergeTableID</MethodName>
            <MethodComment>/** 
 * Associate this column with a SOURCE or TARGET table of a MERGE statement 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prettyPrintMergeTableID</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMergeTableID</MethodName>
            <MethodComment>/** 
 * Get the MERGE table (SOURCE or TARGET) associated with this column 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RemapInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSource</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setColNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTableNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setColName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSource</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>