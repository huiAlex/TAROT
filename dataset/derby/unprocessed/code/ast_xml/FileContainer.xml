<Class>
    <Id>1007</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>FileContainer</ClassName>
    <SuperClass>BaseContainer</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Cacheable</SuperInterface>
        <SuperInterface>TypedFormat</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FileContainer  /** 
 * FileContainer is an abstract base class for containers which are based on files. This class extends BaseContainer and implements Cacheable and TypedFormat
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>formatIdInteger</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>pageCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>containerCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>dataFactory</FieldName>
            <FieldType>BaseDataFileFactory</FieldType>
        </Field>
        <Field>
            <FieldName>pageSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>spareSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>minimumRecordSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>initialPages</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>canUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>PreAllocThreshold</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PreAllocSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>bulkIncreaseContainerSize</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>PRE_ALLOC_THRESHOLD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MIN_PRE_ALLOC_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_PRE_ALLOC_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_PRE_ALLOC_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>firstAllocPageNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>firstAllocPageOffset</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>containerVersion</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>estimatedRowCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lastLogInstant</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>reusableRecordIdSequenceNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lastInsertedPage</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lastInsertedPage_index</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>lastUnfilledPage</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>lastAllocatedPage</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>estimatedPageCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>preDirty</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isDirty</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>allocCache</FieldName>
            <FieldType>AllocationCache</FieldType>
        </Field>
        <Field>
            <FieldName>containerInfo</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>checksum</FieldName>
            <FieldType>CRC32</FieldType>
        </Field>
        <Field>
            <FieldName>encryptionBuffer</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>CONTAINER_FORMAT_ID_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHECKSUM_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CONTAINER_INFO_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FIRST_ALLOC_PAGE_NUMBER</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>FIRST_ALLOC_PAGE_OFFSET</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>FILE_DROPPED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FILE_COMMITTED_DROP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FILE_REUSABLE_RECORDID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SPACE_TRACE</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Return my format identifier.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FileContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factory</ParamName>
                    <ParamType>BaseDataFileFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initContainerHeader;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpaceInfo</MethodName>
            <MethodComment>/** 
 * Get information about space used by the container.
 */
</MethodComment>
            <ReturnType>SpaceInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SpaceInformation [spaceInfo]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>spaceInfo;setPageSize;[pageSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIdentity</MethodName>
            <MethodComment>/** 
 * Open the container.
 * @return a valid object if the container was successfully opened, null ifit does not exist.
 * @exception StandardException Some problem in opening a container.
 * @see Cacheable#setIdentity
 */
</MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerKey [newIdentity=(ContainerKey)key]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIdent</MethodName>
            <MethodComment>/** 
 * Open the container. &lt;p&gt; Open the container with key "newIdentity". &lt;p&gt; should be same name as setIdentity but seems to cause method resolution  ambiguities
 * @exception StandardException Some problem in opening a container.
 * @see Cacheable#setIdentity
 */
</MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ok=openContainer(newIdentity)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initializeLastInsertedPage;[1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIdentity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createParameter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerKey [newIdentity=(ContainerKey)key]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIdent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createParameter</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;createContainer;[newIdentity]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setDirty;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;fillInIdentity;[newIdentity]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearIdentity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeContainer;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initializeLastInsertedPage;[1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDirty</MethodName>
            <MethodComment>/** 
 * We treat this container as dirty if it has the container file open.
 * @see Cacheable#isDirty
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preDirty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>preDirtyOn</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDirty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dirty</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createContainer</MethodName>
            <MethodComment>/** 
 * Create a new container. &lt;p&gt; Create a new container, all references to identity must be through the passed in identity, this object will no identity until after this  method returns.
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment>/** 
 * Open a container. &lt;p&gt; Longer descrption of routine. &lt;p&gt; Open a container. Open the file that maps to this container, if the file does not exist then we assume the container was never created. If the file exists but we have trouble opening it then we throw some  exception. &lt;BR&gt; MT - single thread required - Enforced by cache manager.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropContainer</MethodName>
            <MethodComment>/** 
 * Drop Container. &lt;p&gt;
 * @see Transaction#dropContainer
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isDropped</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bumpContainerVersion</MethodName>
            <MethodComment>/** 
 * increment the version by one and return the new version. &lt;BR&gt; MT - caller must synchronized this in the same sync block that modifies the container header.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerVersion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerProperties</MethodName>
            <MethodComment>/** 
 * Request the system properties associated with a container.  &lt;p&gt; Request the value of properties that are associated with a container.  The following properties can be requested: derby.storage.pageSize  derby.storage.pageReservedSpace derby.storage.minimumRecordSize derby.storage.reusableRecordId derby.storage.initialPages &lt;p&gt; To get the value of a particular property add it to the property list, and on return the value of the property will be set to it's current  value.  For example: get_prop(ConglomerateController cc) { Properties prop = new Properties(); prop.put("derby.storage.pageSize", ""); cc.getContainerProperties(prop); System.out.println( "table's page size = " +  prop.getProperty("derby.storage.pageSize"); }
 * @param prop   Property list to fill in.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prop</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readHeader</MethodName>
            <MethodComment>/** 
 * Read the container's header. When this method is called, the embryonic page that is passed in must have been read directly from the file or the input stream, even if the alloc page may still be in cache.  This is because a stubbify operation only writes the stub to disk, it does not get rid of any stale page from the page cache.  So if it so happens that the stubbified container object is aged out of the container cache but the first alloc page hasn't, then when any stale page of this container wants to be written out, the container needs to be reopened, which is when this routine is called.  We must not get the alloc page in cache because it may be stale page and it may still say the container has not been dropped. &lt;BR&gt; MT - single thread required - Enforced by caller.
 * @param epage the embryonic page to read the header from
 * @exception StandardException Derby Standard error policy
 * @exception IOException error in reading the header from file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>epage</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>AllocPage;ReadContainerInfo;[containerInfo, epage]</InnerMethodInvoke>
                <InnerMethodInvoke>null;readHeaderFromArray;[containerInfo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initContainerHeader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>changeContainer</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDroppedState;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCommittedDropState;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setReusableRecordIdState;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initializeLastInsertedPage;[1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readHeaderFromArray</MethodName>
            <MethodComment>/** 
 * Read containerInfo from a byte array The container Header array must be written by or of the same format as put together by writeHeaderFromArray.
 * @exception StandardException Derby Standard error policy
 * @exception IOException error in reading the header from file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayInputStream [inStream=new ArrayInputStream(a)]</InnerVar>
                <InnerVar>int [fid=inStream.readInt()]</InnerVar>
                <InnerVar>int [status=inStream.readInt()]</InnerVar>
                <InnerVar>long [spare3=inStream.readLong()]</InnerVar>
                <InnerVar>long [onDiskChecksum=inStream.readLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>inStream;setLimit;[CONTAINER_INFO_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;update;[a, 0, CONTAINER_INFO_SIZE - CHECKSUM_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>allocCache;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setDroppedState;[(status &amp; FILE_DROPPED) != 0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCommittedDropState;[(status &amp; FILE_COMMITTED_DROP) != 0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setReusableRecordIdState;[(status &amp; FILE_REUSABLE_RECORDID) != 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeHeader</MethodName>
            <MethodComment>/** 
 * Write the container header to a page array (the first allocation page)
 * @exception StandardException Derby Standard error policy
 * @exception IOException error in writing the header to file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeHeaderToArray;[containerInfo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeHeader</MethodName>
            <MethodComment>/** 
 * Write the container header directly to file. Subclasses that can writes the container header is expected to manufacture a DataOutput stream which is used here. &lt;BR&gt; MT - single thread required - Enforced by caller
 * @exception StandardException Derby Standard error policy
 * @exception IOException error in writing the header to file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>epage</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeHeaderToArray;[containerInfo]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;flush;[lastLogInstant]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;writeInProgress;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeAtOffset</MethodName>
            <MethodComment>/** 
 * Write a sequence of bytes at the given offset in a file. This method is not thread safe, so the caller must make sure that no other thread is performing operations that may change current position in the file.
 * @param file the file to write to
 * @param bytes the bytes to write
 * @param offset the offset to start writing at
 * @throws IOException if an I/O error occurs while writing
 * @exception StandardException  Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>file;seek;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>file;write;[bytes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEmbryonicPage</MethodName>
            <MethodComment>/** 
 * Get an embryonic page from the dataInput stream. The embryonic page will be read in from the input stream (fileData), which is assumed to be  positioned at the beginning of the first allocation page.
 * @exception IOException error in read the embryonic page from file
 * @exception StandardException  Derby Standard error policy
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fileData</ParamName>
                    <ParamType>DataInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [epage=new byte[AllocPage.MAX_BORROWED_SPACE]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>fileData;readFully;[epage]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEmbryonicPage</MethodName>
            <MethodComment>/** 
 * Read an embryonic page (that is, a section of the first alloc page that is so large that we know all the borrowed space is included in it) from the specified offset in a  {@code StorageRandomAccessFile}. This method is not thread safe, so the caller must make sure that no other thread is performing operations that may change current position in the file.
 * @param file the file to read from
 * @param offset where to start reading (normally{@code FileContainer.FIRST_ALLOC_PAGE_OFFSET})
 * @return a byte array containing the embryonic page
 * @throws IOException if an I/O error occurs while reading
 * @throws StandardException  Derby Standard error policy
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>file;seek;[offset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeHeaderToArray</MethodName>
            <MethodComment>/** 
 * Write containerInfo into a byte array The container Header thus put together can be read by readHeaderFromArray.
 * @exception IOException error in writing the header
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayOutputStream [a_out=new ArrayOutputStream(a)]</InnerVar>
                <InnerVar>FormatIdOutputStream [outStream=new FormatIdOutputStream(a_out)]</InnerVar>
                <InnerVar>int [status=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>a_out;setPosition;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>a_out;setLimit;[CONTAINER_INFO_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeInt;[formatIdInteger]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeInt;[status]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeInt;[pageSize]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeInt;[spareSpace]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeInt;[minimumRecordSize]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeShort;[initialPages]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeShort;[PreAllocSize]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[firstAllocPageNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[firstAllocPageOffset]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[containerVersion]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[estimatedRowCount]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[reusableRecordIdSequenceNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;update;[a, 0, CONTAINER_INFO_SIZE - CHECKSUM_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>outStream;writeLong;[checksum.getValue()]</InnerMethodInvoke>
                <InnerMethodInvoke>a_out;clearLimit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logCreateContainerInfo</MethodName>
            <MethodComment>/** 
 * Log all information on the container creation necessary to recreate the container during a load tran.
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>ByteArray</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte[] [array=new byte[CONTAINER_INFO_SIZE]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createInfoFromLog</MethodName>
            <MethodComment>/** 
 * Set container properties from the passed in ByteArray, which is created by logCreateContainerInfo.  This information is used to recreate the container during recovery load tran. The following container properties are set: pageSize spareSpace minimumRecordSize isReusableRecordId initialPages
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>byteArray</ParamName>
                    <ParamType>ByteArray</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [array=byteArray.getArray()]</InnerVar>
                <InnerVar>ArrayInputStream [inStream=new ArrayInputStream(array)]</InnerVar>
                <InnerVar>int [status=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setReusableRecordIdState;[(status &amp; FILE_REUSABLE_RECORDID) != 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createInfoFromProp</MethodName>
            <MethodComment>/** 
 * Set container properties from the passed in createArgs.   The following container properties are set: pageSize spareSpace minimumRecordSize isReusableRecordId initialPages RESOLVE - in the future setting parameters should be overridable by sub-class, e.g. one implementation of Container may require a minimum page size of 4k.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>createArgs</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AccessFactory [af=(AccessFactory)getServiceModule(dataFactory,AccessFactory.MODULE)]</InnerVar>
                <InnerVar>TransactionController [tc=(af == null) ? null : af.getTransaction(getContextService().getCurrentContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canUpdate</MethodName>
            <MethodComment>/** 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deallocatePage</MethodName>
            <MethodComment>/** 
 * Deallocate a page from the container.  
 * @param handle the container handle doing the deallocation
 * @param page the page to be deallocated.  It is latched upon entry andwill be unlatched by the caller of this function
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>page</ParamName>
                    <ParamType>BasePage</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [pnum=page.getPageNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;deallocatePagenum;[handle, pnum]</InnerMethodInvoke>
                <InnerMethodInvoke>page;deallocatePage;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deallocatePagenum</MethodName>
            <MethodComment>/** 
 * deallocate the page from the alloc page 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pnum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressContainer</MethodName>
            <MethodComment>/** 
 * Compress free space from container. &lt;BR&gt; MT - thread aware - It is assumed that our caller (our super class) has already arranged a logical lock on page allocation to only allow a single thread through here. Compressing free space is done in allocation page units, working it's way from the end of the container to the beginning.  Each loop operates on the last allocation page in the container. Freeing space in the container page involves 2 transactions, an update to an allocation page, N data pages, and possibly the delete of the allocation page. The User Transaction (UT) initiated the compress call. The Nested Top Transaction (NTT) is the transaction started by RawStore inside the compress call.  This NTT is committed before compress returns. The NTT is used to access high traffic data structures such as the  AllocPage. This is outline of the algorithm used in compressing the container. Until a non free page is found loop, in each loop return to the OS all space at the end of the container occupied by free pages, including the allocation page itself if all of it's pages are free.   1) Find last 2 allocation pages in container (last if there is only one). 2) invalidate the allocation information cached by the container. Without the cache no page can be gotten from the container.  Pages already in the page cache are not affected.  Thus by latching the  allocPage and invalidating the allocation cache, this NTT blocks out  all page gets from this container until it commits. 3) the allocPage determines which pages can be released to the OS,  mark that in its data structure (the alloc extent).  Mark the  contiguous block of nallocated/free pages at the end of the file as unallocated.  This change is associated with the NTT. 4) The NTT calls the OS to deallocate the space from the file.  Note that the system can handle being booted and asked to get an allocated page which is past end of file, it just extends the file automatically. 5) If freeing all space on the alloc page, and there is more than one alloc page, then free the alloc page - this requires an update to the  previous alloc page which the loop has kept latched also. 6) if the last alloc page was deleted, restart loop at #1 All NTT latches are released before this routine returns. If we use an NTT, the caller has to commit the NTT to release the allocPage latch.  If we don't use an NTT, the allocPage latch is released as this routine returns.
 * @param ntt - the nested top transaction for the purpose of freeing space.If ntt is null, use the user transaction for allocation. #param allocHandle - the container handle opened by the ntt,  use this to latch the alloc page
 * @exception StandardException Standard Derby error policy 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allocHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AllocPage [alloc_page=null]</InnerVar>
                <InnerVar>AllocPage [prev_alloc_page=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dataFactory.getRawStoreFactory();checkpoint;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ntt;blockBackup;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReusableRecordIdSequenceNumber</MethodName>
            <MethodComment>/** 
 * Get the reusable RecordId sequence number for the container.
 * @see BaseContainer#getReusableRecordIdSequenceNumber
 * @return reusable RecordId sequence number for the container.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementReusableRecordIdSequenceNumber</MethodName>
            <MethodComment>/** 
 * Increment the reusable RecordId version sequence number.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [readOnly=dataFactory.isReadOnly()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newPage</MethodName>
            <MethodComment>/** 
 * Create a new page in the container. &lt;BR&gt; MT - thread aware - It is assumed that our caller (our super class) has already arranged a logical lock on page allocation to only allow a single thread through here. Adding a new page involves 2 transactions and 2 pages.   The User Transaction (UT) initiated the addPage call and expects a latched page (owns by the UT) to be returned. The Nested Top Transaction (NTT) is the transaction started by RawStore inside an addPage call.  This NTT is committed before the page is returned.  The NTT is used to accessed high traffic data structure such as the AllocPage. This is outline of the algorithm used in adding a page: 1) find or make an allocPage which can handle the addding of a new page. Latch the allocPage with the NTT. 2) invalidate the allocation information cached by the container. Without the cache no page can be gotten from the container.  Pages already in the page cache is not affected.  Thus by latching the  allocPage and invalidating the allocation cache, this NTT blocks out  all page gets from this container until it commits. 3) the allocPage determines which page can be allocated, mark that in its data structure (the alloc extent) and returns the page number of the new page.  This change is associated with the NTT. 4) the NTT gets or creates the new page in the page cache (bypassing the lookup of the allocPage since that is already latched by the NTT and will deadlock). 5) the NTT initializes the page (mark it is being a VALID page). 6) the page latch is transfered to the UT from the NTT. 7) the new page is returned, latched by UT If we use an NTT, the caller has to commit the NTT to release the allocPage latch.  If we don't use an NTT, the allocPage latch is released as this routine returns.
 * @param userHandle - the container handle opened by the user transaction, use this to latch the new user page
 * @param ntt - the nested top transaction for the purpose of allocating the new pageIf ntt is null, use the user transaction for allocation. #param allocHandle - the container handle opened by the ntt,  use this to latch the alloc page
 * @exception StandardException Standard Derby error policy 
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allocHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isOverflow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [useNTT=(ntt != null)]</InnerVar>
                <InnerVar>long [lastPage]</InnerVar>
                <InnerVar>long [lastPreallocPage]</InnerVar>
                <InnerVar>long [pageNumber=ContainerHandle.INVALID_PAGE_NUMBER]</InnerVar>
                <InnerVar>PageKey [pkey]</InnerVar>
                <InnerVar>boolean [reuse]</InnerVar>
                <InnerVar>boolean [retry]</InnerVar>
                <InnerVar>int [numtries=0]</InnerVar>
                <InnerVar>int [maxTries=InterruptStatus.MAX_INTERRUPT_RETRIES]</InnerVar>
                <InnerVar>long [startSearch=lastAllocatedPage]</InnerVar>
                <InnerVar>AllocPage [allocPage=null]</InnerVar>
                <InnerVar>BasePage [page=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearPreallocThreshold</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareForBulkLoad</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numPage</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [tran=handle.getTransaction()]</InnerVar>
                <InnerVar>AllocPage [allocPage=findLastAllocPage(handle,tran)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;clearPreallocThreshold;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pageValid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
                <InnerVar>boolean [done]</InnerVar>
                <InnerVar>int [maxTries=InterruptStatus.MAX_INTERRUPT_RETRIES]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastPageNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [retval]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findAllocPageForAdd</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AllocPage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allocHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lastAllocatedPage</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AllocPage [allocPage=null]</InnerVar>
                <InnerVar>AllocPage [oldAllocPage=null]</InnerVar>
                <InnerVar>boolean [success=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findLastAllocPage</MethodName>
            <MethodComment>/** 
 * Find the last alloc page, returns null if no alloc page is found
 */
</MethodComment>
            <ReturnType>AllocPage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tran</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AllocPage [allocPage=null]</InnerVar>
                <InnerVar>AllocPage [oldAllocPage=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeAllocPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AllocPage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerInfoSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [noIO=(handle.getMode() &amp; ContainerHandle.MODE_UNLOGGED) == ContainerHandle.MODE_UNLOGGED]</InnerVar>
                <InnerVar>PageCreationArgs [createAllocPageArgs=new PageCreationArgs(AllocPage.FORMAT_NUMBER,noIO ? 0 : CachedPage.WRITE_SYNC,pageSize,0,minimumRecordSize,containerInfoSize)]</InnerVar>
                <InnerVar>PageKey [pkey=new PageKey(identity,pageNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initPage</MethodName>
            <MethodComment>/** 
 * Initialize a page 
 * @return a latched page that has been initialized.
 * @param allochandle the contianer handle to initialize the page with - the ntt
 * @param pkey the page number of the page to be initialized
 * @param createArgs the arguments for page creation
 * @param reuse is true if we are reusing a page that has already been initialized once
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allochandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkey</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createArgs</ParamName>
                    <ParamType>PageCreationArgs</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [page=null]</InnerVar>
                <InnerVar>boolean [releasePage=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserPage</MethodName>
            <MethodComment>/** 
 * Get a page in the container.     Get User page is the generic base routine for all user (client to raw store) getPage.  This routine coordinate with allocation/deallocation to ensure that no page can be gotten from the container while page is in the middle of being allocated or deallocated. This routine latches the page.
 * @param handle the container handle
 * @param pageNumber the page number of the page to get
 * @param overflowOK if true then an overflow page is OK,if false, then only non-overflow page is OK
 * @param wait if true then wait for a latch
 * @return the latched page&lt;BR&gt; MT - thread safe
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageKey [pageSearch=new PageKey(identity,pageNumber)]</InnerVar>
                <InnerVar>BasePage [page=(BasePage)pageCache.find(pageSearch)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trackUnfilledPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unfilled</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPage</MethodName>
            <MethodComment>/** 
 * Get a valid (non-deallocated or free) page in the container. Overflow page is OK. Resulting page is latched. &lt;BR&gt; MT - thread safe
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAnyPage</MethodName>
            <MethodComment>/** 
 * Get any old page - turn off all validation
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageKey [pageSearch=new PageKey(identity,pageNumber)]</InnerVar>
                <InnerVar>BasePage [page=(BasePage)pageCache.find(pageSearch)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reCreatePageForRedoRecovery</MethodName>
            <MethodComment>/** 
 * ReCreate a page for rollforward recovery.   &lt;p&gt; During redo recovery it is possible for the system to try to redo the creation of a page (ie. going from non-existence to version 0). It first trys to read the page from disk, but a few different types of errors can occur: o the page does not exist at all on disk, this can happen during rollforward recovery applied to a backup where the file was copied and the page was added to the file during the time frame of the backup but after the physical file was copied. o space in the file exists, but it was never initalized.  This can happen if you happen to crash at just the right moment during the allocation process.  Also on some OS's it is possible to read from a part of the file that was not ever written - resulting in garbage from the store's  point of view (often the result is all 0's).   All these errors are easy to recover from as the system can easily  create a version 0 from scratch and write it to disk. Because the system does not sync allocation of data pages, it is also possible at this point that whlie writing the version 0 to disk to  create it we may encounter an out of disk space error (caught in this routine as a StandardException from the create() call.  We can't  recovery from this without help from outside, so the caught exception is nested and a new exception thrown which the recovery system will output to the user asking them to check their disk for space/errors.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageFormat</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [rollForwardRecovery=((RawTransaction)handle.getTransaction()).inRollForwardRecovery()]</InnerVar>
                <InnerVar>PageKey [pkey=new PageKey(identity,pageNumber)]</InnerVar>
                <InnerVar>PageCreationArgs [reCreatePageArgs]</InnerVar>
                <InnerVar>BasePage [page=null]</InnerVar>
                <InnerVar>boolean [releasePage=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllocPage</MethodName>
            <MethodComment>/** 
 * Get an alloc page - only accessible to the raw store  (container and recovery)
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageKey [pageSearch=new PageKey(identity,pageNumber)]</InnerVar>
                <InnerVar>BasePage [page=(BasePage)pageCache.find(pageSearch)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeadPage</MethodName>
            <MethodComment>/** 
 * Get only a valid, non-overflow page.  If page number is either invalid or overflow, returns null
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstHeadPage</MethodName>
            <MethodComment>/** 
 * Get the first valid page in the container
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextHeadPage</MethodName>
            <MethodComment>/** 
 * Get the next page in the container.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [nextNumber]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInsertablePage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [p=getUserPage(handle,pageNumber,overflowOK,wait)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageForCompress</MethodName>
            <MethodComment>/** 
 * Get candidate page to move a row for compressing the table. &lt;p&gt; The caller is moving rows from the end of the table toward the beginning, with the goal of freeing up a block of empty pages at the end of the container which can be returned to the OS. &lt;p&gt; On entry pageno will be latched by the caller.  Only return pages with numbers below pageno.  Attempting to return pageno will result in a latch/latch deadlock on the same thread.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageno</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [p=null]</InnerVar>
                <InnerVar>boolean [getLastInserted=(flag &amp; ContainerHandle.GET_PAGE_UNFILLED) == 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageForInsert</MethodName>
            <MethodComment>/** 
 * Get a potentially suitable page for insert and latch it.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [p=null]</InnerVar>
                <InnerVar>boolean [getLastInserted=(flag &amp; ContainerHandle.GET_PAGE_UNFILLED) == 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLatchedPage</MethodName>
            <MethodComment>/** 
 * Get a latched page. Incase of backup page Latch is necessary to  prevent modification to the page when it is being written to the backup. Backup process relies on latches to get consistent snap shot of the page , user level table/page/row locks are NOT  acquired  by the online backup mechanism.
 * @param handle the container handle used to latch the page
 * @param pageNumber the page number of the page to get
 * @return the latched page
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageKey [pageKey=new PageKey(identity,pageNumber)]</InnerVar>
                <InnerVar>BasePage [page=(BasePage)pageCache.find(pageKey)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnfilledPageNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * &lt;BR&gt;MT - this routine is NOT MT-safe and clients don't need to provide synchronization.
 * @see ContainerHandle#getEstimatedRowCount
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * @see ContainerHandle#setEstimatedRowCount
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [readOnly=dataFactory.isReadOnly()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * Update estimated row count by page as it leaves the cache. The estimated row count is updated without logging!
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>delta</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [readOnly=dataFactory.isReadOnly()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedPageCount</MethodName>
            <MethodComment>/** 
 * @see ContainerHandle#getEstimatedPageCount
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readPage</MethodName>
            <MethodComment>/** 
 * Read a page into the supplied array. &lt;BR&gt; MT - thread safe
 * @exception IOException error reading page
 * @exception StandardException standard Derby error message
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePage</MethodName>
            <MethodComment>/** 
 * Write a page from the supplied array. &lt;BR&gt; MT - thread safe
 * @exception IOException error writing page
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>syncPage</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decryptPage</MethodName>
            <MethodComment>/** 
 * Decrypts a page &lt;BR&gt;MT - MT safe.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encryptPage</MethodName>
            <MethodComment>/** 
 * Encrypts a page. &lt;BR&gt; MT - not safe, call within synchronized block and only use the returned byte array withing synchronized block. 
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encryptionBuffer</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newEngine</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [len=dataFactory.encrypt(encryptionBuffer,0,pageSize,encryptionBuffer,0,newEngine)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[pageData, pageSize - 8, encryptionBuffer, 0, 8]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[pageData, 0, encryptionBuffer, 8, pageSize - 8]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEncryptionBuffer</MethodName>
            <MethodComment>/** 
 * Get encryption buffer. MT - not safe, call within synchronized block and only use the returned byte array withing synchronized block. 
 * @return byte array to be used for encryping a page.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preAllocate</MethodName>
            <MethodComment>/** 
 * preAllocate writes out the preallocated pages to disk if necessary. &lt;BR&gt;Make sure the container is large enough and the pages are well formatted.  The only reason to do this is to save some I/O during page initialization.  Once the initPage log record is written, it is expected that the page really do exist and is well formed or recovery will fail.  However, we can gain some performance by writing a bunch of pages at a time rather than one at a time. &lt;BR&gt;If it doesn't make sense for the the implementation to have  pre-allocation, just return 0.  &lt;BR&gt;If the container is not being logged, don't actually do anything, just return 0.  
 * @return number of successfully preallocated page, or 0 ifno page has been preallocated
 * @param lastPreallocPagenum the last preallocated page number as knownby the allocation page
 * @param preAllocSize try to preallocate this page number of pages.Since only the container knows how many pages are actually on disk, it may determine that certain number of pages that the allocation page thinks need to be preallocated is already allocated, in those case, act as if the preallocation is successful.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastPreallocPagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preAllocSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doPreAllocatePages</MethodName>
            <MethodComment>/** 
 * Preallocate the pages - actually doing it, called by subclass only
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastPreallocPagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preAllocSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageCreationArgs [createArgs=new PageCreationArgs(StoredPage.FORMAT_NUMBER,CachedPage.WRITE_NO_SYNC,pageSize,spareSpace,minimumRecordSize,0)]</InnerVar>
                <InnerVar>StoredPage [page=new StoredPage()]</InnerVar>
                <InnerVar>boolean [error=false]</InnerVar>
                <InnerVar>int [count=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>page;setFactory;[dataFactory]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpareSpace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMinimumRecordSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>switchToMultiInsertPageMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastInsertedPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastUnfilledPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeLastInsertedPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastInsertedPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastUnfilledPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>letGo</MethodName>
            <MethodComment>/** 
 * The container is kept by the find() in File.openContainer. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerCache;release;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>latchPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foundPage</ParamName>
                    <ParamType>BasePage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [ret=super.latchPage(handle,foundPage,wait)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>backupContainer</MethodName>
            <MethodComment>/** 
 * backup the container.
 * @param handle the container handle.
 * @param backupLocation location of the backup container. 
 * @exception StandardException Standard Derby error policy 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>backupLocation</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be limited to package visibility so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged module lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>