<Class>
    <Id>2136</Id>
    <Package>org.apache.derby.iapi.sql.compile</Package>
    <ClassName>TypeCompiler</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TypeCompiler  /** 
 * This interface defines methods associated with a TypeId that are used by the compiler.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LONGINT_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INT_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_DECIMAL_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_DECIMAL_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_DECIMAL_PRECISION_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN_MAXWIDTH_AS_CHAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PLUS_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DIVIDE_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>MINUS_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TIMES_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SUM_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>AVG_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>MOD_OP</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>resolveArithmeticOperation</MethodName>
            <MethodComment>/** 
 * Type resolution methods on binary operators
 * @param leftType	The type of the left parameter
 * @param rightType	The type of the right parameter
 * @param operator	The name of the operator (e.g. "+").
 * @return	The type of the result
 * @exception StandardException	Thrown on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertible</MethodName>
            <MethodComment>/** 
 * Determine if this type can be CONVERTed to some other type
 * @param otherType	The CompilationType of the other type to comparethis type to
 * @param forDataTypeFunction  true if this is a type function thatrequires more liberal behavior (e.g DOUBLE can convert a char but  you cannot cast a CHAR to double.
 * @return	true if the types can be converted, false if conversionis not allowed
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forDataTypeFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compatible</MethodName>
            <MethodComment>/** 
 * Determine if this type is compatible to some other type (e.g. COALESCE(thistype, othertype)).
 * @param otherType	The CompilationType of the other type to comparethis type to
 * @return	true if the types are compatible, false if not compatible
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storable</MethodName>
            <MethodComment>/** 
 * Determine if this type can have a value of another type stored into it. Note that direction is relevant here: the test is that the otherType is storable into this type.
 * @param otherType	The TypeId of the other type to compare this type to
 * @param cf		A ClassFactory
 * @return	true if the other type can be stored in a column of this type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>interfaceName</MethodName>
            <MethodComment>/** 
 * Get the name of the interface for this type.  For example, the interface for a SQLInteger is NumberDataValue.  The full path name of the type is returned.
 * @return	The name of the interface for this type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrespondingPrimitiveTypeName</MethodName>
            <MethodComment>/** 
 * Get the name of the corresponding Java type.  For numerics and booleans we will get the corresponding Java primitive type. e Each SQL type has a corresponding Java type.  When a SQL value is passed to a Java method, it is translated to its corresponding Java type.  For example, a SQL Integer will be mapped to a Java int, but a SQL date will be mapped to a java.sql.Date.
 * @return	The name of the corresponding Java primitive type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrimitiveMethodName</MethodName>
            <MethodComment>/** 
 * Get the method name for getting out the corresponding primitive Java type from a DataValueDescriptor.
 * @return String		The method call name for getting thecorresponding primitive Java type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateNull</MethodName>
            <MethodComment>/** 
 * Generate the code necessary to produce a SQL null of the appropriate type. The stack must contain a DataValueFactory and a null or a value of the correct type (interfaceName()).
 * @param mb	The method to put the expression in
 * @param collationType For character DVDs, this will be used to determinewhat Collator should be associated with the DVD which in turn will  decide whether to generate CollatorSQLcharDVDs or SQLcharDVDs.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateDataValue</MethodName>
            <MethodComment>/** 
 * Generate the code necessary to produce a SQL value based on a value.  The value's type is assumed to match the type of this TypeId.  For example, a TypeId for the SQL int type should be given an value that evaluates to a Java int or Integer. If the type of the value is incorrect, the generated code will not work. The stack must contain data value factory value.
 * @param mb	The method to put the expression in
 * @param collationType For character DVDs, this will be used to determinewhat Collator should be associated with the DVD which in turn will  decide whether to generate CollatorSQLcharDVDs or SQLcharDVDs. For  other types of DVDs, this parameter will be ignored.
 * @param field LocalField
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>field</ParamName>
                    <ParamType>LocalField</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCastToCharWidth</MethodName>
            <MethodComment>/** 
 * Return the maximum width for this data type when cast to a char type.
 * @param dts		The associated DataTypeDescriptor for this TypeId.
 * @return int			The maximum width for this data type when cast to a char type.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dts</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>