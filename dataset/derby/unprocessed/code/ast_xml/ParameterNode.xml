<Class>
    <Id>1110</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ParameterNode</ClassName>
    <SuperClass>ValueNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ParameterNode  /** 
 * This node type represents a ? parameter.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>parameterNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>userParameterTypes</FieldName>
            <FieldType>DataTypeDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>defaultValue</FieldName>
            <FieldType>DataValueDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>jsqlType</FieldName>
            <FieldType>JSQLType</FieldType>
        </Field>
        <Field>
            <FieldName>orderableVariantType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>returnOutputParameter</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>valToGenerate</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ParameterNode</MethodName>
            <MethodComment>/** 
 * Constructor for a ParameterNode.
 * @param parameterNumber			The number of this parameter,(unique per query starting at 0)
 * @param defaultValue				The default value for this parameter
 * @param cm                        The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaultValue</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterNumber</MethodName>
            <MethodComment>/** 
 * Get the parameter number
 * @return	The parameter number
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDescriptors</MethodName>
            <MethodComment>/** 
 * Set the descriptor array
 * @param descriptors	The array of DataTypeServices to fill in when the parametersare bound.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptors</ParamName>
                    <ParamType>DataTypeDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setType</MethodName>
            <MethodComment>/** 
 * Set the DataTypeServices for this parameter
 * @param descriptor	The DataTypeServices to set for this parameter
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReturnOutputParam</MethodName>
            <MethodComment>/** 
 * Mark this as a return output parameter (e.g. ? = CALL myMethod())
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>valueNode</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReturnOutputParam</MethodName>
            <MethodComment>/** 
 * Is this as a return output parameter (e.g. ? = CALL myMethod())
 * @return true if it is a return param
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  A parameter can't figure out what its type is without knowing where it appears, so this method does nothing. It is up to the node that points to this parameter node to figure out the type of the parameter and set it, using the setType() method above.
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkReliability;["?", CompilerContext.UNNAMED_PARAMETER_ILLEGAL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstantExpression</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree represents a constant expression.
 * @return	Whether or not this expression tree represents a constant expression.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantExpression</MethodName>
            <MethodComment>/** 
 * @see ValueNode#constantExpression 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>whereClause</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. The variant type can be: VARIANT				- variant within a scan (method calls and non-static field access) SCAN_INVARIANT		- invariant within a scan (column references from outer tables) QUERY_INVARIANT		- invariant within the life of a query (constant expressions)
 * @return	The variant type for the underlying expression.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOrderableVariantType</MethodName>
            <MethodComment>/** 
 * In a special circumstance, we want to consider parameters as constants.  For that situation, we allow a caller to temporarily set us to CONSTANT and then restore us.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setJSQLType</MethodName>
            <MethodComment>/** 
 * Set the JSQLType of this parameter. This supports the unnamed parameters that we use for replicated work units.
 * @param type	the JSQLType associated with this parameter
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>JSQLType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJSQLType</MethodName>
            <MethodComment>/** 
 * Get the JSQLType associated with this parameter. Again, part of method resolution for replicated work units.
 * @return	the JSQLType that the remote system assigned
 */
</MethodComment>
            <ReturnType>JSQLType</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * For a ParameterNode, we generate for the return value: (&lt;java type name&gt;) ( (BaseActivation) this.getParameter(parameterNumber) )
 * @param acb	The ExpressionClassBuilder for the class being built
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd=getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[parameterNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getParameter", ClassName.DataValueDescriptor, 1]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;cast;[getTypeCompiler().interfaceName()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateParameterValueSet</MethodName>
            <MethodComment>/** 
 * Generate the code to create the ParameterValueSet, if necessary, when constructing the activation.  Also generate the code to call a method that will throw an exception if we try to execute without all the parameters being set. This generated code goes into the Activation's constructor early on.
 * @param acb					The ExpressionClassBuilder for the class we're building
 * @param numberOfParameters	number of parameters for this statement
 * @param parameterList			The parameter list for the statement.
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numberOfParameters</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterList</ParamName>
                    <ParamType>ParameterNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultValue</MethodName>
            <MethodComment>/** 
 * Get the default value for the parameter.  Parameters may get default values for optimization purposes.
 * @return the value, may be null
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiresTypeFromContext</MethodName>
            <MethodComment>/** 
 * @see ValueNode#requiresTypeFromContext
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isParameterNode</MethodName>
            <MethodComment>/** 
 * @see ValueNode#isParameterNode
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment>/** 
 * @inheritDoc
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValueToGenerate</MethodName>
            <MethodComment>/** 
 * Save the received ValueNode locally so that we can generate it (in place of "this") at generation time.  See the preprocess() method of InListOperatorNode for more on how this is used.
 * @param vn The ValueNode to generate in place of this ParameterNode.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vn</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>