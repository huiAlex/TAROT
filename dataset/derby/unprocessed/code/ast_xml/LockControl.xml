<Class>
    <Id>27</Id>
    <Package>org.apache.derby.impl.services.locks</Package>
    <ClassName>LockControl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Control</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LockControl  /** 
 * A LockControl contains a reference to the item being locked and doubly linked lists for the granted locks and the waiting locks. &lt;P&gt; MT - Mutable - Container object : single thread required
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>ref</FieldName>
            <FieldType>Lockable</FieldType>
        </Field>
        <Field>
            <FieldName>firstGrant</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>granted</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>granted</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>waiting</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>waiting</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
        <Field>
            <FieldName>lastPossibleSkip</FieldName>
            <FieldType>Lock</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>LockControl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>firstLock</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ref</ParamName>
                    <ParamType>Lockable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LockControl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>copyFrom</ParamName>
                    <ParamType>LockControl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockControl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LockControl</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>grant</MethodName>
            <MethodComment>/** 
 * Grant this lock.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockItem</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Lock&gt; [lgranted=granted]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lockItem;grant;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unlock</MethodName>
            <MethodComment>/** 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockInGroup</ParamName>
                    <ParamType>Latch</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unlockCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Lock&gt; [lgranted=granted]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGrantable</MethodName>
            <MethodComment>/** 
 * This routine can be called to see if a lock currently on the wait list could be granted. If this lock has waiters ahead of it then we do not jump over the waiter(s) even if we can be granted. This avoids the first waiter being starved out.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>noWaitersBeforeMe</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compatibilitySpace</ParamName>
                    <ParamType>CompatibilitySpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [grantLock=false]</InnerVar>
                <InnerVar>Lockable [lref=ref]</InnerVar>
                <InnerVar>List&lt;Lock&gt; [lgranted=granted]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addLock</MethodName>
            <MethodComment>/** 
 * Add a lock into this control, granted it if possible. This can be entered in several states. &lt;/OL&gt; &lt;LI&gt;The Lockable is locked (granted queue not empty), and there are no waiters (waiting queue is empty) &lt;LI&gt;The Lockable is locked and there are waiters &lt;LI&gt;The Lockable is locked and there are waiters and the first is potentially granted &lt;LI&gt;The Lockable is unlocked and there are waiters and the first is potentially granted. Logically the item is still locked, it's just that the lock has just been released and the first waker has not woken up yet. &lt;/OL&gt; This call is never entered when the object is unlocked and there are no waiters. 1) The Lockable has just been unlocked, 
 */
</MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compatibilitySpace</ParamName>
                    <ParamType>CompatibilitySpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [grantLock=false]</InnerVar>
                <InnerVar>boolean [otherWaiters=(firstWaiter() != null)]</InnerVar>
                <InnerVar>Lock [lockItem=null]</InnerVar>
                <InnerVar>Lockable [lref=ref]</InnerVar>
                <InnerVar>boolean [spaceHasALock=false]</InnerVar>
                <InnerVar>boolean [noGrantAtAll=false]</InnerVar>
                <InnerVar>ActiveLock [waitingLock=new ActiveLock(compatibilitySpace,lref,qualifier)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addWaiter;[waitingLock, ls]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUnlocked</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;Lock&gt; [lgranted=granted]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstWaiter</MethodName>
            <MethodComment>/** 
 * Return the first lock in the wait line, null if the line is empty.
 */
</MethodComment>
            <ReturnType>ActiveLock</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextWaiter</MethodName>
            <MethodComment>/** 
 * Get the next waiting lock (if any).
 */
</MethodComment>
            <ReturnType>ActiveLock</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>item</ParamName>
                    <ParamType>ActiveLock</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remove</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ActiveLock [nextWaitingLock=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockable</MethodName>
            <MethodComment>/** 
 * Return the lockable object controlled by me.
 */
</MethodComment>
            <ReturnType>Lockable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstGrant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGranted</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWaiting</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>giveUpWait</MethodName>
            <MethodComment>/** 
 * Give up waiting up on a lock
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>item</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=removeWaiter(item,ls)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWaiters</MethodName>
            <MethodComment>/** 
 * Add the waiters of this lock into this Map object. &lt;BR&gt; Each waiting thread gets two entries in the hashtable &lt;OL&gt; &lt;LI&gt;key=compatibility space - value=ActiveLock &lt;LI&gt;key=ActiveLock - value={LockControl for first waiter|ActiveLock of previosue waiter} &lt;/OL&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>waiters</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [previous=this]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGrants</MethodName>
            <MethodComment>/** 
 * Return a Stack of the held locks (Lock objects) on this Lockable.
 */
</MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;Lock&gt; [ret]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLock</MethodName>
            <MethodComment>/** 
 * Find a granted lock matching this space and qualifier
 */
</MethodComment>
            <ReturnType>Lock</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compatibilitySpace</ParamName>
                    <ParamType>CompatibilitySpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Lock&gt; [lgranted=granted]</InnerVar>
                <InnerVar>int [index=0]</InnerVar>
                <InnerVar>int [endIndex=firstGrant == null ? lgranted.size() : 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>blockedByParent</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Returns true if the childLock is blocked because its parent owns a conficting lock. This code was written to support the fix to DERBY-6554. The only known way that this condition arises is when a write attempt by a nested user transaction is blocked by a read lock held by the main transaction. This only happens while trying to write to SYS.SYSSEQUENCES while managing sequence generators. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>childLock</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LockOwner [childOwner=childLock.getCompatabilitySpace().getOwner()]</InnerVar>
                <InnerVar>Object [requestedQualifier=childLock.getQualifier()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shallowClone</MethodName>
            <MethodComment>/** 
 * make a shallow clone of myself
 */
</MethodComment>
            <ReturnType>Control</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWaiter</MethodName>
            <MethodComment>/** 
 * Add a lock request to a list of waiters.
 * @param lockItem	The lock request
 * @param ls		The lock table
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockItem</ParamName>
                    <ParamType>Lock</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>waiting;add;[lockItem]</InnerMethodInvoke>
                <InnerMethodInvoke>ls;oneMoreWaiter;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popFrontWaiter</MethodName>
            <MethodComment>/** 
 * Remove and return the first lock request from a list of waiters.
 * @param ls		The lock table
 * @return	The removed lock request
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeWaiter</MethodName>
            <MethodComment>/** 
 * Remove and return the lock request at the given index from a list of waiters.
 * @param index		The index at which to remove the lock request
 * @param ls		The lock table
 * @return	The removed lock request
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ls;oneLessWaiter;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeWaiter</MethodName>
            <MethodComment>/** 
 * Remove and return the given lock request from a list of waiters.
 * @param item		The item to remove
 * @param ls		The lock table
 * @return	The number of items removed
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>item</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ls</ParamName>
                    <ParamType>LockTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ls;oneLessWaiter;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>