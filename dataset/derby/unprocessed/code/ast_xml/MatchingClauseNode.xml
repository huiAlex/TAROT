<Class>
    <Id>694</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>MatchingClauseNode</ClassName>
    <SuperClass>QueryTreeNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MatchingClauseNode  /** 
 * Node representing a WHEN MATCHED or WHEN NOT MATCHED clause in a MERGE statement.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>CURRENT_OF_NODE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_matchingRefinement</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>_updateColumns</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>_insertColumns</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>_insertValues</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>_dml</FieldName>
            <FieldType>DMLModStatementNode</FieldType>
        </Field>
        <Field>
            <FieldName>_thenColumns</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>_clauseNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>_actionMethodName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_resultSetFieldName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_rowMakingMethodName</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MatchingClauseNode</MethodName>
            <MethodComment>/** 
 * Constructor called by factory methods.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>matchingRefinement</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertValues</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeUpdateClause</MethodName>
            <MethodComment>/** 
 * Make a WHEN MATCHED ... THEN UPDATE clause 
 */
</MethodComment>
            <ReturnType>MatchingClauseNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>matchingRefinement</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeDeleteClause</MethodName>
            <MethodComment>/** 
 * Make a WHEN MATCHED ... THEN DELETE clause 
 */
</MethodComment>
            <ReturnType>MatchingClauseNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>matchingRefinement</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeInsertClause</MethodName>
            <MethodComment>/** 
 * Make a WHEN NOT MATCHED ... THEN INSERT clause 
 */
</MethodComment>
            <ReturnType>MatchingClauseNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>matchingRefinement</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertValues</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUpdateClause</MethodName>
            <MethodComment>/** 
 * Return true if this is a WHEN MATCHED ... UPDATE clause 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInsertClause</MethodName>
            <MethodComment>/** 
 * Return true if this is a WHEN NOT MATCHED ... INSERT clause 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDeleteClause</MethodName>
            <MethodComment>/** 
 * Return true if this is a WHEN MATCHED ... DELETE clause 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getThenColumns</MethodName>
            <MethodComment>/** 
 * Return the list of columns which form the rows of the ResultSet which drive the INSERT/UPDATE/DELETE actions.
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bind</MethodName>
            <MethodComment>/** 
 * Bind this WHEN [ NOT ] MATCHED clause against the parent MergeNode 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forbidSubqueries;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindRefinement</MethodName>
            <MethodComment>/** 
 * Bind the optional refinement condition in the MATCHED clause 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnsInExpressions</MethodName>
            <MethodComment>/** 
 * Collect the columns mentioned by expressions in this MATCHED clause 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drivingColumnMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUpdate</MethodName>
            <MethodComment>/** 
 * Bind a WHEN MATCHED ... THEN UPDATE clause 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [setClauses=realiasSetClauses(targetTable)]</InnerVar>
                <InnerVar>TableName [tableName=targetTable.getTableNameField()]</InnerVar>
                <InnerVar>FromList [selectFromList=fullFromList]</InnerVar>
                <InnerVar>SelectNode [selectNode=new SelectNode(setClauses,selectFromList,null,null,null,null,null,getContextManager())]</InnerVar>
                <InnerVar>boolean [wasSkippingTypePrivileges=getCompilerContext().skipTypePrivileges(true)]</InnerVar>
                <InnerVar>ResultColumnList [beforeColumns=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>ResultColumnList [afterColumns=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>ResultColumnList [fullUpdateRow=getBoundSelectUnderUpdate().getResultColumns()]</InnerVar>
                <InnerVar>int [rowSize=fullUpdateRow.size() / 2]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindSetClauses;[mergeNode, fullFromList, targetTable, setClauses]</InnerMethodInvoke>
                <InnerMethodInvoke>_dml;bindStatement;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;buildThenColumnsForUpdate;[fullFromList, targetTable, fullUpdateRow, beforeColumns, afterColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();skipTypePrivileges;[wasSkippingTypePrivileges]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>realiasSetClauses</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Due to discrepancies in how names are resolved by SELECT and UPDATE, we have to force the left side of SET clauses to use the same table identifiers as the right sides of the SET clauses. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [rcl=new ResultColumnList(getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBoundSelectUnderUpdate</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the bound SELECT node under the dummy UPDATE node. This may not be the source result set of the UPDATE node. That is because a ProjectRestrictNode may have been inserted on top of it by DEFAULT handling. This method exists to make the UPDATE actions of MERGE statements behave like ordinary UPDATE statements in this situation. The behavior is actually wrong. See DERBY-6414. Depending on how that bug is addressed, we may be able to remove this method eventually. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultSetNode [candidate=_dml.resultSet]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindSetClauses</MethodName>
            <MethodComment>/** 
 * Bind the SET clauses of an UPDATE action 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>setClauses</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ColumnReference&gt; [colRefs=getColumnReferences(_updateColumns)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>setClauses;replaceOrForbidDefaults;[targetTable.getTableDescriptor(), _updateColumns, true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindExpressions;[setClauses, fullFromList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildThenColumnsForUpdate</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Construct the row in the temporary table which drives an UPDATE action. Unlike a DELETE, whose temporary row is just a list of copied columns, the temporary row for UPDATE may contain complex expressions which must be code-generated later on. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullRow</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>beforeRow</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>afterValues</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [td=targetTable.getTableDescriptor()]</InnerVar>
                <InnerVar>HashSet&lt;String&gt; [changedColumns=getChangedColumnNames()]</InnerVar>
                <InnerVar>HashSet&lt;String&gt; [changedGeneratedColumns=getChangedGeneratedColumnNames(td,changedColumns)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChangedColumnNames</MethodName>
            <MethodComment>/** 
 * Get the names of the columns explicitly changed by SET clauses 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>HashSet&lt;String&gt; [result=new HashSet&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChangedGeneratedColumnNames</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the names of the generated columns which are changed by the UPDATE statement. These are the generated columns which match one of the following conditions: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;Are explicitly mentioned on the left side of a SET clause.&lt;/li&gt; &lt;li&gt;Are built from other columns which are explicitly mentioned on the left side of a SET clause.&lt;/li&gt; &lt;/ul&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashSet&lt;String&gt; [result=new HashSet&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindDelete</MethodName>
            <MethodComment>/** 
 * Bind a WHEN MATCHED ... THEN DELETE clause 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IgnoreFilter [ignorePermissions=new IgnoreFilter()]</InnerVar>
                <InnerVar>FromBaseTable [deleteTarget=new FromBaseTable(targetTable.getTableNameField(),null,null,null,getContextManager())]</InnerVar>
                <InnerVar>FromList [dummyFromList=new FromList(getContextManager())]</InnerVar>
                <InnerVar>CurrentOfNode [currentOfNode=CurrentOfNode.makeForMerge(CURRENT_OF_NODE_NAME,deleteTarget,getContextManager())]</InnerVar>
                <InnerVar>FromList [fromList=new FromList(getContextManager())]</InnerVar>
                <InnerVar>SelectNode [selectNode=new SelectNode(null,fromList,null,null,null,null,null,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyFromList;addFromTable;[deleteTarget]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyFromList;bindTables;[dd, new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerMethodInvoke>
                <InnerMethodInvoke>fromList;addFromTable;[currentOfNode]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>_dml;bindStatement;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;buildThenColumnsForDelete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildThenColumnsForDelete</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Construct the signature of the temporary table which drives the INSERT/UPDATE/DELETE action. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumnList [dmlSignature=_dml.resultSet.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindInsert</MethodName>
            <MethodComment>/** 
 * Bind a WHEN NOT MATCHED ... THEN INSERT clause 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeNode</ParamName>
                    <ParamType>MergeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [selectList=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>FromList [sourceTableFromList=new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerVar>
                <InnerVar>SelectNode [selectNode=new SelectNode(selectList,fullFromList,null,null,null,null,null,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>selectList;replaceOrForbidDefaults;[targetTable.getTableDescriptor(), _insertColumns, true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindExpressions;[selectList, fullFromList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindInsertValues;[fullFromList, targetTable]</InnerMethodInvoke>
                <InnerMethodInvoke>sourceTableFromList;addElement;[fullFromList.elementAt(MergeNode.SOURCE_TABLE_INDEX)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindExpressions;[_insertValues, sourceTableFromList]</InnerMethodInvoke>
                <InnerMethodInvoke>_dml;bindStatement;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;buildThenColumnsForInsert;[fullFromList, targetTable, _dml.resultSet.getResultColumns(), _insertColumns, _insertValues]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindInsertValues</MethodName>
            <MethodComment>/** 
 * Bind the values in the INSERT list 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [td=targetTable.getTableDescriptor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>_insertValues;replaceOrForbidDefaults;[targetTable.getTableDescriptor(), _insertColumns, true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindExpressions;[_insertValues, fullFromList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildFullColumnList</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Build the full column list for a table. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [result=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>ColumnDescriptorList [cdl=td.getColumnDescriptorList()]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildThenColumnsForInsert</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Construct the row in the temporary table which drives an INSERT action. Unlike a DELETE, whose temporary row is just a list of copied columns, the temporary row for INSERT may contain complex expressions which must be code-generated later on. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fullFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullRow</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertValues</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [wasSkippingTypePrivileges=getCompilerContext().skipTypePrivileges(true)]</InnerVar>
                <InnerVar>TableDescriptor [td=targetTable.getTableDescriptor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();skipTypePrivileges;[wasSkippingTypePrivileges]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeAutoGenRC</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Make a ResultColumn for an identity column which is being set to the DEFAULT value. This special ResultColumn will make it through code generation so that it will be calculated when the INSERT/UPDATE action is run. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>origRC</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>virtualColumnID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [columnName=origRC.getName()]</InnerVar>
                <InnerVar>ColumnReference [autoGenCR=new ColumnReference(columnName,targetTable.getTableName(),getContextManager())]</InnerVar>
                <InnerVar>ResultColumn [autoGenRC=new ResultColumn(autoGenCR,null,getContextManager())]</InnerVar>
                <InnerVar>VirtualColumnNode [autoGenVCN=new VirtualColumnNode(targetTable,autoGenRC,virtualColumnID,getContextManager())]</InnerVar>
                <InnerVar>ResultColumn [newRC=new ResultColumn(autoGenCR,autoGenVCN,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newRC;setType;[origRC.getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressions</MethodName>
            <MethodComment>/** 
 * Boilerplate for binding a list of ResultColumns against a FromList 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>int [previousReliability=cc.getReliability()]</InnerVar>
                <InnerVar>boolean [wasSkippingTypePrivileges=cc.skipTypePrivileges(true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;setReliability;[previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidSubqueries</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Forbid subqueries in WHEN [ NOT ] MATCHED clauses. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forbidSubqueries;[_matchingRefinement]</InnerMethodInvoke>
                <InnerMethodInvoke>null;forbidSubqueries;[_updateColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>null;forbidSubqueries;[_insertColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>null;forbidSubqueries;[_insertValues]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidSubqueries</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidSubqueries</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimize</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Optimize the INSERT/UPDATE/DELETE action. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>_dml;optimizeStatement;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [refinementName=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClauseType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildThenColumnSignature</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Build the signature of the row which will go into the temporary table. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumnDescriptor[] [cells=_thenColumns.makeResultDescriptors()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Generate a method to invoke the INSERT/UPDATE/DELETE action. This method will be called at runtime by MatchingClauseConstantAction.executeConstantAction(). &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generatedScan</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hojn</ParamName>
                    <ParamType>HalfOuterJoinNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>clauseNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [mb=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,ClassName.ResultSet,_actionMethodName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;adjustMatchingRefinement;[selectList, generatedScan]</InnerMethodInvoke>
                <InnerMethodInvoke>null;generateInsertUpdateRow;[acb, selectList, generatedScan, hojn]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;addThrownException;[ClassName.StandardException]</InnerMethodInvoke>
                <InnerMethodInvoke>null;remapConstraints;[]</InnerMethodInvoke>
                <InnerMethodInvoke>_dml;generate;[acb, mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;complete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapConstraints</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Re-map ColumnReferences in constraints to point into the row from the temporary table. This is where the row will be stored when constraints are being evaluated. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateResultSetField</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Adds a field to the generated class to hold the ResultSet of "then" rows which drive the INSERT/UPDATE/DELETE action. Generates code to push the contents of that field onto the stack. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LocalField [resultSetField=acb.newFieldDeclaration(Modifier.PUBLIC,ClassName.NoPutResultSet,_resultSetFieldName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;getField;[resultSetField]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateInsertUpdateRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Generate a method to build a row for the temporary table for INSERT/UPDATE actions. The method stuffs each column in the row with the result of the corresponding expression built out of columns in the current row of the driving left join. The method returns the stuffed row. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generatedScan</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hojn</ParamName>
                    <ParamType>HalfOuterJoinNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [mb=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,ClassName.ExecRow,_rowMakingMethodName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;adjustThenColumns;[selectList, generatedScan, hojn]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;addThrownException;[ClassName.StandardException]</InnerMethodInvoke>
                <InnerMethodInvoke>_thenColumns;generateEvaluatedRow;[acb, mb, false, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustMatchingRefinement</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Point the column references in the matching refinement at the corresponding columns returned by the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generatedScan</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustThenColumns</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Point the column references in the temporary row at the corresponding columns returned by the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generatedScan</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hojn</ParamName>
                    <ParamType>HalfOuterJoinNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [leftJoinResult=generatedScan.getResultColumns()]</InnerVar>
                <InnerVar>int [lastRCSlot=_thenColumns.size() - 1]</InnerVar>
                <InnerVar>ResultColumn [lastRC=_thenColumns.elementAt(lastRCSlot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;useGeneratedScan;[selectList, generatedScan, _thenColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>useGeneratedScan</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Point a node's ColumnReferences into the row returned by the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generatedScan</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [leftJoinResult=generatedScan.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSelectListOffset</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Find a column reference in the SELECT list of the driving left join and return its 1-based offset into that list.  Returns -1 if the column can't be found. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>thenExpression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [selectCount=selectList.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMergeTableID</MethodName>
            <MethodComment>/** 
 * Find the MERGE table id of the indicated column 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [mergeTableID=cr.getMergeTableID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnReferences</MethodName>
            <MethodComment>/** 
 * Get a list of column references in an expression 
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [getCRs=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expression;accept;[getCRs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRowLocation</MethodName>
            <MethodComment>/** 
 * Return true if the ResultColumn represents a RowLocation 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd=rc.getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>