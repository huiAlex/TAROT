<Class>
    <Id>1236</Id>
    <Package>org.apache.derbyTesting.unitTests.store</Package>
    <ClassName>T_AccessFactory</ClassName>
    <SuperClass>T_Generic</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>testService</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>store</FieldName>
            <FieldType>AccessFactory</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>T_AccessFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getModuleToTestProtocolName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runTests</MethodName>
            <MethodComment>/** 
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TransactionController [tc=null]</InnerVar>
                <InnerVar>boolean [pass=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>startParams;put;[Property.NO_AUTO_BOOT, Boolean.TRUE.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>startParams;put;[Property.DELETE_ON_CREATE, Boolean.TRUE.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(unitTestMain) Testing " + testService]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flush_cache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>RawStoreFactory [rawstore=(RawStoreFactory)findServiceModule(this.store,RawStoreFactory.MODULE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;checkpoint;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAndFetchExample</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(insertAndFetchExample)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAndFetch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StaticCompiledOpenConglomInfo [static_info=tc.getStaticCompiledConglomInfo(conglomid)]</InnerVar>
                <InnerVar>DynamicCompiledOpenConglomInfo [dynamic_info=tc.getDynamicCompiledConglomInfo(conglomid)]</InnerVar>
                <InnerVar>String [curr_xact_name=tc.getTransactionIdString()]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openCompiledConglomerate(false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,static_info,dynamic_info)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(value)]</InnerVar>
                <InnerVar>RowLocation [rowloc=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>Hashtable&lt;RowLocation,RowLocation&gt; [test_rowloc_hash=new Hashtable&lt;RowLocation,RowLocation&gt;()]</InnerVar>
                <InnerVar>RowLocation [hash_find=test_rowloc_hash.get(rowloc)]</InnerVar>
                <InnerVar>T_AccessRow [r2=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(0)]</InnerVar>
                <InnerVar>SQLInteger [c3=new SQLInteger(0)]</InnerVar>
                <InnerVar>FormatableBitSet [singleColumn=new FormatableBitSet(1)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [c3row=new DataValueDescriptor[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(insertAndFetch) xact id = " + curr_xact_name]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>test_rowloc_hash;put;[rowloc, rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>r2;setCol;[0, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>singleColumn;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAndUpdateExample</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(insertAndUpdateExample)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deletetest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value1</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value2</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>RowLocation [rowloc=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [update_row=new DataValueDescriptor[1]]</InnerVar>
                <InnerVar>FormatableBitSet [update_desc=new FormatableBitSet(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(value1)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>update_desc;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAndUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value1</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value2</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>RowLocation [rowloc=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [update_row=new DataValueDescriptor[1]]</InnerVar>
                <InnerVar>FormatableBitSet [update_desc=new FormatableBitSet(1)]</InnerVar>
                <InnerVar>T_AccessRow [r2=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(value1)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>update_desc;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;replace;[rowloc, update_row, update_desc]</InnerMethodInvoke>
                <InnerMethodInvoke>r2;setCol;[0, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>scanExample</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>int [values[]={11,22,33,44,55,66}]</InnerVar>
                <InnerVar>T_AccessRow [row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>int [scanindex=0]</InnerVar>
                <InnerVar>SQLInteger [col=new SQLInteger(0)]</InnerVar>
                <InnerVar>StaticCompiledOpenConglomInfo [static_info=tc.getStaticCompiledConglomInfo(conglomid)]</InnerVar>
                <InnerVar>ScanController [scan1=tc.openCompiledScan(false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0,static_info,tc.getDynamicCompiledConglomInfo(conglomid))]</InnerVar>
                <InnerVar>RowLocation [third_row_rowloc=scan1.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [scan2=tc.openScan(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>int [newvalues[]={22,33,444,55,6666}]</InnerVar>
                <InnerVar>ScanController [scan3=tc.openScan(conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>ScanController [scan4=tc.openScan(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [update_row=new DataValueDescriptor[1]]</InnerVar>
                <InnerVar>FormatableBitSet [update_desc=new FormatableBitSet(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) debug output testing: " + tc.debugOpened()]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) rows inserted"]</InnerMethodInvoke>
                <InnerMethodInvoke>row;setCol;[0, col]</InnerMethodInvoke>
                <InnerMethodInvoke>null;flush_cache;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;setEstimatedRowCount;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;reopenScan;[null, 0, null, null, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;fetchLocation;[third_row_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;reopenScanByRowLocation;[third_row_rowloc, null]</InnerMethodInvoke>
                <InnerMethodInvoke>scan1;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) rows present and accounted for"]</InnerMethodInvoke>
                <InnerMethodInvoke>scan2;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) rows fiddled with"]</InnerMethodInvoke>
                <InnerMethodInvoke>row;setCol;[0, col]</InnerMethodInvoke>
                <InnerMethodInvoke>scan3;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>row;setCol;[0, col]</InnerMethodInvoke>
                <InnerMethodInvoke>scan3;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) fiddled rows present and accounted for"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) testing expected delete errors"]</InnerMethodInvoke>
                <InnerMethodInvoke>update_desc;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>scan4;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanExample) completed"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [cc]</InnerVar>
                <InnerVar>long [orig_conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(dropTest) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[orig_conglomid]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableProperties</MethodName>
            <MethodComment>/** 
 * Test the access level getTableProperties() call. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>Properties [prop=new Properties()]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,prop,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [ret_prop=tc.getUserCreateConglomPropList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>prop;put;[Property.PAGE_SIZE_PARAMETER, "8192"]</InnerMethodInvoke>
                <InnerMethodInvoke>prop;put;[RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, "99"]</InnerMethodInvoke>
                <InnerMethodInvoke>prop;put;[RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, "42"]</InnerMethodInvoke>
                <InnerMethodInvoke>prop;put;[RawStoreFactory.CONTAINER_INITIAL_PAGES, "22"]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;getTableProperties;[ret_prop]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>alterTable</MethodName>
            <MethodComment>/** 
 * Test the access level alter table interface for adding columns. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @param temporary flag which tells whether or not the conglomerateused in the test should be temporary
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporary</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>int [temporaryFlag=temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,temporaryFlag)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>RowLocation [rowloc1=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>RowLocation [rowloc2=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>T_AccessRow [two_column_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [col1=new SQLInteger(3)]</InnerVar>
                <InnerVar>SQLInteger [col2=new SQLInteger(3)]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(alterTable) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(2)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc2]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commitNoSync;[TransactionController.RELEASE_LOCKS]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;addColumnToConglomerate;[conglomid, 1, c1, StringDataValue.COLLATION_TYPE_UCS_BASIC]</InnerMethodInvoke>
                <InnerMethodInvoke>two_column_row;setCol;[0, new SQLInteger(3)]</InnerMethodInvoke>
                <InnerMethodInvoke>two_column_row;setCol;[1, new SQLInteger(300)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[two_column_row.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;reopenScan;[null, 0, null, null, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(alterTable) completed"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>scanInfo</MethodName>
            <MethodComment>/** 
 * Test the access level ScanInfo interface. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(100)]</InnerVar>
                <InnerVar>RowLocation [rowloc1=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>RowLocation [rowloc2=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(conglomid,false,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>ScanInfo [scan_info=scan.getScanInfo()]</InnerVar>
                <InnerVar>Properties [prop=scan_info.getAllScanInfo(null)]</InnerVar>
                <InnerVar>FormatableBitSet [validColumns=new FormatableBitSet(3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(scanInfo) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(2)]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, new SQLInteger(200)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;delete;[rowloc2]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;[("return from full row scan heap.getScanInfo() = " + prop)]</InnerMethodInvoke>
                <InnerMethodInvoke>validColumns;set;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;[("return from partial scan heap.getScanInfo() = " + prop)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(scanInfo) finishing"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>partialScan</MethodName>
            <MethodComment>/** 
 * Test partial scans. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(100)]</InnerVar>
                <InnerVar>RowLocation [rowloc1=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>RowLocation [rowloc2=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>FormatableBitSet [validColumns=new FormatableBitSet()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,validColumns,null,0,null,null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(partialScan) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(2)]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, new SQLInteger(200)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;delete;[rowloc2]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(partialScan) finishing"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insert_bench</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [cc=null]</InnerVar>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>long [conglomid=-1]</InnerVar>
                <InnerVar>long [before, after]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>long [iter=100]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sortCost</MethodName>
            <MethodComment>/** 
 * Test the access level SortCost interface. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(100)]</InnerVar>
                <InnerVar>RowLocation [rowloc1=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>SortCostController [scc=tc.openSortCostController()]</InnerVar>
                <InnerVar>double [estimated_cost=scc.getSortCost(template_row.getRowArray(),null,false,10000,100,100)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(sortCost) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;flush_cache;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(sortCost) finishing"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeCost</MethodName>
            <MethodComment>/** 
 * Test the access level StoreCost interface. &lt;p&gt;
 * @return true if the test succeeded.
 * @param tc The transaction controller to use in the test.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail Unexpected behaviour from the API
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(100)]</InnerVar>
                <InnerVar>RowLocation [rowloc1=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>StoreCostController [scc=tc.openStoreCost(conglomid)]</InnerVar>
                <InnerVar>double [fetch_cost=scc.getFetchFromRowLocationCost((FormatableBitSet)null,0)]</InnerVar>
                <InnerVar>FormatableBitSet [bit_set=new FormatableBitSet(2)]</InnerVar>
                <InnerVar>StoreCostResult [cost_result=new T_StoreCostResult()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(storeCost) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;flush_cache;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;setEstimatedRowCount;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;setEstimatedRowCount;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch cost (full row) of row loc = " + fetch_cost]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch cost (no cols) of row loc = " + fetch_cost]</InnerMethodInvoke>
                <InnerMethodInvoke>bit_set;set;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch cost (1 col) of row loc = " + fetch_cost]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;getScanCost;[StoreCostController.STORECOST_SCAN_NORMAL, -1, 1, false, (FormatableBitSet)null, new T_AccessRow(2).getRowArray(), null, 0, null, 0, false, 0, cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch scan cost (full row) of row loc = " + cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;getScanCost;[StoreCostController.STORECOST_SCAN_NORMAL, -1, 1, false, new FormatableBitSet(0), new T_AccessRow(2).getRowArray(), null, 0, null, 0, false, 0, cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch scan cost (no cols) of row loc = " + cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;getScanCost;[StoreCostController.STORECOST_SCAN_NORMAL, -1, 1, false, new FormatableBitSet(1), new T_AccessRow(2).getRowArray(), null, 0, null, 0, false, 0, cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch scan cost (no cols) of row loc = " + cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>bit_set;set;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>scc;getScanCost;[StoreCostController.STORECOST_SCAN_NORMAL, -1, 1, false, bit_set, new T_AccessRow(2).getRowArray(), null, 0, null, 0, false, 0, cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["fetch scan cost (1 cols) of row loc = " + cost_result]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(storeCost) finishing"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transactionalProperties</MethodName>
            <MethodComment>/** 
 * Test transactional properties
 * @exception StandardException test failure
 * @exception T_Fail test failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [lvalue=((SQLLongint)(tc.getProperty("T_Key_Frog"))).getLong()]</InnerVar>
                <InnerVar>String [svalue=(String)tc.getProperty("T_Key_Tiger")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["start transactionalProperties"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Frog", new SQLLongint(479), false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Tiger", "Roar, ROAR", false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Tiger", "mieow, mieow", false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Tiger", new SQLLongint(570), false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Frog", (Serializable)null, false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;setProperty;["T_Key_Tiger", new SQLLongint(457), false]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;PASS;["transactionalProperties"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tempTest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [cid5252t=createAConglom(tc,5252,true)]</InnerVar>
                <InnerVar>long [cid87t=createAConglom(tc,87,true)]</InnerVar>
                <InnerVar>long [cid999p=createAConglom(tc,999,false)]</InnerVar>
                <InnerVar>long [cid3t=createAConglom(tc,3,true)]</InnerVar>
                <InnerVar>long [cid5252ti=createBtree(tc,cid5252t,true)]</InnerVar>
                <InnerVar>long [cid999pi=createBtree(tc,cid999p,false)]</InnerVar>
                <InnerVar>int [r]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(cid3t,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(tempTest) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[cid999pi]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[cid999p]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[cid87t]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commitNoSync;[TransactionController.RELEASE_LOCKS]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[cid5252ti]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[cid5252t]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(tempTest) succeeded"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createAConglom</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>testValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporary</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [cid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(cid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLLongint [col=new SQLLongint(testValue)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>row;setCol;[0, col]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[row.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBtreeTemplate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FormatableBitSet [singleColumn=new FormatableBitSet(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(baseConglomId,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,singleColumn,null,0,null,null,0)]</InnerVar>
                <InnerVar>T_AccessRow [template=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLLongint [col0=new SQLLongint(0)]</InnerVar>
                <InnerVar>RowLocation [col1=sc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>singleColumn;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>template;setCol;[0, col0]</InnerMethodInvoke>
                <InnerMethodInvoke>template;setCol;[1, col1]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createBtree</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporary</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [indexProps=new Properties()]</InnerVar>
                <InnerVar>FormatableBitSet [singleColumn=new FormatableBitSet(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(baseConglomId,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,singleColumn,null,0,null,null,0)]</InnerVar>
                <InnerVar>T_AccessRow [template=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLLongint [col0=new SQLLongint(0)]</InnerVar>
                <InnerVar>RowLocation [col1=sc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [baseRow=new DataValueDescriptor[1]]</InnerVar>
                <InnerVar>long [iid=tc.createConglomerate("BTREE",template.getRowArray(),null,null,indexProps,temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(iid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>indexProps;put;["baseConglomerateId", Long.toString(baseConglomId)]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProps;put;["nUniqueColumns", "1"]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProps;put;["rowLocationColumn", "1"]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProps;put;["nKeyFields", "2"]</InnerMethodInvoke>
                <InnerMethodInvoke>singleColumn;set;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>template;setCol;[0, col0]</InnerMethodInvoke>
                <InnerMethodInvoke>template;setCol;[1, col1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkAConglom</MethodName>
            <MethodComment>/** 
 * Open a scan on the conglomerate for the given conglom id, and verify that it has rows with the given test value.  This is a way of verifying that we got the right conglomerate.  Returns the number of rows that it checked (-1 if the conglomerate doesn't exist).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scratch_template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>testValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [sc=tc.openScan(conglomId,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>T_AccessRow [row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLLongint [col=new SQLLongint(0)]</InnerVar>
                <InnerVar>int [nrows=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>row;setCol;[0, col]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatelocks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(updatelocks starting.)"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updatelocks_0;[tc, TransactionController.ISOLATION_SERIALIZABLE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updatelocks_0;[tc, TransactionController.ISOLATION_READ_COMMITTED]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(updatelocks ending.)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatelocks_0</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(2)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(1)]</InnerVar>
                <InnerVar>SQLInteger [c2=new SQLInteger(100)]</InnerVar>
                <InnerVar>long [orig_conglomid=tc.createConglomerate("heap",r1.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(orig_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(orig_conglomid,false,(TransactionController.OPENMODE_FORUPDATE | TransactionController.OPENMODE_USE_UPDATE_LOCKS),TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>int [key_value]</InnerVar>
                <InnerVar>boolean [found_row_2=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, c2]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(1)]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, new SQLInteger(100)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(2)]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, new SQLInteger(200)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, new SQLInteger(3)]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[1, new SQLInteger(300)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(updatelocks ending.)"]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;reopenScan;[null, 0, null, null, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nestedUserTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [orig_conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>long [tmp_conglomid=tc.createConglomerate("heap",new T_AccessRow(1).getRowArray(),null,null,null,TransactionController.IS_TEMPORARY)]</InnerVar>
                <InnerVar>TransactionController [current_xact=store.getTransaction(getContextService().getCurrentContextManager())]</InnerVar>
                <InnerVar>TransactionController [child_tc=tc.startNestedUserTransaction(true,true)]</InnerVar>
                <InnerVar>TransactionController [current_xact_after_nest=store.getTransaction(getContextService().getCurrentContextManager())]</InnerVar>
                <InnerVar>ConglomerateController [cc=child_tc.openConglomerate(orig_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [tmp_cc=child_tc.openConglomerate(tmp_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>String [twok_string=new String("0123456789012345")]</InnerVar>
                <InnerVar>T_AccessRow [big_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>ConglomerateController [child_cc=child_tc.openConglomerate(orig_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(nestedUserTransaction) starting"]</InnerMethodInvoke>
                <InnerMethodInvoke>T_Fail;T_ASSERT;[tc.getLockSpace() == child_tc.getLockSpace(), "getLockSpace() returned different object for child."]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tmp_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[orig_conglomid]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>big_row;setCol;[1, new SQLChar(twok_string)]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>child_tc;destroy;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(nestedUserTransaction) finishing"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commitTest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_AccessRow [template_row=new T_AccessRow(1)]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("heap",template_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=new T_AccessRow(1)]</InnerVar>
                <InnerVar>SQLInteger [c1=new SQLInteger(0)]</InnerVar>
                <InnerVar>RowLocation [rowloc=cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ContextManager [cm2=getContextService().newContextManager()]</InnerVar>
                <InnerVar>TransactionController [tc2=null]</InnerVar>
                <InnerVar>ConglomerateController [cc2=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(commitTest)"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>r1;setCol;[0, c1]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insertAndFetchLocation;[r1.getRowArray(), rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commitNoSync;[TransactionController.KEEP_LOCKS]</InnerMethodInvoke>
                <InnerMethodInvoke>getContextService();setCurrentContextManager;[cm2]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getContextService();setCurrentContextManager;[cm2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(commitTest) succeeded"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testOpsBeforeFirstNext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scan</ParamName>
                    <ParamType>ScanController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>holdCursor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [base_id=createAConglom(tc,0,false)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(base_id,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [r1=null]</InnerVar>
                <InnerVar>SQLLongint [c1=null]</InnerVar>
                <InnerVar>long [index_id=createBtree(tc,base_id,false)]</InnerVar>
                <InnerVar>ScanController [base_scan=tc.openScan(base_id,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>ScanController [index_scan=tc.openScan(index_id,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>long [row_count=base_scan.getEstimatedRowCount()]</InnerVar>
                <InnerVar>long [key_value=((SQLLongint)r1.getCol(0)).getLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(holdCursor)"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[base_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[index_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;setEstimatedRowCount;[10]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;setEstimatedRowCount;[10]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[base_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[index_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[base_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[index_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;fetch;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[base_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[index_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;setEstimatedRowCount;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;setEstimatedRowCount;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;fetch;[r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;delete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;delete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;setEstimatedRowCount;[15]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;setEstimatedRowCount;[15]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[base_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;testOpsBeforeFirstNext;[index_scan, r1.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(holdCursor) succeeded"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [base_id=createAConglom(tc,0,false)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(base_id,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_AccessRow [accessRow=null]</InnerVar>
                <InnerVar>ScanController [base_scan=tc.openScan(base_id,true,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>RowLocation [firstRow=base_scan.newRowLocationTemplate()]</InnerVar>
                <InnerVar>long [key_value=((SQLLongint)accessRow.getCol(0)).getLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(positionAtRowLocation)"]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetchLocation;[firstRow]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;reopenScanByRowLocation;[firstRow, null]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;compressConglomerate;[base_id]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[accessRow.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(positionAtRowLocation) succeeded"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readUncommitted</MethodName>
            <MethodComment>/** 
 * Test critical cases for read uncommitted. &lt;p&gt; test 1 - test heap fetch, delete and replace of row on page which does not exist.   test 2 - test heap fetch, delete and replace of row on page where row does not exist.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [twok_string=new String("0123456789012345")]</InnerVar>
                <InnerVar>T_AccessRow [big_row=new T_AccessRow(2)]</InnerVar>
                <InnerVar>long [orig_conglomid=tc.createConglomerate("heap",big_row.getRowArray(),null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(orig_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_READ_UNCOMMITTED)]</InnerVar>
                <InnerVar>ScanController [base_scan=tc.openScan(orig_conglomid,true,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
                <InnerVar>RowLocation [deleted_page_rowloc=base_scan.newRowLocationTemplate()]</InnerVar>
                <InnerVar>FormatableBitSet [update_desc=new FormatableBitSet(1)]</InnerVar>
                <InnerVar>SQLChar [stringcol=new SQLChar()]</InnerVar>
                <InnerVar>RowLocation [deleted_row_rowloc=base_scan.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [delete_scan=tc.openScan(orig_conglomid,true,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,0,null,null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["(readUncommitted)"]</InnerMethodInvoke>
                <InnerMethodInvoke>big_row;setCol;[1, new SQLChar(twok_string)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stringcol;setValue;[T_AccessFactory.repeatString("012345678901234",100)]</InnerMethodInvoke>
                <InnerMethodInvoke>big_row;setCol;[1, stringcol]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;insert;[big_row.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>big_row;setCol;[1, new SQLChar(twok_string)]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetch;[big_row.getRowArray()]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetchLocation;[deleted_row_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>delete_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;fetchLocation;[deleted_row_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>base_scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(readUncommitted) succeeded"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>repeatString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>repeat</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [s=data]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPersistentService</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>