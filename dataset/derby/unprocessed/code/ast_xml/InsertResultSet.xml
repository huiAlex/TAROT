<Class>
    <Id>1783</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>InsertResultSet</ClassName>
    <SuperClass>DMLWriteGeneratedColumnsResultSet</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>TargetResultSet</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>InsertResultSet  /** 
 * Insert the rows from the source into the specified base table. This will cause constraints to be checked and triggers to be executed based on the c's and t's compiled into the insert plan.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>savedSource</FieldName>
            <FieldType>NoPutResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>constants</FieldName>
            <FieldType>InsertConstantAction</FieldType>
        </Field>
        <Field>
            <FieldName>generationClauses</FieldName>
            <FieldType>GeneratedMethod</FieldType>
        </Field>
        <Field>
            <FieldName>checkGM</FieldName>
            <FieldType>GeneratedMethod</FieldType>
        </Field>
        <Field>
            <FieldName>heapConglom</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>rowChanger</FieldName>
            <FieldType>RowChanger</FieldType>
        </Field>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>row</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>userSpecifiedBulkInsert</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bulkInsertPerformed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bulkInsert</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bulkInsertReplace</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>firstRow</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>needToDropSort</FieldName>
            <FieldType>boolean[]</FieldType>
        </Field>
        <Field>
            <FieldName>indexConversionTable</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>indexConversionTable</FieldName>
            <FieldType>Long</FieldType>
        </Field>
        <Field>
            <FieldName>indexedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>bulkHeapCC</FieldName>
            <FieldType>ConglomerateController</FieldType>
        </Field>
        <Field>
            <FieldName>dd</FieldName>
            <FieldType>DataDictionary</FieldType>
        </Field>
        <Field>
            <FieldName>td</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>indexRows</FieldName>
            <FieldType>ExecIndexRow[]</FieldType>
        </Field>
        <Field>
            <FieldName>fullTemplateId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>schemaName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>tableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>sortIds</FieldName>
            <FieldType>long[]</FieldType>
        </Field>
        <Field>
            <FieldName>rowSources</FieldName>
            <FieldType>RowLocationRetRowSource[]</FieldType>
        </Field>
        <Field>
            <FieldName>bulkHeapSC</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
        <Field>
            <FieldName>ordering</FieldName>
            <FieldType>ColumnOrdering[][]</FieldType>
        </Field>
        <Field>
            <FieldName>collation</FieldName>
            <FieldType>int[][]</FieldType>
        </Field>
        <Field>
            <FieldName>sorters</FieldName>
            <FieldType>SortController[]</FieldType>
        </Field>
        <Field>
            <FieldName>rowHolder</FieldName>
            <FieldType>TemporaryRowHolderImpl</FieldType>
        </Field>
        <Field>
            <FieldName>rl</FieldName>
            <FieldType>RowLocation</FieldType>
        </Field>
        <Field>
            <FieldName>hasBeforeRowTrigger</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>tableScan</FieldName>
            <FieldType>BulkTableScanResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>numOpens</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>firstExecute</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>fkInfoArray</FieldName>
            <FieldType>FKInfo[]</FieldType>
        </Field>
        <Field>
            <FieldName>triggerInfo</FieldName>
            <FieldType>TriggerInfo</FieldType>
        </Field>
        <Field>
            <FieldName>fkChecker</FieldName>
            <FieldType>RISetChecker</FieldType>
        </Field>
        <Field>
            <FieldName>triggerActivator</FieldName>
            <FieldType>TriggerEventActivator</FieldType>
        </Field>
        <Field>
            <FieldName>bulkInsertCounters</FieldName>
            <FieldType>BulkInsertCounter[]</FieldType>
        </Field>
        <Field>
            <FieldName>deferredChecks</FieldName>
            <FieldType>BackingStoreHashtable</FieldType>
        </Field>
        <Field>
            <FieldName>violatingCheckConstraints</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>violatingCheckConstraints</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>changedRow</MethodName>
            <MethodComment>/** 
 * @see TargetResultSet#changedRow
 * @exception StandardException thrown if cursor finish ed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocessSourceRow</MethodName>
            <MethodComment>/** 
 * Preprocess the source row.  Apply any check constraints here. Do an inplace cloning of all key columns.  For triggers, if we have a before row trigger, we fire it here if we can. This is useful for bulk insert where the store stands between the source and us.
 * @param execRow	The source row.
 * @return The preprocessed source row.
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>execRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>offendingRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constainerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>evaluateCheckConstraints</MethodName>
            <MethodComment>/** 
 * Run the check constraints against the current row. Raise an error if a check constraint is violated, unless all the offending checks are deferred, in which case a false value will be returned. A NULL value will be interpreted as success (not violation).
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [result=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>InsertResultSet</MethodName>
            <MethodComment>/** 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generationClauses</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkGM</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [insertMode=constants.getProperty("insertMode")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initializeAIcache;[constants.getAutoincRowLocation()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>open</MethodName>
            <MethodComment>/** 
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setup;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;verifyAutoGeneratedRScolumnsList;[constants.targetUUID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanUp;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;saveAIcacheInformation;[constants.getSchemaName(), constants.getTableName(), constants.getColumnNames()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Clean up resources and call close on data members.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[constants.underMerge()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generatedColumnPositionsArray</MethodName>
            <MethodComment>/** 
 * If user didn't provide columns list for auto-generated columns, then only include columns with auto-generated values in the resultset. Those columns would be ones with default value defined.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TableDescriptor [tabDesb=dd.getTableDescriptor(constants.targetUUID)]</InnerVar>
                <InnerVar>ColumnDescriptor [cd]</InnerVar>
                <InnerVar>int [size=tabDesb.getMaxColumnID()]</InnerVar>
                <InnerVar>int[] [generatedColumnPositionsArray=new int[size]]</InnerVar>
                <InnerVar>int [generatedColumnNumbers=0]</InnerVar>
                <InnerVar>int[] [returnGeneratedColumnPositionsArray=new int[generatedColumnNumbers]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Arrays;fill;[generatedColumnPositionsArray, -1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetAutoincrementValue</MethodName>
            <MethodComment>/** 
 * getSetAutoincrementValue will get the autoincrement value of the  columnPosition specified for the target table. If increment is  non-zero we will also update the autoincrement value. 
 * @param columnPosition	position of the column in the table (1-based)
 * @param increment			amount of increment. 
 * @exception StandardException if anything goes wrong.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>increment</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [index=columnPosition - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOldStyleBulkInsertValue</MethodName>
            <MethodComment>/** 
 * Identity generation logic for bulk-insert used in pre-10.11 databases.
 * @param index   0-based index into aiCache
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>increment</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>NumberDataValue [dvd]</InnerVar>
                <InnerVar>int [columnPosition=index + 1]</InnerVar>
                <InnerVar>ColumnDescriptor [cd=td.getColumnDescriptor(columnPosition)]</InnerVar>
                <InnerVar>long [ret]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>aiCache[columnPosition - 1];setValue;[ret]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOldStyleIdentityValue</MethodName>
            <MethodComment>/** 
 * Identity generation logic used in pre-10.11 databases.
 * @param index   0-based index into aiCache
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>NumberDataValue [newValue]</InnerVar>
                <InnerVar>TransactionController [nestedTC=null]</InnerVar>
                <InnerVar>TransactionController [tcToUse]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSourceRowResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [isRow=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSingleRowResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [isRow=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalInsertCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstExecute</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [setUserIdentity=constants.hasAutoincrement() &amp;&amp; isSingleRowResultSet()]</InnerVar>
                <InnerVar>ExecRow [deferredRowBuffer]</InnerVar>
                <InnerVar>long [user_autoinc=0]</InnerVar>
                <InnerVar>int [lockMode=decodeLockMode(constants.lockMode)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rowChanger;open;[lockMode]</InnerMethodInvoke>
                <InnerMethodInvoke>null;firstExecuteSpecialHandlingAutoGen;[firstExecute, rowChanger, constants.targetUUID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [nextRow=super.getNextRowCore(source)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processMergeRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Special handling if this is an INSERT action of a MERGE statement. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sourceRS</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bulkInsertCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldHeapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [newHeapConglom]</InnerVar>
                <InnerVar>Properties [properties=new Properties()]</InnerVar>
                <InnerVar>Properties [targetProperties=constants.getTargetProperties()]</InnerVar>
                <InnerVar>Enumeration [key=targetProperties.keys()]</InnerVar>
                <InnerVar>long[] [loadedRowCount=new long[1]]</InnerVar>
                <InnerVar>DependencyManager [dm=dd.getDependencyManager()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cd=td.getConglomerateDescriptor(oldHeapConglom)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>bulkHeapCC;getInternalTablePropertySet;[properties]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setEstimatedRowCount;[newHeapConglom]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;invalidateFor;[td, DependencyManager.BULK_INSERT, lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>bulkHeapCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateConglomerateDescriptor;[cd, newHeapConglom, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[oldHeapConglom]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bulkValidateForeignKeys</MethodName>
            <MethodComment>/** 
 * Bulk Referential Integrity Checker
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bulkValidateForeignKeysCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkInfo</ParamName>
                    <ParamType>FKInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkConstraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [template]</InnerVar>
                <InnerVar>GroupFetchScanController [refScan=null]</InnerVar>
                <InnerVar>GroupFetchScanController [fkScan=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeIndexTemplate</MethodName>
            <MethodComment>/** 
 * Make a template row with the correct columns.
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fkInfo</ParamName>
                    <ParamType>FKInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [newRow=RowUtil.getEmptyIndexRow(fkInfo.colArray.length + 1,lcc)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [templateColArray=fullTemplate.getRowArray()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [newRowColArray=newRow.getRowArray()]</InnerVar>
                <InnerVar>int [i]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUpAllSorts</MethodName>
            <MethodComment>/** 
 * Set up to update all of the indexes on a table when doing a bulk insert on an empty table.
 * @exception StandardException					thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sourceRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes=constants.irgs.length]</InnerVar>
                <InnerVar>int [numColumns=td.getNumberOfColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateAllIndexes</MethodName>
            <MethodComment>/** 
 * Update all of the indexes on a table when doing a bulk insert on an empty table.
 * @exception StandardException					thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newHeapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constants</ParamName>
                    <ParamType>InsertConstantAction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes=constants.irgs.length]</InnerVar>
                <InnerVar>long[] [newIndexCongloms=new long[numIndexes]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropStatisticsDescriptors;[td.getUUID(), null, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUp</MethodName>
            <MethodComment>/** 
 * @see ResultSet#cleanUp
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[constants.underMerge()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyBulkInsert</MethodName>
            <MethodComment>/** 
 * Verify that bulkInsert is allowed on this table. The execution time check to see if bulkInsert is allowed simply consists of checking to see if this is not a deferred mode insert and that the table is empty if this is not replace. A side effect of calling this method is to get an exclusive table lock on the table.
 * @return Whether or not bulkInsert is allowed on this table.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExclusiveTableLock</MethodName>
            <MethodComment>/** 
 * Get an exclusive table lock on the target table (and check to see if the table is populated if this is not a bulk insert replace).
 * @return Whether or not bulkInsert is allowed on this table.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [rowFound=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>bulkHeapSC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * Set the estimated row count for this table.
 * @param heapConglom	Conglomerate number for the heap
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>heapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>bulkHeapSC;setEstimatedRowCount;[rowCount]</InnerMethodInvoke>
                <InnerMethodInvoke>bulkHeapSC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>emptyIndexes</MethodName>
            <MethodComment>/** 
 * Empty the indexes after doing a bulk insert replace where the table has 0 rows after the replace. RESOLVE: This method is ugly!  Prior to 2.0, we simply scanned back across the table to build the indexes.  We changed this in 2.0 to populate the sorters via a call back as we populated the table.  Doing a 0 row replace into a table with indexes is a degenerate case, hence we allow ugly and unoptimized code.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newHeapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constants</ParamName>
                    <ParamType>InsertConstantAction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes=constants.irgs.length]</InnerVar>
                <InnerVar>ExecIndexRow[] [idxRows=new ExecIndexRow[numIndexes]]</InnerVar>
                <InnerVar>ExecRow [baseRows]</InnerVar>
                <InnerVar>ColumnOrdering[][] [order=new ColumnOrdering[numIndexes][]]</InnerVar>
                <InnerVar>int [numColumns=td.getNumberOfColumns()]</InnerVar>
                <InnerVar>FormatableBitSet [bitSet=new FormatableBitSet(numColumns + 1)]</InnerVar>
                <InnerVar>int [numReferencedColumns=0]</InnerVar>
                <InnerVar>int [colNumber=0]</InnerVar>
                <InnerVar>SortController[] [sorter=new SortController[numIndexes]]</InnerVar>
                <InnerVar>long[] [newIndexCongloms=new long[numIndexes]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableScanResultSet</MethodName>
            <MethodComment>/** 
 * Get me a table scan result set, preferably a bulk table scan, thank you.  If we already have one, reopen it.
 */
</MethodComment>
            <ReturnType>BulkTableScanResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnNames</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseColumnPositions</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [length=baseColumnPositions.length]</InnerVar>
                <InnerVar>String[] [columnNames=new String[length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sourceResultSet;finish;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rememberConstraint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeAIcache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rla</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>