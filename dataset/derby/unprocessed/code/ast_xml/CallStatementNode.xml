<Class>
    <Id>658</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>CallStatementNode</ClassName>
    <SuperClass>DMLStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>CallStatementNode  /** 
 * An CallStatementNode represents a CALL &lt;procedure&gt; statement. It is the top node of the query tree for that statement. A procedure call is very simple. CALL [&lt;schema&gt;.]&lt;procedure&gt;(&lt;args&gt;) &lt;args&gt; are either constants or parameter markers. This implementation assumes that no subqueries or aggregates can be in the argument list. A procedure is always represented by a MethodCallNode.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>methodCall</FieldName>
            <FieldType>JavaToSQLValueNode</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>CallStatementNode</MethodName>
            <MethodComment>/** 
 * Constructor for a CallStatementNode.
 * @param methodCall		The expression to "call"
 * @param cm                The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodCall</ParamName>
                    <ParamType>JavaToSQLValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.methodCall.getJavaValueNode();markForCallStatement;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment>/** 
 * Bind this UpdateNode.  This means looking up tables and columns and getting their types, and figuring out the result types of all expressions, as well as doing view resolution, permissions checking, etc. &lt;p&gt; Binding an update will also massage the tree so that the ResultSetNode has a single column, the RID.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>SubqueryList [subqueries=new SubqueryList(getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();pushCurrentPrivType;[getPrivType()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkReliability;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();popCurrentPrivType;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeStatement</MethodName>
            <MethodComment>/** 
 * Optimize a DML statement (which is the only type of statement that should need optimizing, I think). This method over-rides the one in QueryTreeNode. This method takes a bound tree, and returns an optimized tree. It annotates the bound tree rather than creating an entirely new tree. Throws an exception if the tree is not bound, or if the binding is out of date.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Code generation for CallStatementNode. The generated code will contain: o  A generated void method for the user's method call.
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb	The method for the execute() method to be built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JavaValueNode [methodCallBody]</InnerVar>
                <InnerVar>MethodBuilder [userExprFun=acb.newGeneratedFun("void",Modifier.PUBLIC)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateParameterValueSet;[acb]</InnerMethodInvoke>
                <InnerMethodInvoke>methodCallBody;markReturnValueDiscarded;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;addThrownException;["java.lang.Exception"]</InnerMethodInvoke>
                <InnerMethodInvoke>methodCallBody;generate;[acb, userExprFun]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;endStatement;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushMethodReference;[mb, userExprFun]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushThisAsActivation;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, "getCallStatementResultSet", ClassName.ResultSet, 2]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeResultDescription</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrivType</MethodName>
            <MethodComment>/** 
 * Set default privilege of EXECUTE for this node. 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkReliability</MethodName>
            <MethodComment>/** 
 * This method checks if the called procedure allows modification of SQL  data. If yes, it cannot be compiled if the reliability is  &lt;code&gt;CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL&lt;/code&gt;. This  reliability is set for BEFORE triggers in the create trigger node. This  check thus disallows creation of BEFORE triggers which contain calls to  procedures that modify SQL data in the trigger action statement.  
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLAllowedInProcedure</MethodName>
            <MethodComment>/** 
 * This method checks the SQL allowed by the called procedure. This method  should be called only after the procedure has been resolved.
 * @return	SQL allowed by the procedure
 */
</MethodComment>
            <ReturnType>short</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>RoutineAliasInfo [routineInfo=((MethodCallNode)methodCall.getJavaValueNode()).routineInfo]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>