<Class>
    <Id>97</Id>
    <Package>org.apache.derby.impl.services.bytecode</Package>
    <ClassName>CodeChunk</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>CodeChunk  /** 
 * This class represents a chunk of code in a CodeAttribute. Typically, a CodeAttribute represents the code in a method. If there is a try/catch block, each catch block will get its own code chunk.  This allows the catch blocks to all be put at the end of the generated code for a method, which eliminates the need to generate a jump around each catch block, which would be a forward reference.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>CODE_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOAD_VARIABLE</FieldName>
            <FieldType>short[]</FieldType>
        </Field>
        <Field>
            <FieldName>LOAD_VARIABLE_FAST</FieldName>
            <FieldType>short[]</FieldType>
        </Field>
        <Field>
            <FieldName>STORE_VARIABLE</FieldName>
            <FieldType>short[]</FieldType>
        </Field>
        <Field>
            <FieldName>STORE_VARIABLE_FAST</FieldName>
            <FieldType>short[]</FieldType>
        </Field>
        <Field>
            <FieldName>ARRAY_ACCESS</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>ARRAY_STORE</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>RETURN_OPCODE</FieldName>
            <FieldType>short[]</FieldType>
        </Field>
        <Field>
            <FieldName>CAST_CONVERSION_INFO</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>push1_1i</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>push2_1i</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>NS</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>VARIABLE_STACK</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>OPCODE_ACTION</FieldName>
            <FieldType>byte[][]</FieldType>
        </Field>
        <Field>
            <FieldName>pcDelta</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>cb</FieldName>
            <FieldType>BCClass</FieldType>
        </Field>
        <Field>
            <FieldName>cout</FieldName>
            <FieldType>ClassFormatOutput</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>limitHit</MethodName>
            <MethodComment>/** 
 * Assume an IOException means some limit of the class file format was hit
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ioe</ParamName>
                    <ParamType>IOException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cb;addLimitExceeded;[ioe.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstr</MethodName>
            <MethodComment>/** 
 * Add an instruction that has no operand. All opcodes are 1 byte large.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrU2</MethodName>
            <MethodComment>/** 
 * Add an instruction that has a 16 bit operand.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrU4</MethodName>
            <MethodComment>/** 
 * Add an instruction that has a 32 bit operand.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrU1</MethodName>
            <MethodComment>/** 
 * Add an instruction that has an 8 bit operand.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrCPE</MethodName>
            <MethodComment>/** 
 * This takes an instruction that has a narrow and a wide form for CPE access, and generates accordingly the right one. We assume the narrow instruction is what we were given, and that the wide form is the next possible instruction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cpeNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrWide</MethodName>
            <MethodComment>/** 
 * This takes an instruction that can be wrapped in a wide for large variable #s and does so.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>varNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addInstrU2U1U1</MethodName>
            <MethodComment>/** 
 * For adding an instruction with 3 operands, a U2 and two U1's. So far, this is used by VMOpcode.INVOKEINTERFACE.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand1</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand2</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operand3</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPC</MethodName>
            <MethodComment>/** 
 * Get the current program counter 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>instructionLength</MethodName>
            <MethodComment>/** 
 * Return the complete instruction length for the passed in opcode. This will include the space for the opcode and its operand.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [instructionLength=OPCODE_ACTION[opcode][1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CodeChunk</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cb</ParamName>
                    <ParamType>BCClass</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>CodeChunk</MethodName>
            <MethodComment>/** 
 * Return a CodeChunk that has limited visibility into this CodeChunk. Used when a caller needs to insert instructions into an existing stream.
 * @param pc
 * @param byteCount
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>main</ParamName>
                    <ParamType>CodeChunk</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>byteCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayOutputStream [aos=new ArrayOutputStream(main.cout.getData())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fixLengths</MethodName>
            <MethodComment>/** 
 * now that we have codeBytes, fix the lengths fields in it to reflect what was stored. Limits checked here are from these sections of the JVM spec. &lt;UL&gt; &lt;LI&gt; 4.7.3 The Code Attribute &lt;LI&gt; 4.10 Limitations of the Java Virtual Machine  &lt;/UL&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxStack</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxLocals</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [codeBytes=cout.getData()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>complete</MethodName>
            <MethodComment>/** 
 * wrap up the entry and stuff it in the class, now that it holds all of the instructions and the exception table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>ClassMember</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxStack</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxLocals</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codeLength=getPC()]</InnerVar>
                <InnerVar>ClassFormatOutput [out=cout]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;fixLengths;[mb, maxStack, maxLocals, codeLength]</InnerMethodInvoke>
                <InnerMethodInvoke>method;addAttribute;["Code", out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOpcode</MethodName>
            <MethodComment>/** 
 * Return the opcode at the given pc.
 */
</MethodComment>
            <ReturnType>short</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getU2</MethodName>
            <MethodComment>/** 
 * Get the unsigned short value for the opcode at the program counter pc.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [codeBytes=cout.getData()]</InnerVar>
                <InnerVar>int [u2p=CODE_OFFSET + pc + 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getU4</MethodName>
            <MethodComment>/** 
 * Get the unsigned 32 bit value for the opcode at the program counter pc.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [codeBytes=cout.getData()]</InnerVar>
                <InnerVar>int [u4p=CODE_OFFSET + pc + 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertCodeSpace</MethodName>
            <MethodComment>/** 
 * Insert room for byteCount bytes after the instruction at pc and prepare to replace the instruction at pc. The instruction at pc is not modified by this call, space is allocated after it. The newly inserted space will be filled with NOP instructions. Returns a CodeChunk positioned at pc and available to write instructions upto (byteCode + length(existing instruction at pc) bytes. This chunk is left correctly positioned at the end of the code stream, ready to accept more code. Its pc will have increased by additionalBytes. It is the responsibility of the caller to patch up any branches or gotos.
 * @param pc
 * @param additionalBytes
 */
</MethodComment>
            <ReturnType>CodeChunk</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>additionalBytes</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>short [existingOpcode=getOpcode(pc)]</InnerVar>
                <InnerVar>int [lengthOfExistingInstruction=instructionLength(existingOpcode)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMaxStack</MethodName>
            <MethodComment>/** 
 * For a block of byte code starting at program counter pc for codeLength bytes return the maximum stack value, assuming a initial stack depth of zero.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [endPc=pc + codeLength]</InnerVar>
                <InnerVar>int [stack=0]</InnerVar>
                <InnerVar>int [maxStack=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stackWordDelta</MethodName>
            <MethodComment>/** 
 * Return the number of stack words pushed (positive) or popped (negative) by this instruction.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [stackDelta=OPCODE_ACTION[opcode][0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get the type descriptor in the virtual machine format for the type defined by the constant pool index for the instruction at pc.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [cpi=getU2(pc)]</InnerVar>
                <InnerVar>CONSTANT_Index_info [cii=(CONSTANT_Index_info)ch.getEntry(cpi)]</InnerVar>
                <InnerVar>int [nameAndType=cii.getI2()]</InnerVar>
                <InnerVar>int [descriptor=cii.getI2()]</InnerVar>
                <InnerVar>CONSTANT_Utf8_info [type=(CONSTANT_Utf8_info)ch.getEntry(descriptor)]</InnerVar>
                <InnerVar>String [vmDescriptor=type.toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorWordCount</MethodName>
            <MethodComment>/** 
 * Get the word count for a type descriptor in the format of the virual machine. For a method this returns the the word count for the return type.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vmDescriptor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [width]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVariableStackDelta</MethodName>
            <MethodComment>/** 
 * Get the number of words pushed (positive) or popped (negative) by this instruction. The instruction is a get/put field or a method call, thus the size of the words is defined by the field or method being access.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [vmDescriptor=getTypeDescriptor(ch,pc)]</InnerVar>
                <InnerVar>int [width=CodeChunk.getDescriptorWordCount(vmDescriptor)]</InnerVar>
                <InnerVar>int [stackDelta=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parameterWordCount</MethodName>
            <MethodComment>/** 
 * Calculate the number of stack words in the arguments pushed for this method descriptor.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodDescriptor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [wordCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findConditionalPCs</MethodName>
            <MethodComment>/** 
 * Find the limits of a conditional block starting at the instruction with the given opcode at the program counter pc. &lt;P&gt; Returns a six element integer array of program counters and lengths. &lt;code&gt; [0] - program counter of the IF opcode (passed in as pc) [1] - program counter of the start of the then block [2] - length of the then block [3] - program counter of the else block, -1 if no else block exists. [4] - length of of the else block, -1 if no else block exists. [5] - program counter of the common end point. &lt;/code&gt; Looks for and handles conditionals that are written by the Conditional class.
 * @return Null if the opcode is not the start of a conditional otherwisethe array of values.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [then_pc]</InnerVar>
                <InnerVar>int [else_pc]</InnerVar>
                <InnerVar>int [if_off=getU2(pc)]</InnerVar>
                <InnerVar>int [end_pc=-1]</InnerVar>
                <InnerVar>int [else_len]</InnerVar>
                <InnerVar>int [then_len]</InnerVar>
                <InnerVar>int[] [ret=new int[6]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitZeroStack</MethodName>
            <MethodComment>/** 
 * Attempt to split the current method by pushing a chunk of its code into a sub-method. The starting point of the split (split_pc) must correspond to a stack depth of zero. It is the reponsibility of the caller to ensure this. Split is only made if there exists a chunk of code starting at pc=split_pc, whose stack depth upon termination is zero. The method will try to split a code section greater than optimalMinLength but may split earlier if no such block exists. &lt;P&gt; The method is aimed at splitting methods that contain many independent statements. &lt;P&gt; If a split is possible this method will perform the split and create a void sub method, and move the code into the sub-method and setup this method to call the sub-method before continuing. This method's max stack and current pc will be correctly set as though the method had just been created.
 * @param mb Method for this chunk.
 * @param ch Class definition
 * @param optimalMinLength minimum length required for split
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>split_pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimalMinLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [splitMinLength=splitMinLength(mb)]</InnerVar>
                <InnerVar>int [stack=0]</InnerVar>
                <InnerVar>int [possibleSplitLength=-1]</InnerVar>
                <InnerVar>int [outerConditionalEnd_pc=-1]</InnerVar>
                <InnerVar>int [end_pc=getPC()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startSubMethod</MethodName>
            <MethodComment>/** 
 * Start a sub method that we will split the portion of our current code to, starting from start_pc and including codeLength bytes of code. Return a BCMethod obtained from BCMethod.getNewSubMethod with the passed in return type and same parameters as mb if the code block to be moved uses parameters.
 */
</MethodComment>
            <ReturnType>BCMethod</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>split_pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>blockLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [needParameters=usesParameters(mb,split_pc,blockLength)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesParameters</MethodName>
            <MethodComment>/** 
 * Does a section of code use parameters. Any load, exception ALOAD_0 in an instance method, is seen as using parameters, as this complete byte code implementation does not use local variables.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isStatic=(mb.myEntry.getModifier() &amp; Modifier.STATIC) != 0]</InnerVar>
                <InnerVar>int [endPc=pc + codeLength]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitCodeIntoSubMethod</MethodName>
            <MethodComment>/** 
 * Split a block of code from this method into a sub-method and call it. Returns the pc of this method just after the call to the sub-method.
 * @param mb My method
 * @param ch My class
 * @param subMethod Sub-method code was pushed into
 * @param split_pc Program counter the split started at
 * @param splitLength Length of code split
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subMethod</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>split_pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CodeChunk [subChunk=subMethod.myCode]</InnerVar>
                <InnerVar>byte[] [codeBytes=cout.getData()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>subMethod;complete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removePushedCode</MethodName>
            <MethodComment>/** 
 * Remove a block of code from this method that was pushed into a sub-method and call the sub-method. Returns the pc of this method just after the call to the sub-method.
 * @param mb My method
 * @param ch My class
 * @param subMethod Sub-method code was pushed into
 * @param split_pc Program counter the split started at
 * @param splitLength Length of code split
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subMethod</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>split_pc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>splitLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codeLength=getPC()]</InnerVar>
                <InnerVar>CodeChunk [replaceChunk=new CodeChunk(mb.cb)]</InnerVar>
                <InnerVar>byte[] [codeBytes=cout.getData()]</InnerVar>
                <InnerVar>int [postSplit_pc=replaceChunk.getPC()]</InnerVar>
                <InnerVar>int [remainingCodePC=split_pc + splitLength]</InnerVar>
                <InnerVar>int [remainingCodeLength=codeLength - splitLength - split_pc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;callSubMethod;[subMethod]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitExpressionOut</MethodName>
            <MethodComment>/** 
 * Split an expression out of a large method into its own sub-method. &lt;P&gt; Method call expressions are of the form: &lt;UL&gt; &lt;LI&gt; expr.method(args) -- instance method call &lt;LI&gt; method(args) -- static method call &lt;/UL&gt; Two special cases of instance method calls will be handled by the first incarnation of splitExpressionOut.  three categories: &lt;UL&gt; &lt;LI&gt;this.method(args) &lt;LI&gt;this.getter().method(args) &lt;/UL&gt; These calls are choosen as they are easier sub-cases and map to the code generated for SQL statements. Future coders can expand the method to cover more cases. &lt;P&gt; This method will split out such expressions in sub-methods and replace the original code with a call to that submethod. &lt;UL&gt; &lt;LI&gt;this.method(args) -&amp;gt;&amp;gt; this.sub1([parameters]) &lt;LI&gt;this.getter().method(args) -&amp;gt;&amp;gt; this.sub1([parameters]) &lt;/UL&gt; The assumption is of course that the call to the sub-method is much smaller than the code it replaces. &lt;P&gt; Looking at the byte code for such calls they would look like (for an example three argument method): &lt;code&gt; this arg1 arg2 arg3 INVOKE // this.method(args) this INVOKE arg1 arg2 arg3 INVOKE // this.getter().metod(args) &lt;/code&gt; The bytecode for the arguments can be arbitary long and consist of expressions, typical Derby code for generated queries is deeply nested method calls. &lt;BR&gt; If none of the arguments requred the parameters passed into the method, then in both cases the replacement bytecode would look like: &lt;code&gt; this.sub1(); &lt;/code&gt; Parameter handling is just as in the method splitZeroStack(). &lt;P&gt; Because the VM is a stack machine the original byte code sequences are self contained. The stack at the start of is sequence is N and at the end (after the method call) will be: &lt;UL&gt; &lt;LI&gt; N - void method &lt;LI&gt; N + 1 - method returning a single word &lt;LI&gt; N + 2 - method returning a double word (java long or double) &lt;/UL&gt; This code will handle the N+1 where the word is a reference, the typical case for generated code. &lt;BR&gt; The code is self contained because in general the byte code for the arguments will push and pop values but never drop below the stack value at the start of the byte code sequence. E.g. in the examples the stack before the first arg will be N+1 (the objectref for the method call) and at the end of the byte code for arg1 will be N+2 or N+3 depending on if arg1 is a single or double word argument. During the execution of the byte code the stack may have had many arguments pushed and popped, but will never have dropped below N+1. Thus the code for arg1 is independent of the stack's previous values and is self contained. This self-containment then extends to all the arguements, the method call itself and pushing the objectref for the method call, thus the complete sequence is self-contained. &lt;BR&gt; The self-containment breaks in a few cases, take the simple method call this.method(3), the byte code for this could be: &lt;code&gt; push3 this swap invoke &lt;/code&gt; In this case the byte code for arg1 (swap) is not self-contained and relies on earlier stack values. &lt;P&gt; How to identify "self-contained blocks of code". &lt;BR&gt; We walk through the byte code and maintain a history of the program counter that indicates the start of the independent sequence each stack word depends on. Thus for a ALOAD_0 instruction which pushes 'this' the dependent pc is that of the this. If a DUP instruction followed then the top-word is now dependent on the previous word (this) and thus the dependence of it is equal to the dependence of the previous word. This information is kept in earliestIndepPC array as we process the instruction stream. &lt;BR&gt; When a INVOKE instruction is seen for an instance method that returns a single or double word, the dependence of the returned value is the dependence of the word in the stack that is the objectref for the call. This complete sequence from the pc the objectref depended on to the INVOKE instruction is then a self contained sequence and can be split into a sub-method. &lt;BR&gt; If the block is self-contained then it can be split, following similar logic to splitZeroStack(). &lt;P&gt; WORK IN PROGRESS - Incremental development &lt;BR&gt; Currently walks the method maintaining the earliestIndepPC array and identifies potential blocks to splt, performs splits as required. Called by BCMethod but commented out in submitted code. Tested with local changes from calls in BCMethod. Splits generally work, though largeCodeGen shows a problem that will be fixed before the code in enabled for real.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>ClassHolder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimalMinLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxStack</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bestSplitPC=-1]</InnerVar>
                <InnerVar>int [bestSplitBlockLength=-1]</InnerVar>
                <InnerVar>String [bestSplitRT=null]</InnerVar>
                <InnerVar>int [splitMinLength=splitMinLength(mb)]</InnerVar>
                <InnerVar>int[] [earliestIndepPC=new int[maxStack + 1]]</InnerVar>
                <InnerVar>int [stack=0]</InnerVar>
                <InnerVar>int [outerConditionalEnd_pc=-1]</InnerVar>
                <InnerVar>int [end_pc=getPC()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReturn</MethodName>
            <MethodComment>/** 
 * See if the opcode is a return instruction.
 * @param opcode opcode to be checked
 * @return true for is a return instruction, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opcode</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitMinLength</MethodName>
            <MethodComment>/** 
 * Minimum split length for a sub-method. If the number of instructions to call the sub-method exceeds the length of the sub-method, then there's no point splitting. The number of bytes in the code stream to call a generated sub-method can take is based upon the number of method args. A method can have maximum of 255 words of arguments (section 4.10 JVM spec) which in the worst case would be 254 (one-word) parameters and this. For a sub-method the arguments will come from the parameters to the method, i.e. ALOAD, ILOAD etc. &lt;BR&gt; This leads to this number of instructions. &lt;UL&gt; &lt;LI&gt; 4 - 'this' and first 3 parameters have single byte instructions &lt;LI&gt; (N-4)*2 - Remaining parameters have two byte instructions &lt;LI&gt; 3 for the invoke instruction. &lt;/UL&gt;
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>BCMethod</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [min=1 + 3]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>