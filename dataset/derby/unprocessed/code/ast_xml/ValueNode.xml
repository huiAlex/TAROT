<Class>
    <Id>1633</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ValueNode</ClassName>
    <SuperClass>QueryTreeNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ValueNode  /** 
 * A ValueNode is an abstract class for all nodes that can represent data values, that is, constants, columns, and expressions.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>dataTypeServices</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>transformed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ValueNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setType</MethodName>
            <MethodComment>/** 
 * Set this node's type from type components.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[new DataTypeDescriptor(typeId,isNullable,maximumWidth)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setType</MethodName>
            <MethodComment>/** 
 * Set this node's type from type components.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[new DataTypeDescriptor(typeId,precision,scale,isNullable,maximumWidth)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeServices</MethodName>
            <MethodComment>/** 
 * Get the DataTypeServices from this ValueNode.
 * @return	The DataTypeServices from this ValueNode.  Thismay be null if the node isn't bound yet.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNullability</MethodName>
            <MethodComment>/** 
 * Set the nullability of this value.
 * @throws StandardException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nullability</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[getTypeServices().getNullabilityType(nullability)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCollationInfo</MethodName>
            <MethodComment>/** 
 * Set the collation type and derivation of this node based upon the collation information in the passed in type. Note that the base type of this node is not changed (e.g. INTEGER), only its collation settings. This may result in a different object being returned from getTypeServices().
 * @param collationInfoType Type to take collation type and derivation from.
 * @throws StandardException Error setting type.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationInfoType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCollationInfo;[collationInfoType.getCollationType(), collationInfoType.getCollationDerivation()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCollationInfo</MethodName>
            <MethodComment>/** 
 * Set the collation type and derivation of this node based upon the collation information passed in. This may result in a different object being returned from getTypeServices().
 * @param collationType Collation type
 * @param collationDerivation Collation derivation
 * @throws StandardException Error setting type
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationDerivation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[getTypeServices().getCollatedType(collationType,collationDerivation)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeId</MethodName>
            <MethodComment>/** 
 * Get the TypeId from this ValueNode.
 * @return	The TypeId from this ValueNode.  Thismay be null if the node isn't bound yet.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd=getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Return the DataValueFactory
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCompiler</MethodName>
            <MethodComment>/** 
 * Get the TypeCompiler from this ValueNode, based on its TypeId using getTypeId().
 * @return	This ValueNode's TypeCompiler
 */
</MethodComment>
            <ReturnType>TypeCompiler</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setType</MethodName>
            <MethodComment>/** 
 * Set the DataTypeServices for this ValueNode.  This method is overridden in ParameterNode.
 * @param dataTypeServices	The DataTypeServices to set in thisValueNode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataTypeServices</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCollationUsingCompilationSchema</MethodName>
            <MethodComment>/** 
 * Set the collation based upon the current schema with derivation type implicit.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCollationUsingCompilationSchema;[StringDataValue.COLLATION_DERIVATION_IMPLICIT]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCollationUsingCompilationSchema</MethodName>
            <MethodComment>/** 
 * There are many subclasses of ValueNode where we want the  DataTypeDescriptor of the node to have the same collation type as the  compilation schema's collation type. For that purpose, this method in  the baseclass here can be utilized by the subclasses. In addition, the subclasses can pass the collationDerivation that they expect the DataTypeDescriptor to have.
 * @param collationDerivation This can be StringDataValue#COLLATION_DERIVATION_IMPLICIT StringDataValue#COLLATION_DERIVATION_NONE StringDataValue#COLLATION_DERIVATION_EXPLICIT
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationDerivation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCollationInfo;[getSchemaDescriptor(null,false).getCollationType(), collationDerivation]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceResultColumn</MethodName>
            <MethodComment>/** 
 * Get the source for this ValueNode.
 * @return	The source of this ValueNode, null if this nodeis not sourced by a column.
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTransformed</MethodName>
            <MethodComment>/** 
 * Mark this predicate has having been transformed (other predicates were generated from it).  This will help us with ensure that the predicate does not get calculated into the selectivity multiple times.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransformed</MethodName>
            <MethodComment>/** 
 * Return whether or not this predicate has been transformed.
 * @return Whether or not this predicate has been transformed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This is a place-holder method - it should never be called.
 * @param fromList			The FROM list to use for binding
 * @param subqueryList		The SubqueryList we are building as we hitSubqueryNodes.
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException	Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forQueryRewrite</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genSQLJavaSQLTree</MethodName>
            <MethodComment>/** 
 * Generate a SQL-&amp;gt;Java-&amp;gt;SQL conversion tree above the current node and bind the new nodes individually. This is useful when doing comparisons, built-in functions, etc. on java types which have a direct mapping to system built-in types.
 * @return ValueNode	The new tree.
 * @exception StandardException	Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ContextManager [cm=getContextManager()]</InnerVar>
                <InnerVar>JavaValueNode [stjvn=new SQLToJavaValueNode(this,cm)]</InnerVar>
                <InnerVar>ValueNode [jtsvn=new JavaToSQLValueNode(stjvn,cm)]</InnerVar>
                <InnerVar>DataTypeDescriptor [resultType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>jtsvn;setType;[resultType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess an expression tree.  We do a number of transformations here (including subqueries, IN lists, LIKE and BETWEEN) plus subquery flattening. NOTE: This is done before the outer ResultSetNode is preprocessed.
 * @param numTables			Number of tables in the DML Statement
 * @param outerFromList		FromList from outer query block
 * @param outerSubqueryList	SubqueryList from outer query block
 * @param outerPredicateList	PredicateList from outer query block
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerSubqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerPredicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>evaluateConstantExpressions</MethodName>
            <MethodComment>/** 
 * If this node is known to always evaluate to the same value, return a node that represents that known value as a constant. Typically used to transform operators with constant operands into constants.
 * @return a constant representing the value to which this node isguaranteed to evaluate, or  {@code this} if the value is not known
 * @throws StandardException if an error occurs during evaluation
 * @see ConstantExpressionVisitor
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>eliminateNots</MethodName>
            <MethodComment>/** 
 * Eliminate NotNodes in the current query block.  We traverse the tree,  inverting ANDs and ORs and eliminating NOTs as we go.  We stop at  ComparisonOperators and boolean expressions.  We invert  ComparisonOperators and replace boolean expressions with  boolean expression = false. NOTE: Since we do not recurse under ComparisonOperators, there still could be NotNodes left in the tree.
 * @param underNotNode		Whether or not we are under a NotNode.
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>underNotNode</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genEqualsFalseTree</MethodName>
            <MethodComment>/** 
 * Transform this into this = false.  Useful for NOT elimination.
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryRelationalOperatorNode [equalsNode]</InnerVar>
                <InnerVar>BooleanConstantNode [falseNode]</InnerVar>
                <InnerVar>boolean [nullableResult]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>equalsNode;setType;[new DataTypeDescriptor(TypeId.BOOLEAN_ID,nullableResult)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genIsNullTree</MethodName>
            <MethodComment>/** 
 * Transform this into this IS NULL or IS NOT NULL.
 * @param notNull if true, transform this into IS NOT NULL;otherwise, transform this into IS NULL
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>notNull</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>IsNullNode [isNullNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>isNullNode;setType;[new DataTypeDescriptor(TypeId.BOOLEAN_ID,false)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyEliminateNots</MethodName>
            <MethodComment>/** 
 * Verify that eliminateNots() did its job correctly.  Verify that there are no NotNodes above the top level comparison operators and boolean expressions.
 * @return		Boolean which reflects validity of the tree.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putAndsOnTop</MethodName>
            <MethodComment>/** 
 * Do the 1st step in putting an expression into conjunctive normal form.  This step ensures that the top level of the expression is a chain of AndNodes.
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BooleanConstantNode [trueNode=new BooleanConstantNode(true,getContextManager())]</InnerVar>
                <InnerVar>AndNode [andNode=new AndNode(this,trueNode,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>andNode;postBindFixup;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyPutAndsOnTop</MethodName>
            <MethodComment>/** 
 * Verify that putAndsOnTop() did its job correctly.  Verify that the top level  of the expression is a chain of AndNodes.
 * @return		Boolean which reflects validity of the tree.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>changeToCNF</MethodName>
            <MethodComment>/** 
 * Finish putting an expression into conjunctive normal form.  An expression tree in conjunctive normal form meets the following criteria: o  If the expression tree is not null, the top level will be a chain of AndNodes terminating in a true BooleanConstantNode. o  The left child of an AndNode will never be an AndNode. o  Any right-linked chain that includes an AndNode will be entirely composed of AndNodes terminated by a true BooleanConstantNode. o  The left child of an OrNode will never be an OrNode. o  Any right-linked chain that includes an OrNode will be entirely composed of OrNodes terminated by a false BooleanConstantNode. o  ValueNodes other than AndNodes and OrNodes are considered leaf nodes for purposes of expression normalization. In other words, we won't do any normalization under those nodes. In addition, we track whether or not we are under a top level AndNode.   SubqueryNodes need to know this for subquery flattening.
 * @param underTopAndNode		Whether or not we are under a top level AndNode.
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>underTopAndNode</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyChangeToCNF</MethodName>
            <MethodComment>/** 
 * Verify that changeToCNF() did its job correctly.  Verify that: o  AndNode  - rightOperand is not instanceof OrNode leftOperand is not instanceof AndNode o  OrNode	- rightOperand is not instanceof AndNode leftOperand is not instanceof OrNode
 * @return		Boolean which reflects validity of the tree.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate. If the source of this ColumnReference (at the next underlying level)  is not a ColumnReference or a VirtualColumnNode then this predicate will not be pushed down. For example, in: select * from (select 1 from s) a (x) where x = 1 we will not push down x = 1. NOTE: It would be easy to handle the case of a constant, but if the inner SELECT returns an arbitrary expression, then we would have to copy that tree into the pushed predicate, and that tree could contain subqueries and method calls. RESOLVE - revisit this issue once we have views.
 * @param referencedTabs	JBitSet with bit map of referenced FromTables
 * @param simplePredsOnly	Whether or not to consider methodcalls, field references and conditional nodes when building bit map
 * @return boolean		Whether or not source.expression is a ColumnReferenceor a VirtualColumnNode.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTabs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>simplePredsOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaName</MethodName>
            <MethodComment>/** 
 * This returns the user-supplied schema name of the column. At this class level, it simply returns null. But, the subclasses of ValueNode will overwrite this method to return the user-supplied schema name. When the value node is in a result column of a select list, the user can request metadata information. The result column won't have a column descriptor, so we return some default information through the expression. This lets expressions that are simply columns return all of the info, and others use this supertype's default values.
 * @return the default schema name for an expression -- null
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableName</MethodName>
            <MethodComment>/** 
 * This returns the user-supplied table name of the column. At this class level, it simply returns null. But, the subclasses of ValueNode will overwrite this method to return the user-supplied table name. When the value node is in a result column of a select list, the user can request metadata information. The result column won't have a column descriptor, so we return some default information through the expression. This lets expressions that are simply columns return all of the info, and others use this supertype's default values.
 * @return the default table name for an expression -- null
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatableByCursor</MethodName>
            <MethodComment>/** 
 * @return the default updatability for an expression - false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnName</MethodName>
            <MethodComment>/** 
 * This is null so that the caller will substitute in the resultset generated name as needed.
 * @return the default column name for an expression -- null.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablesReferenced</MethodName>
            <MethodComment>/** 
 * Get a bit map of table references in this expression
 * @return	A bit map of table numbers referred to in this expression
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>JBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ReferencedTablesVisitor [rtv=new ReferencedTablesVisitor(new JBitSet(0))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;accept;[rtv]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCloneable</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree is cloneable.
 * @return boolean	Whether or not this expression tree is cloneable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClone</MethodName>
            <MethodComment>/** 
 * Return a clone of this node.
 * @return ValueNode	A clone of this node.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyFields</MethodName>
            <MethodComment>/** 
 * Copy all of the "appropriate fields" for a shallow copy.
 * @param oldVN		The ValueNode to copy from.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oldVN</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferencesToExpressions</MethodName>
            <MethodComment>/** 
 * Remap all ColumnReferences in this tree to be clones of the underlying expression.
 * @return ValueNode			The remapped expression tree.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstantExpression</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree represents a constant expression.
 * @return	Whether or not this expression tree represents a constant expression.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantExpression</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree represents a constant value. In this case, "constant" means that it will always evaluate to the same thing, even if it includes columns.  A column is constant if it is compared to a constant expression.
 * @return	True means this expression tree represents a constant value.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>whereClause</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. The variant type can be: VARIANT				- variant within a scan (method calls and non-static field access) SCAN_INVARIANT		- invariant within a scan (column references from outer tables) QUERY_INVARIANT		- invariant within the life of a query (constant expressions)
 * @return	The variant type for the underlying expression.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIsBoolean</MethodName>
            <MethodComment>/** 
 * Bind time logic. Raises an error if this ValueNode does not resolve to a boolean value. This method is called by WHERE clauses.
 * @return	bound coercion of this node to a builtin type as necessary
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ValueNode [whereClause=this]</InnerVar>
                <InnerVar>TypeId [whereTypeId=whereClause.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstantValueAsObject</MethodName>
            <MethodComment>/** 
 * Return an Object representing the bind time value of this expression tree.  If the expression tree does not evaluate to a constant at bind time then we return null. This is useful for bind time resolution of VTIs. RESOLVE: What do we do for primitives?
 * @return	An Object representing the bind time value of this expression tree.(null if not a bind time constant.)
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Do the code generation for this node.  Call the more general routine that generates expressions.
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateExpression;[acb, mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivity</MethodName>
            <MethodComment>/** 
 * The default selectivity for value nodes is 50%.  This is overridden in specific cases, such as the RelationalOperators.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkTopPredicatesForEqualsConditions</MethodName>
            <MethodComment>/** 
 * Update the array of columns in = conditions with expressions without column references from the same table.  This is useful when doing subquery flattening on the basis of an equality condition. eqOuterCols or tableColMap may be null if the calling routine doesn't need the information provided
 * @param tableNumber	The tableNumber of the table from whichthe columns of interest come from.
 * @param eqOuterCols	Array of booleans for noting which columnsare in = predicates without columns from the subquery block. May be null.
 * @param tableNumbers	Array of table numbers in this query block.
 * @param tableColMap	Array of bits for noting which columnsare in = predicates for each table in the query block. May be null.
 * @param resultColTable True if tableNumber is the table containing resultcolumns
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>eqOuterCols</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableColMap</ParamName>
                    <ParamType>JBitSet[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultColTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBooleanTrue</MethodName>
            <MethodComment>/** 
 * Does this represent a true constant.
 * @return Whether or not this node represents a true constant.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBooleanFalse</MethodName>
            <MethodComment>/** 
 * Does this represent a false constant.
 * @return Whether or not this node represents a false constant.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Generate code for this calculation.  This is a place-holder method - it should not be called.
 * @param acb	The ExpressionClassBuilder for the class being built
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateMaps</MethodName>
            <MethodComment>/** 
 * Set the correct bits in tableColMap and set the boolean value in eqOuterCols  given two arguments to an = predicate tableColMap[t] - bit is set if the column is in an = predicate with a column  in table t, or a bit is set if the column is in an  = predicate with a constant,parameter or correlation variable  (for all table t, if this tableColMap is not for the table with the result columns) eqOuterCols[c] - is true if the column is in an = predicate with a constant, parameter or correlation variable
 * @param tableColMap	Array of bitmaps for noting which columns are in = predicates with columns from each table
 * @param eqOuterCols	Array of booleans for noting which columnsare in = predicates without columns from the subquery block.
 * @param tableNumber	table number for which we are setting up the Maps
 * @param resultTable	-1 if this table is not the result table; otherwisethe index into tableNumbers for the result table
 * @param arg1			one side of the = predicate
 * @param arg2			other side of the = predicate
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableColMap</ParamName>
                    <ParamType>JBitSet[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>eqOuterCols</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultTable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg1</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg2</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValueCols</MethodName>
            <MethodComment>/** 
 * Set eqOuterCols and the column in all the tables for constants, parmeters and correlation columns The column in the tableColMap is set only for the current table if the table is the result column table.  For other tables in the query we set the column for all the tables since the constant will reduced the number of columns required in a unique multicolumn index for distinctness. For example, given an unique index on t1(a,b), setting b=1 means that t1(a) is unique since there can be no duplicates for a where b=1 without destroying the uniqueness of t1(a,b).  However, for the result columns setting b=1, does not mean that a select list of t1.a is distinct if t1.a is the only column used in joining with another table e.g. select t1.a from t1, t2 where t1.a = t2.a and t1.b = 1; t1			t2			result a	b		a			a 1	1		1			1 1 	2		2			1 2	1
 * @param tableColMap	Array of bitmaps for noting which columns are in = predicates with columns from each table
 * @param eqOuterCols	Array of booleans for noting which columnsare in = predicates without columns from the subquery block.
 * @param colReference	The column to set
 * @param resultTable	If -1 set all the bit for all the tables for thatcolumn; otherwise set the bit for the specified table
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableColMap</ParamName>
                    <ParamType>JBitSet[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>eqOuterCols</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colReference</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultTable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRelationalOperator</MethodName>
            <MethodComment>/** 
 * Returns true if this ValueNode is a relational operator. Relational Operators are &amp;lt;, &amp;lt;=, =, &amp;gt;, &amp;gt;=, &amp;lt;&amp;gt; as well as IS NULL and IS NOT NULL. This is the preferred way of figuring out if a ValueNode is relational or not. 
 * @see RelationalOperator
 * @see BinaryRelationalOperatorNode
 * @see IsNullNode
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBinaryEqualsOperatorNode</MethodName>
            <MethodComment>/** 
 * Returns true if this value node is a &lt;em&gt;equals&lt;/em&gt; operator. 
 * @see ValueNode#isRelationalOperator
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInListProbeNode</MethodName>
            <MethodComment>/** 
 * Returns true if this value node is an operator created for optimized performance of an IN list. Or more specifically, returns true if this value node is an equals operator of the form "col = ?" that we generated during preprocessing to allow index multi-probing.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizableEqualityNode</MethodName>
            <MethodComment>/** 
 * Return true if the predicate represents an optimizable equality node. an expression is considered to be an optimizable equality node if all the following conditions are met: &lt;ol&gt; &lt;li&gt; the operator is an &lt;em&gt;=&lt;/em&gt; or &lt;em&gt;IS NULL&lt;/em&gt; operator &lt;/li&gt; &lt;li&gt; one of the operands is a column specified by optTable/columnNumber&lt;/li&gt; &lt;li&gt; Both operands are not the same column; i.e tab.col = tab.col &lt;/li&gt; &lt;li&gt; There are no implicit varchar comparisons of the operands; i.e either both operands are string like (varchar, char, longvarchar) or neither operand is string like &lt;/li&gt; &lt;/ol&gt;
 * @param optTable	the table being optimized. Column reference must be fromthis table.
 * @param columnNumber the column number. One of the operands of thispredicate must be the column number specified by optTable/columnNumber
 * @param isNullOkay if set to true we also consider IS NULL predicates;otherwise consider only = predicates.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullOkay</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiresTypeFromContext</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the type of this node will be determined from the context in which it is getting used. If true is returned then after bindExpression() is called on the node, its type must be set (from the relevant context) using setType().
 * @return Whether this node's type will be determined from the context
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isParameterNode</MethodName>
            <MethodComment>/** 
 * Returns TRUE if this is a parameter node. We do lots of special things with Parameter Nodes.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment>/** 
 * Tests if this node is equivalent to the specified ValueNode. Two  ValueNodes are considered equivalent if they will evaluate to the same value during query execution.  &lt;p&gt;  This method provides basic expression matching facility for the derived  class of ValueNode and it is used by the language layer to compare the  node structural form of the two expressions for equivalence at bind  phase.   &lt;p&gt; Note that it is not comparing the actual row values at runtime to produce  a result; hence, when comparing SQL NULLs, they are considered to be  equivalent and not unknown.   &lt;p&gt; One usage case of this method in this context is to compare the select  column expression against the group by expression to check if they are  equivalent.  e.g.: &lt;p&gt; SELECT c1+c2 FROM t1 GROUP BY c1+c2    &lt;p&gt; In general, node equivalence is determined by the derived class of  ValueNode.  But they generally abide to the rules below: &lt;ul&gt; &lt;li&gt;The two ValueNodes must be of the same node type to be considered  equivalent.  e.g.:  CastNode vs. CastNode - equivalent (if their args  also match), ColumnReference vs CastNode - not equivalent. &lt;li&gt;If node P contains other ValueNode(s) and so on, those node(s) must  also be of the same node type to be considered equivalent. &lt;li&gt;If node P takes a parameter list, then the number of arguments and its  arguments for the two nodes must also match to be considered  equivalent.  e.g.:  CAST(c1 as INTEGER) vs CAST(c1 as SMALLINT), they  are not equivalent. &lt;li&gt;When comparing SQL NULLs in this context, they are considered to be  equivalent. &lt;li&gt;If this does not apply or it is determined that the two nodes are not  equivalent then the derived class of this method should return false;  otherwise, return true. &lt;/ul&gt;   
 * @param other the node to compare this ValueNode against.
 * @return &lt;code&gt;true&lt;/code&gt; if the two nodes are equivalent, &lt;code&gt;false&lt;/code&gt; otherwise.
 * @throws StandardException 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSameNodeKind</MethodName>
            <MethodComment>/** 
 * Some node classes represent several logical node types (to reduce footprint), which we call &lt;em&gt;kinds&lt;/em&gt;. This means that implementations of  {@link #isEquivalent}cannot always just use  {@code instanceof} to check if the other noderepresents the same kind. Hence this method needs to be overridden by all node classes that represent several kinds. This default implementation does not look at kinds. It is only called from implementations of  {@code isEquivalent}.
 * @param other The other value node whose kind we want to compare with.
 * @return {@code true} if {@code this} and {@code o} represent the samelogical node type, i.e. kind.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>