<Class>
    <Id>1760</Id>
    <Package>org.apache.derby.iapi.services.loader</Package>
    <ClassName>ClassInspector</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ClassInspector  /** 
 * Methods to find out relationships between classes and methods within a class. All class names within this interface are treated as java language class names, e.g. int, COM.foo.Myclass, int[], java.lang.Object[]. That is java internal class names as defined in the class file format are not understood.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>primTypeNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>nonPrimTypeNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>OBJECT_TYPE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>STRING_TYPE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BIGDECIMAL_TYPE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cf</FieldName>
            <FieldType>ClassFactory</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ClassInspector</MethodName>
            <MethodComment>/** 
 * DO NOT USE! use the method in ClassFactory.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>instanceOf</MethodName>
            <MethodComment>/** 
 * Is the given object an instance of the named class?
 * @param className	The name of the class
 * @param obj		The object to test to see if it's an instanceof the named class
 * @return	true if obj is an instanceof className, false if not
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [clazz=getClass(className)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assignableTo</MethodName>
            <MethodComment>/** 
 * Is one named class assignable to another named class or interface?
 * @param fromClassName	The name of the class to be assigned
 * @param toClassName	The name of the class to be assigned to
 * @return	true if an object of type fromClass can be assigned to anobject of type toClass, false if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>accessible</MethodName>
            <MethodComment>/** 
 * Does the named class exist, and is it accessible?
 * @param className	The name of the class to test for existence
 * @return	true if the class exists and is accessible, false if not
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [theClass=getClass(className)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment>/** 
 * Get the Java name of the return type from a Member representing a method or the type of a Member representing a field.
 * @param member		A Member representing the method forwhich we want the return type.
 * @return	A Java-language-style string describing the return type ofthe method (for example, it returns "int" instead of "I".
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>member</ParamName>
                    <ParamType>Member</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [type]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findPublicMethod</MethodName>
            <MethodComment>/** 
 * Find a public method that implements a given signature. The signature is given using the full Java class names of the types. &lt;BR&gt; A untyped null parameter is indicated by passing in an empty string ("") as its class name. &lt;BR&gt; If receiverType represents an interface then the methods of java.lang.Object are included in the candidate list. &lt;BR&gt; If the caller is simply checking to see that a public method with the specified name exists, regardless of the signature, exists, then the caller should pass in a null for parmTypes.  (This is useful for checking the validity of a method alias when creating one.) &lt;BR&gt; We use a two-pass algorithm to resolve methods.  In the first pass, we use all "object" types to try to match a method.  If this fails, in the second pass, an array of "primitive" types (if the parameter has one, otherwise the same object type is used) is passed in, as well as the "object" type array.  For each parameter of a method, we try to match it against either the "object" type, or the "primitive" type.  Of all the qualified candidate methods found, we choose the closest one to the input parameter types.  This involves comparing methods whose parameters are mixed "object" and "primitive" types in the second pass.  This is eventually handled in classConvertableFromTo.
 * @param receiverType	The class name of the receiver
 * @param methodName	The name of the method
 * @param parmTypes		An array of class names representing theparameter types.  Pass a zero-element array if there are no parameters.  Pass a null if it is okay to match any signature.
 * @param primParmTypes This is used in the second pass of the two-passmethod resolution algorithm.  Use primitive type if it has one, otherwise use same object type
 * @param isParam		Array of booleans telling whether parameter is a ?.
 * @param staticMethod	Find a static method.
 * @param repeatLastParameter If true the last parameter may be repeated any number of times (total count must be greater than one).If false the last parameter is matched as usual. This also requires an exact match on the last parameter type.
 * @return	A Member representing the matching method.  Returns nullif no such method.
 * @exception ClassNotFoundException	One or more of the classes doesnot exist.
 * @exception StandardException			Thrown on ambiguous method invocation.
 * @see Member
 * @see Modifier
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parmTypes</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primParmTypes</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParam</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staticMethod</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>repeatLastParameter</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasVarargs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [receiverClass=getClass(receiverType)]</InnerVar>
                <InnerVar>Class[] [paramClasses=new Class[parmTypes.length]]</InnerVar>
                <InnerVar>Class[] [primParamClasses=null]</InnerVar>
                <InnerVar>Member[] [methodList=receiverClass.getMethods()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findPublicField</MethodName>
            <MethodComment>/** 
 * Find a public field  for a class. This follows the semantics of the java compiler for locating a field. This means if a field fieldName exists in the class with package, private or protected then an error is raised. Even if the field hides a field fieldName in a super-class/super--interface. See the JVM spec on fields.
 * @param receiverType	The class name of the receiver
 * @param fieldName		The name of the field
 * @param staticField	Find a static field
 * @return	A Member representing the matching field.  
 * @exception StandardException	Class or field does not exist or is not public or a security exception.
 * @see Member
 * @see Modifier
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staticField</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Exception [e=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findPublicConstructor</MethodName>
            <MethodComment>/** 
 * Find a public constructor that implements a given signature. The signature is given using the full Java class names of the types. &lt;BR&gt; A untyped null parameter is indicated by passing in an empty string ("") as its class name. 
 * @param receiverType	The class name of the receiver
 * @param parmTypes		An array of class names representing theparameter types.  Pass a zero-element array if there are no parameters.
 * @param primParmTypes This is used in the second pass of the two-passmethod resolution algorithm.  Use primitive type if it has one, otherwise use same object type
 * @param isParam		Array of booleans telling whether parameter is a ?.
 * @return	A Member representing the matching constructor.  Returns nullif no such constructor.
 * @exception ClassNotFoundException	One or more of the classes doesnot exist.
 * @exception StandardException			Thrown on ambiguous constructor invocation.
 * @see Member
 * @see Modifier
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parmTypes</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primParmTypes</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParam</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [receiverClass=getClass(receiverType)]</InnerVar>
                <InnerVar>Class[] [paramClasses=new Class[parmTypes.length]]</InnerVar>
                <InnerVar>Class[] [primParamClasses=null]</InnerVar>
                <InnerVar>boolean [unknownParameters=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeBounds</MethodName>
            <MethodComment>/** 
 * Given an implementation of a parameterized interface, return the bounds on the type variables. May return null if type resolution fails.
 */
</MethodComment>
            <ReturnType>Class[][]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterizedInterface</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>implementation</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Type[] [genericInterfaces=implementation.getGenericInterfaces()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isVarArgsMethod</MethodName>
            <MethodComment>/** 
 * Return true if the method or constructor supports varargs.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>member</ParamName>
                    <ParamType>Member</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericParameterTypes</MethodName>
            <MethodComment>/** 
 * Given an implementation of a parameterized interface, return the actual types of the interface type variables. May return null or an array of nulls if type resolution fails.
 */
</MethodComment>
            <ReturnType>Class&lt;?&gt;[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterizedType</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>implementation</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Class&lt;?&gt;&gt; [chain=getTypeChain(parameterizedType,implementation)]</InnerVar>
                <InnerVar>HashMap&lt;Type,Type&gt; [resolvedTypes=getResolvedTypes(chain)]</InnerVar>
                <InnerVar>ArrayList&lt;Class&lt;?&gt;&gt; [parameterTypes=getParameterTypes(parameterizedType,resolvedTypes)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypes</MethodName>
            <MethodComment>/** 
 * Get the parameter types for a method described by a Member as a String[].
 * @param method	A Member describing a method
 * @return	A String[] describing the parameters of the method
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>Member</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class[] [parameterClasses]</InnerVar>
                <InnerVar>String[] [parameterTypes=new String[parameterClasses.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>primitiveType</MethodName>
            <MethodComment>/** 
 * Determine whether a type is a Java primitive, like int or boolean
 * @param typeName	The name of the Java type
 * @return	true if it's a primitive type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveMethod</MethodName>
            <MethodComment>/** 
 * Tricky function to resolve a method.  If primParamClasses is null we know it's first pass.  First pass try to match as all "object" types, second pass try to match any combination of "object" and "primitive" types.  Find the closest match among all the qualified candidates.  If there's a tie, it's ambiguous. The preceding paragraph is a bit misleading. As of release 10.4, the second pass did not consider arbitrary combinations of primitive and wrapper types. This is because the first pass removed from consideration candidates which would be allowed under ANSI rules. As a fix for bug DERBY-3652, we now allow primitive and wrapper type matches during the first pass. The ANSI rules are documented in DERBY-3652.
 * @param receiverClass 	the class who holds the methods
 * @param methodName		the name of method
 * @param paramClasses		object type classes of input parameters
 * @param primParamClasses	primitive type classes or null
 * @param isParam			isParam (for ?) array
 * @param staticMethod		static method or not
 * @param methods			method stack
 * @return	the matched method
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramClasses</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primParamClasses</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParam</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staticMethod</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>repeatLastParameter</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methods</ParamName>
                    <ParamType>Member[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasVarargs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [candidateIndex=-1]</InnerVar>
                <InnerVar>boolean [firstTimeAround=true]</InnerVar>
                <InnerVar>boolean [ambiguous]</InnerVar>
                <InnerVar>boolean [somethingChanged]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClass</MethodName>
            <MethodComment>/** 
 * Get (load) the class for the given class name. This method converts any java language class name into a Class object. This includes cases like String[] and primitive types. This will attempt to load the class from the application set.
 * @exception ClassNotFoundException Class cannot be found, ora SecurityException or LinkageException was thrown loading the class.
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [arrayDepth=0]</InnerVar>
                <InnerVar>int [classNameLength=className.length()]</InnerVar>
                <InnerVar>int [position=classNameLength - 2]</InnerVar>
                <InnerVar>Class [baseClass=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>signatureConvertableFromTo</MethodName>
            <MethodComment>/** 
 * Can we convert a signature from fromTypes(primFromTypes) to toTypes. "mixTypes" is a flag to show if object/primitive type conversion is possible; this is used for comparing two candidate methods in the second pass of the two pass method resolution.
 * @param fromTypes	from types' classes
 * @param primFromTypes primitive from types or null
 * @param toTypes		to types' classes
 * @param isParam		is parameter (?) or not
 * @param mixTypes		mixing object/primitive types for comparison
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromTypes</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primFromTypes</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toTypes</ParamName>
                    <ParamType>Class[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParam</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mixTypes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [checkCount=fromTypes.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>classConvertableFromTo</MethodName>
            <MethodComment>/** 
 * Can we convert a fromClass to toClass. "mixTypes" is a flag to show if object/primitive type conversion is possible; this is used for comparing two candidate methods in the second pass of the two pass method resolution.
 * @param fromClass	from class
 * @param toClass		to class
 * @param mixTypes		mixing object/primitive types for comparison
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toClass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mixTypes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [fromName=fromClass.getName(), toName=toClass.getName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readableClassName</MethodName>
            <MethodComment>/** 
 * Translate a JVM-style type descriptor to a Java-language-style type name.
 * @param clazz		The String that contains the JVM type name
 * @return	The Java-language-style type name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clazz</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [arrayDepth=0]</InnerVar>
                <InnerVar>StringBuffer [sb=new StringBuffer(clazz.getName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeclaringClass</MethodName>
            <MethodComment>/** 
 * Get the declaring class for a method.
 * @param method	A Member describing a method
 * @return	A String with the declaring class
 * @see Member#getDeclaringClass
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>Member</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findTypeBounds</MethodName>
            <MethodComment>/** 
 * Get the type bounds for all of the type variables of the given parameterized type.
 */
</MethodComment>
            <ReturnType>Class[][]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pt</ParamName>
                    <ParamType>ParameterizedType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Type[] [actualTypeArguments=pt.getActualTypeArguments()]</InnerVar>
                <InnerVar>int [argCount=actualTypeArguments.length]</InnerVar>
                <InnerVar>Class[][] [retval=new Class[argCount][]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boundType</MethodName>
            <MethodComment>/** 
 * Get the bounds for a single type variable.
 */
</MethodComment>
            <ReturnType>Class[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawType</MethodName>
            <MethodComment>/** 
 * Get the raw type of a type bound.
 */
</MethodComment>
            <ReturnType>Class</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bound</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeChain</MethodName>
            <MethodComment>/** 
 * Construct an inheritance chain of types stretching from a supertype down to a concrete implementation.
 */
</MethodComment>
            <ReturnType>Class&lt;?&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chainEnd</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Class&lt;?&gt;&gt; [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResolvedTypes</MethodName>
            <MethodComment>/** 
 * Given an inheritance chain of types, stretching from a superclass down to a terminal concrete class, construct a map of generic types to their resolved types.
 */
</MethodComment>
            <ReturnType>Type</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chain</ParamName>
                    <ParamType>Class&lt;?&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashMap&lt;Type,Type&gt; [resolvedTypes=new HashMap&lt;Type,Type&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addResolvedTypes</MethodName>
            <MethodComment>/** 
 * Given a generic type, add its parameter types to an evolving map of resolved types. Some of the resolved types may be generic type variables which will need further resolution from other generic types.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolvedTypes</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>genericType</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypes</MethodName>
            <MethodComment>/** 
 * Given a map of resolved types, compose them together in order to resolve the actual concrete types that are plugged into the parameterized type.
 */
</MethodComment>
            <ReturnType>Class&lt;?&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterizedType</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolvedTypes</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Type[] [actualTypeArguments=parameterizedType.getTypeParameters()]</InnerVar>
                <InnerVar>ArrayList&lt;Class&lt;?&gt;&gt; [result=new ArrayList&lt;Class&lt;?&gt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>