<Class>
    <Id>4</Id>
    <Package>org.apache.derbyTesting.unitTests.util</Package>
    <ClassName>BitUtil</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BitUtil  /** 
 * This class provides utility methods for  converting byte arrays to hexidecimal Strings and manipulating BIT/BIT VARYING values as a packed vector of booleans. &lt;P&gt; The BIT/BIT VARYING methods are modeled after some methods in the &lt;I&gt;java.util.BitSet&lt;/I&gt; class.  An alternative to using a SQL BIT (VARYING) column in conjunction with the methods provided herein to provide bit manipulation would be to use a serialized  &lt;I&gt;java.util.BitSet&lt;/I&gt; column instead. &lt;p&gt; This class contains the following static methods: &lt;UL&gt; &lt;LI&gt; void &lt;B&gt;set&lt;/B&gt;(byte[] bytes, int position) to set a bit&lt;/LI&gt; &lt;LI&gt; void &lt;B&gt;clear&lt;/B&gt;(byte[] bytes, int position) to clear a bit&lt;/LI&gt; &lt;LI&gt; boolean &lt;B&gt;get&lt;/B&gt;(byte[] bytes, int position) to get the  bit status &lt;/LI&gt; &lt;/UL&gt; &lt;p&gt; Since these methods effectively allow a SQL BIT to be considered as an array of booleans, all offsets (position parameters) are zero based.  So if you want to set the first bit of a BIT type, you would use &lt;I&gt;  set(MyBitColumn, 0) &lt;/I&gt;. &lt;p&gt;  Examples: &lt;UL&gt; &lt;LI&gt; SELECT BitUtil::get(bitcol, 2) FROM mytab &lt;/LI&gt; &lt;LI&gt; UPDATE mytab SET bitcol = BitUtil::set(bitcol, 2)  &lt;/LI&gt; &lt;LI&gt; UPDATE mytab SET bitcol = BitUtil::clear(bitcol, 2)  &lt;/LI&gt; &lt;/UL&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>hex_table</FieldName>
            <FieldType>char[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>set</MethodName>
            <MethodComment>/** 
 * Set the bit at the specified position
 * @param bytes		the byte array
 * @param position	the bit to set, starting from zero
 * @return the byte array with the set bit
 * @exception IndexOutOfBoundsException on bad position
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Clear the bit at the specified position
 * @param bytes		the byte array
 * @param position	the bit to clear, starting from zero
 * @return the byte array with the cleared bit
 * @exception IndexOutOfBoundsException on bad position
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * Check to see if the specified bit is set
 * @param bytes		the byte array
 * @param position	the bit to check, starting from zero
 * @return true/false
 * @exception IndexOutOfBoundsException on bad position
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hexDump</MethodName>
            <MethodComment>/** 
 * Convert a byte array to a human-readable String for debugging purposes.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [byte_value]</InnerVar>
                <InnerVar>StringBuffer [str=new StringBuffer(data.length * 3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>str;append;["Hex dump:\n"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>