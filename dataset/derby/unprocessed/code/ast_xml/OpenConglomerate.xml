<Class>
    <Id>995</Id>
    <Package>org.apache.derby.impl.store.access.conglomerate</Package>
    <ClassName>OpenConglomerate</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>OpenConglomerate  /** 
 * A Generic class which implements the basic functionality needed to operate on an "open" conglomerate.  This class assumes the following general things about the access method. &lt;p&gt; The access method is page based and contained in a single container maintained by raw store.  
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>init_conglomerate</FieldName>
            <FieldType>Conglomerate</FieldType>
        </Field>
        <Field>
            <FieldName>init_xact_manager</FieldName>
            <FieldType>TransactionManager</FieldType>
        </Field>
        <Field>
            <FieldName>init_rawtran</FieldName>
            <FieldType>Transaction</FieldType>
        </Field>
        <Field>
            <FieldName>init_openmode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_lock_level</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_dynamic_info</FieldName>
            <FieldType>DynamicCompiledOpenConglomInfo</FieldType>
        </Field>
        <Field>
            <FieldName>init_hold</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>init_locking_policy</FieldName>
            <FieldType>LockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>useUpdateLocks</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>forUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>getBaseTableLocks</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>runtime_mem</FieldName>
            <FieldType>OpenConglomerateScratchSpace</FieldType>
        </Field>
        <Field>
            <FieldName>container</FieldName>
            <FieldType>ContainerHandle</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>newRowLocationTemplate</MethodName>
            <MethodComment>/** 
 * Return an "empty" row location object of the correct type. &lt;p&gt;
 * @return The empty Rowlocation.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFormatIds</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>latchPageAndRepositionScan</MethodName>
            <MethodComment>/** 
 * Latch the page containing the current RowPosition, and reposition scan. &lt;p&gt; Upon return the scan will hold a latch on the page to continue the scan on.  The scan will positioned on the record, just before the next record to return. Note that for both hold cursor and read uncommitted support this routine handles all cases of either the current position "dissappearing" (either the row and/or page).  The row and/or page can disappear by deleted  space being reclaimed post commit of that delete, and for some reason  the code requesting the reposition does not have locks which prevented the space reclamation.  Both hold cursor and read uncommitted scans are  examples of ways the caller will not prevent space reclamation from  claiming the position. This implementation also automatically updates the RowPosition to point at the slot containing the current RowPosition.  This slot  value is only valid while the latch is held.
 * @return true if scan had to reposition because a row disappeared.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [scan_repositioned=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>latchPage</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Latch the page containing the current RowPosition. &lt;/p&gt; &lt;p&gt; This implementation also automatically updates the RowPosition to point at the slot containing the current RowPosition.  This slot  value is only valid while the latch is held. &lt;/p&gt; &lt;p&gt; If the row pointed to by  {@code pos} does not exist (including thecase where the page itself does not exist), the page will not be latched, and  {@code pos.current_page} will be set to {@code null}. &lt;/p&gt;
 * @param pos the position to a row on the page that should be latched
 * @return {@code true} if the page was successfully latched, or{@code false} otherwise
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockPositionForRead</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Lock row at given row position for read. &lt;/p&gt; &lt;p&gt; This routine requests a row lock NOWAIT on the row located at the given RowPosition.  If the lock is granted NOWAIT the  routine will return true.  If the lock cannot be granted NOWAIT, then  the routine will release the latch on "page" and then it will request  a WAIT lock on the row.   &lt;/p&gt; &lt;p&gt; This implementation: Assumes latch held on current_page. If the current_rh field of RowPosition is non-null it is assumed that we want to lock that record handle and that we don't have a slot number. If the current_rh field of RowPosition is null, it is assumed the we want to lock the indicated current_slot.  Upon return current_rh will point to the record handle associated with current_slot. &lt;/p&gt; &lt;p&gt; After waiting and getting the lock on the row, this routine will fix up RowPosition to point at the row locked.  This means it will get the page latch again, and it will fix the current_slot to point at the  waited for record handle - it may have moved while waiting on the lock. &lt;/p&gt; &lt;p&gt; When this method returns, the page holding the row pointed to by the {@code RowLocation} is latched. This is however not the case if{@code moveForwardIfRowDisappears} is {@code false} and the row hasdisappeared. Then the latch will be released before the method returns, and  {@code pos.current_page} will be set to {@code null}. &lt;/p&gt;
 * @param pos       Position to lock.
 * @param aux_pos   If you have to give up latch to get lock, then also unlock this position if it is non-null.
 * @param moveForwardIfRowDisappears If true, then this routine must handle the case where the row id we are waiting on disappears when the latch is released.  If false, and the row disappears, the latch will be released again and false is returned.
 * @param waitForLock if true wait for lock, if lock can't be granted NOWAIT, else if false, throw a lock timeout exception if the lock can't be granted without waiting.
 * @return true if lock granted without releasing the latch, else returnfalse.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aux_pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>moveForwardIfRowDisappears</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>waitForLock</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [lock_granted_with_latch_held=this.container.getLockingPolicy().lockRecordForRead(init_rawtran,container,pos.current_rh,false,forUpdate)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockPositionForWrite</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Lock the row at the given position for write. &lt;/p&gt; &lt;p&gt; The page pointed to by the  {@code RowPosition} is assumed to be latchedwhen this method is called. If the lock cannot be obtained without waiting, the latch will be released and re-obtained when the lock has been acquired. &lt;/p&gt; &lt;p&gt; If the latch was released while waiting for the lock, and the row does not exist after the lock is obtained, the latch will be released again before the method returns, and  {@code pos.current_page} will be set to{@code null}. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>waitForLock</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [forInsert=false]</InnerVar>
                <InnerVar>boolean [lock_granted_with_latch_held=this.container.getLockingPolicy().lockRecordForWrite(init_rawtran,pos.current_rh,forInsert,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unlockPositionAfterRead</MethodName>
            <MethodComment>/** 
 * Unlock the record after a previous request to lock it. &lt;p&gt; Unlock the record after a previous call to lockRecordForRead().  It is expected that RowPosition contains information used to lock the record, Thus it is important if using a single RowPosition to track a scan to call unlock before you move the position forward to the next record. &lt;p&gt; Note that this routine assumes that the row was locked forUpdate if the OpenConglomerate is forUpdate, else it assumes the record was locked for read.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInternalTablePropertySet</MethodName>
            <MethodComment>/** 
 * Request set of properties associated with a table.  &lt;p&gt; Returns a property object containing all properties that the store knows about, which are stored persistently by the store.  This set of properties may vary from implementation to implementation of the store. &lt;p&gt; This call is meant to be used only for internal query of the properties by jbms, for instance by language during bulk insert so that it can create a new conglomerate which exactly matches the properties that the original container was created with.  This call should not be used by the user interface to present properties to users as it may contain properties that are meant to be internal to jbms.  Some properties are  meant only to be specified by jbms code and not by users on the command line. &lt;p&gt; Note that not all properties passed into createConglomerate() are stored persistently, and that set may vary by store implementation.
 * @param prop   Property list to add properties to.  If null, routine willcreate a new Properties object, fill it in and return it.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prop</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [ret_properties=ConglomerateUtil.createRawStorePropertySet(prop)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getTableProperties;[ret_properties]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableProperties</MethodName>
            <MethodComment>/** 
 * Request the system properties associated with a table.  &lt;p&gt; Request the value of properties that are associated with a table.  The following properties can be requested: derby.storage.pageSize  derby.storage.pageReservedSpace derby.storage.minimumRecordSize derby.storage.initialPages &lt;p&gt; To get the value of a particular property add it to the property list, and on return the value of the property will be set to it's current  value.  For example: get_prop(ConglomerateController cc) { Properties prop = new Properties(); prop.put("derby.storage.pageSize", ""); cc.getTableProperties(prop); System.out.println( "table's page size = " +  prop.getProperty("derby.storage.pageSize"); }
 * @param prop   Property list to fill in.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prop</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>container;getContainerProperties;[prop]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXactMgr</MethodName>
            <MethodComment>/** 
 * Public Accessors of This class:
 */
</MethodComment>
            <ReturnType>TransactionManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawTran</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Transaction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOpenMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHold</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isForUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosed</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUseUpdateLocks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRuntimeMem</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OpenConglomerateScratchSpace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkConsistency</MethodName>
            <MethodComment>/** 
 * Check consistency of a conglomerate. &lt;p&gt; Checks the consistency of the data within a given conglomerate, does not check consistency external to the conglomerate (ie. does not check that  base table row pointed at by a secondary index actually exists). &lt;p&gt; There is no checking in the default implementation, you must override to get conglomerate specific consistency checking.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpaceInfo</MethodName>
            <MethodComment>/** 
 * Get information about space used by the conglomerate.
 */
</MethodComment>
            <ReturnType>SpaceInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isKeyed</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTableLocked</MethodName>
            <MethodComment>/** 
 * is the open btree table locked?
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * Open the container. &lt;p&gt; Open the container, obtaining necessary locks.  Most work is actually done by RawStore.openContainer().  
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>open_container</ParamName>
                    <ParamType>ContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerate</ParamName>
                    <ParamType>Conglomerate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>format_ids</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collation_ids</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>openmode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopen</MethodName>
            <MethodComment>/** 
 * Open the container. &lt;p&gt; Open the container, obtaining necessary locks.  Most work is actually done by RawStore.openContainer().  Will only reopen() if the container is not already open.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the container. &lt;p&gt; Handles being closed more than once.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>