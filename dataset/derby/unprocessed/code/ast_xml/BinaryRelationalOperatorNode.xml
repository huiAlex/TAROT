<Class>
    <Id>2163</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>BinaryRelationalOperatorNode</ClassName>
    <SuperClass>BinaryComparisonOperatorNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>RelationalOperator</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BinaryRelationalOperatorNode  /** 
 * This class represents the 6 binary operators: LessThan, LessThanEquals, Equals, NotEquals, GreaterThan and GreaterThanEquals.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>K_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_GREATER_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_GREATER_THAN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_LESS_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_LESS_THAN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_NOT_EQUALS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>kind</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>relOpType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>btnVis</FieldName>
            <FieldType>BaseTableNumbersVisitor</FieldType>
        </Field>
        <Field>
            <FieldName>optBaseTables</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>valNodeBaseTables</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>inListProbeSource</FieldName>
            <FieldType>InListOperatorNode</FieldType>
        </Field>
        <Field>
            <FieldName>LEFT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEITHER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RIGHT</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BinaryRelationalOperatorNode</MethodName>
            <MethodComment>/** 
 * Constructor. DERBY-6185 Query against view  with  {@code "where name LIKE'Col1' ESCAPE '\' "} failed.Argument  {@code forQueryRewrite} can be true only if this node has beenadded by an internal rewrite of the query. This allows binding to be more liberal when checking it against allowed syntax. This parameter will be passed FALSE when a new instance of the node is being created(which is the majority of the cases). But when an existing node is getting cloned, the value of this parameter should be passed as the originalNode.getForQueryRewrite(). Examples of this can be found in Predicate.Java and PredicateList.java
 * @param kind            The kind of operator
 * @param leftOperand     The left operand
 * @param rightOperand    The right operand
 * @param forQueryRewrite See method description
 * @param cm              The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forQueryRewrite</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BinaryRelationalOperatorNode</MethodName>
            <MethodComment>/** 
 * Same as constructor above except takes a third argument that is an InListOperatorNode.  This version is used during IN-list preprocessing to create a "probe predicate" for the IN-list. See InListOperatorNode.preprocess() for more. DERBY-6185 (Query against view  with "where name LIKE 'Col1' ESCAPE '\' " failed) 4th argument forQueryRewrite can be true only if this node has been added by an internal rewrite of the query. This allows binding to be more liberal when checking it against allowed syntax. This parameter will be passed FALSE when a new instance of the node is being created(which is the majority of the cases). But when an existing node is getting cloned, the value of this parameter should be passed as the originalNode.getForQueryRewrite(). Examples of this can be found in Predicate.Java and PredicateList.java
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inListOp</ParamName>
                    <ParamType>InListOperatorNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forQueryRewrite</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constructorMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [methodName=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperatorName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [operatorName=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRelOpType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInListOp</MethodName>
            <MethodComment>/** 
 * If this rel op was created for an IN-list probe predicate then return the underlying InListOperatorNode.  Will return null if this rel op is a "legitimate" relational operator (as opposed to a disguised IN-list).  With the exception of nullability checking via the isInListProbeNode() method, all access to this.inListProbeSource MUST come through this method, as this method ensures that the left operand of the inListProbeSource is set correctly before returning it.
 */
</MethodComment>
            <ReturnType>InListOperatorNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnOperand</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getColumnOperand 
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [ft=(FromTable)optTable]</InnerVar>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [walkSubtree=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnOperand</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getColumnOperand 
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [walkSubtree=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExpressionOperand</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getExpressionOperand
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ft</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [walkSubtree=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperand</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getOperand
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cRef</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refSetSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initBaseTableVisitor;[refSetSize, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpressionOperand</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateExpressionOperand
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>acbi</ParamName>
                    <ParamType>ExpressionClassBuilderInterface</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExpressionClassBuilder [acb=(ExpressionClassBuilder)acbi]</InnerVar>
                <InnerVar>FromBaseTable [ft]</InnerVar>
                <InnerVar>ValueNode [exprOp=getExpressionOperand(ft.getTableNumber(),columnPosition,ft)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exprOp;generateExpression;[acb, mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selfComparison</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#selfComparison 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [otherSide]</InnerVar>
                <InnerVar>JBitSet [tablesReferenced]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usefulStartKey</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#usefulStartKey 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnSide=columnOnOneSide(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keyColumnOnLeft</MethodName>
            <MethodComment>/** 
 * Return true if a key column for the given table is found on the left side of this operator, false if it is found on the right side of this operator. NOTE: This method assumes that a key column will be found on one side or the other.  If you don't know whether a key column exists, use the columnOnOneSide() method (below).
 * @param optTable	The Optimizable table that we're looking for a keycolumn on.
 * @return true if a key column for the given table is on the leftside of this operator, false if one is found on the right side of this operator.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [left=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnOnOneSide</MethodName>
            <MethodComment>/** 
 * Determine whether there is a column from the given table on one side of this operator, and if so, which side is it on?
 * @param optTable	The Optimizable table that we're looking for a keycolumn on.
 * @return	LEFT if there is a column on the left, RIGHT if there isa column on the right, NEITHER if no column found on either side.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [left=false]</InnerVar>
                <InnerVar>boolean [walkSubtree=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usefulStopKey</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#usefulStopKey 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnSide=columnOnOneSide(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateAbsoluteColumnId</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateAbsoluteColumnId 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnPosition=getAbsoluteColumnPosition(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;push;[columnPosition]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateRelativeColumnId</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateRelativeColumnId 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnPosition=getAbsoluteColumnPosition(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;push;[columnPosition]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAbsoluteColumnPosition</MethodName>
            <MethodComment>/** 
 * Get the absolute 0-based column position of the ColumnReference from  the conglomerate for this Optimizable.
 * @param optTable	The Optimizable
 * @return The absolute 0-based column position of the ColumnReference
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>ConglomerateDescriptor [bestCD]</InnerVar>
                <InnerVar>int [columnPosition]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateQualMethod</MethodName>
            <MethodComment>/** 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acbi</ParamName>
                    <ParamType>ExpressionClassBuilderInterface</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExpressionClassBuilder [acb=(ExpressionClassBuilder)acbi]</InnerVar>
                <InnerVar>MethodBuilder [qualMethod=acb.newUserExprFun()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>qualMethod;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>qualMethod;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushMethodReference;[mb, qualMethod]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateOrderedNulls</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateOrderedNulls 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;push;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orderedNulls</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#orderedNulls 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isQualifier</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#isQualifier 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forPush</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [ft]</InnerVar>
                <InnerVar>ValueNode [otherSide=null]</InnerVar>
                <InnerVar>JBitSet [tablesReferenced]</InnerVar>
                <InnerVar>ColumnReference [cr]</InnerVar>
                <InnerVar>boolean [found=false]</InnerVar>
                <InnerVar>boolean [walkSubtree=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getOrderableVariantType 
 * @exception StandardException	thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareWithKnownConstant</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#compareWithKnownConstant 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>considerParameters</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [node=keyColumnOnLeft(optTable) ? rightOperand : leftOperand]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompareValue</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getCompareValue
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [node=keyColumnOnLeft(optTable) ? rightOperand : leftOperand]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>booleanSelectivity</MethodName>
            <MethodComment>/** 
 * Return 50% if this is a comparison with a boolean column, a negative selectivity otherwise.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=null]</InnerVar>
                <InnerVar>double [retval=-1.0d]</InnerVar>
                <InnerVar>int [columnSide]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReceiverInterfaceName</MethodName>
            <MethodComment>/** 
 * The methods generated for this node all are on Orderable.   Overrides this method in BooleanOperatorNode for code generation purposes.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>evaluateConstantExpressions</MethodName>
            <MethodComment>/** 
 * See if the node always evaluates to true or false, and return a Boolean constant node if it does.
 * @return a node representing a Boolean constant if the result of theoperator is known; otherwise, this operator node
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newBool</MethodName>
            <MethodComment>/** 
 * Create a Boolean constant node with a specified value.
 * @param b the value of the constant
 * @return a node representing a Boolean constant
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNegation</MethodName>
            <MethodComment>/** 
 * Returns the negation of this operator; negation of Equals is NotEquals.
 */
</MethodComment>
            <ReturnType>BinaryOperatorNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BinaryOperatorNode [negation]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>negation;setType;[getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNegationNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSwappedEquivalent</MethodName>
            <MethodComment>/** 
 * Return an equivalent node with the operands swapped, and possibly with the operator type changed in order to preserve the meaning of the expression.
 */
</MethodComment>
            <ReturnType>BinaryOperatorNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryOperatorNode [newNode=new BinaryRelationalOperatorNode(getKindForSwap(),rightOperand,leftOperand,false,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newNode;setType;[getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getKindForSwap</MethodName>
            <MethodComment>/** 
 * Return the node type that must be used in order to construct an equivalent expression if the operands are swapped. For symmetric operators ( {@code =} and {@code &lt;&gt;}), the same node type is returned. Otherwise, the direction of the operator is switched in order to preserve the meaning (for instance, a node representing less-than will return the node type for greater-than).
 * @return a node type that preserves the meaning of the expression ifthe operands are swapped
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usefulStartKey</MethodName>
            <MethodComment>/** 
 * is this is useful start key? for example a predicate of the from &lt;em&gt;column Lessthan 5&lt;/em&gt; is not a useful start key but is a useful stop key. However &lt;em&gt;5 Lessthan column &lt;/em&gt; is a useful start key.
 * @param columnOnLeft 	is true if the column is the left hand side of thebinary operator.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnOnLeft</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usefulStopKey</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#usefulStopKey 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnOnLeft</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStartOperator</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getStartOperator 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStopOperator</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getStopOperator 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateOperator</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateOperator 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateNegate</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#generateNegate 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOperator</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getOperator 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivity</MethodName>
            <MethodComment>/** 
 * return the selectivity of this predicate.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>double [retval=booleanSelectivity(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransitiveSearchClause</MethodName>
            <MethodComment>/** 
 * @see RelationalOperator#getTransitiveSearchClause 
 */
</MethodComment>
            <ReturnType>RelationalOperator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherCR</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalsComparisonWithConstantExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
                <InnerVar>ValueNode [comparand=null]</InnerVar>
                <InnerVar>int [side=columnOnOneSide(optTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRelationalOperator</MethodName>
            <MethodComment>/** 
 * @see ValueNode#isRelationalOperator 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBinaryEqualsOperatorNode</MethodName>
            <MethodComment>/** 
 * @see ValueNode#isBinaryEqualsOperatorNode 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInListProbeNode</MethodName>
            <MethodComment>/** 
 * @see ValueNode#isInListProbeNode It's okay for this method to reference inListProbeSource directly because it does not rely on the contents of inListProbeSource's leftOperand, and a caller of this method cannot gain access to inListProbeSource's leftOperand through this method.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizableEqualityNode</MethodName>
            <MethodComment>/** 
 * @see ValueNode#optimizableEqualityNode 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullOkay</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [cr=getColumnOperand(optTable,columnNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>implicitVarcharComparison</MethodName>
            <MethodComment>/** 
 * Return whether or not this binary relational predicate requires an implicit (var)char conversion.  This is important when considering hash join since this type of equality predicate is not currently supported for a hash join.
 * @return	Whether or not an implicit (var)char conversion is required forthis binary relational operator.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TypeId [leftType=leftOperand.getTypeId()]</InnerVar>
                <InnerVar>TypeId [rightType=rightOperand.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genSQLJavaSQLTree</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScopedOperand</MethodName>
            <MethodComment>/** 
 * Take a ResultSetNode and return a column reference that is scoped for for the received ResultSetNode, where "scoped" means that the column reference points to a specific column in the RSN.  This is used for remapping predicates from an outer query down to a subquery.  For example, assume we have the following query: select * from (select i,j from t1 union select i,j from t2) X1, (select a,b from t3 union select a,b from t4) X2 where X1.j = X2.b; Then assume that this BinaryRelationalOperatorNode represents the "X1.j = X2.b" predicate and that the childRSN we received as a parameter represents one of the subqueries to which we want to push the predicate; let's say it's: select i,j from t1 Then what we want to do in this method is map one of the operands X1.j or X2.b (depending on the 'whichSide' parameter) to the childRSN, if possible.  Note that in our example, "X2.b" should _NOT_ be mapped because it doesn't apply to the childRSN for the subquery "select i,j from t1"; thus we should leave it as it is.  "X1.j", however, _does_ need to be scoped, and so this method will return a ColumnReference pointing to "T1.j" (or whatever the corresponding column in T1 is). ASSUMPTION: We should only get to this method if we know that exactly one operand in the predicate to which this operator belongs can and should be mapped to the received childRSN. 
 * @param whichSide The operand are we trying to scope (LEFT or RIGHT)
 * @param parentRSNsTables Set of all table numbers referenced bythe ResultSetNode that is _parent_ to the received childRSN. We need this to make sure we don't scope the operand to a ResultSetNode to which it doesn't apply.
 * @param childRSN The result set node to which we want to createa scoped predicate.
 * @param whichRC If not -1 then this tells us which ResultColumnin the received childRSN we need to use for the scoped predicate; if -1 then the column position of the scoped column reference will be stored in this array and passed back to the caller.
 * @return A column reference scoped to the received childRSN, if possible.If the operand is a ColumnReference that is not supposed to be scoped, we return a _clone_ of the reference--this is necessary because the reference is going to be pushed to two places (left and right children of the parentRSN) and if both children are referencing the same instance of the column reference, they'll interfere with each other during optimization.
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>whichSide</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentRSNsTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>childRSN</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whichRC</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [rc]</InnerVar>
                <InnerVar>ColumnReference [cr=whichSide == LEFT ? (ColumnReference)leftOperand : (ColumnReference)rightOperand]</InnerVar>
                <InnerVar>JBitSet [crTables=new JBitSet(parentRSNsTables.size())]</InnerVar>
                <InnerVar>BaseTableNumbersVisitor [btnVisitor=new BaseTableNumbersVisitor(crTables)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cr;accept;[btnVisitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>valNodeReferencesOptTable</MethodName>
            <MethodComment>/** 
 * Determine whether or not the received ValueNode (which will usually be a ColumnReference) references either the received optTable or else a base table in the subtree beneath that optTable.
 * @param valNode The ValueNode that has the reference(s).
 * @param optTable The table/subtree node to which we're tryingto find a reference.
 * @param forPush Whether or not we are searching with the intentto push this operator to the target table.
 * @param walkOptTableSubtree Should we walk the subtree beneathoptTable to find base tables, or not?  Will be false if we've already done it for the left operand and now we're here for the right operand.
 * @return True if valNode contains a reference to optTable orto a base table in the subtree beneath optTable; false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>valNode</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forPush</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>walkOptTableSubtree</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [found=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initBaseTableVisitor;[optTable.getReferencedTableMap().size(), walkOptTableSubtree]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initBaseTableVisitor</MethodName>
            <MethodComment>/** 
 * Initialize the fields used for retrieving base tables in subtrees, which allows us to do a more extensive search for table references.  If the fields have already been created, then just reset their values.
 * @param numTablesInQuery Used for creating JBitSets thatcan hold table numbers for the query.
 * @param initOptBaseTables Whether or not we should clear outor initialize the optBaseTables bit set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTablesInQuery</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initOptBaseTables</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildTableNumList</MethodName>
            <MethodComment>/** 
 * Create a set of table numbers to search when trying to find which (if either) of this operator's operands reference the received target table.  At the minimum this set should contain the target table's own table number.  After that, if we're _not_ attempting to push this operator (or more specifically, the predicate to which this operator belongs) to the target table, we go on to search the subtree beneath the target table and add any base table numbers to the searchable list.
 * @param ft Target table for which we're building the searchlist.
 * @param forPush Whether or not we are searching with the intentto push this operator to the target table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ft</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forPush</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>optBaseTables;or;[ft.getReferencedTableMap()]</InnerMethodInvoke>
                <InnerMethodInvoke>btnVis;setTableMap;[optBaseTables]</InnerMethodInvoke>
                <InnerMethodInvoke>ft;accept;[btnVis]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSameNodeKind</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>