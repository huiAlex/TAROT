<Class>
    <Id>713</Id>
    <Package>org.apache.derby.impl.jdbc.authentication</Package>
    <ClassName>AuthenticationServiceBase</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>AuthenticationService</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
        <SuperInterface>ModuleSupportable</SuperInterface>
        <SuperInterface>PropertySetCallback</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AuthenticationServiceBase  /** 
 * &lt;p&gt; This is the authentication service base class. &lt;/p&gt; &lt;p&gt; There can be 1 Authentication Service for the whole Derby system and/or 1 authentication per database. In a near future, we intend to allow multiple authentication services per system and/or per database. &lt;/p&gt; &lt;p&gt; It should be extended by the specialized authentication services. &lt;/p&gt; &lt;p&gt;&lt;strong&gt;IMPORTANT NOTE:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt; User passwords are hashed using a message digest algorithm if they're stored in the database. They are not hashed if they were defined at the system level. &lt;/p&gt; &lt;p&gt; The passwords can be hashed using two different schemes: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;The SHA-1 authentication scheme, which was the only available scheme in Derby 10.5 and earlier. This scheme uses the SHA-1 message digest algorithm.&lt;/li&gt; &lt;li&gt;The configurable hash authentication scheme, which allows the users to specify which message digest algorithm to use.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; In order to use the configurable hash authentication scheme, the users have to set the  {@code derby.authentication.builtin.algorithm} property (onsystem level or database level) to the name of an algorithm that's available in one of the security providers registered on the system. If this property is not set, or if it's set to NULL or an empty string, the SHA-1 authentication scheme is used. &lt;/p&gt; &lt;p&gt; Which scheme to use is decided when a password is about to be stored in the database. One database may therefore contain passwords stored using different schemes. In order to determine which scheme to use when comparing a user's credentials with those stored in the database, the stored password is prefixed with an identifier that tells which scheme is being used. Passwords stored using the SHA-1 authentication scheme are prefixed with {@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}. Passwords that are stored using the configurable hash authentication scheme are prefixed with {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME} and suffixed with the name ofthe message digest algorithm. &lt;/p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>authenticationScheme</FieldName>
            <FieldType>UserAuthenticator</FieldType>
        </Field>
        <Field>
            <FieldName>store</FieldName>
            <FieldType>AccessFactory</FieldType>
        </Field>
        <Field>
            <FieldName>AuthenticationTrace</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SECMEC_USRSSBPWD</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>AuthenticationServiceBase</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAuthenticationService</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>aScheme</ParamName>
                    <ParamType>UserAuthenticator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment>/** 
 * Start this module.  In this case, nothing needs to be done.
 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
 * @exception StandardException upon failure to load/bootthe expected authentication service.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PropertyFactory [pf=(PropertyFactory)getServiceModule(this,org.apache.derby.iapi.reference.Module.PropertyFactory)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>authenticate</MethodName>
            <MethodComment>/** 
 * Authenticate a User inside JBMS.T his is an overload method. We're passed-in a Properties object containing user credentials information (as well as database name if user needs to be validated for a certain database access).
 * @see org.apache.derby.iapi.jdbc.AuthenticationService#authenticate
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>databaseName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userInfo</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [userName=userInfo.getProperty(Attribute.USERNAME_ATTR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.sql.SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemCredentialsDatabaseName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment>/** 
 * Returns a property if it was set at the database or system level. Treated as SERVICE property by default.
 * @return a property string value.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [propertyValue=null]</InnerVar>
                <InnerVar>TransactionController [tc=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransaction</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get a transaction for performing authentication at the database level. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseProperties</MethodName>
            <MethodComment>/** 
 * Get all the database properties.
 * @return the database properties, or {@code null} if there is noaccess factory
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Properties [props=null]</InnerVar>
                <InnerVar>TransactionController [tc=getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getServiceName</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the name of the database if we are performing authentication at the database level. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [propertyValue=null]</InnerVar>
                <InnerVar>TransactionController [tc=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [dbOnly=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validate</MethodName>
            <MethodComment>/** 
 * @see PropertySetCallback#validate
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [stringValue=(String)value]</InnerVar>
                <InnerVar>boolean [settingToNativeLocal=Property.AUTHENTICATION_PROVIDER_NATIVE_LOCAL.equals(stringValue)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePasswordLifetime</MethodName>
            <MethodComment>/** 
 * Parse the value of the password lifetime property. Return null if it is bad. 
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>passwordLifetimeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePasswordThreshold</MethodName>
            <MethodComment>/** 
 * Parse the value of the password expiration threshold property. Return null if it is bad. 
 */
</MethodComment>
            <ReturnType>Double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expirationThresholdString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment>/** 
 * @see PropertySetCallback#validate
 */
</MethodComment>
            <ReturnType>Serviceable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>map</MethodName>
            <MethodComment>/** 
 * @see PropertySetCallback#map
 * @exception StandardException Thrown on error.
 */
</MethodComment>
            <ReturnType>Serializable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [authService=(String)p.get(org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER)]</InnerVar>
                <InnerVar>String [userPassword=(String)value]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requireAuthentication</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [requireAuthentication=PropertyUtil.getPropertyFromSet(properties,org.apache.derby.iapi.reference.Property.REQUIRE_AUTHENTICATION_PARAMETER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashPasswordSHA1Scheme</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; This method hashes a clear user password using a Single Hash algorithm such as SHA-1 (SHA equivalent) (it is a 160 bits digest) &lt;/p&gt; &lt;p&gt; The digest is returned as an object string. &lt;/p&gt; &lt;p&gt; This method is only used by the SHA-1 authentication scheme. &lt;/p&gt;
 * @param plainTxtUserPassword Plain text user password
 * @return hashed user password (digest) as a String objector  {@code null} if the plaintext password is {@code null}
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>plainTxtUserPassword</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MessageDigest [algorithm=null]</InnerVar>
                <InnerVar>byte[] [bytePasswd=null]</InnerVar>
                <InnerVar>byte[] [hashedVal=algorithm.digest()]</InnerVar>
                <InnerVar>String [hexString=PasswordHasher.ID_PATTERN_SHA1_SCHEME + StringUtil.toHexString(hashedVal,0,hashedVal.length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>algorithm;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>algorithm;update;[bytePasswd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toHexByte</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Convert a string into a byte array in hex format. &lt;/p&gt; &lt;p&gt; For each character (b) two bytes are generated, the first byte represents the high nibble (4 bits) in hexadecimal ( {@code b &amp; 0xf0}), the second byte represents the low nibble ( {@code b &amp; 0x0f}). &lt;/p&gt; &lt;p&gt; The character at  {@code str.charAt(0)} is represented by the first twobytes in the returned String. &lt;/p&gt; &lt;p&gt; New code is encouraged to use  {@code String.getBytes(String)} or similarmethods instead, since this method does not preserve all bits for characters whose codepoint exceeds 8 bits. This method is preserved for compatibility with the SHA-1 authentication scheme. &lt;/p&gt;
 * @param str string
 * @return the byte[] (with hexadecimal format) form of the string (str)
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [data=new byte[str.length() * 2]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashUsingDefaultAlgorithm</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Hash a password using the default message digest algorithm for this system before it's stored in the database. &lt;/p&gt; &lt;p&gt; If the data dictionary supports the configurable hash authentication scheme, and the property  {@code derby.authentication.builtin.algorithm}is a non-empty string, the password will be hashed using the algorithm specified by that property. Otherwise, we fall back to the new authentication scheme based on SHA-1. The algorithm used is encoded in the returned token so that the code that validates a user's credentials knows which algorithm to use. &lt;/p&gt;
 * @param user the user whose password to hash
 * @param password the plain text password
 * @param props database properties
 * @return a digest of the user name and password formatted as a string,or  {@code null} if {@code password} is {@code null}
 * @throws StandardException if the specified algorithm is not supported
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PasswordHasher [hasher=getDataDictionary().makePasswordHasher(props)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDictionary</MethodName>
            <MethodComment>/** 
 * Find the data dictionary for the current connection.
 * @return the {@code DataDictionary} for the current connection
 */
</MethodComment>
            <ReturnType>DataDictionary</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=(LanguageConnectionContext)getContext(LanguageConnectionContext.CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>substitutePassword</MethodName>
            <MethodComment>/** 
 * Strong Password Substitution (USRSSBPWD). This method generates a password substitute to authenticate a client which is using a DRDA security mechanism such as SECMEC_USRSSBPWD. Depending how the user is defined in Derby and if BUILTIN is used, the stored password can be in clear-text (system level) or encrypted (hashed - *not decryptable*)) (database level) - If the user has authenticated at the network level via SECMEC_USRSSBPWD, it means we're presented with a password substitute and we need to generate a substitute password coming from the store to compare with the one passed-in. The substitution algorithm used is the same as the one used in the SHA-1 authentication scheme ( {@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}), so in the case of database passwords stored using that scheme, we can simply compare the received hash with the stored hash. If the configurable hash authentication scheme  {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME}is used, we have no way to find out if the received hash matches the stored password, since we cannot decrypt the hashed passwords and re-apply another hash algorithm. Therefore, strong password substitution only works if the database-level passwords are stored with the SHA-1 scheme. NOTE: A lot of this logic could be shared with the DRDA decryption and client encryption managers - This will be done _once_ code sharing along with its rules are defined between the Derby engine, client and network code (PENDING). Substitution algorithm works as follow: PW_TOKEN = SHA-1(PW, ID) The password (PW) and user name (ID) can be of any length greater than or equal to 1 byte. The client generates a 20-byte password substitute (PW_SUB) as follows: PW_SUB = SHA-1(PW_TOKEN, RDr, RDs, ID, PWSEQs) w/ (RDs) as the random client seed and (RDr) as the server one. See PWDSSB - Strong Password Substitution Security Mechanism (DRDA Vol.3 - P.650)
 * @return a substituted password.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>info</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>databaseUser</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MessageDigest [messageDigest=null]</InnerVar>
                <InnerVar>byte [SECMEC_USRSSBPWD_PWDSEQS[]={(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01}]</InnerVar>
                <InnerVar>byte[] [passwordSubstitute]</InnerVar>
                <InnerVar>byte[] [bytePasswd=null]</InnerVar>
                <InnerVar>byte[] [userBytes=toHexByte(userName)]</InnerVar>
                <InnerVar>String [sourceSeedstr=info.getProperty(Attribute.DRDA_SECTKN_IN)]</InnerVar>
                <InnerVar>String [targetSeedstr=info.getProperty(Attribute.DRDA_SECTKN_OUT)]</InnerVar>
                <InnerVar>byte[] [sourceSeed_=StringUtil.fromHexString(sourceSeedstr,0,sourceSeedstr.length())]</InnerVar>
                <InnerVar>byte[] [targetSeed_=StringUtil.fromHexString(targetSeedstr,0,targetSeedstr.length())]</InnerVar>
                <InnerVar>String [hexString=null]</InnerVar>
                <InnerVar>byte[] [passwordToken=messageDigest.digest()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>messageDigest;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[userBytes]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[toHexByte(hexString)]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[passwordToken]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[targetSeed_]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[sourceSeed_]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[userBytes]</InnerMethodInvoke>
                <InnerMethodInvoke>messageDigest;update;[SECMEC_USRSSBPWD_PWDSEQS]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContext</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getServiceName</MethodName>
            <MethodComment>/** 
 * Privileged service name lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged module lookup. Must be package protected so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>