<Class>
    <Id>1867</Id>
    <Package>org.apache.derby.impl.store.raw.log</Package>
    <ClassName>LogAccessFile</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LogAccessFile  /** 
 * Wraps a RandomAccessFile file to provide buffering on log writes. Only supports the write calls required for the log! MT - unsafe.  Caller of this class must provide synchronization.  The one exception is with the log file access, LogAccessFile will touch the log only inside synchronized block protected by the semaphore, which is defined by the creator of this object. Write to the log buffers are allowed when there are free buffers even when dirty buffers are being written(flushed) to the disk by a different thread. Only one flush writes to log file at a time, other wait for it to finish. Except for flushLogAccessFile , SyncAccessLogFile other function callers must provide syncronization that will allow only one of them to write to  the buffers.  Log Buffers are used in circular fashion, each buffer moves through following stages:  freeBuffers --&amp;gt; dirtyBuffers --&amp;gt; freeBuffers. Movement of buffers from one stage to 	another stage is synchronized using	the object(this) of this class.  A Checksum log record that has the checksum value for the data that is being written to the disk is generated and written 	before the actual data.  Except for the large log records that does not fit into a single buffer,  checksum is calcualted for a group of log records that are in the buffer  when buffers is switched. Checksum log record is written into the reserved space in the beginning buffer.  In case of a large log record that does not fit into a buffer, the checksum is written to the byte[] allocated for the big log record.  Checksum log records helps in identifying the incomplete log disk writes during  recovery. This is done by recalculating the checksum value for the data on the disk and comparing it to the the value stored in the checksum log record. 
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG_RECORD_FIXED_OVERHEAD_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_RECORD_HEADER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_RECORD_TRAILER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_NUMBER_LOG_BUFFERS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>freeBuffers</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>freeBuffers</FieldName>
            <FieldType>LogAccessFileBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>dirtyBuffers</FieldName>
            <FieldType>LinkedList</FieldType>
        </Field>
        <Field>
            <FieldName>dirtyBuffers</FieldName>
            <FieldType>LogAccessFileBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>currentBuffer</FieldName>
            <FieldType>LogAccessFileBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>flushInProgress</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>log</FieldName>
            <FieldType>StorageRandomAccessFile</FieldType>
        </Field>
        <Field>
            <FieldName>logFileSemaphore</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>mon_numWritesToLog</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>mon_numBytesToLog</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>masterFac</FieldName>
            <FieldType>MasterFactory</FieldType>
        </Field>
        <Field>
            <FieldName>inReplicationMasterMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inReplicationSlaveMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>logOutputBuffer</FieldName>
            <FieldType>ArrayOutputStream</FieldType>
        </Field>
        <Field>
            <FieldName>logicalOut</FieldName>
            <FieldType>FormatIdOutputStream</FieldType>
        </Field>
        <Field>
            <FieldName>checksumInstant</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>checksumLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>checksumLogRecordSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>writeChecksum</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>checksumLogOperation</FieldName>
            <FieldType>ChecksumOperation</FieldType>
        </Field>
        <Field>
            <FieldName>checksumLogRecord</FieldName>
            <FieldType>LogRecord</FieldType>
        </Field>
        <Field>
            <FieldName>logFactory</FieldName>
            <FieldType>LogToFile</FieldType>
        </Field>
        <Field>
            <FieldName>databaseEncrypted</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>LogAccessFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logFactory</ParamName>
                    <ParamType>LogToFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>log</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bufferSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logFactory;checkForReplication;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>currentBuffer;init;[checksumLogRecordSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLogRecord</MethodName>
            <MethodComment>/** 
 * Write a single log record to the stream. &lt;p&gt; For performance pass all parameters rather into a specialized routine rather than maintaining the writeInt, writeLong, and write interfaces that this class provides as a standard OutputStream.  It will make it harder to use other OutputStream implementations, but makes for less function calls and allows optimizations knowing when to switch buffers. &lt;p&gt; This routine handles all log records which are smaller than one log buffer.  If a log record is bigger than a log buffer it calls writeUnbufferedLogRecord(). &lt;p&gt; The log record written will always look the same as if the following code had been executed: writeInt(length) writeLong(instant) write(data, data_offset, (length - optional_data_length) ) if (optional_data_length != 0) write(optional_data, optional_data_offset, optional_data_length) writeInt(length)
 * @param length                (data + optional_data) length bytes to write
 * @param instant               the log address of this log record.
 * @param data                  "from" array to copy "data" portion of rec
 * @param data_offset           offset in "data" to start copying from.
 * @param optional_data         "from" array to copy "optional data" from
 * @param optional_data_offset  offset in "optional_data" to start copy from
 * @param optional_data_length  length of optional data to copy.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>data_offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data_offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data_length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [total_log_record_length=length + LOG_RECORD_FIXED_OVERHEAD_SIZE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendLogRecordToBuffer</MethodName>
            <MethodComment>/** 
 * Append a log record to a byte[]. Typically, the byte[] will be currentBuffer, but if a log record that is too big to fit in a buffer is added, buff will be a newly allocated byte[].
 * @param buff The byte[] the log record is appended to
 * @param pos The position in buff where the method will start toappend to
 * @param length (data + optional_data) length bytes to write
 * @param instant the log address of this log record.
 * @param data "from" array to copy "data" portion of rec
 * @param data_offset offset in "data" to start copying from.
 * @param optional_data "from" array to copy "optional data" from
 * @param optional_data_offset offset in "optional_data" to start copy from
 * @param optional_data_length length of optional data to copy.
 * @see LogAccessFile#writeLogRecord
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buff</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>data_offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data_offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optional_data_length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [data_length=length - optional_data_length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[data, data_offset, buff, pos, data_length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeInt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLong</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>l</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeInt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLong</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>l</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>off</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[b, off, currentBuffer.buffer, currentBuffer.position, len]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushDirtyBuffers</MethodName>
            <MethodComment>/** 
 * Write data from all dirty buffers into the log file. &lt;p&gt; A call for clients of LogAccessFile to insure that all privately buffered data has been writen to the file - so that reads on the file using one of the various scan classes will see all the data which has been writen to this point. &lt;p&gt; Note that this routine only "writes" the data to the file, this does not mean that the data has been synced to disk unless file was opened in WRITE SYNC mode(rws/rwd).  The only way to insure that is by calling is to call syncLogAccessFile() after this call in Non-WRITE sync mode(rw) &lt;p&gt; MT-Safe : parallel thereads can call this function, only one threads does the flush and the other threads waits for the one that is doing the flush to finish. Currently there are two possible threads that can call this function in parallel  1) A Thread that is doing the commit 2) A Thread that is writing to the log and log buffers are full or a log records does not fit in a buffer. (Log Buffers full(switchLogBuffer() or a log record size that is greater than logbuffer size has to be writtern through writeToLog call directlty) Note: writeToLog() is not synchronized on the semaphore that is used to do  buffer management to allow writes  to the free buffers when flush is in progress.  
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogAccessFileBuffer [buf=null]</InnerVar>
                <InnerVar>int [noOfBuffers]</InnerVar>
                <InnerVar>int [nFlushed=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushLogAccessFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;switchLogBuffer;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;flushDirtyBuffers;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>switchLogBuffer</MethodName>
            <MethodComment>/** 
 * Appends the current Buffer to the dirty Buffer list and assigns a free buffer to be the currrent active buffer . Flushing of the buffer to disk is delayed if there is a free buffer available.  dirty buffers will be  flushed to the disk    when  flushDirtyBuffers() is invoked by  a commit call  or when no more free buffers are available. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>syncLogAccessFile</MethodName>
            <MethodComment>/** 
 * Guarantee all writes up to the last call to flushLogAccessFile on disk. &lt;p&gt; A call for clients of LogAccessFile to insure that all data written up to the last call to flushLogAccessFile() are written to disk. This call will not return until those writes have hit disk. &lt;p&gt; Note that this routine may block waiting for I/O to complete so  callers should limit the number of resource held locked while this operation is called.  It is expected that the caller Note that this routine only "writes" the data to the file, this does not mean that the data has been synced to disk.  The only way to insure that is to first call switchLogBuffer() and then follow by a call of sync().
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>corrupt</MethodName>
            <MethodComment>/** 
 * The database is being marked corrupted, get rid of file pointer without writing out anything more.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;flushLogAccessFile;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReplicationMasterRole</MethodName>
            <MethodComment>/** 
 * Make this LogAccessFile pass chunks of log records (byte[]) to the MasterFactory when the chunks are written to disk.
 * @param masterFac The MasterFactory service responsible forcontrolling the master side replication behaviour.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>masterFac</ParamName>
                    <ParamType>MasterFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stopReplicationMasterRole</MethodName>
            <MethodComment>/** 
 * Stop this LogAccessFile from passing chunks of log records to the MasterFactory.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReplicationSlaveRole</MethodName>
            <MethodComment>/** 
 * Method to put this LogAccessFile object in replication slave mode, effectively disabling checksum writes. Because checksums are received from the replication master, the slave can not be allowed to add it's own checksums - that would invalidate the checksums and would stop the database from recovering. Replication slave mode must therefore be set before LogAccessFile decides whether to write it's own checksums, and this method is therefore indirectly called from the constructor of this class by calling LogFactory.checkForReplication If replication slave mode for the database is stopped after this object has been created, checksums cannot be reenabled without creating a new instance of this class. That is conveniently handled as LogToFile.recover completes (which automatically happens once replication slave mode is no longer active)
 * @see LogToFile#checkForReplication
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeToLog</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>off</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>highestInstant</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reserveSpaceForChecksum</MethodName>
            <MethodComment>/** 
 * reserve the space for the checksum log record in the log file. 
 * @param length           the length of the log record to be written
 * @param logFileNumber    current log file number 
 * @param currentPosition  current position in the log file. 
 * @return the space that is needed to write a checksum log record.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>logFileNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentPosition</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [total_log_record_length=length + LOG_RECORD_FIXED_OVERHEAD_SIZE]</InnerVar>
                <InnerVar>boolean [reserveChecksumSpace=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeChecksumLogRecord</MethodName>
            <MethodComment>/** 
 * Generate the checkum log record and write it into the log buffer. The checksum applies to all bytes from this checksum log record to the next one. 
 * @param buffer The byte[] the checksum is written to. Thechecksum is always written at the beginning of buffer.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buffer</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [p=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logOutputBuffer;setData;[buffer]</InnerMethodInvoke>
                <InnerMethodInvoke>logOutputBuffer;setPosition;[p]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalOut;writeObject;[checksumLogRecord]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChecksumLogRecordSize</MethodName>
            <MethodComment>/** 
 * Return the length of a checksum record 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeEndMarker</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>marker</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [b=currentBuffer.buffer]</InnerVar>
                <InnerVar>int [p=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;flushLogAccessFile;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeToLog;[b, 0, p, -1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>