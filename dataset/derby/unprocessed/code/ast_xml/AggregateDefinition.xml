<Class>
    <Id>1545</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>AggregateDefinition</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AggregateDefinition  /** 
 * An AggregateDefinition defines an aggregate. It is used by Derby during query compilation to determine what  Aggregator is used to aggregate a particular data type  and what datatype the Aggregator will emit.  A single  AggregateDefinition may map to one or more Aggregators  depending on the input type.  For example, a user defined STDEV aggregate may use one aggregator implementation for the INTEGER type and another for a user defined type that implements  a point.  In this case, both the aggregators would have a  single AggregateDefinition that would chose the appropriate aggregator based on the input type.  On the other hand, if only a single aggregator is needed to aggregate over all of the input types (e.g. COUNT()), then it may be convenient to implement both the AggregateDefinition and the Aggregator interfaces by the same class.
 * @see org.apache.derby.catalog.TypeDescriptor
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>getAggregator</MethodName>
            <MethodComment>/** 
 * Get the aggregator that performs the aggregation on the input datatype at execution time.  If the input type can be handled,  return a type descriptor with the resultant type information and fill in the string buffer with the name of the class that is used to perform the aggregation over the input type. If the aggregate cannot be performed on this type, then a null should be returned. &lt;p&gt; The aggregator class must implement a zero argument  constructor.  The aggregator class can be the same class as the AggregateDefinition if it implements both interfaces. &lt;p&gt; The result datatype may be the same as the input datatype  or a different datatype.  To create your own type descriptor to return to this method, see &lt;i&gt;com.ibm.db2j.types.TypeFactory&lt;/i&gt;.
 * @param inputType	the input type descriptor
 * @param aggregatorClassName	output parameter, filled inwith the class name that implements &lt;i&gt;com.ibm.db2j.aggregates.Aggregator&lt;/i&gt;
 * @return the output type descriptor (which may or may notbe the same as the input type -- it is ok to simply return the input type).  Null is returned if the aggregate cannot process the input type. Note that the output type may be a type that maps directly to a standard SQL (e.g. &lt;i&gt;java.lang.Integer&lt;/i&gt;) or any other java type (e.g. &lt;i&gt;java.sql.ResultSet&lt;/i&gt;, &lt;i&gt;java.util.Vector&lt;/i&gt;, &lt;i&gt;java.util.TimeZone&lt;/i&gt; or whatever). To construct a type descriptor see &lt;i&gt;com.ibm.db2j.types.TypeFactory&lt;/i&gt;.
 * @see org.apache.derby.catalog.TypeDescriptor
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregatorClassName</ParamName>
                    <ParamType>StringBuffer</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>