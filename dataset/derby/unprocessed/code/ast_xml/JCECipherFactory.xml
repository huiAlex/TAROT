<Class>
    <Id>381</Id>
    <Package>org.apache.derby.impl.services.jce</Package>
    <ClassName>JCECipherFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>CipherFactory</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>JCECipherFactory  /** 
 * This CipherFactory creates new JCECipherProvider.
 * @see CipherFactory
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MESSAGE_DIGEST</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_ALGORITHM</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DES</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DESede</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TripleDES</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>AES</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BLOCK_LENGTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AES_IV_LENGTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>keyLengthBits</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>encodedKeyLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>cryptoAlgorithm</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cryptoAlgorithmShort</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cryptoProvider</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cryptoProviderShort</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>messageDigest</FieldName>
            <FieldType>MessageDigest</FieldType>
        </Field>
        <Field>
            <FieldName>mainSecretKey</FieldName>
            <FieldType>SecretKey</FieldType>
        </Field>
        <Field>
            <FieldName>mainIV</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>persistentProperties</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>VERIFYKEY_DATALEN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>hexOutput</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>paddedInputKey</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>JCECipherFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAttributes</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;checkDerbyInternalsPrivilege;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;init;[create, props, newAttributes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>providerErrorName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cps</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateUniqueBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encryptKey</MethodName>
            <MethodComment>/** 
 * Encrypt the secretKey with the boot password. This includes the following steps,  getting muck from the boot password and then using this to generate a key, generating an appropriate IV using the muck using the key and IV thus generated to create the appropriate cipher provider and encrypting the secretKey 
 * @return hexadecimal string of the encrypted secretKey
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>EncryptedKeyResult</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bootPassword</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [muckLength=secretKey.length]</InnerVar>
                <InnerVar>byte[] [muck=getMuckFromBootPassword(bootPassword,muckLength)]</InnerVar>
                <InnerVar>SecretKey [key=generateKey(muck)]</InnerVar>
                <InnerVar>byte[] [IV=generateIV(muck)]</InnerVar>
                <InnerVar>CipherProvider [tmpCipherProvider=createNewCipher(ENCRYPT,key,IV)]</InnerVar>
                <InnerVar>byte[] [result=new byte[secretKey.length]]</InnerVar>
                <InnerVar>String [hexOutput=org.apache.derby.iapi.util.StringUtil.toHexString(result,0,result.length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tmpCipherProvider;encrypt;[secretKey, 0, secretKey.length, result, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padKey</MethodName>
            <MethodComment>/** 
 * For block ciphers, and  algorithms using the NoPadding scheme, the data that has  to be encrypted needs to be a multiple of the expected block size for the cipher  Pad the key with appropriate padding to make it blockSize align
 * @param secretKey	the data that needs blocksize alignment
 * @param blockSizeAlign   secretKey needs to be blocksize aligned		
 * @return    a byte array with the contents of secretKey along with padded bytes in the endto make it blockSize aligned
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>blockSizeAlign</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [result=secretKey]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decryptKey</MethodName>
            <MethodComment>/** 
 * Decrypt the secretKey with the user key . This includes the following steps,  retrieve the encryptedKey, generate the muck from the boot password and generate an appropriate IV using the muck,and using the key and IV decrypt the encryptedKey 
 * @return decrypted key  
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>encryptedKey</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encodedKeyCharLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bootPassword</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [secretKey=org.apache.derby.iapi.util.StringUtil.fromHexString(encryptedKey,0,encodedKeyCharLength)]</InnerVar>
                <InnerVar>int [muckLength]</InnerVar>
                <InnerVar>byte[] [muck=getMuckFromBootPassword(bootPassword,muckLength)]</InnerVar>
                <InnerVar>SecretKey [key=generateKey(muck)]</InnerVar>
                <InnerVar>byte[] [IV=generateIV(muck)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>createNewCipher(DECRYPT,key,IV);decrypt;[secretKey, 0, secretKey.length, secretKey, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMuckFromBootPassword</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bootPassword</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encodedKeyByteLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ulength=bootPassword.length]</InnerVar>
                <InnerVar>byte[] [muck=new byte[encodedKeyByteLength]]</InnerVar>
                <InnerVar>int [rotation=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateKey</MethodName>
            <MethodComment>/** 
 * Generate a Key object using the input secretKey that can be used by JCECipherProvider to encrypt or decrypt.
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>SecretKey</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [length=secretKey.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateIV</MethodName>
            <MethodComment>/** 
 * Generate an IV using the input secretKey that can be used by JCECipherProvider to encrypt or decrypt.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [IVlen=BLOCK_LENGTH]</InnerVar>
                <InnerVar>byte[] [iv=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>digest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [digest=messageDigest.digest(input)]</InnerVar>
                <InnerVar>byte[] [condenseDigest=new byte[2]]</InnerVar>
                <InnerVar>int [retval=(condenseDigest[0] &amp; 0xFF) | ((condenseDigest[1] &lt;&lt; 8) &amp; 0xFF00)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>messageDigest;reset;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSecureRandom</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SecureRandom</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createNewCipher</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CipherProvider</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createNewCipher</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CipherProvider</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>SecretKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>iv</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAttrs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [provider_or_algo_specified=false]</InnerVar>
                <InnerVar>boolean [storeProperties=create]</InnerVar>
                <InnerVar>String [externalKey=properties.getProperty((newAttrs ? Attribute.NEW_CRYPTO_EXTERNAL_KEY : Attribute.CRYPTO_EXTERNAL_KEY))]</InnerVar>
                <InnerVar>int [firstSlashPos=cryptoAlgorithm.indexOf('/')]</InnerVar>
                <InnerVar>int [lastSlashPos=cryptoAlgorithm.lastIndexOf('/')]</InnerVar>
                <InnerVar>String [feedbackMode=cryptoAlgorithm.substring(firstSlashPos + 1,lastSlashPos)]</InnerVar>
                <InnerVar>String [padding=cryptoAlgorithm.substring(lastSlashPos + 1,cryptoAlgorithm.length())]</InnerVar>
                <InnerVar>Throwable [t]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Security;addProvider;[provider]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleBootPassword</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPasswd</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [inputKey=properties.getProperty((newPasswd ? Attribute.NEW_BOOT_PASSWORD : Attribute.BOOT_PASSWORD))]</InnerVar>
                <InnerVar>byte[] [bootPassword=StringUtil.getAsciiBytes(inputKey)]</InnerVar>
                <InnerVar>byte[] [generatedKey]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>saveProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseSecretKey</MethodName>
            <MethodComment>/** 
 * get the secretkey used for encryption and decryption when boot password mechanism is used for encryption Steps include  retrieve the stored key, decrypt the stored key and verify if the correct boot password was passed  There is a possibility that the decrypted key includes the original key and padded bytes in order to have been block size aligned during encryption phase. Hence extract the original key 
 * @param properties	properties to retrieve the encrypted key  
 * @param bootPassword	boot password used to connect to the encrypted database
 * @param errorState	errorstate to account for any errors during retrieval /creation of the secretKey
 * @return the original unencrypted key bytes to use for encryption and decrytion   
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bootPassword</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errorState</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [keyString=properties.getProperty(RawStoreFactory.ENCRYPTED_KEY)]</InnerVar>
                <InnerVar>int [encodedKeyCharLength=keyString.indexOf('-')]</InnerVar>
                <InnerVar>int [verifyKey=Integer.parseInt(keyString.substring(encodedKeyCharLength + 1))]</InnerVar>
                <InnerVar>byte[] [generatedKey=decryptKey(keyString,encodedKeyCharLength,bootPassword)]</InnerVar>
                <InnerVar>int [checkKey=digest(generatedKey)]</InnerVar>
                <InnerVar>byte[] [result]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>saveSecretKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>secretKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bootPassword</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EncryptedKeyResult [ekr=encryptKey(secretKey,bootPassword)]</InnerVar>
                <InnerVar>String [encryptedKey=ekr.hexOutput]</InnerVar>
                <InnerVar>int [verifyKey=digest(ekr.paddedInputKey)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>changeBootPassword</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>changeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>verify</ParamName>
                    <ParamType>CipherProvider</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [seperator=changeString.indexOf(',')]</InnerVar>
                <InnerVar>String [oldBP=changeString.substring(0,seperator).trim()]</InnerVar>
                <InnerVar>byte[] [oldBPAscii=StringUtil.getAsciiBytes(oldBP)]</InnerVar>
                <InnerVar>String [newBP=changeString.substring(seperator + 1).trim()]</InnerVar>
                <InnerVar>byte[] [newBPAscii=StringUtil.getAsciiBytes(newBP)]</InnerVar>
                <InnerVar>byte[] [generatedKey=getDatabaseSecretKey(properties,oldBPAscii,SQLState.WRONG_BOOT_PASSWORD)]</InnerVar>
                <InnerVar>byte[] [IV=generateIV(generatedKey)]</InnerVar>
                <InnerVar>CipherProvider [newDecrypter=createNewCipher(DECRYPT,generateKey(generatedKey),IV)]</InnerVar>
                <InnerVar>String [newkey=saveSecretKey(generatedKey,newBPAscii)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;vetCipherProviders;[newDecrypter, verify, SQLState.WRONG_BOOT_PASSWORD]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;[Attribute.CRYPTO_KEY_LENGTH, keyLengthBits + "-" + encodedKeyLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>vetCipherProviders</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Verify that a decrypter matches an encrypter. Raises an exception if they don't. The verification is performed by encrypting a block of text and checking that it decrypts to the same block. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>decrypter</ParamName>
                    <ParamType>CipherProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encrypter</ParamName>
                    <ParamType>CipherProvider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlState</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [clearTextLength=1024]</InnerVar>
                <InnerVar>int [byteSize=256]</InnerVar>
                <InnerVar>byte[] [clearText=new byte[clearTextLength]]</InnerVar>
                <InnerVar>byte[] [cipherText=new byte[clearTextLength]]</InnerVar>
                <InnerVar>byte[] [unencryptedText=new byte[clearTextLength]]</InnerVar>
                <InnerVar>int [bytesEncrypted=encrypter.encrypt(clearText,0,clearTextLength,cipherText,0)]</InnerVar>
                <InnerVar>int [bytesDecrypted=decrypter.decrypt(cipherText,0,bytesEncrypted,unencryptedText,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyKey</MethodName>
            <MethodComment>/** 
 * The database can be encrypted with an encryption key given in connection url. For security reasons, this key is not made persistent in the database. But it is necessary to verify the encryption key when booting the database if it is similar to the one used when creating the database This needs to happen before we access the data/logs to avoid the risk of corrupting the  database because of a wrong encryption key. This method performs the steps necessary to verify the encryption key if an external encryption key is given. At database creation, 4k of random data is generated using SecureRandom and MD5 is used to compute the checksum for the random data thus generated.  This 4k page of random data is then encrypted using the encryption key. The checksum of unencrypted data and encrypted data is made persistent in the database in file by name given by Attribute.CRYPTO_EXTERNAL_KEY_VERIFYFILE (verifyKey.dat). This file exists directly under the database root directory. When trying to boot an existing encrypted database, the given encryption key is used to decrypt the data in the verifyKey.dat and the checksum is calculated and compared against the original stored checksum. If these checksums dont match an exception is thrown. Please note, this process of verifying the key  does not provide any added security but only is  intended to allow to fail gracefully if a wrong encryption key is used StandardException is thrown if there are any problems during the process of verification of the encryption key or if there is any mismatch of the encryption key.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sf</ParamName>
                    <ParamType>StorageFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InputStream [verifyKeyInputStream=null]</InnerVar>
                <InnerVar>StorageRandomAccessFile [verifyKeyFile=null]</InnerVar>
                <InnerVar>byte[] [data=new byte[VERIFYKEY_DATALEN]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMD5Checksum</MethodName>
            <MethodComment>/** 
 * Use MD5 MessageDigest algorithm to generate checksum
 * @param data	data to be used to compute the hash value
 * @return returns the hash value computed using the data
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privAccessFile</MethodName>
            <MethodComment>/** 
 * access a file for either read/write
 * @param storageFactory	factory used for io access
 * @param fileName		name of the file to create and open for writeThe file will be created directly under the database root directory
 * @param filePerms		file permissions, if "rw" open file with read and write permissionsif "r" , open file with read permissions
 * @return	StorageRandomAccessFile returns file with fileName for writing
 * @exception IOException Any exception during accessing the file for read/write
 */
</MethodComment>
            <ReturnType>StorageRandomAccessFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>storageFactory</ParamName>
                    <ParamType>StorageFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filePerms</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StorageFile [verifyKeyFile=storageFactory.newStorageFile("",fileName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.io.IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StorageRandomAccessFile</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privAccessGetInputStream</MethodName>
            <MethodComment>/** 
 * access a InputStream for a given file for reading.
 * @param storageFactory   factory used for io access
 * @param fileName        name of the file to open as a stream for reading
 * @return InputStream returns the stream for the file with fileName for reading
 * @exception IOException Any exception during accessing the file for read
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>storageFactory</ParamName>
                    <ParamType>StorageFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StorageFile [verifyKeyFile=storageFactory.newStorageFile("",fileName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>FileNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>EncryptedKeyResult</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hexOutput</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paddedInputKey</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>