<Class>
    <Id>1136</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>Predicate</ClassName>
    <SuperClass>QueryTreeNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>OptimizablePredicate</SuperInterface>
        <SuperInterface>Comparable</SuperInterface>
        <SuperInterface>Predicate</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Predicate  /** 
 * A Predicate represents a top level predicate.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>andNode</FieldName>
            <FieldType>AndNode</FieldType>
        </Field>
        <Field>
            <FieldName>pushable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>referencedSet</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>equivalenceClass</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>indexPosition</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>startKey</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>stopKey</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isQualifier</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>searchClauses</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>searchClauses</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>scoped</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>Predicate</MethodName>
            <MethodComment>/** 
 * Constructor.
 * @param andNode		The top of the predicate	 
 * @param referencedSet	Bit map of referenced tables
 * @param cm            The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>andNode</ParamName>
                    <ParamType>AndNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedSet</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedMap</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#getReferencedMap
 */
</MethodComment>
            <ReturnType>JBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasSubquery</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasSubquery
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasMethodCall</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasMethodCall
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markStartKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#markStartKey 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStartKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#isStartKey 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markStopKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#markStopKey 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStopKey</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#isStopKey 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markQualifier</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#markQualifier 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isQualifier</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#isQualifier 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareWithKnownConstant</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#compareWithKnownConstant 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>considerParameters</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
                <InnerVar>RelationalOperator [relop=getRelop()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasEqualOnColumnList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseColumnPositions</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RelationalOperator [relop=getRelop()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompareValue</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#getCompareValue
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RelationalOperator [relop=getRelop()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalsComparisonWithConstantExpression</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#equalsComparisonWithConstantExpression 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivity</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#selectivity 
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexPosition</MethodName>
            <MethodComment>/** 
 * @see OptimizablePredicate#getIndexPosition 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Predicate [otherPred=other]</InnerVar>
                <InnerVar>int [otherIndexPosition=otherPred.getIndexPosition()]</InnerVar>
                <InnerVar>boolean [thisIsEquals=false, otherIsEquals=false]</InnerVar>
                <InnerVar>boolean [thisIsNotEquals=true, otherIsNotEquals=true]</InnerVar>
                <InnerVar>boolean [thisIsBefore=(thisIsEquals &amp;&amp; !otherIsEquals) || (!thisIsNotEquals &amp;&amp; otherIsNotEquals)]</InnerVar>
                <InnerVar>boolean [otherIsBefore=(otherIsEquals &amp;&amp; !thisIsEquals) || (!otherIsNotEquals &amp;&amp; thisIsNotEquals)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAndNode</MethodName>
            <MethodComment>/** 
 * Return the andNode.
 * @return AndNode	The andNode.
 */
</MethodComment>
            <ReturnType>AndNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAndNode</MethodName>
            <MethodComment>/** 
 * Set the andNode.
 * @param andNode	The new andNode.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>andNode</ParamName>
                    <ParamType>AndNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPushable</MethodName>
            <MethodComment>/** 
 * Return the pushable.
 * @return boolean	Whether or not the predicate is pushable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPushable</MethodName>
            <MethodComment>/** 
 * Set whether or not this predicate is pushable.  This method is intended for use when creating a copy of the predicate, ex for predicate pushdown.  We choose not to add this assignment to copyFields() because the comments for that method say that it should copy all fields _except_ the two specified at init time; "pushable" is one of the two specified at init time.
 * @param pushable Whether or not the predicate is pushable.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pushable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedSet</MethodName>
            <MethodComment>/** 
 * Return the referencedSet.
 * @return JBitSet	The referencedSet.
 */
</MethodComment>
            <ReturnType>JBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEquivalenceClass</MethodName>
            <MethodComment>/** 
 * Set the equivalence class, if any, for this predicate.
 * @param equivalenceClass	The equivalence class for this predicate.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>equivalenceClass</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEquivalenceClass</MethodName>
            <MethodComment>/** 
 * Get the equivalenceClass for this predicate.
 * @return The equivalenceClass for this predicate.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRelop</MethodName>
            <MethodComment>/** 
 * Get the RelationalOperator on the left side of the AND node, if there is one.  If the left side is not a RelationalOperator, return null.
 * @return	The RelationalOperator on the left side of the AND node,if any.
 */
</MethodComment>
            <ReturnType>RelationalOperator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOrList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStoreQualifier</MethodName>
            <MethodComment>/** 
 * Is this predicate a possible Qualifier for store? &lt;p&gt; Current 2 types of predicates can be pushed to store:  1) RelationalOperator -  represented with by left operand as instance of RelationalOperator. 2) A single And'd term of a list of OR terms represented by left operand as instance of OrNode. More checking specific operator's terms to see if they are finally pushable to store.  In the final push at execution each term of the AND  or OR must be a Relational operator with a column reference on one side  and a constant on the other.
 * @return true if term is wither a AND of a RelationalOperator, or anOR of one or more Relational Operators.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPushableOrClause</MethodName>
            <MethodComment>/** 
 * Is this predicate an pushable OR list? &lt;p&gt; Does the predicate represent a AND'd list of OR term's, all of which are pushable.  To be pushable each of OR terms must be a legal  qualifier, which is a column reference on one side of a Relational operator and a constant on the other.
 * @return true if the predicate is a pushable set of OR clauses.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transitiveSearchClauseAdded</MethodName>
            <MethodComment>/** 
 * Return whether or not this predicate has been used to add a new search clause of the specified type via transitive closure. NOTE: This can only be true if this is an equijoin between 2 column references.
 * @param ro	The search clause that we are currently consideringas the source for transitive closure
 * @return	Whether or not this predicate has been usedto add a new search clause of the specified type via transitive  closure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ro</ParamName>
                    <ParamType>RelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTransitiveSearchClauseAdded</MethodName>
            <MethodComment>/** 
 * Mark this predicate as having been used to add a new predicate of the specified type via transitive closure on search clauses.
 * @param ro	The search clause that we are currently consideringas the source for transitive closure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ro</ParamName>
                    <ParamType>RelationalOperator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>searchClauses;add;[ro.getOperator()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStartOperator</MethodName>
            <MethodComment>/** 
 * Get the start operator for this predicate for a scan.
 * @param optTable	The optimizable table, so we can tell which side ofthe operator the search column is on.
 * @return	The start operator for a start key on this column.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStopOperator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIndexPosition</MethodName>
            <MethodComment>/** 
 * Set the position of the index column that this predicate restricts
 * @param indexPosition	The position of the index column that thispredicate restricts.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearScanFlags</MethodName>
            <MethodComment>/** 
 * Clear the start/stop position and qualifier flags
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpressionOperand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optTable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getRelop();generateExpressionOperand;[optTable, columnPosition, acb, mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>binaryRelOpColRefsToString</MethodName>
            <MethodComment>/** 
 * Get a string version of the column references for this predicate IF it's a binary relational operator.  We only print out the names of the operands if they are column references; otherwise we just print a dummy value.  This is for debugging purposes only--it's a convenient way to see what columns the predicate is referencing, especially when tracing through code and printing assert failure.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [DUMMY_VAL="&lt;expr&gt;"]</InnerVar>
                <InnerVar>java.lang.StringBuilder [sBuf=new java.lang.StringBuilder()]</InnerVar>
                <InnerVar>BinaryRelationalOperatorNode [opNode=(BinaryRelationalOperatorNode)getAndNode().getLeftOperand()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sBuf;append;[' ']</InnerMethodInvoke>
                <InnerMethodInvoke>sBuf;append;[opNode.operator]</InnerMethodInvoke>
                <InnerMethodInvoke>sBuf;append;[' ']</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyFields</MethodName>
            <MethodComment>/** 
 * Copy all fields of this Predicate (except the two that are set from 'init').
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherPred</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushableToSubqueries</MethodName>
            <MethodComment>/** 
 * Determine whether or not this predicate is eligible for push-down into subqueries.  Right now the only predicates we consider to be eligible are those which 1) are Binary Relational operator nodes and 2) have a column reference on BOTH sides, each of which has a reference to a base table somewhere beneath it.
 * @return Whether or not this predicate is eligible to bepushed into subqueries.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryRelationalOperatorNode [opNode=(BinaryRelationalOperatorNode)getAndNode().getLeftOperand()]</InnerVar>
                <InnerVar>JBitSet [tNums=new JBitSet(getReferencedSet().size())]</InnerVar>
                <InnerVar>BaseTableNumbersVisitor [btnVis=new BaseTableNumbersVisitor(tNums)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>opNode.getLeftOperand();accept;[btnVis]</InnerMethodInvoke>
                <InnerMethodInvoke>tNums;clearAll;[]</InnerMethodInvoke>
                <InnerMethodInvoke>opNode.getRightOperand();accept;[btnVis]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isJoinPredicate</MethodName>
            <MethodComment>/** 
 * Is this predicate a join predicate?  In order to be so, it must be a binary relational operator node that has a column reference on both sides.
 * @return Whether or not this is a join predicate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryRelationalOperatorNode [opNode=(BinaryRelationalOperatorNode)getAndNode().getLeftOperand()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPredScopedForResultSet</MethodName>
            <MethodComment>/** 
 * If this predicate's operator is a BinaryRelationalOperatorNode, then look at the operands and return a new, equivalent predicate that is "scoped" to the received ResultSetNode.  By "scoped" we mean that the operands, which shold be column references, have been mapped to the appropriate result columns in the received RSN. This is useful for pushing predicates from outer queries down into inner queries, in which case the column references need to be remapped. For example, let V1 represent select i,j from t1 UNION select i,j from t2 and V2 represent select a,b from t3 UNION select a,b from t4 Then assume we have the following query: select * from V1, V2 where V1.j = V2.b Let's further assume that this Predicate object represents the "V1.j = V2.b" operator and that the childRSN we received as a parameter represents one of the subqueries to which we want to push the predicate; let's say it's: select i,j from t1 Then this method will return a new predicate whose binary operator represents the expression "T1.j = V2.b" (that is, V1.j will be mapped to the corresponding column in T1).  For more on how that mapping is made, see the "getScopedOperand()" method in BinaryRelationalOperatorNode.java. ASSUMPTION: We should only get to this method if we know that at least one operand in this predicate can and should be mapped to the received childRSN.  For an example of where that check is made, see the pushOptPredicate() method in SetOperatorNode.java.
 * @param parentRSNsTables Set of all table numbers referenced bythe ResultSetNode that is _parent_ to the received childRSN. We need this to make sure we don't scope the operands to a ResultSetNode to which they don't apply.
 * @param childRSN The result set node for which we want to createa scoped predicate.
 * @param whichRC If not -1 then this tells us which ResultColumnin the received childRSN we need to use for the scoped predicate; if -1 then the column position of the scoped column reference will be stored in this array and passed back to the caller.
 * @return A new predicate whose operands have been scoped to thereceived childRSN.
 */
</MethodComment>
            <ReturnType>Predicate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentRSNsTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>childRSN</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whichRC</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [trueNode=new BooleanConstantNode(true,getContextManager())]</InnerVar>
                <InnerVar>BinaryRelationalOperatorNode [opNode=(BinaryRelationalOperatorNode)getAndNode().getLeftOperand()]</InnerVar>
                <InnerVar>BinaryRelationalOperatorNode [newOpNode=new BinaryRelationalOperatorNode(opNode.kind,opNode.getScopedOperand(BinaryRelationalOperatorNode.LEFT,parentRSNsTables,childRSN,whichRC),opNode.getScopedOperand(BinaryRelationalOperatorNode.RIGHT,parentRSNsTables,childRSN,whichRC),opNode.getForQueryRewrite(),getContextManager())]</InnerVar>
                <InnerVar>AndNode [newAnd=new AndNode(newOpNode,trueNode,getContextManager())]</InnerVar>
                <InnerVar>JBitSet [tableMap=new JBitSet(childRSN.getReferencedTableMap().size())]</InnerVar>
                <InnerVar>Predicate [newPred=new Predicate(newAnd,tableMap,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newOpNode;bindComparisonOperator;[]</InnerMethodInvoke>
                <InnerMethodInvoke>newAnd;postBindFixup;[]</InnerMethodInvoke>
                <InnerMethodInvoke>newAnd;categorize;[tableMap, false]</InnerMethodInvoke>
                <InnerMethodInvoke>newPred;clearScanFlags;[]</InnerMethodInvoke>
                <InnerMethodInvoke>newPred;copyFields;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>newPred;setPushable;[getPushable()]</InnerMethodInvoke>
                <InnerMethodInvoke>newPred;markAsScopedForPush;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsScopedForPush</MethodName>
            <MethodComment>/** 
 * Indicate that this predicate is a scoped copy of some other predicate (i.e. it was created as the result of a call to getPredScopedForResultSet() on some other predicate).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isScopedForPush</MethodName>
            <MethodComment>/** 
 * Return whether or not this predicate is a scoped copy of another predicate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapScopedPred</MethodName>
            <MethodComment>/** 
 * When remapping a "normal" (i.e. non-scoped) predicate both of the predicate's operands are remapped and that's it. But when remapping a scoped predicate, things are slightly different.  This method handles remapping of scoped predicates. We know that, for a scoped predicate, exactly one operand has been scoped for a specific target result set; the other operand is pointing to some other instance of FromTable with which the target result set is to be joined (see getScopedOperand() in BinaryRelationalOperatorNode.java).  For every level of the query through which the scoped predicate is pushed, we have to perform a remap operation of the scoped operand.  We do *not*, however, remap the non-scoped operand.  The reason is that the non-scoped operand is already pointing to the result set against which it must be evaluated.  As the scoped predicate is pushed down the query tree, the non-scoped operand should not change where it's pointing and thus should not be remapped.  For example, assume we have a query whose tree has the following form: SELECT[0]  /     \  PRN      PRN  |        | SELECT[4]   UNION |           /   \  PRN     SELECT[1]  SELECT[2]  |         |          |  [FBT:T1]     PRN        PRN  |          | SELECT[3]  [FromBaseTable:T2] | PRN | [FromBaseTable:T3] Assume also that we have some predicate "SELECT[4].i = &lt;UNION&gt;.j". If the optimizer decides to push the predicate to the UNION node, it (the predicate) will be scoped to the UNION's children, yielding something like "SELECT[4].i = SELECT[1].j" for the left child and "SELECT[4].i = SELECT[2].j" for the right child. These scoped predicates will then be pushed to the PRNs above SELECT[3] and T2, respectively.  As part of that pushing process a call to PRN.pushOptPredicate() will occur, which brings us to this method.  So let's assume we're here for the scoped predicate "SELECT[4].i = SELECT[1].j".  Then we want to remap the scoped operand, "SELECT[1].j", so that it will point to the correct column in "SELECT[3]".  We do NOT, however, want to remap the non-scoped operand "SELECT[4].i" because that operand is already pointing to the correct result set--namely, to a column in SELECT[4].  That non-scoped operand should not change regardless of how far down the UNION subtree the scoped predicate is pushed. If we did try to remap the non-scoped operand, it would end up pointing to result sets too low in the tree, which could lead to execution-time errors.  So when we remap a scoped predicate, we have to make sure we only remap the scoped operand.  That's what this method does.
 * @return True if this predicate is a scoped predicate, in whichcase we performed a one-sided remap.  False if the predicate is not scoped; the caller can then make the calls to perform a "normal" remap on this predicate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryRelationalOperatorNode [binRelOp=(BinaryRelationalOperatorNode)andNode.getLeftOperand()]</InnerVar>
                <InnerVar>ValueNode [operand]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isScopedToSourceResultSet</MethodName>
            <MethodComment>/** 
 * Return true if this predicate is scoped AND the scoped operand is a ColumnReference that points to a source result set.  If the scoped operand is not a ColumnReference that points to a source result set then it must be pointing to some kind of expression, such as a literal (ex. 'strlit'), an aggregate value (ex. "count(*)"), or the result of a function (ex. "sin(i)") or operator (ex. "i+1"). This method is used when pushing predicates to determine how far down the query tree a scoped predicate needs to be pushed to allow for successful evaluation of the scoped operand.  If the scoped operand is not pointing to a source result set then it should not be pushed any further down tree.  The reason is that evaluation of the expression to which the operand is pointing may depend on other values from the current level in the tree (ex. "sin(i)" depends on the value of "i", which could be a column at the predicate's current level).  If we pushed the predicate further down, those values could become inaccessible, leading to execution-time errors. If, on the other hand, the scoped operand *is* pointing to a source result set, then we want to push it further down the tree until it reaches that result set, which allows evaluation of this predicate to occur as close to store as possible.  This method doesn't actually do the push, it just returns "true" and then the caller can push as appropriate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BinaryRelationalOperatorNode [binRelOp=(BinaryRelationalOperatorNode)andNode.getLeftOperand()]</InnerVar>
                <InnerVar>ValueNode [operand=binRelOp.getLeftOperand()]</InnerVar>
                <InnerVar>ValueNode [exp]</InnerVar>
                <InnerVar>ColumnReference [cRef=(ColumnReference)operand]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRelationalOpPredicate</MethodName>
            <MethodComment>/** 
 * Return whether or not this predicate corresponds to a legitimate relational operator.
 * @return False if there is no relational operator for this predicateOR if this predicate is an internal "probe predicate" (in which case it "looks" like we have a relational operator but in truth it's a disguised IN-list operator). True otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInListProbePredicate</MethodName>
            <MethodComment>/** 
 * Return whether or not this predicate is an IN-list probe predicate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceInList</MethodName>
            <MethodComment>/** 
 * If this predicate corresponds to an IN-list, return the underlying InListOperatorNode from which it was built.  There are two forms to check for: 1. This predicate is an IN-list "probe predicate", in which case the underlying InListOpNode is stored within the binary relational operator that is the left operand of this predicate's AND node. 2. This predicate corresponds to an IN-list that could _not_ be transformed into a "probe predicate" (i.e. the IN-list contains one or more non-parameter, non-constant values). In that case the underlying InListOpNode is simply the left operand of this predicate's AND node. If this predicate does not correspond to an IN-list in any way, this method will return null.
 */
</MethodComment>
            <ReturnType>InListOperatorNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceInList</MethodName>
            <MethodComment>/** 
 * Does the work of getSourceInList() above, but can also be called directly with an argument to indicate whether or not we should limit ourselves to probe predicates.
 * @param probePredOnly If true, only get the source IN list for thispredicate *if* it is an IN-list probe predicate.  If false, return the underlying InListOperatorNode (if it exists) regardless of whether this is a probe predicate or an un-transformed IN-list pred.
 * @return Underlying InListOp for this predicate (depending onthe value of probePredOnly), or null if this predicate does not correspond to an IN-list in any way.
 */
</MethodComment>
            <ReturnType>InListOperatorNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>probePredOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [vn=andNode.getLeftOperand()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>