<Class>
    <Id>2174</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>DMLModStatementNode</ClassName>
    <SuperClass>DMLStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DMLModStatementNode  /** 
 * A DMLStatement for a table modification: to wit, INSERT UPDATE or DELETE.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>targetVTI</FieldName>
            <FieldType>FromVTI</FieldType>
        </Field>
        <Field>
            <FieldName>targetTableName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>resultColumnList</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>lockMode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>fkInfo</FieldName>
            <FieldType>FKInfo[]</FieldType>
        </Field>
        <Field>
            <FieldName>triggerInfo</FieldName>
            <FieldType>TriggerInfo</FieldType>
        </Field>
        <Field>
            <FieldName>targetTableDescriptor</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>indicesToMaintain</FieldName>
            <FieldType>IndexRowGenerator[]</FieldType>
        </Field>
        <Field>
            <FieldName>indexConglomerateNumbers</FieldName>
            <FieldType>long[]</FieldType>
        </Field>
        <Field>
            <FieldName>indexNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>relevantCdl</FieldName>
            <FieldType>ConstraintDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>relevantTriggers</FieldName>
            <FieldType>TriggerDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>requiresDeferredProcessing</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>statementType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>bound</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>checkConstraints</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>fkSchemaNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>fkTableNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>fkRefActions</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>fkColDescriptors</FieldName>
            <FieldType>ColumnDescriptorList[]</FieldType>
        </Field>
        <Field>
            <FieldName>fkIndexConglomNumbers</FieldName>
            <FieldType>long[]</FieldType>
        </Field>
        <Field>
            <FieldName>isDependentTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>fkColArrays</FieldName>
            <FieldType>int[][]</FieldType>
        </Field>
        <Field>
            <FieldName>synonymTableName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>matchingClause</FieldName>
            <FieldType>MatchingClauseNode</FieldType>
        </Field>
        <Field>
            <FieldName>dependentTables</FieldName>
            <FieldType>Set</FieldType>
        </Field>
        <Field>
            <FieldName>dependentTables</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DMLModStatementNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>matchingClause</ParamName>
                    <ParamType>MatchingClauseNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DMLModStatementNode</MethodName>
            <MethodComment>/** 
 * Constructor for a DMLModStatementNode -- delegate to DMLStatementNode
 * @param resultSet	A ResultSetNode for the result set of theDML statement
 * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
 * @param statementType used by nodes that allocate a DMLMod directly(rather than inheriting it).
 * @param cm        The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>matchingClause</ParamName>
                    <ParamType>MatchingClauseNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statementType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inMatchingClause</MethodName>
            <MethodComment>/** 
 * Returns true if this DMLModStatement a [ NOT ] MATCHED action of a MERGE statement 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTarget</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetName</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateCodeForTemporaryTable</MethodName>
            <MethodComment>/** 
 * If the DML is on a temporary table, generate the code to mark temporary table as modified in the current UOW. At rollback transaction (or savepoint), we will check if the temporary table was modified in that UOW. If yes, we will remove all the data from the temporary table
 * @param acb	The ActivationClassBuilder for the class being built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyTargetTable</MethodName>
            <MethodComment>/** 
 * Verify the target table.  Get the TableDescriptor if the target table is not a VTI.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataDictionary [dataDictionary=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAtomic</MethodName>
            <MethodComment>/** 
 * INSERT/UPDATE/DELETE are always atomic.
 * @return true 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get a schema descriptor for the given table. Uses this.targetTableName.
 * @return Schema Descriptor
 * @exception StandardException	throws on schema namethat doesn't exist	
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [sd]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReadColMap</MethodName>
            <MethodComment>/** 
 * Get a map to efficiently find heap columns from a compressed set of read columns. The returns a map such that &lt;PRE&gt; map[heapColId (0 based)] -&amp;gt; readCol id (0 based) &lt;/PRE&gt;
 * @param column_map_length The number of columns(ints) in the map.
 * @param readColsBitSet A language style (1 based) bit set with bits forread heap columns set. RESOLVE: Replace this with a call to RowUtil when the store and the language both use 0 base or 1 base offsets for columns. Today we can't use the store function because we have a 1 based FormatableBitSet.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>column_map_length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>readColsBitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [partial_col_cnt=0]</InnerVar>
                <InnerVar>int [column_map[]=new int[column_map_length]]</InnerVar>
                <InnerVar>int [readColsBitSetSize=readColsBitSet.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultColumnList</MethodName>
            <MethodComment>/** 
 * Get and bind the ResultColumnList representing the columns in the target table, given the table's name.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultColumnList</MethodName>
            <MethodComment>/** 
 * Get and bind the ResultColumnList representing the columns in the target table, given the table's name.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromBaseTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputRcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromBaseTable [fbt=new FromBaseTable(synonymTableName != null ? synonymTableName : targetTableName,null,null,null,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>fbt;bindNonVTITables;[getDataDictionary(), new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getResultColumnList;[fbt, inputRcl]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultColumnList</MethodName>
            <MethodComment>/** 
 * Get and bind the ResultColumnList representing the columns in the target table, given a FromTable for the target table.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromBaseTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputRcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseAndBindGenerationClauses</MethodName>
            <MethodComment>/** 
 * Parse and bind the generating expressions of computed columns.
 * @param dataDictionary    metadata
 * @param targetTableDescriptor metadata for the table that has the generated columns
 * @param sourceRCL  the tuple stream which drives the INSERT or UPDATE
 * @param targetRCL  the row in the table that's being INSERTed or UPDATEd
 * @param forUpdate true if this is an UPDATE. false otherwise.
 * @param updateResultSet more information on the tuple stream driving the UPDATE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateResultSet</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
                <InnerVar>int [count=targetRCL.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseGenerationClause</MethodName>
            <MethodComment>/** 
 * Parse the generation clause for a column.
 * @param clauseText  Text of the generation clause
 * @return	The parsed expression as a query tree.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clauseText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parser [p]</InnerVar>
                <InnerVar>ValueNode [clauseTree]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>String [select="SELECT " + clauseText + " FROM "+ td.getQualifiedName()]</InnerVar>
                <InnerVar>CompilerContext [newCC=lcc.pushCompilerContext()]</InnerVar>
                <InnerVar>Visitable [qt=p.parseStatement(select)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;popCompilerContext;[newCC]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindConstraints</MethodName>
            <MethodComment>/** 
 * Gets and binds all the constraints for an INSERT/UPDATE/DELETE. First finds the constraints that are relevant to this node. This is done by calling getAllRelevantConstriants().  If getAllRelevantConstraints() has already been called, then this list is used.  Then it creates appropriate  dependencies. Then binds check constraints.  It also  generates the array of FKInfo items that are used in code generation. Note: we have a new flag here to see if defer processing is enabled or not, the only scenario that is disabled is when we reapply the reply message we get from the source
 * @param dataDictionary		The DataDictionary
 * @param targetTableDescriptor	The TableDescriptor
 * @param dependent			Parent object that will depend on all the constraintsthat we look up. If this argument is null, then we use the default dependent (the statement being compiled).
 * @param sourceRCL				RCL of the table being changed
 * @param changedColumnIds		If null, all columns being changed, otherwise arrayof 1-based column ids for columns being changed
 * @param readColsBitSet		bit set for the read scan
 * @param includeTriggers		whether triggers are included in the processing
 * @param hasDeferrableCheckConstraints OUT semantics: set element 0 to true if the target table has any deferrable CHECK constraints
 * @return	The bound, ANDed check constraints as a query tree.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerFactory</ParamName>
                    <ParamType>OptimizerFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependent</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>readColsBitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>includeTriggers</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasDeferrableCheckConstraints</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compilerContext;pushCurrentPrivType;[Authorizer.NULL_PRIV]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindRowScopedExpression</MethodName>
            <MethodComment>/** 
 * Binds an already parsed expression that only involves columns in a single row. E.g., a check constraint or a generation clause.
 * @param optimizerFactory      The optimizer factory
 * @param cm                    The context manager
 * @param targetTableDescriptor The TableDescriptor for the constrainedtable
 * @param sourceRCL             Result columns
 * @param expression            Parsed query tree for row scoped expression
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizerFactory</ParamName>
                    <ParamType>OptimizerFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [targetTableName=makeTableName(cm,targetTableDescriptor.getSchemaName(),targetTableDescriptor.getName())]</InnerVar>
                <InnerVar>FromList [fakeFromList=new FromList(optimizerFactory.doJoinOrderOptimization(),cm)]</InnerVar>
                <InnerVar>FromBaseTable [table=new FromBaseTable(targetTableName,null,sourceRCL,null,cm)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>table;setTableNumber;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>fakeFromList;addFromTable;[table]</InnerMethodInvoke>
                <InnerMethodInvoke>expression;bindExpression;[fakeFromList, (SubqueryList)null, (List&lt;AggregateNode&gt;)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasCheckConstraints</MethodName>
            <MethodComment>/** 
 * Determine whether or not there are check constraints on the specified table.
 * @param dd	The DataDictionary to use
 * @param td	The TableDescriptor for the table
 * @return Whether or not there are check constraints on the specified table.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [cdl=dd.getConstraintDescriptors(td)]</InnerVar>
                <InnerVar>ConstraintDescriptorList [ccCDL=cdl.getSubList(DataDictionary.CHECK_CONSTRAINT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasGenerationClauses</MethodName>
            <MethodComment>/** 
 * Determine whether or not there are generated columns in the specified table.
 * @param td	The TableDescriptor for the table
 * @return Whether or not there are generated columns in the specified table.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptorList [list=td.getGeneratedColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateCheckTree</MethodName>
            <MethodComment>/** 
 * Get the ANDing of all appropriate check constraints as 1 giant query tree. Makes the calling object (usually a Statement) dependent on all the constraints.
 * @param cdl               The constraint descriptor list
 * @param td				The TableDescriptor
 * @return	The ANDing of all appropriate check constraints as a query tree.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasDeferrable</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [ccCDL=cdl.getSubList(DataDictionary.CHECK_CONSTRAINT)]</InnerVar>
                <InnerVar>int [ccCDLSize=ccCDL.size()]</InnerVar>
                <InnerVar>ValueNode [checkTree=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateFKInfo</MethodName>
            <MethodComment>/** 
 * Generate the FKInfo structures used during code generation. For each constraint that isn't a check constraint, add another one of these FKInfo structures and then package them up into a single array.
 * @param cdl				The constraint descriptor list
 * @param dd				The DataDictionary
 * @param td				The TableDescriptor
 * @param readColsBitSet 	columns read
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>readColsBitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;FKInfo&gt; [fkList=new ArrayList&lt;FKInfo&gt;()]</InnerVar>
                <InnerVar>int [type]</InnerVar>
                <InnerVar>UUID[] [uuids]</InnerVar>
                <InnerVar>long[] [conglomNumbers]</InnerVar>
                <InnerVar>String[] [fkNames]</InnerVar>
                <InnerVar>ConstraintDescriptorList [fkcdl]</InnerVar>
                <InnerVar>ReferencedKeyConstraintDescriptor [refcd]</InnerVar>
                <InnerVar>boolean[] [isSelfReferencingFK]</InnerVar>
                <InnerVar>ConstraintDescriptorList [activeList=dd.getActiveConstraintDescriptors(cdl)]</InnerVar>
                <InnerVar>int[] [rowMap=getRowMap(readColsBitSet,td)]</InnerVar>
                <InnerVar>int[] [raRules]</InnerVar>
                <InnerVar>boolean[] [deferrable]</InnerVar>
                <InnerVar>UUID[] [fkIds]</InnerVar>
                <InnerVar>ArrayList&lt;String&gt; [refSchemaNames=new ArrayList&lt;String&gt;(1)]</InnerVar>
                <InnerVar>ArrayList&lt;String&gt; [refTableNames=new ArrayList&lt;String&gt;(1)]</InnerVar>
                <InnerVar>ArrayList&lt;Long&gt; [refIndexConglomNum=new ArrayList&lt;Long&gt;(1)]</InnerVar>
                <InnerVar>ArrayList&lt;Integer&gt; [refActions=new ArrayList&lt;Integer&gt;(1)]</InnerVar>
                <InnerVar>ArrayList&lt;ColumnDescriptorList&gt; [refColDescriptors=new ArrayList&lt;ColumnDescriptorList&gt;(1)]</InnerVar>
                <InnerVar>ArrayList&lt;int[]&gt; [fkColMap=new ArrayList&lt;int[]&gt;(1)]</InnerVar>
                <InnerVar>int [activeSize=activeList.size()]</InnerVar>
                <InnerVar>int [size=refActions.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fkSetupArrays</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkcd</ParamName>
                    <ParamType>ForeignKeyConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuids</ParamName>
                    <ParamType>UUID[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomNumbers</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isSelfReferencingFK</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>raRules</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isDeferrable</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkIds</ParamName>
                    <ParamType>UUID[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateTriggerInfo</MethodName>
            <MethodComment>/** 
 * Generate the TriggerInfo structures used during code generation.
 * @param triggerList				The trigger descriptor list
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerList</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFKInfo</MethodName>
            <MethodComment>/** 
 * Return the FKInfo structure.  Just  a little wrapper to make sure we don't try to access it until after binding.
 * @return the array of fkinfos
 */
</MethodComment>
            <ReturnType>FKInfo[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerInfo</MethodName>
            <MethodComment>/** 
 * Return the TriggerInfo structure.  Just  a little wrapper to make sure we don't try to access it until after binding.
 * @return the trigger info
 */
</MethodComment>
            <ReturnType>TriggerInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCheckConstraints</MethodName>
            <MethodComment>/** 
 * Get the check constraints for this node
 * @return the check constraints, may be null
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTriggerDependencies</MethodName>
            <MethodComment>/** 
 * Makes the calling object (usually a Statement) dependent on all the constraints.
 * @param tdl				The trigger descriptor list
 * @param dependent			Parent object that will depend on all the constraintsthat we look up. If this argument is null, then we use the default dependent (the statement being compiled).
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tdl</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependent</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllRelevantTriggers</MethodName>
            <MethodComment>/** 
 * Get all the triggers relevant to this DML operation
 * @param dd				The data dictionary
 * @param td				The TableDescriptor
 * @param changedColumnIds	If null, all columns being changed, otherwise arrayof 1-based column ids for columns being changed
 * @param includeTriggers	whether we allow trigger processing or not forthis table
 * @return	the constraint descriptor list
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>includeTriggers</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>td;getAllRelevantTriggers;[statementType, changedColumnIds, relevantTriggers]</InnerMethodInvoke>
                <InnerMethodInvoke>null;adjustDeferredFlag;[relevantTriggers.size() &gt; 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustDeferredFlag</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>adjustment</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConstraintDependencies</MethodName>
            <MethodComment>/** 
 * Get all of our dependents due to a constraint. Makes the calling object (usually a Statement) dependent on all the constraints.
 * @param dd				The data dictionary
 * @param cdl				The constraint descriptor list
 * @param dependent			Parent object that will depend on all the constraintsthat we look up. If this argument is null, then we use the default dependent (the statement being compiled).
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependent</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllRelevantConstraints</MethodName>
            <MethodComment>/** 
 * Get all the constraints relevant to this DML operation
 * @param dd				The DataDictionary
 * @param td				The TableDescriptor
 * @param changedColumnIds	If null, all columns being changed, otherwise arrayof 1-based column ids for columns being changed
 * @return	the constraint descriptor list
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean[] [needsDeferredProcessing=new boolean[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>td;getAllRelevantConstraints;[statementType, changedColumnIds, needsDeferredProcessing, relevantCdl]</InnerMethodInvoke>
                <InnerMethodInvoke>null;adjustDeferredFlag;[needsDeferredProcessing[0]]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiresDeferredProcessing</MethodName>
            <MethodComment>/** 
 * Does this DML Node require deferred processing? Set to true if we have triggers or referential constraints that need deferred processing.
 * @return true/false 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCheckConstraint</MethodName>
            <MethodComment>/** 
 * Parse a check constraint and turn it into a query tree.
 * @param checkConstraintText	Text of CHECK CONSTRAINT.
 * @param td					The TableDescriptor for the table the the constraint is on.
 * @return	The parsed check constraint as a query tree.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>checkConstraintText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parser [p]</InnerVar>
                <InnerVar>ValueNode [checkTree]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>String [select="SELECT * FROM " + td.getQualifiedName() + " WHERE "+ checkConstraintText]</InnerVar>
                <InnerVar>CompilerContext [newCC=lcc.pushCompilerContext()]</InnerVar>
                <InnerVar>Visitable [qt=p.parseStatement(select)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;popCompilerContext;[newCC]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateCheckConstraints</MethodName>
            <MethodComment>/** 
 * Generate the code to evaluate a tree of CHECK CONSTRAINTS.
 * @param checkConstraints	Bound query tree of ANDed check constraints.
 * @param ecb					Expression Class Builder
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>checkConstraints</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ecb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateCheckConstraints</MethodName>
            <MethodComment>/** 
 * Generate a method to evaluate a tree of CHECK CONSTRAINTS.
 * @param checkConstraints	Bound query tree of ANDed check constraints.
 * @param ecb					Expression Class Builder
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>MethodBuilder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>checkConstraints</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ecb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [userExprFun=ecb.newUserExprFun()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>checkConstraints;generateExpression;[ecb, userExprFun]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;complete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateGenerationClauses</MethodName>
            <MethodComment>/** 
 * Generate the code to evaluate all of the generation clauses. If there are generation clauses, this routine builds an Activation method which evaluates the generation clauses and fills in the computed columns.
 * @param rcl  describes the row of expressions to be put into the bas table
 * @param resultSetNumber  index of base table into array of ResultSets
 * @param isUpdate true if this is for an UPDATE statement
 * @param ecb code generation state variable
 * @param mb the method being generated
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ecb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [hasGenerationClauses=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateGenerationClauses</MethodName>
            <MethodComment>/** 
 * Generate a method to compute all of the generation clauses in a row.
 * @param rcl  describes the row of expressions to be put into the bas table
 * @param rsNumber  index of base table into array of ResultSets
 * @param isUpdate true if this is for an UPDATE statement
 * @param ecb code generation state variable
 */
</MethodComment>
            <ReturnType>MethodBuilder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rsNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ecb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodBuilder [userExprFun=ecb.newUserExprFun()]</InnerVar>
                <InnerVar>int [size=rcl.size()]</InnerVar>
                <InnerVar>int [startColumn=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>userExprFun;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;push;[rsNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;callMethod;[VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getCurrentRow", ClassName.Row, 1]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;complete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeStatement</MethodName>
            <MethodComment>/** 
 * Generate an optimized QueryTree from a bound QueryTree.  Actually, it can annotate the tree in place rather than generate a new tree, but this interface allows the root node of the optimized QueryTree to be different from the root node of the bound QueryTree. For non-optimizable statements, this method is a no-op. Throws an exception if the tree is not bound, or if the binding is out of date.
 * @exception StandardException         Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAffectedIndexes</MethodName>
            <MethodComment>/** 
 * Get the list of indexes that must be updated by this DML statement. WARNING: As a side effect, it creates dependencies on those indexes.
 * @param td	The table descriptor for the table being updated
 * @param updatedColumns	The updated column list.  If not update, null
 * @param colBitSet			a 1 based bit set of the columns in the list
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updatedColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colBitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;ConglomerateDescriptor&gt; [conglomerates=new ArrayList&lt;ConglomerateDescriptor&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DMLModStatementNode;getXAffectedIndexes;[td, updatedColumns, colBitSet, conglomerates]</InnerMethodInvoke>
                <InnerMethodInvoke>null;markAffectedIndexes;[conglomerates]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXAffectedIndexes</MethodName>
            <MethodComment>/** 
 * Marks which indexes are affected by an UPDATE of the desired shape. Is passed a list of updated columns. Does the following: 1)	finds all indices which overlap the updated columns 2)	adds the index columns to a bitmap of affected columns 3)	adds the index descriptors to a list of conglomerate descriptors.
 * @param updatedColumns	a list of updated columns
 * @param colBitSet		OUT: evolving bitmap of affected columns
 * @param conglomerates   OUT: list of affected indices
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updatedColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colBitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerates</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cds=baseTable.getConglomerateDescriptors()]</InnerVar>
                <InnerVar>long[] [distinctConglomNums=new long[cds.length - 1]]</InnerVar>
                <InnerVar>int [distinctCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAffectedIndexes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>affectedConglomerates</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor [cd]</InnerVar>
                <InnerVar>int [indexCount=affectedConglomerates.size()]</InnerVar>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapReferencedColumns</MethodName>
            <MethodComment>/** 
 * Remap referenced columns in the cd to reflect the passed in row map.
 * @param cd 		constraint descriptor
 * @param rowMap	1 based row map 
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowMap</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [oldCols=cd.getReferencedColumns()]</InnerVar>
                <InnerVar>int[] [newCols=new int[oldCols.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowMap</MethodName>
            <MethodComment>/** 
 * Get a integer based row map from a bit set.
 * @param bitSet
 * @param td 
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bitSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=td.getMaxColumnID()]</InnerVar>
                <InnerVar>int[] [iArray=new int[size + 1]]</InnerVar>
                <InnerVar>int [j=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRefActionInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fkIndexConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkColArray</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentResultSetId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependentScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resultSet;setRefActionInfo;[fkIndexConglomId, fkColArray, parentResultSetId, dependentScan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalizeSynonymColumns</MethodName>
            <MethodComment>/** 
 * Normalize synonym column references to have the name of the base table. 
 * @param rcl	           The result column list of the target table
 * @param targetTableName  The target tablename
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [synTableName=synonymTableName.getTableName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>