<Class>
    <Id>298</Id>
    <Package>org.apache.derby.impl.drda</Package>
    <ClassName>DRDAConnThread</ClassName>
    <SuperClass>Thread</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DRDAConnThread  /** 
 * This class translates DRDA protocol from an application requester to JDBC for Derby and then translates the results from Derby to DRDA for return to the application requester.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>leftBrace</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>rightBrace</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NULL_VALUE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>SYNTAX_ERR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>MGRLVL_3</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MGRLVL_4</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MGRLVL_5</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MGRLVL_6</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MGRLVL_7</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMMIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ROLLBACK</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>correlationID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sockis</FieldName>
            <FieldType>InputStream</FieldType>
        </Field>
        <Field>
            <FieldName>sockos</FieldName>
            <FieldType>OutputStream</FieldType>
        </Field>
        <Field>
            <FieldName>reader</FieldName>
            <FieldType>DDMReader</FieldType>
        </Field>
        <Field>
            <FieldName>writer</FieldName>
            <FieldType>DDMWriter</FieldType>
        </Field>
        <Field>
            <FieldName>xaProto</FieldName>
            <FieldType>DRDAXAProtocol</FieldType>
        </Field>
        <Field>
            <FieldName>ACCRDB_REQUIRED</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_REQUIRED_LEN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentRequiredLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>required</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>server</FieldName>
            <FieldType>NetworkServerControlImpl</FieldType>
        </Field>
        <Field>
            <FieldName>session</FieldName>
            <FieldType>Session</FieldType>
        </Field>
        <Field>
            <FieldName>timeSlice</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>logConnections</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>sendWarningsOnCNTQRY</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>close</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>logStream</FieldName>
            <FieldType>HeaderPrintWriter</FieldType>
        </Field>
        <Field>
            <FieldName>appRequester</FieldName>
            <FieldType>AppRequester</FieldType>
        </Field>
        <Field>
            <FieldName>database</FieldName>
            <FieldType>Database</FieldType>
        </Field>
        <Field>
            <FieldName>sqlamLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>diagnosticLevel</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>unknownManagers</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>unknownManagers</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>knownManagers</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>knownManagers</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>databaseAccessException</FieldName>
            <FieldType>SQLException</FieldType>
        </Field>
        <Field>
            <FieldName>prevPkgnamcsn</FieldName>
            <FieldType>Pkgnamcsn</FieldType>
        </Field>
        <Field>
            <FieldName>rdbnam</FieldName>
            <FieldType>DRDAString</FieldType>
        </Field>
        <Field>
            <FieldName>rdbcolid</FieldName>
            <FieldType>DRDAString</FieldType>
        </Field>
        <Field>
            <FieldName>pkgid</FieldName>
            <FieldType>DRDAString</FieldType>
        </Field>
        <Field>
            <FieldName>pkgcnstkn</FieldName>
            <FieldType>DRDAString</FieldType>
        </Field>
        <Field>
            <FieldName>pkgsn</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIMEOUT_STATEMENT</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>pendingStatementTimeout</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>decryptionManager</FieldName>
            <FieldType>DecryptionManager</FieldType>
        </Field>
        <Field>
            <FieldName>myPublicKey</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>myTargetSeed</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>prdIdBytes</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>eod00000</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>eod02000</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>nullSQLState</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>errD5_D6</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>warn0_warnA</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>AUTHENTICATION_PROVIDER_BUILTIN_CLASS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>AUTHENTICATION_PROVIDER_NONE_CLASS</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>dummy</FieldName>
            <FieldType>DRDAProtocolExceptionInfo</FieldType>
        </Field>
        <Field>
            <FieldName>deferredReset</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>gmtCalendar</FieldName>
            <FieldType>Calendar</FieldType>
        </Field>
        <Field>
            <FieldName>SQLERRMC_TOKEN_DELIMITER</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DRDAConnThread</MethodName>
            <MethodComment>/** 
 * Create a new Thread for processing session requests
 * @param session Session requesting processing
 * @param server  Server starting thread
 * @param timeSlice timeSlice for thread
 * @param logConnections
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>session</ParamName>
                    <ParamType>Session</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>server</ParamName>
                    <ParamType>NetworkServerControlImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeSlice</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>logConnections</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initialize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment>/** 
 * Main routine for thread, loops until the thread is closed Gets a session, does work for the session
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Session [prevSession]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>server;removeThread;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInputStream</MethodName>
            <MethodComment>/** 
 * Get input stream
 * @return input stream
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOutputStream</MethodName>
            <MethodComment>/** 
 * Get output stream
 * @return output stream
 */
</MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProductIDBytes</MethodName>
            <MethodComment>/** 
 * Get product id as bytes 
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReader</MethodName>
            <MethodComment>/** 
 * get DDMReader
 * @return DDMReader for this thread
 */
</MethodComment>
            <ReturnType>DDMReader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWriter</MethodName>
            <MethodComment>/** 
 * get  DDMWriter 
 * @return DDMWriter for this thread
 */
</MethodComment>
            <ReturnType>DDMWriter</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrelationID</MethodName>
            <MethodComment>/** 
 * Get correlation id
 * @return correlation id
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSession</MethodName>
            <MethodComment>/** 
 * Get session we are working on
 * @return session
 */
</MethodComment>
            <ReturnType>Session</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabase</MethodName>
            <MethodComment>/** 
 * Get Database we are working on
 * @return database
 */
</MethodComment>
            <ReturnType>Database</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getServer</MethodName>
            <MethodComment>/** 
 * Get server
 * @return server
 */
</MethodComment>
            <ReturnType>NetworkServerControlImpl</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCrrtkn</MethodName>
            <MethodComment>/** 
 * Get correlation token
 * @return crrtkn
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDbName</MethodName>
            <MethodComment>/** 
 * Get database name
 * @return database name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close DRDA  connection thread
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLogConnections</MethodName>
            <MethodComment>/** 
 * Set logging of connections
 * @param value value to set for logging connections
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTimeSlice</MethodName>
            <MethodComment>/** 
 * Set time slice value
 * @param value new value for time slice
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markCommunicationsFailure</MethodName>
            <MethodComment>/** 
 * Indicate a communications failure
 * @param arg1 - info about the communications failure
 * @param arg2 - info about the communications failure
 * @param arg3 - info about the communications failure
 * @param arg4 - info about the communications failure
 * @exception DRDAProtocolException  disconnect exception always thrown
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg3</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg4</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;markCommunicationsFailure;[null, arg1, arg2, arg3, arg4]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markCommunicationsFailure</MethodName>
            <MethodComment>/** 
 * Indicate a communications failure. Log to derby.log
 * @param e  - Source exception that was thrown
 * @param arg1 - info about the communications failure
 * @param arg2 - info about the communications failure
 * @param arg3 - info about the communications failure
 * @param arg4 - info about the communications failure
 * @exception DRDAProtocolException  disconnect exception always thrown
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Exception</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg3</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg4</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [oa={arg1,arg2,arg3,arg4}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwSyntaxrm</MethodName>
            <MethodComment>/** 
 * Syntax error
 * @param errcd     Error code
 * @param cpArg  code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>errcd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cpArg</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>agentError</MethodName>
            <MethodComment>/** 
 * Agent error - something very bad happened
 * @param msg   Message describing error
 * @exception DRDAProtocolException  newAgentError always thrown
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>missingCodePoint</MethodName>
            <MethodComment>/** 
 * Missing code point
 * @param codePoint  code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>println2Log</MethodName>
            <MethodComment>/** 
 * Print a line to the DB2j log
 * @param dbname  database name
 * @param drdaID    DRDA identifier
 * @param msg   message
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logStream;printlnWithHeader;["(DATABASE = " + dbname + "), (DRDAID = "+ drdaID+ "), "+ msg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeRDBNAM</MethodName>
            <MethodComment>/** 
 * Write RDBNAM
 * @param rdbnam    database name
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rdbnam</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CcsidManager [currentManager=writer.getCurrentCcsidManager()]</InnerVar>
                <InnerVar>int [len=Math.max(CodePoint.RDBNAM_LEN,currentManager.getByteLength(rdbnam))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeScalarPaddedString;[CodePoint.RDBNAM, rdbnam, len]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * Initialize class
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeForSession</MethodName>
            <MethodComment>/** 
 * Initialize for a new session
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;initialize;[this, session.dssTrace]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;reset;[session.dssTrace]</InnerMethodInvoke>
                <InnerMethodInvoke>reader;setEbcdicCcsid;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;setEbcdicCcsid;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sessionInitialState</MethodName>
            <MethodComment>/** 
 * In initial state for a session,  determine whether this is a command session or a DRDA protocol session.  A command session is for changing the configuration of the Net server, e.g., turning tracing on If it is a command session, process the command and close the session. If it is a DRDA session, exchange server attributes and change session state.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUpAndCloseResultSet</MethodName>
            <MethodComment>/** 
 * Cleans up and closes a result set if an exception is thrown when collecting QRYDTA in response to OPNQRY or CNTQRY.
 * @param stmt the DRDA statement to clean up
 * @param sqle the exception that was thrown
 * @param writerMark start index for the first DSS to clear fromthe output buffer
 * @exception DRDAProtocolException if a DRDA protocol error isdetected
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqle</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writerMark</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;errorInChain;[sqle]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processCommands</MethodName>
            <MethodComment>/** 
 * Process DRDA commands we can receive once server attributes have been exchanged.
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DRDAStatement [stmt=null]</InnerVar>
                <InnerVar>boolean [PRPSQLSTTfailed=false]</InnerVar>
                <InnerVar>boolean [checkSecurityCodepoint=session.requiresSecurityCodepoint()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>errorInChain</MethodName>
            <MethodComment>/** 
 * If there's a severe error in the DDM chain, and if the header indicates "terminate chain on error", we stop processing further commands in the chain nor do we send any reply for them.  In accordance to this, a SQLERRRM message  indicating the severe error must have been sent! (otherwise application requestor, such as JCC, would not terminate the receiving of chain replies.) Each DRDA command is processed independently. DRDA defines no interdependencies across chained commands. A command is processed the same when received within a set of chained commands or received separately.  The chaining was originally defined as a way to save network costs.
 * @param e     the SQLException raised
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>exchangeServerAttributes</MethodName>
            <MethodComment>/** 
 * Exchange server attributes with application requester
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;parseEXCSAT;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeEXCSATRD;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finalizeChain;[]</InnerMethodInvoke>
                <InnerMethodInvoke>session;setState;[Session.ATTEXC]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDRDAConnection</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>boolean [sessionOK=true]</InnerVar>
                <InnerVar>int [securityCheckCode=parseSECCHK()]</InnerVar>
                <InnerVar>int [svrcod=parseACCRDB()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSECCHKRM;[securityCheckCode]</InnerMethodInvoke>
                <InnerMethodInvoke>null;verifyRequiredObject;[codePoint, CodePoint.ACCRDB]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>switchToUtf8</MethodName>
            <MethodComment>/** 
 * Switch the DDMWriter and DDMReader to UTF8 IF supported
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;setUtf8Ccsid;[]</InnerMethodInvoke>
                <InnerMethodInvoke>reader;setUtf8Ccsid;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>switchToEbcdic</MethodName>
            <MethodComment>/** 
 * Switch the DDMWriter and DDMReader to EBCDIC
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;setEbcdicCcsid;[]</InnerMethodInvoke>
                <InnerMethodInvoke>reader;setEbcdicCcsid;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeRDBfailure</MethodName>
            <MethodComment>/** 
 * Write RDB Failure Instance Variables SVRCOD - Severity Code - required RDBNAM - Relational Database name - required SRVDGN - Server Diagnostics - optional (not sent for now)
 * @param codePoint   codepoint of failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRdbAccessErrorCodePoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [sqlState=databaseAccessException.getSQLState()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAuthenticationException</MethodName>
            <MethodComment>/** 
 * There are multiple reasons for not getting a connection, and all these should throw SQLExceptions with SQL state 08004 according to the SQL standard. Since only one of these SQL states indicate that an authentication error has occurred, it is not enough to check that the SQL state is 08004 and conclude that authentication caused the exception to be thrown. This method tries to get a StandardException from the SQLException and use getMessageId on that object to check for authentication error instead of the SQL state we get from SQLExceptions#getSQLState. getMessageId returns the entire id as defined in SQLState (e.g. 08004.C.1), while getSQLState only return the 5 first characters (i.e. 08004 instead of 08004.C.1) If the SQLException isn't linked to a StandardException, the assumption that SQL State 08004 is caused by an authentication failure is followed even though this is not correct. This was the pre DERBY-3060 way of solving the issue.
 * @param sqlException The exception that is checked to see ifthis is really caused by an authentication failure
 * @return true if sqlException is (or has to be assumed to be)caused by an authentication failure, false otherwise.
 * @see SQLState
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [authFail=false]</InnerVar>
                <InnerVar>StandardException [se=StandardException.getArgumentFerry(sqlException)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyUserIdPassword</MethodName>
            <MethodComment>/** 
 * Verify userId and password Username and password is verified by making a connection to the database
 * @return security check code, 0 is O.K.
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConnFromDatabaseName</MethodName>
            <MethodComment>/** 
 * Get connection from a database name Username and password is verified by making a connection to the database
 * @return security check code, 0 is O.K.
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Properties [p=new Properties()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>p;put;[Attribute.DRDAID_ATTR, session.drdaID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSAT</MethodName>
            <MethodComment>/** 
 * Parses EXCSAT (Exchange Server Attributes) Instance variables EXTNAM(External Name)   - optional MGRLVLLS(Manager Levels) - optional SPVNAM(Supervisor Name) - optional SRVCLSNM(Server Class Name) - optional SRVNAM(Server Name) - optional, ignorable SRVRLSLV(Server Product Release Level) - optional, ignorable
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>String [strVal]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSAT2</MethodName>
            <MethodComment>/** 
 * Parses EXCSAT2 (Exchange Server Attributes) Instance variables EXTNAM(External Name)   - optional MGRLVLLS(Manager Levels) - optional SPVNAM(Supervisor Name) - optional SRVCLSNM(Server Class Name) - optional SRVNAM(Server Name) - optional, ignorable SRVRLSLV(Server Product Release Level) - optional, ignorable
 * @exception DRDAProtocolException This parses a second occurrence of an EXCSAT command The target must ignore the values for extnam, srvclsnm, srvnam and srvrlslv. I am also going to ignore spvnam since it should be null anyway. Only new managers can be added.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseMGRLVLLS</MethodName>
            <MethodComment>/** 
 * Parse manager levels Instance variables MGRLVL - repeatable, required CODEPOINT CCSIDMGR - CCSID Manager CMNAPPC - LU 6.2 Conversational Communications Manager CMNSYNCPT - SNA LU 6.2 SyncPoint Conversational Communications Manager CMNTCPIP - TCP/IP Communication Manager DICTIONARY - Dictionary RDB - Relational Database RSYNCMGR - Resynchronization Manager SECMGR - Security Manager SQLAM - SQL Application Manager SUPERVISOR - Supervisor SYNCPTMGR - Sync Point Manager VALUE On the second appearance of this codepoint, it can only add managers
 * @param time  1 for first time this is seen, 2 for subsequent ones
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>time</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [manager, managerLevel]</InnerVar>
                <InnerVar>int [currentLevel]</InnerVar>
                <InnerVar>ArrayList&lt;Integer&gt; [errorManagers=new ArrayList&lt;Integer&gt;()]</InnerVar>
                <InnerVar>ArrayList&lt;Integer&gt; [errorManagersLevel=new ArrayList&lt;Integer&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeEXCSATRD</MethodName>
            <MethodComment>/** 
 * Write reply to EXCSAT command Instance Variables EXTNAM - External Name (optional) MGRLVLLS - Manager Level List (optional) SRVCLSNM - Server Class Name (optional) - used by JCC SRVNAM - Server Name (optional) SRVRLSLV - Server Product Release Level (optional)
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.EXCSATRD]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.EXTNAM, NetworkServerControlImpl.att_extnam()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.SRVCLSNM, NetworkServerControlImpl.att_srvclsnm()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.SRVNAM, NetworkServerControlImpl.ATT_SRVNAM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.SRVRLSLV, NetworkServerControlImpl.att_srvrlslv()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeMGRLEVELS</MethodName>
            <MethodComment>/** 
 * Write manager levels The target server must not provide information for any target managers unless the source explicitly requests it. For each manager class, if the target server's support level is greater than or equal to the source server's level, then the source server's level is returned for that class if the target server can operate at the source's level; otherwise a level 0 is returned.  If the target server's support level is less than the source server's level, the target server's level is returned for that class.  If the target server does not recognize the code point of a manager class or does not support that class, it returns a level of 0.  The target server then waits for the next command or for the source server to terminate communications. When the source server receives EXCSATRD, it must compare each of the entries in the mgrlvlls parameter it received to the corresponding entries in the mgrlvlls parameter it sent.  If any level mismatches, the source server must decide whether it can use or adjust to the lower level of target support for that manager class.  There are no architectural criteria for making this decision. The source server can terminate communications or continue at the target servers level of support.  It can also attempt to use whatever commands its user requests while receiving error reply messages for real functional mismatches. The manager levels the source server specifies or the target server returns must be compatible with the manager-level dependencies of the specified manangers.  Incompatible manager levels cannot be specified. Instance variables MGRLVL - repeatable, required CODEPOINT CCSIDMGR - CCSID Manager CMNAPPC - LU 6.2 Conversational Communications Manager CMNSYNCPT - SNA LU 6.2 SyncPoint Conversational Communications Manager CMNTCPIP - TCP/IP Communication Manager DICTIONARY - Dictionary RDB - Relational Database RSYNCMGR - Resynchronization Manager SECMGR - Security Manager SQLAM - SQL Application Manager SUPERVISOR - Supervisor SYNCPTMGR - Sync Point Manager XAMGR - XA manager VALUE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.MGRLVLLS]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdm;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseACCSEC</MethodName>
            <MethodComment>/** 
 * Parse Access Security If the target server supports the SECMEC requested by the application requester then a single value is returned and it is identical to the SECMEC value in the ACCSEC command. If the target server does not support the SECMEC requested, then one or more values are returned and the application requester must choose one of these values for the security mechanism. We currently support - user id and password (default for JCC) - encrypted user id and password - strong password substitute (USRSSBPWD w/ Derby network client only) Instance variables SECMGRNM  - security manager name - optional SECMEC    - security mechanism - required RDBNAM    - relational database name - optional SECTKN    - security token - optional, (required if sec mech. needs it)
 * @return security check code - 0 if everything O.K.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [securityCheckCode=0]</InnerVar>
                <InnerVar>int [securityMechanism=0]</InnerVar>
                <InnerVar>byte[] [secTokenIn=null]</InnerVar>
                <InnerVar>int [codePoint=reader.getCodePoint()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>session;setState;[(securityCheckCode == 0) ? Session.SECACC : Session.ATTEXC]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseOPNQRY</MethodName>
            <MethodComment>/** 
 * Parse OPNQRY Instance Variables RDBNAM - relational database name - optional PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required QRYBLKSZ - Query Block Size - required QRYBLKCTL - Query Block Protocol Control - optional  MAXBLKEXT - Maximum Number of Extra Blocks - optional - default value 0 OUTOVROPT - Output Override Option QRYROWSET - Query Rowset Size - optional - level 7 MONITOR - Monitor events - optional.
 * @return RDB Package Name, Consistency Token, and Section Number
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>Pkgnamcsn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>boolean [gotQryblksz=false]</InnerVar>
                <InnerVar>int [blksize=0]</InnerVar>
                <InnerVar>int [qryblkctl=CodePoint.QRYBLKCTL_DEFAULT]</InnerVar>
                <InnerVar>int [maxblkext=CodePoint.MAXBLKEXT_DEFAULT]</InnerVar>
                <InnerVar>int [qryrowset=CodePoint.QRYROWSET_DEFAULT]</InnerVar>
                <InnerVar>int [qryclsimp=DRDAResultSet.QRYCLSIMP_DEFAULT]</InnerVar>
                <InnerVar>int [outovropt=CodePoint.OUTOVRFRS]</InnerVar>
                <InnerVar>int [codePoint=reader.getCodePoint()]</InnerVar>
                <InnerVar>DRDAStatement [stmt=database.getDRDAStatement(pkgnamcsn)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;setOPNQRYOptions;[blksize, qryblkctl, maxblkext, outovropt, qryrowset, qryclsimp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseOPNQRYobjects</MethodName>
            <MethodComment>/** 
 * Parse OPNQRY objects Objects TYPDEFNAM - Data type definition name - optional TYPDEFOVR - Type defintion overrides - optional SQLDTA- SQL Program Variable Data - optional If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects sent with the statement.  Once the statement is over, the default values sent in the ACCRDB are once again in effect.  If no values are supplied, the values sent in the ACCRDB are used. Objects may follow in one DSS or in several DSS chained together.
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseOUTOVROPT</MethodName>
            <MethodComment>/** 
 * Parse OUTOVROPT - this indicates whether output description can be overridden on just the first CNTQRY or on any CNTQRY
 * @return output override option
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [outovropt=reader.readUnsignedByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[CodePoint.OUTOVROPT, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQRYBLKSZ</MethodName>
            <MethodComment>/** 
 * Parse QRYBLSZ - this gives the maximum size of the query blocks that can be returned to the requester
 * @return query block size
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [blksize=reader.readNetworkInt()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[CodePoint.QRYBLKSZ, 4]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQRYROWSET</MethodName>
            <MethodComment>/** 
 * Parse QRYROWSET - this is the number of rows to return
 * @param minVal - minimum value
 * @return query row set size
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>minVal</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [qryrowset=reader.readNetworkInt()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[CodePoint.QRYROWSET, 4]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQRYCLSIMP</MethodName>
            <MethodComment>/** 
 * Parse a QRYCLSIMP - Implicitly close non-scrollable cursor  after end of data.
 * @return  true to close on end of data 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [qryclsimp=reader.readUnsignedByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[CodePoint.QRYCLSIMP, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQRYCLSRLS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;skipBytes;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeQRYPOPRM</MethodName>
            <MethodComment>/** 
 * Write a QRYPOPRM - Query Previously opened Instance Variables SVRCOD - Severity Code - required - 8 ERROR RDBNAM - Relational Database Name - required PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.QRYPOPRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writePKGNAMCSN;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeQRYNOPRM</MethodName>
            <MethodComment>/** 
 * Write a QRYNOPRM - Query Not Opened Instance Variables SVRCOD - Severity Code - required -  4 Warning 8 ERROR RDBNAM - Relational Database Name - required PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required
 * @param svrCod    Severity Code
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>svrCod</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.QRYNOPRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, svrCod]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writePKGNAMCSN;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeOPNQFLRM</MethodName>
            <MethodComment>/** 
 * Write a OPNQFLRM - Open Query Failure Instance Variables SVRCOD - Severity Code - required - 8 ERROR RDBNAM - Relational Database Name - required
 * @param e   Exception describing failure
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.OPNQFLRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdm;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLCARD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAGRP;[e, 0, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePKGNAMCSN</MethodName>
            <MethodComment>/** 
 * Write PKGNAMCSN Instance Variables NAMESYMDR - database name - not validated RDBCOLID - RDB Collection Identifier PKGID - RDB Package Identifier PKGCNSTKN - RDB Package Consistency Token PKGSN - RDB Package Section Number There are two possible formats, fixed and extended which includes length information for the strings
 * @throws DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkgcnstkn</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.PKGNAMCSN]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdm;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePKGNAMCSN</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writePKGNAMCSN;[pkgcnstkn.getBytes()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCNTQRY</MethodName>
            <MethodComment>/** 
 * Parse CNTQRY - Continue Query Instance Variables RDBNAM - Relational Database Name - optional PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required QRYBLKSZ - Query Block Size - required QRYRELSCR - Query Relative Scrolling Action - optional QRYSCRORN - Query Scroll Orientation - optional - level 7 QRYROWNBR - Query Row Number - optional QRYROWSNS - Query Row Sensitivity - optional - level 7 QRYBLKRST - Query Block Reset - optional - level 7 QRYRTNDTA - Query Returns Data - optional - level 7 QRYROWSET - Query Rowset Size - optional - level 7 QRYRFRTBL - Query Refresh Answer Set Table - optional NBRROW - Number of Fetch or Insert Rows - optional MAXBLKEXT - Maximum number of extra blocks - optional RTNEXTDTA - Return of EXTDTA Option - optional MONITOR - Monitor events - optional.
 * @return DRDAStatement we are continuing
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte [val]</InnerVar>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>boolean [gotQryblksz=false]</InnerVar>
                <InnerVar>boolean [qryrelscr=true]</InnerVar>
                <InnerVar>long [qryrownbr=1]</InnerVar>
                <InnerVar>boolean [qryrfrtbl=false]</InnerVar>
                <InnerVar>int [nbrrow=1]</InnerVar>
                <InnerVar>int [blksize=0]</InnerVar>
                <InnerVar>int [maxblkext=-1]</InnerVar>
                <InnerVar>long [qryinsid]</InnerVar>
                <InnerVar>boolean [gotQryinsid=false]</InnerVar>
                <InnerVar>int [qryscrorn=CodePoint.QRYSCRREL]</InnerVar>
                <InnerVar>boolean [qryrowsns=false]</InnerVar>
                <InnerVar>boolean [gotQryrowsns=false]</InnerVar>
                <InnerVar>boolean [qryblkrst=false]</InnerVar>
                <InnerVar>boolean [qryrtndta=true]</InnerVar>
                <InnerVar>int [qryrowset=CodePoint.QRYROWSET_DEFAULT]</InnerVar>
                <InnerVar>int [rtnextdta=CodePoint.RTNEXTROW]</InnerVar>
                <InnerVar>int [codePoint=reader.getCodePoint()]</InnerVar>
                <InnerVar>DRDAStatement [stmt=database.getDRDAStatement(pkgnamcsn)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;setQueryOptions;[blksize, qryrelscr, qryrownbr, qryrfrtbl, nbrrow, maxblkext, qryscrorn, qryrowsns, qryblkrst, qryrtndta, qryrowset, rtnextdta]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipRemainder</MethodName>
            <MethodComment>/** 
 * Skip remainder of current DSS and all chained DSS'es
 * @param onlySkipSameIds True if we _only_ want to skip DSS'esthat are chained with the SAME id as the current DSS. False means skip ALL chained DSSes, whether they're chained with same or different ids.
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onlySkipSameIds</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;skipDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCNTQRYobjects</MethodName>
            <MethodComment>/** 
 * Parse CNTQRY objects Instance Variables OUTOVR - Output Override Descriptor - optional
 * @param stmt DRDA statement we are working on
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseOUTOVR</MethodName>
            <MethodComment>/** 
 * Parse OUTOVR - Output Override Descriptor This specifies the output format for data to be returned as output to a SQL statement or as output from a query.
 * @param stmt  DRDA statement this applies to
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [first=true]</InnerVar>
                <InnerVar>int [numVars]</InnerVar>
                <InnerVar>int [dtaGrpLen]</InnerVar>
                <InnerVar>int [tripType]</InnerVar>
                <InnerVar>int [tripId]</InnerVar>
                <InnerVar>int [precision]</InnerVar>
                <InnerVar>int [start=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePBSD</MethodName>
            <MethodComment>/** 
 * Piggy-back any modified session attributes on the current message. Writes a PBSD conataining one or both of PBSD_ISO and PBSD_SCHEMA. PBSD_ISO is followed by the jdbc isolation level as an unsigned byte. PBSD_SCHEMA is followed by the name of the current schema as an UTF-8 String.
 * @throws java.sql.SQLException
 * @throws org.apache.derby.impl.drda.DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PiggyBackedSessionData [pbsd=database.getPiggyBackedSessionData(true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pbsd;refresh;[]</InnerMethodInvoke>
                <InnerMethodInvoke>pbsd;setUnmodified;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeOPNQRYRM</MethodName>
            <MethodComment>/** 
 * Write OPNQRYRM - Open Query Complete Instance Variables SVRCOD - Severity Code - required QRYPRCTYP - Query Protocol Type - required SQLCSRHLD - Hold Cursor Position - optional QRYATTSCR - Query Attribute for Scrollability - optional - level 7 QRYATTSNS - Query Attribute for Sensitivity - optional - level 7 QRYATTUPD - Query Attribute for Updatability -optional - level 7 QRYINSID - Query Instance Identifier - required - level 7 SRVDGN - Server Diagnostic Information - optional
 * @param isDssObject - return as a DSS object (part of a reply) 
 * @param stmt - DRDA statement we are processing
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isDssObject</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [prcType=stmt.getQryprctyp()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.OPNQRYRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_INFO]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.QRYPRCTYP, prcType]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeENDQRYRM</MethodName>
            <MethodComment>/** 
 * Write ENDQRYRM - query process has terminated in such a manner that the query or result set is now closed.  It cannot be resumed with the CNTQRY command or closed with the CLSQRY command
 * @param svrCod  Severity code - WARNING or ERROR
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>svrCod</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.ENDQRYRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, svrCod]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeABNUOWRM</MethodName>
            <MethodComment>/** 
 * Write ABNUOWRM - query process has terminated in an error condition such as deadlock or lock timeout. Severity code is always error * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.ABNUOWRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseRDBNAM</MethodName>
            <MethodComment>/** 
 * Parse database name
 * @return database name
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [name]</InnerVar>
                <InnerVar>byte[] [rdbName=reader.readBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeACCSECRD</MethodName>
            <MethodComment>/** 
 * Write ACCSECRD If the security mechanism is known, we just send it back along with the security token if encryption is going to be used. If the security mechanism is not known, we send a list of the ones we know. Instance Variables SECMEC - security mechanism - required SECTKN - security token - optional (required if security mechanism uses encryption) SECCHKCD - security check code - error occurred in processing ACCSEC
 * @param securityCheckCode
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>securityCheckCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.ACCSECRD]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finalizeChain;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSECCHK</MethodName>
            <MethodComment>/** 
 * Parse security check Instance Variables SECMGRNM - security manager name - optional, ignorable SECMEC  - security mechanism - required SECTKN  - security token - optional, (required if encryption used) PASSWORD - password - optional, (required if security mechanism uses it) NEWPASSWORD - new password - optional, (required if sec mech. uses it) USRID   - user id - optional, (required if sec mec. uses it) RDBNAM  - database name - optional (required if databases can have own sec.)
 * @return security check code
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint, securityCheckCode=0]</InnerVar>
                <InnerVar>int [securityMechanism=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSECCHKRM</MethodName>
            <MethodComment>/** 
 * Write security check reply Instance variables SVRCOD - serverity code - required SECCHKCD    - security check code  - required SECTKN - security token - optional, ignorable SVCERRNO    - security service error number SRVDGN  - Server Diagnostic Information
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>securityCheckCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SECCHKRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, svrcodFromSecchkcd(securityCheckCode)]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar1Byte;[CodePoint.SECCHKCD, securityCheckCode]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finalizeChain;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>svrcodFromSecchkcd</MethodName>
            <MethodComment>/** 
 * Calculate SVRCOD value from SECCHKCD
 * @param securityCheckCode
 * @return SVRCOD value
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>securityCheckCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseACCRDB</MethodName>
            <MethodComment>/** 
 * Parse access RDB Instance variables RDBACCCL - RDB Access Manager Class - required must be SQLAM CRRTKN - Correlation Token - required RDBNAM - Relational database name -required PRDID - Product specific identifier - required TYPDEFNAM   - Data Type Definition Name -required TYPDEFOVR   - Type definition overrides -required RDBALWUPD -  RDB Allow Updates optional PRDDTA - Product Specific Data - optional - ignorable STTDECDEL - Statement Decimal Delimiter - optional STTSTRDEL - Statement String Delimiter - optional TRGDFTRT - Target Default Value Return - optional
 * @return severity code
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>int [svrcod=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;copyToRequired;[ACCRDB_REQUIRED]</InnerMethodInvoke>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkRequired;[CodePoint.ACCRDB]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseTYPDEFNAM</MethodName>
            <MethodComment>/** 
 * Parse TYPDEFNAM
 * @return typdefnam
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [typDefNam=reader.readString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidTypDefNam;[typDefNam]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStmtOrDbByteOrder</MethodName>
            <MethodComment>/** 
 * Set a statement or the database' byte order, depending on the arguments
 * @param setDatabase   if true, set database' byte order, otherwise set statement's
 * @param stmt          DRDAStatement, used when setDatabase is false
 * @param typDefNam     TYPDEFNAM value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>setDatabase</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typDefNam</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteOrder=(typDefNam.equals(CodePoint.TYPDEFNAM_QTDSQLX86) ? SignedBinary.LITTLE_ENDIAN : SignedBinary.BIG_ENDIAN)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeACCRDBRM</MethodName>
            <MethodComment>/** 
 * Write Access to RDB Completed Instance Variables SVRCOD - severity code - 0 info, 4 warning -required PRDID - product specific identifier -required TYPDEFNAM - type definition name -required TYPDEFOVR - type definition overrides - required RDBINTTKN - token which can be used to interrupt DDM commands - optional CRRTKN  - correlation token - only returned if we didn't get one from requester SRVDGN - server diagnostic information - optional PKGDFTCST - package default character subtype - optional USRID - User ID at the target system - optional SRVLST - Server List
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>svrcod</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.ACCRDBRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, svrcod]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.PRDID, NetworkServerControlImpl.prdId()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarString;[CodePoint.TYPDEFNAM, CodePoint.TYPDEFNAM_QTDSQLASC]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeTYPDEFOVR;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finalizeChain;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeTYPDEFOVR</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.TYPDEFOVR]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.CCSIDSBC, NetworkServerControlImpl.CCSIDSBC]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.CCSIDMBC, NetworkServerControlImpl.CCSIDMBC]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdm;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseTYPDEFOVR</MethodName>
            <MethodComment>/** 
 * Parse Type Defintion Overrides TYPDEF Overrides specifies the Coded Character SET Identifiers (CCSIDs) that are in a named TYPDEF. Instance Variables CCSIDSBC - CCSID for Single-Byte - optional CCSIDDBC - CCSID for Double-Byte - optional CCSIDMBC - CCSID for Mixed-byte characters -optional
 * @param st    Statement this TYPDEFOVR applies to
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>st</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>int [ccsidSBC=0]</InnerVar>
                <InnerVar>int [ccsidDBC=0]</InnerVar>
                <InnerVar>int [ccsidMBC=0]</InnerVar>
                <InnerVar>String [ccsidSBCEncoding=null]</InnerVar>
                <InnerVar>String [ccsidDBCEncoding=null]</InnerVar>
                <InnerVar>String [ccsidMBCEncoding=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePRPSQLSTT</MethodName>
            <MethodComment>/** 
 * Parse PRPSQLSTT - Prepare SQL Statement Instance Variables RDBNAM - Relational Database Name - optional PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required RTNSQLDA - Return SQL Descriptor Area - optional MONITOR - Monitor events - optional.
 * @return return 0 - don't return sqlda, 1 - return input sqlda, 2 - return output sqlda
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>boolean [rtnsqlda=false]</InnerVar>
                <InnerVar>boolean [rtnOutput=true]</InnerVar>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>Database [databaseToSet=null]</InnerVar>
                <InnerVar>DRDAStatement [stmt=database.newDRDAStatement(pkgnamcsn)]</InnerVar>
                <InnerVar>String [sqlStmt=parsePRPSQLSTTobjects(stmt)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;explicitPrepare;[sqlStmt]</InnerMethodInvoke>
                <InnerMethodInvoke>database;setCurrentStatement;[stmt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePRPSQLSTTobjects</MethodName>
            <MethodComment>/** 
 * Parse PRPSQLSTT objects Objects TYPDEFNAM - Data type definition name - optional TYPDEFOVR - Type defintion overrides - optional SQLSTT - SQL Statement required SQLATTR - Cursor attributes on prepare - optional - level 7 If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects sent with the statement.  Once the statement is over, the default values sent in the ACCRDB are once again in effect.  If no values are supplied, the values sent in the ACCRDB are used. Objects may follow in one DSS or in several DSS chained together.
 * @return SQL statement
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [sqlStmt=null]</InnerVar>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseTYPSQLDA</MethodName>
            <MethodComment>/** 
 * Parse TYPSQLDA - Type of the SQL Descriptor Area
 * @return true if for output; false otherwise
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte [sqldaType=reader.readByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[CodePoint.TYPSQLDA, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSQLATTR</MethodName>
            <MethodComment>/** 
 * Parse SQLATTR - Cursor attributes on prepare This is an encoded string. Can have combination of following, eg INSENSITIVE SCROLL WITH HOLD Possible strings are SENSITIVE DYNAMIC SCROLL [FOR UPDATE] SENSITIVE STATIC SCROLL [FOR UPDATE] INSENSITIVE SCROLL FOR UPDATE WITH HOLD
 * @param stmt DRDAStatement
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [attrs=parseEncodedString()]</InnerVar>
                <InnerVar>boolean [validAttribute=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDSCSQLSTT</MethodName>
            <MethodComment>/** 
 * Parse DSCSQLSTT - Describe SQL Statement previously prepared Instance Variables TYPSQLDA - sqlda type expected (output or input) RDBNAM - relational database name - optional PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required MONITOR - Monitor events - optional.
 * @return expect "output sqlda" or not
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>boolean [rtnOutput=true]</InnerVar>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSQLSTT</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLSTT - Execute non-cursor SQL Statement previously prepared Instance Variables RDBNAM - relational database name - optional PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required OUTEXP - Output expected NBRROW - Number of rows to be inserted if it's an insert PRCNAM - procedure name if specified by host variable, not needed for Derby QRYBLKSZ - query block size MAXRSLCNT - max resultset count MAXBLKEXT - Max number of extra blocks RSLSETFLG - resultset flag RDBCMTOK - RDB Commit Allowed - optional OUTOVROPT - output override option QRYROWSET - Query Rowset Size - Level 7 MONITOR - Monitor events - optional.
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>String [strVal]</InnerVar>
                <InnerVar>boolean [outputExpected=false]</InnerVar>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>int [numRows=1]</InnerVar>
                <InnerVar>int [blkSize=0]</InnerVar>
                <InnerVar>int [maxrslcnt=0]</InnerVar>
                <InnerVar>int [maxblkext=CodePoint.MAXBLKEXT_DEFAULT]</InnerVar>
                <InnerVar>int [qryrowset=CodePoint.QRYROWSET_DEFAULT]</InnerVar>
                <InnerVar>int [outovropt=CodePoint.OUTOVRFRS]</InnerVar>
                <InnerVar>byte[] [rslsetflg=null]</InnerVar>
                <InnerVar>String [procName=null]</InnerVar>
                <InnerVar>DRDAStatement [stmt]</InnerVar>
                <InnerVar>boolean [needPrepareCall=false]</InnerVar>
                <InnerVar>boolean [isProcedure=(procName != null || (stmt != null &amp;&amp; stmt.wasExplicitlyPrepared() &amp;&amp; stmt.isCall))]</InnerVar>
                <InnerVar>boolean [hasResultSet]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
                <InnerVar>int [numResults=0]</InnerVar>
                <InnerVar>boolean [sendSQLDTARD=stmt.hasOutputParams() &amp;&amp; outputExpected]</InnerVar>
                <InnerVar>EnginePreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
                <InnerVar>int [rsNum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>database;setCurrentStatement;[stmt]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;finishParams;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseRDBCMTOK</MethodName>
            <MethodComment>/** 
 * Parse RDBCMTOK - tells the database whether to allow commits or rollbacks to be executed as part of the command Since we don't have a SQL commit or rollback command, we will just ignore this for now
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [rdbcmtok=readBoolean(CodePoint.RDBCMTOK)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSQLSTTobjects</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLSTT command objects Command Objects TYPDEFNAM - Data Type Definition Name - optional TYPDEFOVR - TYPDEF Overrides -optional SQLDTA - optional, variable data, specified if prpared statement has input parameters EXTDTA - optional, externalized FD:OCA data OUTOVR - output override descriptor, not allowed for stored procedure calls If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects sent with the statement.  Once the statement is over, the default values sent in the ACCRDB are once again in effect.  If no values are supplied, the values sent in the ACCRDB are used. Objects may follow in one DSS or in several DSS chained together.
 * @param stmt  the DRDAStatement to execute
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>boolean [gotSQLDTA=false, gotEXTDTA=false]</InnerVar>
                <InnerVar>boolean [result=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCINRD</MethodName>
            <MethodComment>/** 
 * Write SQLCINRD - result set column information
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs=stmt.getResultSet()]</InnerVar>
                <InnerVar>ResultSetMetaData [rsmeta=rs.getMetaData()]</InnerVar>
                <InnerVar>int [ncols=rsmeta.getColumnCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLCINRD]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[ncols]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLRSLRD</MethodName>
            <MethodComment>/** 
 * Write SQLRSLRD - result set reply data
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numResults=stmt.getNumResultSets()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLRSLRD]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[numResults]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeRSLSETRM</MethodName>
            <MethodComment>/** 
 * Write RSLSETRM Instance variables SVRCOD - Severity code - Information only - required PKGSNLST - list of PKGNAMCSN -required SRVDGN - Server Diagnostic Information -optional
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numResults=stmt.getNumResultSets()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.RSLSETRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.PKGSNLST]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdm;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSQLDTA</MethodName>
            <MethodComment>/** 
 * Parse SQLDTA - SQL program variable data  and handle exception.
 * @see #parseSQLDTA_work
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSQLDTA_work</MethodName>
            <MethodComment>/** 
 * Parse SQLDTA - SQL program variable data Instance Variables FDODSC - FD:OCA data descriptor - required FDODTA - FD:OCA data - optional
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [strVal]</InnerVar>
                <InnerVar>EnginePreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>ParameterMetaData [pmeta=null]</InnerVar>
                <InnerVar>int [numVars=0]</InnerVar>
                <InnerVar>boolean [rtnParam=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;clearDrdaParams;[]</InnerMethodInvoke>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getByteOrder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DRDAStatement [stmt=database.getCurrentStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGMTCalendar</MethodName>
            <MethodComment>/** 
 * Get a  {@code Calendar} instance with time zone set to GMT. The instanceis cached for reuse by this thread. This calendar can be used to consistently read and write date and time values using the same calendar. Since the local default calendar may not be able to represent all times (for instance because the time would fall into a non-existing hour of the day when switching to daylight saving time, see DERBY-4582), we use the GMT time zone which doesn't observe daylight saving time.
 * @return a calendar in the GMT time zone
 */
</MethodComment>
            <ReturnType>Calendar</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readAndSetParams</MethodName>
            <MethodComment>/** 
 * Read different types of input parameters and set them in PreparedStatement
 * @param i         index of the parameter
 * @param stmt      drda statement
 * @param pmeta     parameter meta data
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
                <InnerVar>int [drdaType=((stmt.getParamDRDAType(i + 1) | 0x01) &amp; 0xff)]</InnerVar>
                <InnerVar>int [paramLenNumBytes=stmt.getParamLen(i + 1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readUDT</MethodName>
            <MethodComment>/** 
 * Read a UDT from the stream 
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [length=reader.readNetworkShort()]</InnerVar>
                <InnerVar>byte[] [bytes=reader.readBytes(length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readLobLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>extLenIndicator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDate</MethodName>
            <MethodComment>/** 
 * Parse a date string as it is received from the client.
 * @param dateString the date string to parse
 * @param cal the calendar in which the date is parsed
 * @return a Date object representing the date in the specified calendar
 * @see org.apache.derby.client.am.DateTime#dateToDateBytes
 * @throws IllegalArgumentException if the date is not correctly formatted
 */
</MethodComment>
            <ReturnType>java.sql.Date</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dateString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [components=dateString.split("-")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.YEAR, Integer.parseInt(components[0])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MONTH, Integer.parseInt(components[1]) - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.DAY_OF_MONTH, Integer.parseInt(components[2])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.HOUR_OF_DAY, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MINUTE, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.SECOND, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MILLISECOND, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseTime</MethodName>
            <MethodComment>/** 
 * Parse a time string as it is received from the client.
 * @param timeString the time string to parse
 * @param cal the calendar in which the time is parsed
 * @return a Date object representing the time in the specified calendar
 * @see org.apache.derby.client.am.DateTime#timeToTimeBytes
 * @throws IllegalArgumentException if the time is not correctly formatted
 */
</MethodComment>
            <ReturnType>Time</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [components=timeString.split(":")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.YEAR, 1970]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MONTH, Calendar.JANUARY]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.DAY_OF_MONTH, 1]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.HOUR_OF_DAY, Integer.parseInt(components[0])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MINUTE, Integer.parseInt(components[1])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.SECOND, Integer.parseInt(components[2])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MILLISECOND, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseTimestamp</MethodName>
            <MethodComment>/** 
 * Parse a timestamp string as it is received from the client.
 * @param timeString the time string to parse
 * @param cal the calendar in which the timestamp is parsed
 * @return a Date object representing the timestamp in the specifiedcalendar
 * @see org.apache.derby.client.am.DateTime#timestampToTimestampBytes
 * @throws IllegalArgumentException if the timestamp is not correctlyformatted
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [components=timeString.split("[-.]")]</InnerVar>
                <InnerVar>int [nanos=0]</InnerVar>
                <InnerVar>int [radix=10]</InnerVar>
                <InnerVar>String [nanoString=components[6]]</InnerVar>
                <InnerVar>Timestamp [ts=new Timestamp(cal.getTimeInMillis())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.YEAR, Integer.parseInt(components[0])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MONTH, Integer.parseInt(components[1]) - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.DAY_OF_MONTH, Integer.parseInt(components[2])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.HOUR_OF_DAY, Integer.parseInt(components[3])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.MINUTE, Integer.parseInt(components[4])]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;set;[Calendar.SECOND, Integer.parseInt(components[5])]</InnerMethodInvoke>
                <InnerMethodInvoke>ts;setNanos;[nanos]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readAndSetAllExtParams</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>streamLOB</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numExt=stmt.getExtPositionCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readAndSetExtParam</MethodName>
            <MethodComment>/** 
 * Read different types of input parameters and set them in PreparedStatement
 * @param i zero-based index of the parameter
 * @param stmt          associated ps
 * @param drdaType  drda type of the parameter
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extLen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>streamLOB</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [checkNullability=false]</InnerVar>
                <InnerVar>EXTDTAReaderInputStream [stream=reader.getEXTDTAReaderInputStream(checkNullability)]</InnerVar>
                <InnerVar>String [encoding="na"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;traceEXTDTARead;[drdaType, i + 1, stream, streamLOB, encoding]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSQLIMM</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLIMM - Execute Immediate Statement Instance Variables RDBNAM - relational database name - optional PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required RDBCMTOK - RDB Commit Allowed - optional MONITOR - Monitor Events - optional Command Objects TYPDEFNAM - Data Type Definition Name - optional TYPDEFOVR - TYPDEF Overrides -optional SQLSTT - SQL Statement -required
 * @return update count
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>DRDAStatement [drdaStmt=database.getDefaultStatement(pkgnamcsn)]</InnerVar>
                <InnerVar>String [sqlStmt=parseEXECSQLIMMobjects()]</InnerVar>
                <InnerVar>EngineStatement [statement=drdaStmt.getStatement()]</InnerVar>
                <InnerVar>long [updCount=statement.executeLargeUpdate(sqlStmt)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>drdaStmt;initialize;[]</InnerMethodInvoke>
                <InnerMethodInvoke>statement;clearWarnings;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSQLSET</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLSET - Execute Set SQL Environment Instance Variables RDBNAM - relational database name - optional PKGNAMCT - RDB Package Name, Consistency Token  - optional MONITOR - Monitor Events - optional Command Objects TYPDEFNAM - Data Type Definition Name - required TYPDEFOVR - TYPDEF Overrides - required SQLSTT - SQL Statement - required (at least one; may be more)
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;parseEXCSQLSETobjects;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXECSQLIMMobjects</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLIMM objects Objects TYPDEFNAM - Data type definition name - optional TYPDEFOVR - Type defintion overrides SQLSTT - SQL Statement required If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects sent with the statement.  Once the statement is over, the default values sent in the ACCRDB are once again in effect.  If no values are supplied, the values sent in the ACCRDB are used. Objects may follow in one DSS or in several DSS chained together.
 * @return SQL Statement
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [sqlStmt=null]</InnerVar>
                <InnerVar>int [codePoint]</InnerVar>
                <InnerVar>DRDAStatement [stmt=database.getDefaultStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEXCSQLSETobjects</MethodName>
            <MethodComment>/** 
 * Parse EXCSQLSET objects Objects TYPDEFNAM - Data type definition name - optional TYPDEFOVR - Type defintion overrides - optional SQLSTT - SQL Statement - required (a list of at least one) Objects may follow in one DSS or in several DSS chained together.
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [gotSqlStt=false]</InnerVar>
                <InnerVar>boolean [hadUnrecognizedStmt=false]</InnerVar>
                <InnerVar>DRDAStatement [drdaStmt=database.getDefaultStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>drdaStmt;initialize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canIgnoreStmt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeRDBUPDRM</MethodName>
            <MethodComment>/** 
 * Write RDBUPDRM Instance variables SVRCOD - Severity code - Information only - required RDBNAM - Relational database name -required SRVDGN - Server Diagnostic Information -optional
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.RDBUPDRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_INFO]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeRDBNAM;[database.getDatabaseName()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePKGNAMCT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;skipBytes;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parsePKGNAMCSN</MethodName>
            <MethodComment>/** 
 * Parse PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number Instance Variables NAMESYMDR - database name - not validated RDBCOLID - RDB Collection Identifier PKGID - RDB Package Identifier PKGCNSTKN - RDB Package Consistency Token PKGSN - RDB Package Section Number
 * @return &lt;code&gt;Pkgnamcsn&lt;/code&gt; value
 * @throws DRDAProtocolException
 */
</MethodComment>
            <ReturnType>Pkgnamcsn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSQLSTTDss</MethodName>
            <MethodComment>/** 
 * Parse SQLSTT Dss
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [codePoint=reader.readLengthAndCodePoint(false)]</InnerVar>
                <InnerVar>String [strVal=parseEncodedString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEncodedString</MethodName>
            <MethodComment>/** 
 * Parse an encoded data string from the Application Requester
 * @return string value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseVCMorVCS</MethodName>
            <MethodComment>/** 
 * Parse variable character mixed byte or variable character single byte Format I2 - VCM Length N bytes - VCM value I2 - VCS Length N bytes - VCS value  Only 1 of VCM length or VCS length can be non-zero
 * @return string value
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [strVal=null]</InnerVar>
                <InnerVar>int [vcm_length=reader.readNetworkShort()]</InnerVar>
                <InnerVar>int [vcs_length=reader.readNetworkShort()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseNOCMorNOCS</MethodName>
            <MethodComment>/** 
 * Parse nullable character mixed byte or nullable character single byte Format 1 byte - null indicator I4 - mixed character length N bytes - mixed character string 1 byte - null indicator I4 - single character length N bytes - single character length string
 * @return string value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>byte [nocm_nullByte=reader.readByte()]</InnerVar>
                <InnerVar>String [strVal=null]</InnerVar>
                <InnerVar>int [length]</InnerVar>
                <InnerVar>byte [nocs_nullByte=reader.readByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCcsidMBC</MethodName>
            <MethodComment>/** 
 * Parse mixed character string
 * @return string value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [strVal=null]</InnerVar>
                <InnerVar>DRDAStatement [currentStatement]</InnerVar>
                <InnerVar>String [ccsidMBCEncoding=currentStatement.ccsidMBCEncoding]</InnerVar>
                <InnerVar>byte[] [byteStr=reader.readBytes(length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCcsidSBC</MethodName>
            <MethodComment>/** 
 * Parse single byte character string
 * @return string value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [strVal=null]</InnerVar>
                <InnerVar>DRDAStatement [currentStatement]</InnerVar>
                <InnerVar>String [ccsidSBCEncoding=currentStatement.ccsidSBCEncoding]</InnerVar>
                <InnerVar>byte[] [byteStr=reader.readBytes(length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System.out;println;["ccsidSBCEncoding - " + ccsidSBCEncoding]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseCLSQRY</MethodName>
            <MethodComment>/** 
 * Parse CLSQRY Instance Variables RDBNAM - relational database name - optional PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required QRYINSID - Query Instance Identifier - required - level 7 MONITOR - Monitor events - optional.
 * @return DRDAstatement being closed
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Pkgnamcsn [pkgnamcsn=null]</InnerVar>
                <InnerVar>long [qryinsid=0]</InnerVar>
                <InnerVar>boolean [gotQryinsid=false]</InnerVar>
                <InnerVar>int [codePoint=reader.getCodePoint()]</InnerVar>
                <InnerVar>DRDAStatement [stmt=database.getDRDAStatement(pkgnamcsn)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;markCollection;[]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;CLSQRY;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseMONITOR</MethodName>
            <MethodComment>/** 
 * Parse MONITOR DRDA spec says this is optional.  Since we don't currently support it, we just ignore.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>reader;skipBytes;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCARDs</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLCARDs;[e, updateCount, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCARDs</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sendSQLERRRM</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [severity=getExceptionSeverity(e)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLCARD;[e, updateCount, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSqlCode</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the SQLCODE to send for an exception or a warning. &lt;/p&gt; &lt;p&gt; The client expects a negative SQLCODE for exceptions and a positive SQLCODE for warnings. SQLCODE 0 means there is no error or warning condition. SQLCODE is also used to encode the severity of the condition (as returned by  {@code SQLException.getErrorCode()}). &lt;/p&gt; &lt;p&gt; For warnings, the SQLCODE is 10000, which is identical to {@link ExceptionSeverity#WARNING_SEVERITY}. &lt;/p&gt; &lt;p&gt; For exceptions, the SQLCODE is set to  {@code -severity-1}, which allows all non-negative severity values to be encoded. (Derby only uses non-negative severity values in the first place.) &lt;/p&gt;
 * @param e the exception or warning to get the SQLCODE for
 * @return the value to send as SQLCODE
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [severity=Math.max(ExceptionSeverity.NO_APPLICABLE_SEVERITY,e.getErrorCode())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCARD</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLCARD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAGRP;[e, updateCount, rowCount]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeNullSQLCARDobject</MethodName>
            <MethodComment>/** 
 * Write a null SQLCARD as an object
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLCARD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAGRP;[nullSQLState, 0, 0, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLERRRM</MethodName>
            <MethodComment>/** 
 * Write SQLERRRM Instance Variables SVRCOD - Severity Code - required
 * @param severity    severity of error
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>severity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLERRRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, severity]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeCMDCHKRM</MethodName>
            <MethodComment>/** 
 * Write CMDCHKRM Instance Variables SVRCOD - Severity Code - required
 * @param severity    severity of error
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>severity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.CMDCHKRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, severity]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExceptionSeverity</MethodName>
            <MethodComment>/** 
 * Translate from Derby exception severity to SVRCOD
 * @param e SQLException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [severity=CodePoint.SVRCOD_INFO]</InnerVar>
                <InnerVar>int [ec=e.getErrorCode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCAGRP</MethodName>
            <MethodComment>/** 
 * Write SQLCAGRP SQLCAGRP : FDOCA EARLY GROUP SQL Communcations Area Group Description FORMAT FOR SQLAM &amp;lt;= 6 SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5 SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8 SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0 FORMAT FOR SQLAM &amp;gt;= 7 SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5 SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8 SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0 SQLDIAGGRP; DRDA TYPE N-GDA; ENVLID 0x56; Length Override 0
 * @param e     SQLException encountered
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [sqlcode=getSqlCode(e)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[sqlcode]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeString;[e.getSQLState()]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeBytes;[getProductIDBytes()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAXGRP;[updateCount, rowCount, buildSqlerrmc(e), e.getNextException()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCAGRP</MethodName>
            <MethodComment>/** 
 * Same as writeSQLCAGRP, but optimized for the case when there is no real exception, i.e. the exception is null, or "End of data" SQLCAGRP : FDOCA EARLY GROUP SQL Communcations Area Group Description FORMAT FOR SQLAM &amp;lt;= 6 SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5 SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8 SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0 FORMAT FOR SQLAM &amp;gt;= 7 SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5 SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8 SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0 SQLDIAGGRP; DRDA TYPE N-GDA; ENVLID 0x56; Length Override 0
 * @param sqlState     SQLState (already converted to UTF8)
 * @param sqlcode    sqlcode
 * @param updateCount
 * @param rowCount
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlState</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlcode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[sqlcode]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeBytes;[sqlState]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeBytes;[getProductIDBytes()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAXGRP;[updateCount, rowCount, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildSqlerrmc</MethodName>
            <MethodComment>/** 
 * Create error message or message argements to return to client.   The SQLERRMC will normally be passed back  to the server in a call  to the SYSIBM.SQLCAMESSAGE but for severe exceptions the stored procedure  call cannot be made. So for Severe messages we will just send the message text. This method will also truncate the value according the client capacity. CCC can only handle 70 characters. Server sends the sqlerrmc using UTF8 encoding to the client. To get the message, client sends back information to the server calling SYSIBM.SQLCAMESSAGE (see Sqlca.getMessage).  Several parameters  are sent to this procedure including the locale, the sqlerrmc that the  client received from the server.  On server side, the procedure SQLCAMESSAGE in SystemProcedures then calls the MessageService.getLocalizedMessage to retrieve the localized error message.  In MessageService.getLocalizedMessage the sqlerrmc that is passed in,  is parsed to retrieve the message id. The value it uses to parse the MessageId is char value of 20, otherwise it uses the entire sqlerrmc as the message id.  This messageId is then used to retrieve the localized message if present, to  the client.
 * @param se  SQLException to build SQLERRMC
 * @return  String which is either the message arguments to be passed to SYSIBM.SQLCAMESSAGE or just message text for severe errors.  
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>se</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [severe=(se.getErrorCode() &gt;= ExceptionSeverity.SESSION_SEVERITY)]</InnerVar>
                <InnerVar>String [sqlerrmc]</InnerVar>
                <InnerVar>StandardException [ferry=StandardException.getArgumentFerry(se)]</InnerVar>
                <InnerVar>int [maxlen=(sqlerrmc == null) ? -1 : Math.min(sqlerrmc.length(),appRequester.supportedMessageParamLength())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildPreformattedSqlerrmc</MethodName>
            <MethodComment>/** 
 * Build preformatted SQLException text  for severe exceptions or SQLExceptions that are not Derby exceptions. Just send the message text localized to the server locale.
 * @param se  SQLException for which to build SQLERRMC
 * @return preformated message text with messages separted by SQLERRMC_PREFORMATED_MESSAGE_DELIMITER
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>se</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;[se.getLocalizedMessage()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildTokenizedSqlerrmc</MethodName>
            <MethodComment>/** 
 * Build Tokenized SQLERRMC to just send the tokenized arguments to the client. for a Derby SQLException or an SQLException thrown by user code. Message argument tokens are separated by SQLERRMC_TOKEN_DELIMITER  Multiple messages are separated by SystemProcedures.SQLERRMC_MESSAGE_DELIMITER ...
 * @param se   SQLException to print
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>se</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [sqlerrmc=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildDataTruncationSqlerrmc</MethodName>
            <MethodComment>/** 
 * Build the SQLERRMC for a  {@code java.sql.DataTruncation} warning.Serialize all the fields of the  {@code DataTruncation} instance in theorder in which they appear in the parameter list of the constructor.
 * @param dt the {@code DataTruncation} instance to serialize
 * @return the SQLERRMC string with all fields of the warning
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dt</ParamName>
                    <ParamType>DataTruncation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCAXGRP</MethodName>
            <MethodComment>/** 
 * Write SQLCAXGRP SQLCAXGRP : EARLY FDOCA GROUP SQL Communications Area Exceptions Group Description FORMAT FOR SQLAM &amp;lt;= 6 SQLRDBNME; DRDA TYPE FCS; ENVLID 0x30; Length Override 18 SQLERRD1; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD2; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD3; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD4; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD5; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD6; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLWARN0; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN1; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN2; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN3; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN4; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN5; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN6; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN7; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN8; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN9; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARNA; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLERRMSG_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 70 SQLERRMSG_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 70 FORMAT FOR SQLAM &amp;gt;= 7 SQLERRD1; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD2; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD3; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD4; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD5; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLERRD6; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLWARN0; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN1; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN2; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN3; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN4; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN5; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN6; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN7; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN8; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARN9; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLWARNA; DRDA TYPE FCS; ENVLID 0x30; Length Override 1 SQLRDBNAME; DRDA TYPE VCS; ENVLID 0x32; Length Override 1024 SQLERRMSG_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 70 SQLERRMSG_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 70
 * @param nextException SQLException encountered
 * @param sqlerrmc sqlcode
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlerrmc</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nextException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[sqlerrmc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLCAERRWARN</MethodName>
            <MethodComment>/** 
 * Write the ERR and WARN part of the SQLCA
 * @param updateCount
 * @param rowCount 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeInt;[(int)((rowCount &gt;&gt;&gt; 32))]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[(int)(rowCount &amp; 0x0000000ffffffffL)]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[(int)(updateCount &amp; 0x0000000ffffffffL)]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[(int)(updateCount &gt;&gt;&gt; 32)]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeBytes;[errD5_D6]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeBytes;[warn0_warnA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDIAGGRP</MethodName>
            <MethodComment>/** 
 * Write SQLDIAGGRP: SQL Diagnostics Group Description - Identity 0xD1 Nullable Group SQLDIAGSTT; DRDA TYPE N-GDA; ENVLID 0xD3; Length Override 0 SQLDIAGCN;  DRFA TYPE N-RLO; ENVLID 0xF6; Length Override 0 SQLDIAGCI;  DRDA TYPE N-RLO; ENVLID 0xF5; Length Override 0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLDIAGSTT;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLDIAGCI;[nextException]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLDIAGCN;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDIAGSTT</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[CodePoint.NULLDATA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDIAGCI</MethodName>
            <MethodComment>/** 
 * writeSQLDIAGCI: SQL Diagnostics Condition Information Array - Identity 0xF5 SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1 SQLDCIROW; ROW LID 0xE5; ELEMENT TAKEN 0(all); REP FACTOR 0(all)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLException [se=nextException]</InnerVar>
                <InnerVar>long [rowNum=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLNUMROW;[se]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLNUMROW</MethodName>
            <MethodComment>/** 
 * writeSQLNUMROW: Writes SQLNUMROW : FDOCA EARLY ROW SQL Number of Elements Row Description FORMAT FOR SQLAM LEVELS SQLNUMGRP; GROUP LID 0x58; ELEMENT TAKEN 0(all); REP FACTOR 1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLNUMGRP;[nextException]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLNUMGRP</MethodName>
            <MethodComment>/** 
 * writeSQLNUMGRP: Writes SQLNUMGRP : FDOCA EARLY GROUP SQL Number of Elements Group Description FORMAT FOR ALL SQLAM LEVELS SQLNUM; DRDA TYPE I2; ENVLID 0x04; Length Override 2
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextException</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=0]</InnerVar>
                <InnerVar>SQLException [se]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeShort;[i]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDCROW</MethodName>
            <MethodComment>/** 
 * writeSQLDCROW: SQL Diagnostics Condition Row - Identity 0xE5 SQLDCGRP; GROUP LID 0xD5; ELEMENT TAKEN 0(all); REP FACTOR 1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlState</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlerrmc</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLDCGRP;[rowNum, sqlCode, sqlState, dbname, sqlerrmc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDCGRP</MethodName>
            <MethodComment>/** 
 * writeSQLDCGRP: SQL Diagnostics Condition Group Description SQLDCCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCSTATE; DRDA TYPE FCS; ENVLID Ox30; Lengeh Override 5 SQLDCREASON; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCLINEN; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCROWN; DRDA TYPE FD; ENVLID 0x0E; Lengeh Override 31 SQLDCER01; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCER02; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCER03; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCER04; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCPART; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCPPOP; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLDCMSGID; DRDA TYPE FCS; ENVLID 0x30; Length Override 10 SQLDCMDE; DRDA TYPE FCS; ENVLID 0x30; Length Override 8 SQLDCPMOD; DRDA TYPE FCS; ENVLID 0x30; Length Override 5 SQLDCRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 SQLDCTOKS; DRDA TYPE N-RLO; ENVLID 0xF7; Length Override 0 SQLDCMSG_m; DRDA TYPE NVMC; ENVLID 0x3F; Length Override 32672 SQLDCMSG_S; DRDA TYPE NVCS; ENVLID 0x33; Length Override 32672 SQLDCCOLN_m; DRDA TYPE NVCM ; ENVLID 0x3F; Length Override 255 SQLDCCOLN_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255 SQLDCCURN_m; DRDA TYPE NVCM; ENVLID 0x3F; Length Override 255 SQLDCCURN_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255 SQLDCPNAM_m; DRDA TYPE NVCM; ENVLID 0x3F; Length Override 255 SQLDCPNAM_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255 SQLDCXGRP; DRDA TYPE N-GDA; ENVLID 0xD3; Length Override 1
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlCode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlState</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlerrmc</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [byteArray=new byte[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeInt;[sqlCode]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeString;[sqlState]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeLong;[rowNum]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalarPaddedBytes;[byteArray, 47, (byte)0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeByte;[CodePoint.NULLDATA]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeLDString;[sqlerrmc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeByte;[CodePoint.NULLDATA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDIAGCN</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[CodePoint.NULLDATA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDARD</MethodName>
            <MethodComment>/** 
 * Write SQLDARD SQLDARD : FDOCA EARLY ARRAY SQL Descriptor Area Row Description with SQL Communications Area FORMAT FOR SQLAM &amp;lt;= 6 SQLCARD; ROW LID 0x64; ELEMENT TAKEN 0(all); REP FACTOR 1 SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1 SQLDAROW; ROW LID 0x60; ELEMENT TAKEN 0(all); REP FACTOR 0(all) FORMAT FOR SQLAM &amp;gt;= 7 SQLCARD; ROW LID 0x64; ELEMENT TAKEN 0(all); REP FACTOR 1 SQLDHROW; ROW LID 0xE0; ELEMENT TAKEN 0(all); REP FACTOR 1 SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1
 * @param stmt  prepared statement
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rtnOutput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
                <InnerVar>ResultSetMetaData [rsmeta=ps.getMetaData()]</InnerVar>
                <InnerVar>ParameterMetaData [pmeta=stmt.getParameterMetaData()]</InnerVar>
                <InnerVar>int [numElems=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.SQLDARD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLCAGRP;[e, 0, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[numElems]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeQRYDSC</MethodName>
            <MethodComment>/** 
 * Write QRYDSC - Query Answer Set Description
 * @param stmt DRDAStatement we are working on
 * @param FDODSConly    simply the FDODSC, without the wrapInstance Variables SQLDTAGRP - required Only 84 columns can be sent in a single QRYDSC.  If there are more columns they must be sent in subsequent QRYDSC. If the QRYDSC will not fit into the current block, as many columns as can fit are sent and then the remaining are sent in the following blocks.
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>FDODSConly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs=null]</InnerVar>
                <InnerVar>ResultSetMetaData [rsmeta=null]</InnerVar>
                <InnerVar>ParameterMetaData [pmeta=null]</InnerVar>
                <InnerVar>int [numCols=(rsmeta != null ? rsmeta.getColumnCount() : pmeta.getParameterCount())]</InnerVar>
                <InnerVar>int [numGroups=1]</InnerVar>
                <InnerVar>int [colStart=1]</InnerVar>
                <InnerVar>int [colEnd=numCols]</InnerVar>
                <InnerVar>int [blksize=stmt.getBlksize() &gt; 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX]</InnerVar>
                <InnerVar>int [remaining=blksize - (writer.getDSSLength() % blksize) - (3 + FdocaConstants.SQLCADTA_SQLDTARD_RLO_SIZE)]</InnerVar>
                <InnerVar>int [firstcols=remaining / FdocaConstants.SQLDTAGRP_COL_DSC_SIZE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeBytes;[FdocaConstants.SQLCADTA_SQLDTARD_RLO]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDTAGRP</MethodName>
            <MethodComment>/** 
 * Write SQLDTAGRP SQLDAGRP : Late FDOCA GROUP SQL Data Value Group Descriptor LENGTH - length of the SQLDTAGRP TRIPLET_TYPE - NGDA for first, CPT for following ID - SQLDTAGRP_LID for first, NULL_LID for following For each column DRDA TYPE  LENGTH OVERRIDE For numeric/decimal types PRECISON SCALE otherwise LENGTH or DISPLAY_WIDTH
 * @param stmt      drda statement
 * @param rsmeta    resultset meta data
 * @param pmeta     parameter meta data for CallableStatement
 * @param colStart  starting column for group to send
 * @param colEnd    end column to send
 * @param first     is this the first group
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rsmeta</ParamName>
                    <ParamType>ResultSetMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colStart</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [length=(FdocaConstants.SQLDTAGRP_COL_DSC_SIZE * ((colEnd + 1) - colStart)) + 3]</InnerVar>
                <InnerVar>boolean [hasRs=(rsmeta != null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDHROW</MethodName>
            <MethodComment>/** 
 * Holdability passed in as it can represent the holdability of the statement or a specific result set.
 * @param holdability HOLD_CURSORS_OVER_COMMIT or CLOSE_CURSORS_AT_COMMIT
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>holdability</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[holdability]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeQRYDTA</MethodName>
            <MethodComment>/** 
 * Write QRYDTA - Query Answer Set Data Contains some or all of the answer set data resulting from a query If the client is not using rowset processing, this routine attempts to pack as much data into the QRYDTA as it can. This may result in splitting the last row across the block, in which case when the client calls CNTQRY we will return the remainder of the row. Splitting a QRYDTA block is expensive, for several reasons: - extra logic must be run, on both client and server side - more network round-trips are involved - the QRYDTA block which contains the continuation of the split row is generally wasteful, since it contains the remainder of the split row but no additional rows. Since splitting is expensive, the server makes some attempt to avoid it. Currently, the server's algorithm for this is to compute the length of the current row, and to stop trying to pack more rows into this buffer if another row of that length would not fit. However, since rows can vary substantially in length, this algorithm is often ineffective at preventing splits. For example, if a short row near the end of the buffer is then followed by a long row, that long row will be split. It is possible to improve this algorithm substantially: - instead of just using the length of the previous row as a guide for whether to attempt packing another row in, use some sort of overall average row size computed over multiple rows (e.g., all the rows we've placed into this QRYDTA block, or all the rows we've process for this result set) - when we discover that the next row will not fit, rather than splitting the row across QRYDTA blocks, if it is relatively small, we could just hold the entire row in a buffer to place it entirely into the next QRYDTA block, or reset the result set cursor back one row to "unread" this row. - when splitting a row across QRYDTA blocks, we tend to copy data around multiple times. Careful coding could remove some of these copies. However, it is important not to over-complicate this code: it is better to be correct than to be efficient, and there have been several bugs in the split logic already. Instance Variables Byte string
 * @param stmt  DRDA statement we are processing
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [getMoreData=true]</InnerVar>
                <InnerVar>boolean [sentExtData=false]</InnerVar>
                <InnerVar>int [startLength=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssObject;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.QRYDTA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFDODTA</MethodName>
            <MethodComment>/** 
 * This routine places some data into the current QRYDTA block using FDODTA (Formatted Data Object DaTA rules). There are 3 basic types of processing flow for this routine: - In normal non-rowset, non-scrollable cursor flow, this routine places a single row into the QRYDTA block and returns TRUE, indicating that the caller can call us back to place another row into the result set if he wishes. (The caller may need to send Externalized Data, which would be a reason for him NOT to place any more rows into the QRYDTA). - In ROWSET processing, this routine places an entire ROWSET of rows into the QRYDTA block and returns FALSE, indicating that the QRYDTA block is full and should now be sent. - In callable statement processing, this routine places the results from the output parameters of the called procedure into the QRYDTA block. This code path is really dramatically different from the other two paths and shares only a very small amount of common code in this routine. In all cases, it is possible that the data we wish to return may not fit into the QRYDTA block, in which case we call splitQRYDTA to split the data and remember the remainder data in the result set. Splitting the data is relatively rare in the normal cursor case, because our caller (writeQRYDTA) uses a coarse estimation technique to avoid calling us if he thinks a split is likely. The overall structure of this routine is implemented as two loops: - the outer "do ... while ... " loop processes a ROWSET, one row at a time. For non-ROWSET cursors, and for callable statements, this loop executes only once. - the inner "for ... i &amp;lt; numCols ..." loop processes each column in the current row, or each output parmeter in the procedure. Most column data is written directly inline in the QRYDTA block. Some data, however, is written as Externalized Data. This is commonly used for Large Objects. In that case, an Externalized Data Pointer is written into the QRYDTA block, and the actual data flows in separate EXTDTA blocks which are returned after this QRYDTA block.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [hasdata]</InnerVar>
                <InnerVar>int [blksize=stmt.getBlksize() &gt; 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX]</InnerVar>
                <InnerVar>long [rowCount=0]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
                <InnerVar>boolean [moreData=(stmt.getQryprctyp() == CodePoint.LMTBLKPRC)]</InnerVar>
                <InnerVar>int [numCols]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectForWriteFdoca</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get a column value of the specified type from a  {@code ResultSet}, in a form suitable for being writted by  {@link #writeFdocaVal}. For most types, this means just calling  {@code ResultSet.getObject(int)}. &lt;/p&gt; &lt;p&gt; The only exception currently is the data types representing dates and times, as they need to be fetched using the same {@code java.util.Calendar} as {@link #writeFdocaVal} uses when writingthem (DERBY-4582). &lt;/p&gt; &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; Changes made in this method should also be made in the corresponding method for  {@code CallableStatement}: {@link #getObjectForWriteFdoca(java.sql.CallableStatement,int,int)}. &lt;/p&gt;
 * @param rs the result set to fetch the object from
 * @param index the column index
 * @param drdaType the DRDA type of the object to fetch
 * @return an object with the value of the column
 * @throws if a database error occurs while fetching the column value
 * @see #getObjectForWriteFdoca(java.sql.CallableStatement,int,int)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ndrdaType=drdaType | 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectForWriteFdoca</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the value of an output parameter of the specified type from a {@code CallableStatement}, in a form suitable for being writted by {@link #writeFdocaVal}. For most types, this means just calling {@code CallableStatement.getObject(int)}. &lt;/p&gt; &lt;p&gt; This method should behave like the corresponding method for {@code ResultSet}, and changes made to one of these methods, must be reflected in the other method. See {@link #getObjectForWriteFdoca(java.sql.ResultSet,int,int)}for details. &lt;/p&gt;
 * @param cs the callable statement to fetch the object from
 * @param index the parameter index
 * @param drdaType the DRDA type of the object to fetch
 * @return an object with the value of the output parameter
 * @throws if a database error occurs while fetching the parameter value
 * @see #getObjectForWriteFdoca(java.sql.ResultSet,int,int)
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cs</ParamName>
                    <ParamType>CallableStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ndrdaType=drdaType | 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitQRYDTA</MethodName>
            <MethodComment>/** 
 * Split QRYDTA into blksize chunks This routine is called if the QRYDTA data will not fit. It writes as much data as it can, then stores the remainder in the result set. At some later point, when the client returns with a CNTQRY, we will call processLeftoverQRYDTA to handle that data. The interaction between DRDAConnThread and DDMWriter is rather complicated here. This routine gets called because DRDAConnThread realizes that it has constructed a QRYDTA message which is too large. At that point, we need to reclaim the "extra" data and hold on to it. To aid us in that processing, DDMWriter provides the routines getDSSLength, copyDSSDataToEnd, and truncateDSS. For some additional detail on this complex sub-protocol, the interested reader should study bug DERBY-491 and 492 at: http://issues.apache.org/jira/browse/DERBY-491 and http://issues.apache.org/jira/browse/DERBY-492
 * @param stmt DRDA statment
 * @param blksize size of query block
 * @throws SQLException
 * @throws DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>blksize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [temp=writer.copyDSSDataToEnd(blksize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;truncateDSS;[blksize]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;setSplitQRYDTA;[temp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processLeftoverQRYDTA</MethodName>
            <MethodComment>/** 
 * Process remainder data resulting from a split. This routine is called at the start of building each QRYDTA block. Normally, it observes that there is no remainder data from the previous QRYDTA block, and returns FALSE, indicating that there was nothing to do. However, if it discovers that the previous QRYDTA block was split, then it retrieves the remainder data from the result set, writes as much of it as will fit into the QRYDTA block (hopefully all of it will fit, but the row may be very long), and returns TRUE, indicating that this QRYDTA block has been filled with remainder data and should now be sent immediately.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [leftovers=stmt.getSplitQRYDTA()]</InnerVar>
                <InnerVar>int [blksize=stmt.getBlksize() &gt; 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doneData</MethodName>
            <MethodComment>/** 
 * Done data Send SQLCARD for the end of the data
 * @param stmt DRDA statement
 * @param rs Result set
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [blksize=stmt.getBlksize() &gt; 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX]</InnerVar>
                <InnerVar>boolean [isQRYSCRAFT=(stmt.getQryscrorn() == CodePoint.QRYSCRAFT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeSQLCAGRP;[(isQRYSCRAFT ? eod00000 : eod02000), (isQRYSCRAFT ? 0 : 100), 0, stmt.rowCount]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeByte;[CodePoint.NULLDATA]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionCursor</MethodName>
            <MethodComment>/** 
 * Position cursor for insensitive scrollable cursors
 * @param stmt  DRDA statement
 * @param rs    Result set
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [retval=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDAGRP</MethodName>
            <MethodComment>/** 
 * Write SQLDAGRP SQLDAGRP : EARLY FDOCA GROUP SQL Data Area Group Description FORMAT FOR SQLAM &amp;lt;= 6 SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLLENGTH; DRDA TYPE I4; ENVLID 0x02; Length Override 4 SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2 SQLNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30 SQLNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30 SQLLABEL_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30 SQLLABEL_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30 SQLCOMMENTS_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 254 SQLCOMMENTS_m; DRDA TYPE VCS; ENVLID 0x32; Length Override 254 FORMAT FOR SQLAM == 6 SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLLENGTH; DRDA TYPE I8; ENVLID 0x16; Length Override 8 SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2 SQLNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30 SQLNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30 SQLLABEL_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30 SQLLABEL_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30 SQLCOMMENTS_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 254 SQLCOMMENTS_m; DRDA TYPE VCS; ENVLID 0x32; Length Override 254 SQLUDTGRP; DRDA TYPE N-GDA; ENVLID 0x51; Length Override 0 FORMAT FOR SQLAM &amp;gt;= 7 SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLLENGTH; DRDA TYPE I8; ENVLID 0x16; Length Override 8 SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2 SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2 SQLDOPTGRP; DRDA TYPE N-GDA; ENVLID 0xD2; Length Override 0
 * @param rsmeta    resultset meta data
 * @param pmeta     parameter meta data
 * @param elemNum   column number we are returning (in case of result set), or,parameter number (in case of parameter)
 * @param rtnOutput whether this is for a result set
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsmeta</ParamName>
                    <ParamType>ResultSetMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>elemNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rtnOutput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [jdbcElemNum=elemNum + 1]</InnerVar>
                <InnerVar>int[] [outlen={-1}]</InnerVar>
                <InnerVar>int [elemType=rtnOutput ? rsmeta.getColumnType(jdbcElemNum) : pmeta.getParameterType(jdbcElemNum)]</InnerVar>
                <InnerVar>int [precision=Math.min(FdocaConstants.NUMERIC_MAX_PRECISION,rtnOutput ? rsmeta.getPrecision(jdbcElemNum) : pmeta.getPrecision(jdbcElemNum))]</InnerVar>
                <InnerVar>int [scale=(rtnOutput ? rsmeta.getScale(jdbcElemNum) : pmeta.getScale(jdbcElemNum))]</InnerVar>
                <InnerVar>boolean [nullable=rtnOutput ? (rsmeta.isNullable(jdbcElemNum) == ResultSetMetaData.columnNullable) : (pmeta.isNullable(jdbcElemNum) == ParameterMetaData.parameterNullable)]</InnerVar>
                <InnerVar>int [sqlType=SQLTypes.mapJdbcTypeToDB2SqlType(elemType,nullable,appRequester,outlen)]</InnerVar>
                <InnerVar>String [typeName=rtnOutput ? rsmeta.getColumnTypeName(jdbcElemNum) : pmeta.getParameterTypeName(jdbcElemNum)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeShort;[precision]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[scale]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[sqlType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeVCMorVCS</MethodName>
            <MethodComment>/** 
 * Write variable character mixed byte or single byte The preference is to write mixed byte if it is defined for the server, since that is our default and we don't allow it to be changed, we always write mixed byte.
 * @param s string to write
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeLDString;[s]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLUDTGRP</MethodName>
            <MethodComment>/** 
 * Write SQLUDTGRP (SQL Descriptor User-Defined Type Group Descriptor) This is the format from the DRDA spec, Volume 1, section 5.6.4.10. However, this format is not rich enough to carry the information needed by JDBC. This format does not have a subtype code for JAVA_OBJECT and this format does not convey the Java class name needed by ResultSetMetaData.getColumnClassName(). SQLUDXTYPE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 Constants which map to java.sql.Types constants DISTINCT, STRUCT, and REF. But DRDA does not define a constant which maps to java.sql.Types.JAVA_OBJECT. SQLUDTRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Database name. SQLUDTSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Schema name. One of the above. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Unqualified UDT name. One of the above. Instead, we use the following format and only for communication between Derby servers and Derby clients which are both at version 10.6 or higher. For all other client/server combinations, we send null. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Fully qualified UDT name. One of the above. SQLUDTCLASSNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN SQLUDTCLASSNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN Name of the Java class bound to the UDT. One of the above.
 * @param rsmeta    resultset meta data
 * @param pmeta     parameter meta data
 * @param jdbcElemNum   column number we are returning (in case of result set), or,parameter number (in case of parameter)
 * @param rtnOutput whether this is for a result set
 * @throws DRDAProtocolException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsmeta</ParamName>
                    <ParamType>ResultSetMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jdbcElemNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rtnOutput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [jdbcType=rtnOutput ? rsmeta.getColumnType(jdbcElemNum) : pmeta.getParameterType(jdbcElemNum)]</InnerVar>
                <InnerVar>String [typeName=rtnOutput ? rsmeta.getColumnTypeName(jdbcElemNum) : pmeta.getParameterTypeName(jdbcElemNum)]</InnerVar>
                <InnerVar>String [className=rtnOutput ? rsmeta.getColumnClassName(jdbcElemNum) : pmeta.getParameterClassName(jdbcElemNum)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeVCMorVCS;[typeName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[className]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDOPTGRP</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsmeta</ParamName>
                    <ParamType>ResultSetMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jdbcElemNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rtnOutput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[rtnOutput ? rsmeta.getColumnName(jdbcElemNum) : null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLUDTGRP;[rsmeta, pmeta, jdbcElemNum, rtnOutput]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeSQLDXGRP;[rsmeta, pmeta, jdbcElemNum, rtnOutput]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeSQLDXGRP</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsmeta</ParamName>
                    <ParamType>ResultSetMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pmeta</ParamName>
                    <ParamType>ParameterMetaData</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jdbcElemNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rtnOutput</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;writeByte;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[rtnOutput ? rsmeta.isWritable(jdbcElemNum) : false]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[rtnOutput ? rsmeta.getTableName(jdbcElemNum) : null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[rtnOutput ? rsmeta.getSchemaName(jdbcElemNum) : null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeVCMorVCS;[rtnOutput ? rsmeta.getColumnName(jdbcElemNum) : null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFdocaVal</MethodName>
            <MethodComment>/** 
 * Write Fdoca Value to client 
 * @param index     Index of column being returned
 * @param val       Value to write to client
 * @param drdaType  FD:OCA DRDA Type from FdocaConstants
 * @param precision Precision
 * @param stmt       Statement being processed
 * @param isParam   True when writing a value for a procedure parameter
 * @exception DRDAProtocolException  
 * @exception SQLException
 * @see FdocaConstants
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valNull</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParam</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeNullability;[drdaType, valNull]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeNullability</MethodName>
            <MethodComment>/** 
 * write nullability if this is a nullable drdatype and FDOCA null value if appropriate
 * @param drdaType      FDOCA type
 * @param valNull       true if this is a null value. False otherwise
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valNull</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatDate</MethodName>
            <MethodComment>/** 
 * Convert a  {@code java.sql.Date} to a string with the format expectedby the client.
 * @param date the date to format
 * @return a string on the format YYYY-MM-DD representing the date
 * @see org.apache.derby.client.am.DateTime#dateBytesToDate
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>date</ParamName>
                    <ParamType>java.sql.Date</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Calendar [cal=getGMTCalendar()]</InnerVar>
                <InnerVar>char[] [buf="YYYY-MM-DD".toCharArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;setTime;[date]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 0, 4, cal.get(Calendar.YEAR)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 5, 2, cal.get(Calendar.MONTH) + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 8, 2, cal.get(Calendar.DAY_OF_MONTH)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatTime</MethodName>
            <MethodComment>/** 
 * Convert a  {@code java.sql.Time} to a string with the format expectedby the client.
 * @param time the time to format
 * @return a string on the format HH:MM:SS representing the time
 * @see org.apache.derby.client.am.DateTime#timeBytesToTime
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>time</ParamName>
                    <ParamType>Time</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Calendar [cal=getGMTCalendar()]</InnerVar>
                <InnerVar>char[] [buf="HH:MM:SS".toCharArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;setTime;[time]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 0, 2, cal.get(Calendar.HOUR_OF_DAY)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 3, 2, cal.get(Calendar.MINUTE)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 6, 2, cal.get(Calendar.SECOND)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatTimestamp</MethodName>
            <MethodComment>/** 
 * Convert a  {@code java.sql.Timestamp} to a string with the formatexpected by the client.
 * @param ts the timestamp to format
 * @return a string on the format YYYY-MM-DD-HH.MM.SS.ffffff[fff]
 * @see org.apache.derby.client.am.DateTime#timestampBytesToTimestamp
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ts</ParamName>
                    <ParamType>Timestamp</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Calendar [cal=getGMTCalendar()]</InnerVar>
                <InnerVar>char[] [buf=new char[appRequester.getTimestampLength()]]</InnerVar>
                <InnerVar>int [nanos=ts.getNanos()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cal;clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>cal;setTime;[ts]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 0, 4, cal.get(Calendar.YEAR)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 5, 2, cal.get(Calendar.MONTH) + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 8, 2, cal.get(Calendar.DAY_OF_MONTH)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 11, 2, cal.get(Calendar.HOUR_OF_DAY)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 14, 2, cal.get(Calendar.MINUTE)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padInt;[buf, 17, 2, cal.get(Calendar.SECOND)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padInt</MethodName>
            <MethodComment>/** 
 * Insert an integer into a char array and pad it with leading zeros if its string representation is shorter than  {@code length} characters.
 * @param buf the char array
 * @param offset where in the array to start inserting the value
 * @param length the desired length of the inserted string
 * @param value the integer value to insert
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [radix=10]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyToRequired</MethodName>
            <MethodComment>/** 
 * Copy a list of required code points to template for checking
 * @param req list of required codepoints
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>req</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[req, 0, required, 0, req.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFromRequired</MethodName>
            <MethodComment>/** 
 * Remove codepoint from required list
 * @param codePoint - code point to be removed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRequired</MethodName>
            <MethodComment>/** 
 * Check whether we have seen all the required code points
 * @param codePoint code point for which list of code points is required
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstMissing=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tooMany</MethodName>
            <MethodComment>/** 
 * Seen too many of this code point
 * @param codePoint  code point which has been duplicated
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_TOO_MANY, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tooBig</MethodName>
            <MethodComment>/** 
 * Object too big
 * @param codePoint  code point with too big object
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_TOO_BIG, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidClient</MethodName>
            <MethodComment>/** 
 * Invalid non-derby client tried to connect. thrown a required Value not found error and log a message to derby.log
 * @param prdid product id that does not match DNC 
 * @throws DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prdid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Monitor;logMessage;[new Date() + " : " + server.localizeMessage("DRDA_InvalidClient.S",new String[]{prdid})]</InnerMethodInvoke>
                <InnerMethodInvoke>null;requiredValueNotFound;[CodePoint.PRDID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiredValueNotFound</MethodName>
            <MethodComment>/** 
 * Required value not found.
 * @param codePoint code point with invalid value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_REQ_VAL_NOT_FOUND, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>badObjectLength</MethodName>
            <MethodComment>/** 
 * Object length not allowed
 * @param codePoint  code point with bad object length
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_OBJ_LEN_NOT_ALLOWED, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rdbNotFound</MethodName>
            <MethodComment>/** 
 * RDB not found
 * @param rdbnam  name of database
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rdbnam</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [oa={rdbnam}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidValue</MethodName>
            <MethodComment>/** 
 * Invalid value for this code point
 * @param codePoint  code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_REQ_VAL_NOT_FOUND, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidCodePoint</MethodName>
            <MethodComment>/** 
 * Invalid codepoint for this command
 * @param codePoint code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwSyntaxrm;[CodePoint.SYNERRCD_INVALID_CP_FOR_CMD, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>codePointNotSupported</MethodName>
            <MethodComment>/** 
 * Don't support this code point
 * @param codePoint  code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>valueNotSupported</MethodName>
            <MethodComment>/** 
 * Don't support this value
 * @param codePoint  code point value
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyRequiredObject</MethodName>
            <MethodComment>/** 
 * Verify that the code point is the required code point
 * @param codePoint code point we have
 * @param reqCodePoint code point required at this time
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reqCodePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyInOrderACCSEC_SECCHK</MethodName>
            <MethodComment>/** 
 * Verify that the code point is in the right order
 * @param codePoint code point we have
 * @param reqCodePoint code point required at this time
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reqCodePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rdbnamMismatch</MethodName>
            <MethodComment>/** 
 * Database name given under code point doesn't match previous database names
 * @param codePoint codepoint where the mismatch occurred
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeSession</MethodName>
            <MethodComment>/** 
 * Close the current session
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>server;removeFromSessionTable;[session.connNum]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleException</MethodName>
            <MethodComment>/** 
 * Handle Exceptions - write error protocol if appropriate and close session or thread as appropriate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Exception</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendProtocolException</MethodName>
            <MethodComment>/** 
 * Notice the client about a protocol error.
 * @param de &lt;code&gt;DRDAProtocolException&lt;/code&gt; to be sent
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>de</ParamName>
                    <ParamType>DRDAProtocolException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [dbname=getDbName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendUnexpectedException</MethodName>
            <MethodComment>/** 
 * Send unpexpected error to the client
 * @param e Exception to be sent
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>Exception</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DRDAProtocolException [unExpDe]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closed</MethodName>
            <MethodComment>/** 
 * Test if DRDA connection thread is closed
 * @return true if close; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogConnections</MethodName>
            <MethodComment>/** 
 * Get whether connections are logged
 * @return true if connections are being logged; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeSlice</MethodName>
            <MethodComment>/** 
 * Get time slice value for length of time to work on a session
 * @return time slice
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trace</MethodName>
            <MethodComment>/** 
 * Send string to console
 * @param value - value to print on console
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceEXTDTARead</MethodName>
            <MethodComment>/** 
 * Sends a trace string to the console when reading an EXTDTA value (if tracing is enabled).
 * @param drdaType the DRDA type of the EXTDTA value
 * @param index the one-based parameter index
 * @param stream the stream being read
 * @param streamLOB whether or not the value is being streamed as the lastparameter value in the DRDA protocol flow
 * @param encoding the encoding of the data, if any
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>EXTDTAReaderInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>streamLOB</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encoding</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>showmem</MethodName>
            <MethodComment>/** 
 * Show runtime memory
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Runtime [rt=Runtime.getRuntime()]</InnerVar>
                <InnerVar>Date [d=new Date()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rt;gc;[]</InnerMethodInvoke>
                <InnerMethodInvoke>System.out;println;["total memory: " + rt.totalMemory() + " free: "+ rt.freeMemory()+ " "+ d.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertToHexString</MethodName>
            <MethodComment>/** 
 * convert byte array to a Hex string
 * @param buf buffer to  convert
 * @return hex string representation of byte array
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkValidTypDefNam</MethodName>
            <MethodComment>/** 
 * check that the given typdefnam is acceptable
 * @param typdefnam 
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typdefnam</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkLength</MethodName>
            <MethodComment>/** 
 * Check that the length is equal to the required length for this codepoint
 * @param codepoint codepoint we are checking
 * @param reqlen    required length
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codepoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reqlen</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [len=reader.getDdmLength()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readBoolean</MethodName>
            <MethodComment>/** 
 * Read and check a boolean value
 * @param codepoint codePoint to be used in error reporting
 * @return true or false depending on boolean value read
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codepoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [val=reader.readByte()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkLength;[codepoint, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeDatabase</MethodName>
            <MethodComment>/** 
 * Create a new database and intialize the  DRDAConnThread database.
 * @param dbname database name to initialize. If dbnam is non null, add database to the current session
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Database [db]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDatabase</MethodName>
            <MethodComment>/** 
 * Set the current database
 * @param codePoint     codepoint we are processing
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [dbname=parseRDBNAM()]</InnerVar>
                <InnerVar>Database [d=session.getDatabase(dbname)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeENDUOWRM</MethodName>
            <MethodComment>/** 
 * Write ENDUOWRM Instance Variables SVCOD - severity code - WARNING - required UOWDSP - Unit of Work Disposition - required RDBNAM - Relational Database name - optional SRVDGN - Server Diagnostics information - optional
 * @param opType - operation type 1 - commit, 2 -rollback
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;createDssReply;[]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;startDdm;[CodePoint.ENDUOWRM]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar2Bytes;[CodePoint.SVRCOD, CodePoint.SVRCOD_WARNING]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;writeScalar1Byte;[CodePoint.UOWDSP, opType]</InnerMethodInvoke>
                <InnerMethodInvoke>writer;endDdmAndDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeEXTDTA</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Object&gt; [extdtaValues=stmt.getExtDtaObjects()]</InnerVar>
                <InnerVar>boolean [chainFlag, chainedWithSameCorrelator]</InnerVar>
                <InnerVar>boolean [writeNullByte=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;clearExtDtaObjects;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkWarning</MethodName>
            <MethodComment>/** 
 * Check SQLWarning and write SQLCARD as needed.
 * @param conn      connection to check
 * @param stmt      statement to check
 * @param rs        result set to check
 * @param updateCount   update count to include in SQLCARD
 * @param alwaysSend    whether always send SQLCARD regardless ofthe existance of warnings
 * @param sendWarn  whether to send any warnings or not.
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alwaysSend</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sendWarn</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLWarning [reportWarning=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasSession</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytesRead</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytesWritten</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildRuntimeInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indent</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localLangUtil</ParamName>
                    <ParamType>LocalizedResource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Session [s=session]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finalizeChain</MethodName>
            <MethodComment>/** 
 * Finalize the current DSS chain and send it if needed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>writer;finalizeChain;[reader.getCurrChainState(), getOutputStream()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateSecMecUSRSSBPWD</MethodName>
            <MethodComment>/** 
 * Validate SECMEC_USRSSBPWD (Strong Password Substitute) can be used as DRDA security mechanism. Here we check that the target server can support SECMEC_USRSSBPWD security mechanism based on the environment, application requester's identity (PRDID) and connection URL. IMPORTANT NOTE: -------------- SECMEC_USRSSBPWD is ONLY supported by the target server if: - current authentication provider is Derby BUILTIN or NONE. (database / system level) (Phase I) - database-level password must have been encrypted with the SHA-1 based authentication scheme - Application requester is 'DNC' (Derby Network Client) (Phase I)
 * @return security check code - 0 if everything O.K.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AuthenticationService [authenticationService=null]</InnerVar>
                <InnerVar>org.apache.derby.iapi.db.Database [databaseObj=null]</InnerVar>
                <InnerVar>String [srvrlslv=appRequester.srvrlslv]</InnerVar>
                <InnerVar>String [dbName=database.getShortDbName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>appRequester;setClientVersion;[srvrlslv.substring(0,(int)CodePoint.PRDID_MAX)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeStream</MethodName>
            <MethodComment>/** 
 * Close a stream.
 * @param stream the stream to close (possibly {@code null})
 * @throws SQLException wrapped around an {@code IOException} if closingthe stream failed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertAsByteArrayInputStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>EXTDTAReaderInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteArrayLength=stream instanceof StandardEXTDTAReaderInputStream ? (int)((StandardEXTDTAReaderInputStream)stream).getLength() : 1 + stream.available()]</InnerVar>
                <InnerVar>PublicBufferOutputStream [pbos=new PublicBufferOutputStream(byteArrayLength)]</InnerVar>
                <InnerVar>byte[] [buffer=new byte[Math.min(byteArrayLength,32 * 1024)]]</InnerVar>
                <InnerVar>int [c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stream;setSuppressException;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PublicBufferOutputStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuffer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCount</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAsCharacterStream</MethodName>
            <MethodComment>/** 
 * Sets the specified character EXTDTA parameter of the embedded statement.
 * @param stmt the DRDA statement to use
 * @param i the one-based index of the parameter
 * @param extdtaStream the EXTDTA stream to read data from
 * @param streamLOB whether or not the stream content is streamed as thelast value in the DRDA protocol flow
 * @param encoding the encoding of the EXTDTA stream
 * @throws IOException if reading from the stream fails
 * @throws SQLException if setting the stream fails
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extdtaStream</ParamName>
                    <ParamType>EXTDTAReaderInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>streamLOB</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encoding</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
                <InnerVar>InputStream [is=streamLOB ? (InputStream)extdtaStream : convertAsByteArrayInputStream(extdtaStream)]</InnerVar>
                <InnerVar>InputStreamReader [streamReader=new InputStreamReader(is,encoding)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setCharacterStream;[i, streamReader]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAsBinaryStream</MethodName>
            <MethodComment>/** 
 * Sets the specified binary EXTDTA parameter of the embedded statement.
 * @param stmt the DRDA statement to use
 * @param index the one-based index of the parameter
 * @param stream the EXTDTA stream to read data from
 * @param streamLOB whether or not the stream content is streamed as thelast value in the DRDA protocol flow
 * @throws IOException if reading from the stream fails
 * @throws SQLException  if setting the stream fails
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stream</ParamName>
                    <ParamType>EXTDTAReaderInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>streamLOB</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [type=stmt.getParameterMetaData().getParameterType(index)]</InnerVar>
                <InnerVar>boolean [useSetBinaryStream=(type == Types.BLOB)]</InnerVar>
                <InnerVar>PreparedStatement [ps=stmt.getPreparedStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Privileged Monitor lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findService</MethodName>
            <MethodComment>/** 
 * Privileged service lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>