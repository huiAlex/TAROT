<Class>
    <Id>1761</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>TemporaryRowHolderResultSet</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>CursorResultSet</SuperInterface>
        <SuperInterface>NoPutResultSet</SuperInterface>
        <SuperInterface>Cloneable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TemporaryRowHolderResultSet  /** 
 * A result set to scan temporary row holders.  Ultimately, this may be returned to users, hence the extra junk from the ResultSet interface.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>rowArray</FieldName>
            <FieldType>ExecRow[]</FieldType>
        </Field>
        <Field>
            <FieldName>numRowsOut</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>scan</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>isOpen</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>finished</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>currentRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>resultDescription</FieldName>
            <FieldType>ResultDescription</FieldType>
        </Field>
        <Field>
            <FieldName>isAppendable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>positionIndexConglomId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>isVirtualMemHeap</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>currRowFromMem</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>holder</FieldName>
            <FieldType>TemporaryRowHolderImpl</FieldType>
        </Field>
        <Field>
            <FieldName>heapCC</FieldName>
            <FieldType>ConglomerateController</FieldType>
        </Field>
        <Field>
            <FieldName>baseRowLocation</FieldName>
            <FieldType>RowLocation</FieldType>
        </Field>
        <Field>
            <FieldName>indexRow</FieldName>
            <FieldType>DataValueDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>indexsc</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>TemporaryRowHolderResultSet</MethodName>
            <MethodComment>/** 
 * Constructor
 * @param tc the xact controller
 * @param rowArray the row array
 * @param resultDescription value returned by getResultDescription()
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowArray</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultDescription</ParamName>
                    <ParamType>ResultDescription</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isVirtualMemHeap</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>holder</ParamName>
                    <ParamType>TemporaryRowHolderImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TemporaryRowHolderResultSet</MethodName>
            <MethodComment>/** 
 * Constructor
 * @param tc the xact controller
 * @param rowArray the row array
 * @param resultDescription value returned by getResultDescription()
 * @param isAppendable true,if we can insert rows after this result is created
 * @param positionIndexConglomId conglomId of the index which has order rowsare inserted and their row location 
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowArray</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultDescription</ParamName>
                    <ParamType>ResultDescription</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isVirtualMemHeap</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isAppendable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>positionIndexConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>holder</ParamName>
                    <ParamType>TemporaryRowHolderImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reset</MethodName>
            <MethodComment>/** 
 * Reset the exec row array and reinitialize
 * @param rowArray the row array
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowArray</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reStartScan</MethodName>
            <MethodComment>/** 
 * postion scan to start from after where we stopped earlier
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pconglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supersetofAllColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnsArray1</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnsArray2</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxLength=columnsArray1.length + columnsArray2.length]</InnerVar>
                <InnerVar>int[] [maxArray=new int[maxLength]]</InnerVar>
                <InnerVar>int [validColsPosition=columnsArray1.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>java.util.Arrays;sort;[maxArray]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shrinkArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnsArrary</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [countOfColsRefedInArray=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=columnsArrary.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>justTheRequiredColumnsPositions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnsArrary</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [countOfColsRefedInArray=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=columnsArrary.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewRSOnCurrentRow</MethodName>
            <MethodComment>/** 
 * Whip up a new Temp ResultSet that has a single row. This row will either have all the columns from the current row of the passed resultset or a subset  of the columns from the passed resulset. It all depends on what columns are needed by the passed trigger and what columns exist in the resulset. The Temp resulset should only have the columns required by the trigger.
 * @param triggerd We are building Temp resultset for this trigger
 * @param activation the activation
 * @param rs the result set 
 * @param colsReadFromTable The passed resultset is composed ofthese columns. We will create a temp resultset which will have either all these columns or only a subset of these columns. It all depends on what columns are needed by the trigger. If this param is null, then that means that all the columns from the trigger table have been read into the passed resultset.
 * @return a single row result set
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>TemporaryRowHolderResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerd</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>CursorResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsReadFromTable</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TemporaryRowHolderImpl [singleRow]</InnerVar>
                <InnerVar>DataDictionary [dd=activation.getLanguageConnectionContext().getDataDictionary()]</InnerVar>
                <InnerVar>int[] [referencedColsInTriggerAction=triggerd.getReferencedColsInTriggerAction()]</InnerVar>
                <InnerVar>int[] [referencedColsInTrigger=triggerd.getReferencedCols()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsTopResultSet</MethodName>
            <MethodComment>/** 
 * Mark the ResultSet as the topmost one in the ResultSet tree. Useful for closing down the ResultSet on an error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openCore</MethodName>
            <MethodComment>/** 
 * Open the scan and evaluate qualifiers and the like. For us, there are no qualifiers, this is really a noop.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenCore</MethodName>
            <MethodComment>/** 
 * Reopen the scan.  Typically faster than open()/close()
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowCore</MethodName>
            <MethodComment>/** 
 * Get the next row.
 * @return the next row, or null if none
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteCurrentRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupPositionBasedScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [searchRow=new DataValueDescriptor[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextAppendedRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>RowLocation [baseRowLocation=(RowLocation)indexRow[1]]</InnerVar>
                <InnerVar>boolean [base_row_exists=heapCC.fetch(baseRowLocation,currentRow.getRowArray(),(FormatableBitSet)null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPointOfAttachment</MethodName>
            <MethodComment>/** 
 * Return the point of attachment for this subquery. (Only meaningful for Any and Once ResultSets, which can and will only be at the top of a ResultSet for a subquery.)
 * @return int	Point of attachment (result set number) for thissubquery.  (-1 if not a subquery - also Sanity violation)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanIsolationLevel</MethodName>
            <MethodComment>/** 
 * Return the isolation level of the scan in the result set. Only expected to be called for those ResultSets that contain a scan.
 * @return The isolation level of the scan (in TransactionController constants).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTargetResultSet</MethodName>
            <MethodComment>/** 
 * Notify a NPRS that it is the source for the specified  TargetResultSet.  This is useful when doing bulk insert.
 * @param trs	The TargetResultSet.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>trs</ParamName>
                    <ParamType>TargetResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNeedsRowLocation</MethodName>
            <MethodComment>/** 
 * Set whether or not the NPRS need the row location when acting as a row source.  (The target result set determines this.)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>needsRowLocation</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * Get the estimated row count from this result set.
 * @return	The estimated row count (as a double) from this result set.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resultSetNumber</MethodName>
            <MethodComment>/** 
 * Get the number of this ResultSet, which is guaranteed to be unique within a statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentRow</MethodName>
            <MethodComment>/** 
 * Set the current row to the row passed in.
 * @param row the new current row
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearCurrentRow</MethodName>
            <MethodComment>/** 
 * Clear the current row
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRow</MethodName>
            <MethodComment>/** 
 * This result set has its row from the last fetch done.  If the cursor is closed, a null is returned.
 * @see CursorResultSet
 * @return the last row returned;
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowLocation</MethodName>
            <MethodComment>/** 
 * Returns the row location of the current base table row of the cursor. If this cursor's row is composed of multiple base tables' rows, i.e. due to a join, then a null is returned.  For a temporary row holder, we always return null.
 * @return the row location of the current cursor row.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Clean up
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnsRows</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the statement returns rows (i.e. is a SELECT or FETCH statement), FALSE if it returns no rows.
 * @return	TRUE if the statement returns rows, FALSE if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifiedRowCount</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultDescription</MethodName>
            <MethodComment>/** 
 * Returns a ResultDescription object, which describes the results of the statement this ResultSet is in. This will *not* be a description of this particular ResultSet, if this is not the outermost ResultSet.
 * @return	A ResultDescription describing the results of thestatement.
 */
</MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>open</MethodName>
            <MethodComment>/** 
 * Tells the system that there will be calls to getNextRow().
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;openCore;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAbsoluteRow</MethodName>
            <MethodComment>/** 
 * Returns the row at the absolute position from the query,  and returns NULL when there is no such position. (Negative position means from the end of the result set.) Moving the cursor to an invalid position leaves the cursor positioned either before the first row (negative position) or after the last row (positive position). NOTE: An exception will be thrown on 0.
 * @param row	The position.
 * @return	The row at the absolute position, or NULL if no such position.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRelativeRow</MethodName>
            <MethodComment>/** 
 * Returns the row at the relative position from the current cursor position, and returns NULL when there is no such position. (Negative position means toward the beginning of the result set.) Moving the cursor to an invalid position leaves the cursor positioned either before the first row (negative position) or after the last row (positive position). NOTE: 0 is valid. NOTE: An exception is thrown if the cursor is not currently positioned on a row.
 * @param row	The position.
 * @return	The row at the relative position, or NULL if no such position.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeforeFirstRow</MethodName>
            <MethodComment>/** 
 * Sets the current position to before the first row and returns NULL because there is no current row.
 * @return	NULL.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstRow</MethodName>
            <MethodComment>/** 
 * Returns the first row from the query, and returns NULL when there are no rows.
 * @return	The first row, or NULL if no rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRow</MethodName>
            <MethodComment>/** 
 * Returns the next row from the query, and returns NULL when there are no more rows.
 * @return	The next row, or NULL if no more rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreviousRow</MethodName>
            <MethodComment>/** 
 * Returns the previous row from the query, and returns NULL when there are no more previous rows.
 * @return	The previous row, or NULL if no more previous rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastRow</MethodName>
            <MethodComment>/** 
 * Returns the last row from the query, and returns NULL when there are no rows.
 * @return	The last row, or NULL if no rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAfterLastRow</MethodName>
            <MethodComment>/** 
 * Sets the current position to after the last row and returns NULL because there is no current row.
 * @return	NULL.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRowPosition</MethodName>
            <MethodComment>/** 
 * Determine if the cursor is before the first row in the result  set.   
 * @return true if before the first row, false otherwise. Returnsfalse when the result set contains no rows.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowNumber</MethodName>
            <MethodComment>/** 
 * Returns the row number of the current row.  Row numbers start from 1 and go to 'n'.  Corresponds to row numbering used to position current row in the result set (as per JDBC).
 * @return	the row number, or 0 if not on a row
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUp</MethodName>
            <MethodComment>/** 
 * Tells the system to clean up on an error.
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosed</MethodName>
            <MethodComment>/** 
 * Find out if the ResultSet is closed or not. Will report true for result sets that do not return rows.
 * @return true if the ResultSet has been closed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment>/** 
 * Tells the system that there will be no more access to any database information via this result set; in particular, no more calls to open(). Will close the result set if it is not already closed.
 * @exception StandardException	on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecuteTime</MethodName>
            <MethodComment>/** 
 * Get the execution time in milliseconds.
 * @return long		The execution time in milliseconds.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoGeneratedKeysResultset</MethodName>
            <MethodComment>/** 
 * @see ResultSet#getAutoGeneratedKeysResultset
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBeginExecutionTimestamp</MethodName>
            <MethodComment>/** 
 * Get the Timestamp for the beginning of execution.
 * @return Timestamp		The Timestamp for the beginning of execution.
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEndExecutionTimestamp</MethodName>
            <MethodComment>/** 
 * Get the Timestamp for the end of execution.
 * @return Timestamp		The Timestamp for the end of execution.
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeSpent</MethodName>
            <MethodComment>/** 
 * Return the total amount of time spent in this ResultSet
 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSetENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
 * @return long		The total amount of time spent (in milliseconds).
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubqueryTrackingArray</MethodName>
            <MethodComment>/** 
 * Get the subquery ResultSet tracking array from the top ResultSet. (Used for tracking open subqueries when closing down on an error.)
 * @param numSubqueries		The size of the array (For allocation on demand.)
 * @return NoPutResultSet[]	Array of NoPutResultSets for subqueries.
 */
</MethodComment>
            <ReturnType>NoPutResultSet[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numSubqueries</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCursorName</MethodName>
            <MethodComment>/** 
 * Returns the name of the cursor, if this is cursor statement of some type (declare, open, fetch, positioned update, positioned delete, close).
 * @return	A String with the name of the cursor, if any. ReturnsNULL if this is not a cursor statement.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiresRelocking</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#requiresRelocking
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowFromRowSource</MethodName>
            <MethodComment>/** 
 * Get the next row as an array of column objects. The column objects can be a JBMS Storable or any Serializable/Externalizable/Formattable/Streaming type. &lt;BR&gt; A return of null indicates that the complete set of rows has been read. &lt;p&gt; A null column can be specified by leaving the object null, or indicated by returning a non-null getValidColumns.  On streaming columns, it can be indicated by returning a non-null get FieldStates. &lt;p&gt; If RowSource.needToClone() is true then the returned row (the  DataValueDescriptor[]) is guaranteed not to be modified by drainer of  the RowSource (except that the input stream will be read, of course)  and drainer will keep no reference to it before making the subsequent  nextRow call.  So it is safe to return the same DataValueDescriptor[]  in subsequent nextRow calls if that is desirable for performance  reasons.   &lt;p&gt; If RowSource.needToClone() is false then the returned row (the  DataValueDescriptor[]) may be be modified by drainer of the RowSource,  and the drainer may keep a reference to it after making the subsequent  nextRow call.  In this case the client should severe all references to  the row after returning it from getNextRowFromRowSource().
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsToClone</MethodName>
            <MethodComment>/** 
 * Does the caller of getNextRowFromRowSource() need to clone the row in order to keep a reference to the row past the  getNextRowFromRowSource() call which returned the row.  This call must always return the same for all rows in a RowSource (ie. the caller will call this once per scan from a RowSource and assume the behavior is true for all rows in the RowSource).
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValidColumns</MethodName>
            <MethodComment>/** 
 * getValidColumns describes the DataValueDescriptor[] returned by all  calls to the getNextRowFromRowSource() call.  If getValidColumns returns null, the number of columns is given by the DataValueDescriptor.length where DataValueDescriptor[] is returned by the preceeding getNextRowFromRowSource() call.  Column N maps to  DataValueDescriptor[N], where column numbers start at zero. If getValidColumns return a non null validColumns FormatableBitSet the number of columns is given by the number of bits set in validColumns.  Column N is not in the partial row if validColumns.get(N) returns false.  Column N is in the partial row if validColumns.get(N) returns true.  If column N is in the partial row then it maps to DataValueDescriptor[M] where M is the count of calls to validColumns.get(i) that return true where i &amp;lt; N.  If DataValueDescriptor.length is greater than the number of columns  indicated by validColumns the extra entries are ignored.  
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeRowSource</MethodName>
            <MethodComment>/** 
 * closeRowSource tells the RowSource that it will no longer need to return any rows and it can release any resource it may have. Subsequent call to any method on the RowSource will result in undefined behavior.  A closed rowSource can be closed again.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsRowLocation</MethodName>
            <MethodComment>/** 
 * needsRowLocation returns true iff this the row source expects the drainer of the row source to call rowLocation after getting a row from getNextRowFromRowSource.
 * @return true iff this row source expects some row location to bereturned 
 * @see #rowLocation
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHasDeferrableChecks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsRowLocationForDeferredCheckConstraints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rowLocation</MethodName>
            <MethodComment>/** 
 * rowLocation is a callback for the drainer of the row source to return the rowLocation of the current row, i.e, the row that is being returned by getNextRowFromRowSource.  This interface is for the purpose of loading a base table with index.  In that case, the indices can be built at the same time the base table is laid down once the row location of the base row is known.  This is an example pseudo code on how this call is expected to be used: &lt;BR&gt;&lt;pre&gt; boolean needsRL = rowSource.needsRowLocation(); DataValueDescriptor[] row; while((row = rowSource.getNextRowFromRowSource()) != null) { RowLocation rl = heapConglomerate.insertRow(row); if (needsRL) rowSource.rowLocation(rl); } &lt;/pre&gt;&lt;BR&gt; NeedsRowLocation and rowLocation will ONLY be called by a drainer of the row source which CAN return a row location.  Drainer of row source which cannot return rowLocation will guarentee to not call either callbacks. Conversely, if NeedsRowLocation is called and it returns true, then for every row return by getNextRowFromRowSource, a rowLocation callback must also be issued with the row location of the row.  Implementor of both the source and the drain of the row source must be aware of this protocol. &lt;BR&gt; The RowLocation object is own by the caller of rowLocation, in other words, the drainer of the RowSource.  This is so that we don't need to new a row location for every row.  If the Row Source wants to keep the row location, it needs to clone it (RowLocation is a ClonableObject).
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>offendingRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containdId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionScanAtRowLocation</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#positionScanAtRowLocation This method is result sets used for scroll insensitive updatable  result sets for other result set it is a no-op.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isForUpdate</MethodName>
            <MethodComment>/** 
 * Is this ResultSet or it's source result set for update This method will be overriden in the inherited Classes if it is true
 * @return Whether or not the result set is for update.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment>/** 
 * Shallow clone this result set.  Used in trigger reference. beetle 4373.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [clo=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWarning</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>w</ParamName>
                    <ParamType>SQLWarning</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getActivation();addWarning;[w]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWarnings</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SQLWarning</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateRow</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#updateRow This method is result sets used for scroll insensitive updatable  result sets for other result set it is a no-op.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowChanger</ParamName>
                    <ParamType>RowChanger</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markRowAsDeleted</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#markRowAsDeleted This method is result sets used for scroll insensitive updatable  result sets for other result set it is a no-op.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActivation</MethodName>
            <MethodComment>/** 
 * Return the &lt;code&gt;Activation&lt;/code&gt; for this result set.
 * @return activation
 */
</MethodComment>
            <ReturnType>Activation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toXML</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Element</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentNode</ParamName>
                    <ParamType>Element</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tag</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>