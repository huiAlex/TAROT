<Class>
    <Id>2072</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>SpecialFunctionNode</ClassName>
    <SuperClass>ValueNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SpecialFunctionNode  /** 
 * SpecialFunctionNode handles system SQL functions. A function value is either obtained by a method call off the LanguageConnectionContext or Activation. LanguageConnectionContext functions are state related to the connection. Activation functions are those related to the statement execution. Each SQL function takes no arguments and returns a SQLvalue. &lt;P&gt; Functions supported: &lt;UL&gt; &lt;LI&gt; USER &lt;LI&gt; CURRENT_USER &lt;LI&gt; CURRENT_ROLE &lt;LI&gt; SESSION_USER &lt;LI&gt; SYSTEM_USER &lt;LI&gt; CURRENT SCHEMA &lt;LI&gt; CURRENT ISOLATION &lt;LI&gt; IDENTITY_VAL_LOCAL &lt;/UL&gt; &lt;P&gt; This node is used rather than some use of MethodCallNode for runtime performance. MethodCallNode does not provide a fast access to the current language connection or activation, since it is geared towards user defined routines.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>sqlName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>K_IDENTITY_VAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_CURRENT_ISOLATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_CURRENT_SCHEMA</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_USER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_CURRENT_USER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_SESSION_USER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_SYSTEM_USER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_CURRENT_ROLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>kind</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>methodName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>methodType</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SpecialFunctionNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Binding this special function means setting the result DataTypeServices. In this case, the result type is based on the operation requested.
 * @param fromList			The FROM list for the statement.  This parameteris not used in this case.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes. Not used in this case.
 * @param aggregates        The aggregate list being built as we findAggregateNodes. Not used in this case.
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkReliability;[sqlName, CompilerContext.USER_ILLEGAL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[dtd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. All supported special functions are QUERY_INVARIANT
 * @return	The variant type for the underlying expression.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Generate an expression that returns a DataValueDescriptor and calls a method off the language connection or the activation.
 * @param acb	The ExpressionClassBuilder for the class being built
 * @param mb	The method the code to place the code
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [argCount=0]</InnerVar>
                <InnerVar>String [fieldType=getTypeCompiler().interfaceName()]</InnerVar>
                <InnerVar>LocalField [field=acb.newFieldDeclaration(Modifier.PRIVATE,fieldType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, methodName, methodType, argCount]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;generateDataValue;[mb, getTypeCompiler(), getTypeServices().getCollationType(), field]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSameNodeKind</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>