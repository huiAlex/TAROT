<Class>
    <Id>2164</Id>
    <Package>org.apache.derby.iapi.sql.dictionary</Package>
    <ClassName>TableDescriptor</ClassName>
    <SuperClass>UniqueSQLObjectDescriptor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Provider</SuperInterface>
        <SuperInterface>Dependent</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TableDescriptor  /** 
 * This class represents a table descriptor. The external interface to this class is: &lt;p&gt; &lt;ol&gt; &lt;li&gt;external interface &lt;/li&gt; &lt;li&gt;public String	getSchemaName();&lt;/li&gt; &lt;li&gt;public String	getQualifiedName();&lt;/li&gt; &lt;li&gt;public int	getTableType();&lt;/li&gt; &lt;li&gt;public long getHeapConglomerateId() throws StandardException;&lt;/li&gt; &lt;li&gt;public int getNumberOfColumns();		&lt;/li&gt; &lt;li&gt;public FormatableBitSet getReferencedColumnMap();&lt;/li&gt; &lt;li&gt;public void setReferencedColumnMap(FormatableBitSet referencedColumnMap);&lt;/li&gt; &lt;li&gt;public int getMaxColumnID() throws StandardException;&lt;/li&gt; &lt;li&gt;public void	setUUID(UUID uuid);&lt;/li&gt; &lt;li&gt;public char	getLockGranularity();&lt;/li&gt; &lt;li&gt;public void	setTableName(String newTableName);&lt;/li&gt; &lt;li&gt;public void	setLockGranularity(char lockGranularity);&lt;/li&gt; &lt;li&gt;public ExecRow getEmptyExecRow( ContextManager cm) throws StandardException;&lt;/li&gt; &lt;li&gt;public boolean tableNameEquals(String otherSchemaName, String otherTableName);&lt;/li&gt; &lt;li&gt;public ReferencedKeyConstraintDescriptor getPrimaryKey() throws StandardException;&lt;/li&gt; &lt;li&gt;public void removeConglomerateDescriptor(ConglomerateDescriptor cd)	throws StandardException;&lt;/li&gt; &lt;li&gt;public void removeConstraintDescriptor(ConstraintDescriptor cd)	throws StandardException;&lt;/li&gt; &lt;li&gt;public void getAffectedIndexes(...) throws StandardException;&lt;/li&gt; &lt;li&gt;public void	getAllRelevantTriggers(...) throws StandardException;&lt;/li&gt; &lt;li&gt;public void getAllRelevantConstraints(...) throws StandardException&lt;/li&gt; &lt;li&gt;public ColumnDescriptorList getColumnDescriptorList();&lt;/li&gt; &lt;li&gt; public String[] getColumnNamesArray();&lt;/li&gt; &lt;li&gt;public long[]   getAutoincIncrementArray();&lt;/li&gt; &lt;li&gt;public ColumnDescriptor	getColumnDescriptor(String columnName);&lt;/li&gt; &lt;li&gt;public ColumnDescriptor	getColumnDescriptor(int columnNumber);&lt;/li&gt; &lt;li&gt;public ConglomerateDescriptor[]	getConglomerateDescriptors() throws StandardException;&lt;/li&gt; &lt;li&gt;public ConglomerateDescriptor	getConglomerateDescriptor(long conglomerateNumber)	throws StandardException;&lt;/li&gt; &lt;li&gt;public ConglomerateDescriptor	getConglomerateDescriptor(UUID conglomerateUUID) throws StandardException;&lt;/li&gt; &lt;li&gt;public	IndexLister	getIndexLister() throws StandardException;&lt;/li&gt; &lt;li&gt;public ViewDescriptor getViewDescriptor();&lt;/li&gt; &lt;li&gt;public boolean tableHasAutoincrement();&lt;/li&gt; &lt;li&gt;public boolean statisticsExist(ConglomerateDescriptor cd) throws StandardException;&lt;/li&gt; &lt;li&gt;public double selectivityForConglomerate(...)throws StandardException;&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>BASE_TABLE_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSTEM_TABLE_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VIEW_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GLOBAL_TEMPORARY_TABLE_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYNONYM_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VTI_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ROW_LOCK_GRANULARITY</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>TABLE_LOCK_GRANULARITY</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_LOCK_GRANULARITY</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>ISTATS_CREATE_THRESHOLD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ISTATS_ABSDIFF_THRESHOLD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ISTATS_LNDIFF_THRESHOLD</FieldName>
            <FieldType>double</FieldType>
        </Field>
        <Field>
            <FieldName>lockGranularity</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>onCommitDeleteRows</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>onRollbackDeleteRows</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexStatsUpToDate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexStatsUpdateReason</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>schema</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>tableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>oid</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>tableType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>heapConglomNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>columnDescriptorList</FieldName>
            <FieldType>ColumnDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>conglomerateDescriptorList</FieldName>
            <FieldType>ConglomerateDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>constraintDescriptorList</FieldName>
            <FieldType>ConstraintDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>triggerDescriptorList</FieldName>
            <FieldType>TriggerDescriptorList</FieldType>
        </Field>
        <Field>
            <FieldName>viewDescriptor</FieldName>
            <FieldType>ViewDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>statisticsDescriptorList</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>statisticsDescriptorList</FieldName>
            <FieldType>StatisticsDescriptor</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>referencedColumnMapGet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=(LanguageConnectionContext)getContextOrNull(LanguageConnectionContext.CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencedColumnMapPut</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newReferencedColumnMap</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=(LanguageConnectionContext)getContextOrNull(LanguageConnectionContext.CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TableDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for a TableDescriptor (this is for a temporary table).
 * @param dataDictionary		The data dictionary that this descriptor lives in
 * @param tableName	The name of the temporary table
 * @param schema	The schema descriptor for this table.
 * @param tableType	An integer identifier for the type of the table : declared global temporary table
 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>onCommitDeleteRows</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>onRollbackDeleteRows</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TableDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for a TableDescriptor.
 * @param dataDictionary		The data dictionary that this descriptor lives in
 * @param tableName	The name of the table
 * @param schema	The schema descriptor for this table.
 * @param tableType	An integer identifier for the type of the table(base table, view, etc.)
 * @param lockGranularity	The lock granularity.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockGranularity</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaName</MethodName>
            <MethodComment>/** 
 * Gets the name of the schema the table lives in.
 * @return	A String containing the name of the schema the tablelives in.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the SchemaDescriptor for this TableDescriptor.
 * @return SchemaDescriptor	The SchemaDescriptor.
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment>/** 
 * Gets the name of the table.
 * @return	A String containing the name of the table.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTableName</MethodName>
            <MethodComment>/** 
 * Sets the the table name in case of rename table. This is used only by rename table
 * @param newTableName	The new table name.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQualifiedName</MethodName>
            <MethodComment>/** 
 * Gets the full, qualified name of the table.
 * @return	A String containing the name of the table.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUUID</MethodName>
            <MethodComment>/** 
 * Gets the UUID of the table.
 * @return	The UUID of the table.
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableType</MethodName>
            <MethodComment>/** 
 * Gets an identifier telling what type of table this is (base table, declared global temporary table, view, etc.)
 * @return	An identifier telling what type of table this is.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeapConglomerateId</MethodName>
            <MethodComment>/** 
 * Gets the id for the heap conglomerate of the table. There may also be keyed conglomerates, these are stored separately in the conglomerates table.
 * @return the id of the heap conglomerate for the table.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor [cd=null]</InnerVar>
                <InnerVar>ConglomerateDescriptor[] [cds=getConglomerateDescriptors()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumberOfColumns</MethodName>
            <MethodComment>/** 
 * Gets the number of columns in the table.
 * @return the number of columns in the table.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedColumnMap</MethodName>
            <MethodComment>/** 
 * Get the referenced column map of the table.
 * @return the referencedColumnMap of the table.
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReferencedColumnMap</MethodName>
            <MethodComment>/** 
 * Set the referenced column map of the table.
 * @param referencedColumnMap	FormatableBitSet of referenced columns.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedColumnMap</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;referencedColumnMapPut;[referencedColumnMap]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeColumnMap</MethodName>
            <MethodComment>/** 
 * Given a list of columns in the table, construct a bit  map of those columns' ids.
 * @param cdl list of columns whose positions we want to record in the bit map
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FormatableBitSet [result=new FormatableBitSet(columnDescriptorList.size() + 1)]</InnerVar>
                <InnerVar>int [count=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnID</MethodName>
            <MethodComment>/** 
 * Gets the highest column id in the table. For now this is the same as the number of columns. However, in the future, after we implement ALTER TABLE DROP COLUMN, this correspondence won't hold any longer.
 * @return the highest column ID in the table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [maxColumnID=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUUID</MethodName>
            <MethodComment>/** 
 * Sets the UUID of the table
 * @param oid	The UUID of the table to be set in the descriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>oid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockGranularity</MethodName>
            <MethodComment>/** 
 * Gets the lock granularity for the table.
 * @return	A char representing the lock granularity for the table.
 */
</MethodComment>
            <ReturnType>char</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLockGranularity</MethodName>
            <MethodComment>/** 
 * Sets the lock granularity for the table to the specified value.
 * @param lockGranularity	The new lockGranularity.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lockGranularity</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOnRollbackDeleteRows</MethodName>
            <MethodComment>/** 
 * Gets the on rollback behavior for the declared global temporary table.
 * @return	A boolean representing the on rollback behavior for the declared global temporary table.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOnCommitDeleteRows</MethodName>
            <MethodComment>/** 
 * Gets the on commit behavior for the declared global temporary table.
 * @return	A boolean representing the on commit behavior for the declared global temporary table.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetHeapConglomNumber</MethodName>
            <MethodComment>/** 
 * Sets the heapConglomNumber to -1 for temporary table since the table was dropped and recreated at the commit time and hence its conglomerate id has changed. This is used for temporary table descriptors only
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEmptyExecRow</MethodName>
            <MethodComment>/** 
 * Gets an ExecRow for rows stored in the table this describes.
 * @return	the row.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [columnCount=getNumberOfColumns()]</InnerVar>
                <InnerVar>ExecRow [result=getDataDictionary().getExecutionFactory().getValueRow(columnCount)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnCollationIds</MethodName>
            <MethodComment>/** 
 * Return an array of collation ids for this table. &lt;p&gt; Return an array of collation ids, one for each column in the columnDescriptorList.  This is useful for passing collation id info down to store, for instance in createConglomerate(). This is only expected to get called during ddl, so object allocation is ok. 
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int[] [collation_ids=new int[getNumberOfColumns()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets the conglomerate descriptor list
 * @return	The conglomerate descriptor list for this table descriptor
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the view descriptor for this TableDescriptor.
 * @return ViewDescriptor	The ViewDescriptor, if any.
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setViewDescriptor</MethodName>
            <MethodComment>/** 
 * Set (cache) the view descriptor for this TableDescriptor
 * @param viewDescriptor	The view descriptor to cache.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>viewDescriptor</ParamName>
                    <ParamType>ViewDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPersistent</MethodName>
            <MethodComment>/** 
 * Is this provider persistent?  A stored dependency will be required if both the dependent and provider are persistent.
 * @return boolean              Whether or not this provider is persistent.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSynonymDescriptor</MethodName>
            <MethodComment>/** 
 * Is this descriptor represents a synonym?
 * @return boolean              Whether or not this represents a synonym
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTotalNumberOfIndexes</MethodName>
            <MethodComment>/** 
 * Gets the number of indexes on the table, including the backing indexes.
 * @return the number of columns in the table.
 * @see #getQualifiedNumberOfIndexes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQualifiedNumberOfIndexes</MethodName>
            <MethodComment>/** 
 * Returns the number of indexes matching the criteria.
 * @param minColCount the minimum number of ordered columns in the indexeswe want to count
 * @param nonUniqeTrumpsColCount if {@code true} a non-unique index will beincluded in the count even if it has less than  {@code minColCount}ordered columns
 * @return Number of matching indexes.
 * @see #getTotalNumberOfIndexes()
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>minColCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nonUniqeTrumpsColCount</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [matches=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllRelevantTriggers</MethodName>
            <MethodComment>/** 
 * Builds a list of all triggers which are relevant to a given statement type, given a list of updated columns.
 * @param statementType		defined in StatementType
 * @param changedColumnIds	array of changed columns
 * @param relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statementType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relevantTriggers</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllRelevantConstraints</MethodName>
            <MethodComment>/** 
 * Gets all of the relevant constraints for a statement, given its statement type and its list of updated columns.
 * @param statementType			As defined in StatementType.
 * @param changedColumnIds		If null, all columns being changed, otherwise arrayof 1-based column ids for columns being changed
 * @param needsDeferredProcessing	IN/OUT. true if the statement already needsdeferred processing. set while evaluating this routine if a trigger or constraint requires deferred processing
 * @param relevantConstraints		IN/OUT. Empty list is passed in. We hang constraints on it as we go.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statementType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedColumnIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needsDeferredProcessing</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relevantConstraints</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>ConstraintDescriptorList [cdl=dd.getConstraintDescriptors(this)]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependableFinder</MethodName>
            <MethodComment>/** 
 * @return the stored form of this provider
 * @see Dependable#getDependableFinder
 */
</MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectName</MethodName>
            <MethodComment>/** 
 * Return the name of this Provider.  (Useful for errors.)
 * @return String	The name of this provider.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectID</MethodName>
            <MethodComment>/** 
 * Get the provider's UUID 
 * @return String	The provider's UUID
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassType</MethodName>
            <MethodComment>/** 
 * Get the provider's type.
 * @return String		The provider's type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Prints the contents of the TableDescriptor
 * @return The contents as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets the column descriptor list
 * @return	The column descriptor list for this table descriptor
 */
</MethodComment>
            <ReturnType>ColumnDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedColumns</MethodName>
            <MethodComment>/** 
 * Gets the list of columns defined by generation clauses.
 */
</MethodComment>
            <ReturnType>ColumnDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ColumnDescriptorList [fullList=getColumnDescriptorList()]</InnerVar>
                <InnerVar>ColumnDescriptorList [result=new ColumnDescriptorList()]</InnerVar>
                <InnerVar>int [count=fullList.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnIDs</MethodName>
            <MethodComment>/** 
 * Turn an array of column names into the corresponding 1-based column positions.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>names</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=names.length]</InnerVar>
                <InnerVar>int[] [result=new int[count]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets the constraint descriptor list
 * @return	The constraint descriptor list for this table descriptor
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConstraintDescriptorList</MethodName>
            <MethodComment>/** 
 * Sets the constraint descriptor list
 * @param newCDL	The new constraint descriptor list for this table descriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newCDL</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>emptyConstraintDescriptorList</MethodName>
            <MethodComment>/** 
 * Empty the constraint descriptor list
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrimaryKey</MethodName>
            <MethodComment>/** 
 * Gets the primary key, may return null if no primary key
 * @return	The priamry key or null
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ReferencedKeyConstraintDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [cdl=getDataDictionary().getConstraintDescriptors(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets the trigger descriptor list
 * @return	The trigger descriptor list for this table descriptor
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTriggerDescriptorList</MethodName>
            <MethodComment>/** 
 * Sets the trigger descriptor list
 * @param newCDL	The new trigger descriptor list for this table descriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newCDL</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>emptyTriggerDescriptorList</MethodName>
            <MethodComment>/** 
 * Empty the trigger descriptor list
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tableNameEquals</MethodName>
            <MethodComment>/** 
 * Compare the tables descriptors based on the names. Null schema names match.
 * @param otherTableName	the other table name
 * @param otherSchemaName	the other schema name
 * @return boolean		Whether or not the 2 TableNames are equal.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>otherSchemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [schemaName=getSchemaName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Remove this descriptor
 * @param cd	The conglomerate descriptor 
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglomerateDescriptorList;dropConglomerateDescriptor;[getUUID(), cd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Remove this descriptor.  Warning, removes by using object reference, not uuid.
 * @param cd constraint descriptor 
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>constraintDescriptorList;remove;[cd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for a column in the table, either by the column name or by its ordinal position (column number). Returns NULL for columns that do not exist.
 * @param columnName	A String containing the name of the column
 * @return	A ColumnDescriptor describing the column
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptor</MethodName>
            <MethodComment>/** 
 * @param columnNumber	The ordinal (1-based) position of the column in the table
 * @return	A ColumnDescriptor describing the column
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Gets a ConglomerateDescriptor[] to loop through all the conglomerate descriptors for the table.
 * @return	A ConglomerateDescriptor[] for looping through the table's conglomerates
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=conglomerateDescriptorList.size()]</InnerVar>
                <InnerVar>ConglomerateDescriptor[] [cdls=new ConglomerateDescriptor[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglomerateDescriptorList;toArray;[cdls]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Gets a conglomerate descriptor for the given table and conglomerate number.
 * @param conglomerateNumber	The conglomerate numberwe're interested in
 * @return	A ConglomerateDescriptor describing the requestedconglomerate. Returns NULL if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Gets array of conglomerate descriptors for the given table and conglomerate number.  More than one descriptors if duplicate indexes share one conglomerate.
 * @param conglomerateNumber	The conglomerate numberwe're interested in
 * @return	Array of ConglomerateDescriptors with the requestedconglomerate number. Returns size 0 array if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Gets a conglomerate descriptor for the given table and conglomerate UUID String.
 * @param conglomerateUUID	The UUID  for the conglomeratewe're interested in
 * @return	A ConglomerateDescriptor describing the requestedconglomerate. Returns NULL if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Gets array of conglomerate descriptors for the given table and conglomerate UUID.  More than one descriptors if duplicate indexes share one conglomerate.
 * @param conglomerateUUID	The conglomerate UUIDwe're interested in
 * @return	Array of ConglomerateDescriptors with the requestedconglomerate UUID. Returns size 0 array if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexLister</MethodName>
            <MethodComment>/** 
 * Gets an object which lists out all the index row generators on a table together with their conglomerate ids.
 * @return	An object to list out the index row generators.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>IndexLister</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tableHasAutoincrement</MethodName>
            <MethodComment>/** 
 * Does the table have an auto-increment column or not?
 * @return TRUE if the table has at least one auto-increment column, falseotherwise 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnNamesArray</MethodName>
            <MethodComment>/** 
 * Gets an array of column names.
 * @return An array, filled with the column names in the table.
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=getNumberOfColumns()]</InnerVar>
                <InnerVar>String[] [s=new String[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoincIncrementArray</MethodName>
            <MethodComment>/** 
 * gets an array of increment values for autoincrement columns in the target table. If column is not an autoincrement column, then increment value is 0. If table has no autoincrement columns, returns NULL.
 * @return		array containing the increment values of autoincrementcolumns.
 */
</MethodComment>
            <ReturnType>long[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=getNumberOfColumns()]</InnerVar>
                <InnerVar>long[] [inc=new long[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatistics</MethodName>
            <MethodComment>/** 
 * Returns a list of statistics for this table.
 */
</MethodComment>
            <ReturnType>StatisticsDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markForIndexStatsUpdate</MethodName>
            <MethodComment>/** 
 * Marks the cardinality statistics for the indexes associated with this table for update if they are considered stale, or for creation if they don't exist, and if it is considered useful to update/create them.
 * @param tableRowCountEstimate row count estimate for this table
 * @throws StandardException if obtaining index statistics fails
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableRowCountEstimate</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;StatisticsDescriptor&gt; [sdl=getStatistics()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAndClearIndexStatsIsUpToDate</MethodName>
            <MethodComment>/** 
 * Tells if the index statistics for the indexes associated with this table are consideres up-to-date, and clears the state.
 * @return {@code true} if the statistics are considered up-to-date,{@code false} if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [tmp=indexStatsUpToDate]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexStatsUpdateReason</MethodName>
            <MethodComment>/** 
 * Returns the update criteria telling why the statistics are considered stale. &lt;p&gt; This method is used for debugging.
 * @return A string describing the update criteria that were met.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statisticsExist</MethodName>
            <MethodComment>/** 
 * Are there statistics for this particular conglomerate.
 * @param cd	Conglomerate/Index for which we want to check if statisticsexist. cd can be null in which case user wants to know if there are any statistics at all on the table.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;StatisticsDescriptor&gt; [sdl=getStatistics()]</InnerVar>
                <InnerVar>UUID [cdUUID=cd.getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>selectivityForConglomerate</MethodName>
            <MethodComment>/** 
 * For this conglomerate (index), return the selectivity of the first numKeys. This basically returns the reciprocal of the number of unique values in the leading numKey columns of the index. It is assumed that statistics exist for the conglomerate if this function is called. However, no locks are held to prevent the statistics from being dropped, so the method also handles the case of missing statistics by using a heuristic to estimate the selectivity.
 * @param cd		ConglomerateDescriptor (Index) whosecardinality we are interested in.
 * @param numKeys	Number of leading columns of the index for whichcardinality is desired.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [referenceUUID=cd.getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorName</MethodName>
            <MethodComment>/** 
 * @see TupleDescriptor#getDescriptorName 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorType</MethodName>
            <MethodComment>/** 
 * @see TupleDescriptor#getDescriptorType 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isValid</MethodName>
            <MethodComment>/** 
 * Check that all of the dependent's dependencies are valid.
 * @return true if the dependent is currently valid
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToInvalidate</MethodName>
            <MethodComment>/** 
 * Prepare to mark the dependent as invalid (due to at least one of its dependencies being invalid).
 * @param action	The action causing the invalidation
 * @param p		the provider
 * @exception StandardException thrown if unable to make it invalid
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DependencyManager [dm=getDataDictionary().getDependencyManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeInvalid</MethodName>
            <MethodComment>/** 
 * Mark the dependent as invalid (due to at least one of its dependencies being invalid).  Always an error for a table -- should never have gotten here.
 * @param action	The action causing the invalidation
 * @exception StandardException thrown if called in sanity mode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeSequenceName</MethodName>
            <MethodComment>/** 
 * Make the name of an identity sequence generator from a table ID 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextOrNull</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>