<Class>
    <Id>181</Id>
    <Package>org.apache.derby.iapi.services.compiler</Package>
    <ClassName>JavaFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>JavaFactory  /** 
 * JavaFactory provides generators for Java constructs. Once Java constructs have been connected into a complete class definition, the class can be generated from them. The generated class is created as a byte-code array that can then be loaded by a class loader or, in our case, the class utilities wrapper around our special class loader. &lt;p&gt; Each method shows the equivalent Java in the line starting "Java:" in the header comment.  Items in the java code that begin with # refer to parameters used in constructing the object.  So, for example, newReturnStatement takes a parameter named value; its Java code is: &lt;verbatim&gt; Java: return #value; &lt;/verbatim&gt; &lt;p&gt; This represents the fact that newReturnStatement returns a object that represents a return statement that returns the value represented by the parameter named value. &lt;p&gt; REVISIT: when StandardException is moved to BasicServices, all of these want to support it so they can throw real NotImplementedYet exceptions. It is expected that alot of this interface can be not-implemented for engines that do not need this complete treatment of the language. &lt;p&gt; Known Java constructs missing from this interface include: &lt;ul&gt; &lt;li&gt; array initializers &lt;li&gt; ,-lists of statements in for segments &lt;li&gt; accessing a field of the current object or class without including this or the class name &lt;li&gt; declaring a list of variables against one type &lt;li&gt; conversions/coercions/promotions of types &lt;li&gt; empty statement &lt;li&gt; labeled statement &lt;li&gt; switch statement &lt;li&gt; break, continue statements &lt;li&gt; "super" expression (akin to the "this" expression). &lt;li&gt; operations on multi-dimensional arrays &lt;/ul&gt; &lt;p&gt; This interface also does not do real compilation -- there are no checks for things like initialization before use of variables, inclusion of catchs on throws, dead code, etc. Its purpose is to let other parts of the system piece together what they know is valid code and get bytecode out of doing that. &lt;p&gt; Also, implementations will require that the constructs be built appropriately or they may fail to produce a valid class.  For example, newStaticMethodCall must be used to call static methods only, not non-static local instance methods. &lt;p&gt; Implementations may be more, or less strict.  You are best off assuming you have to piece together each java construct and be as explicit as possible.  So, constructors must be created with newConstructor, not newMethodBuilder; constructors must include the explicit call to super(...) or this(...), as their first statement; all methods and constructors must contain a final return statement at the end of their code path(s). Method calls will derive the method to call based on the type of the argument, so you must cast arguments as the system will not search for a close method and coerce arguments appropriately.  This includes coercing them to be some superclass or interface that they already are.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>JAVA_FACTORY_PROPERTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>newClassBuilder</MethodName>
            <MethodComment>/** 
 * a class.  Once it is created, fields, methods, interfaces, static initialization code,  and constructors can be added to it. &lt;verbatim&gt; Java: package #packageName; #modifiers #className extends #superClass { } // modifiers is the | of the JVM constants for // the modifiers such as static, public, etc. &lt;/verbatim&gt;
 * @param cf ClassFactory to be used for class resolution (debug only)and loading of the generated class.
 * @param packageName the name of the package the class is inincluding the trailing 'dot' if it is not the empty package. Pass the empty package as "".
 * @param modifiers the | of the Modifierconstants representing the visibility and control of this method.
 * @param className the name of the class or interface
 * @param superClass the name of the superclass or superinterface
 * @return the class builder.
 * @see java.lang.reflect.Modifier
 */
</MethodComment>
            <ReturnType>ClassBuilder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>packageName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>modifiers</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>superClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>