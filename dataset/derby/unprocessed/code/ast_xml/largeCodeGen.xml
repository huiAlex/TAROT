<Class>
    <Id>1041</Id>
    <Package>org.apache.derbyTesting.functionTests.tests.lang</Package>
    <ClassName>largeCodeGen</ClassName>
    <SuperClass>BaseJDBCTestCase</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>TEST_QUERY_EXECUTION</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>largeCodeGen</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>suite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Test</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BaseTestSuite [suite=new BaseTestSuite()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [stmt=createStatement()]</InnerVar>
                <InnerVar>String [createSQL="create table t0 " + "(si smallint,i int, bi bigint, r real, f float, d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), ch20 char(3),vc varchar(20), lvc long varchar)"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getConnection();setAutoCommit;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;executeUpdate;[createSQL]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;executeUpdate;["insert into t0 values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')"]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tearDown</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [stmt=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;execute;["DROP TABLE T0"]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkT0Query</MethodName>
            <MethodComment>/** 
 * Prepares and executes query against table t0 with n parameters The assumption is that the query will always return our one row of data inserted into the t0 table.
 * @param testName
 * @param sqlBuffer  - StringBuffer with SQL Text
 * @param numParams  - Number of parameters
 * @param paramValue - Parameter value
 * @return true if the check fails
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>testName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlBuffer</ParamName>
                    <ParamType>StringBuffer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numParams</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testLogicalOperators</MethodName>
            <MethodComment>/** 
 * Test many logical operators in the where clause.  
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [passCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertEquals;["logical operators change from previous limit", 800, passCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logicalOperators</MethodName>
            <MethodComment>/** 
 * Tests numParam parameter markers in a where clause
 * @param numOperands 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numOperands</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [pred="(si = ? AND si = ? )"]</InnerVar>
                <InnerVar>String [testName="Logical operators with " + numOperands + " parameters"]</InnerVar>
                <InnerVar>StringBuffer [sqlBuffer=new StringBuffer((numOperands * 20) + 512)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sqlBuffer;append;["SELECT * FROM T0 WHERE " + pred]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testInClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [passCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertFalse;["IN clause with 3400 parameters ", inClause(3400)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertEquals;["IN clause change from previous limit", 98000, passCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inClause</MethodName>
            <MethodComment>/** 
 * Test in clause with many parameters
 * @param numParams Number of parameters to test
 * @return true if the test fails
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numParams</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [testName="IN clause with " + numParams + " parameters"]</InnerVar>
                <InnerVar>StringBuffer [sqlBuffer=new StringBuffer((numParams * 20) + 512)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sqlBuffer;append;["SELECT * FROM T0 WHERE SI IN ("]</InnerMethodInvoke>
                <InnerMethodInvoke>sqlBuffer;append;["?)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testUnions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [viewName="v0"]</InnerVar>
                <InnerVar>Statement [stmt=createStatement()]</InnerVar>
                <InnerVar>StringBuffer [createView=new StringBuffer("create view " + viewName + " as select * from t0 ")]</InnerVar>
                <InnerVar>int [passCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;executeUpdate;[createView.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>createStatement();executeUpdate;["DROP VIEW " + viewName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assertEquals;["UNION operators change from previous limit", 1000, passCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>largeUnionSelect</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>viewName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numUnions</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [unionClause=" UNION ALL (SELECT * FROM " + viewName + ")"]</InnerVar>
                <InnerVar>StringBuffer [selectSQLBuffer=new StringBuffer(((numUnions / 100) * unionClause.length()) + 512)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>selectSQLBuffer;append;["select * from t0 "]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRowData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [values={"2","3","4","5.3","5.3","5.3","31.13","123456.123","one","one","one"}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testInsertValues</MethodName>
            <MethodComment>/** 
 * Test an INSERT statement with a large number of rows in the VALUES clause. Reported as DERBY-1714.
 * @throws SQLException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [passCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assertEquals;["INSERT VALUES change from previous limit", 1700, passCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertValues</MethodName>
            <MethodComment>/** 
 * Create a large insert statement with rowCount rows all with constants. Prepare and execute it and then rollback to leave the table unchanged.
 * @param rowCount
 * @return false if rollback succeeds, otherwise true
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Random [r=new Random(3457245435L)]</InnerVar>
                <InnerVar>StringBuffer [insertSQL=new StringBuffer("INSERT INTO T0(SI,I,BI,R,F,D,N5_2,DEC10_3,CH20,VC,LVC) VALUES\n")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>