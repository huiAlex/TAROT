<Class>
    <Id>999</Id>
    <Package>org.apache.derby.iapi.sql.compile</Package>
    <ClassName>CompilerContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Context</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>CompilerContext  /** 
 * CompilerContext stores the parser and type id factory to be used by the compiler.  Stack compiler contexts when a new, local parser is needed (if calling the compiler recursively from within the compiler, for example). CompilerContext objects are private to a LanguageConnectionContext. History: 5/22/97 Moved getExternalInterfaceFactory() to LanguageConnectionContext because it had to be used at execution. - Jeff
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>CONTEXT_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DATETIME_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CURRENT_CONNECTION_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FUNCTION_CALL_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>UNNAMED_PARAMETER_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DIAGNOSTICS_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SUBQUERY_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>USER_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMN_REFERENCE_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>IGNORE_MISSING_CLASSES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCHEMA_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INTERNAL_SQL_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NON_DETERMINISTIC_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SQL_IN_ROUTINES_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEXT_VALUE_FOR_ILLEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SQL_LEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INTERNAL_SQL_LEGAL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHECK_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GENERATION_CLAUSE_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>WHERE_CLAUSE_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>HAVING_CLAUSE_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ON_CLAUSE_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AGGREGATE_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CONDITIONAL_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GROUP_BY_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CASE_OPERAND_RESTRICTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>WHERE_SCOPE</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getParser</MethodName>
            <MethodComment>/** 
 * Get the Parser from this CompilerContext. *
 * @return	The parser associated with this CompilerContext
 */
</MethodComment>
            <ReturnType>Parser</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerFactory</MethodName>
            <MethodComment>/** 
 * Get the OptimizerFactory from this CompilerContext.
 * @return  The OptimizerFactory associated with this CompilerContext
 */
</MethodComment>
            <ReturnType>OptimizerFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCompilerFactory</MethodName>
            <MethodComment>/** 
 * Get the TypeCompilerFactory from this CompilerContext.
 * @return	The TypeCompilerFactory associated with this CompilerContext
 */
</MethodComment>
            <ReturnType>TypeCompilerFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassFactory</MethodName>
            <MethodComment>/** 
 * Return the class factory to use in this compilation.
 */
</MethodComment>
            <ReturnType>ClassFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJavaFactory</MethodName>
            <MethodComment>/** 
 * Get the JavaFactory from this CompilerContext.
 * @return	The JavaFactory associated with this CompilerContext
 */
</MethodComment>
            <ReturnType>JavaFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextColumnNumber</MethodName>
            <MethodComment>/** 
 * Get the current next column number (for generated column names) from this CompilerContext.
 * @return int	The next column number for the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetContext</MethodName>
            <MethodComment>/** 
 * Reset compiler context (as for instance, when we recycle a context for use by another compilation.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextTableNumber</MethodName>
            <MethodComment>/** 
 * Get the current next table number from this CompilerContext.
 * @return int	The next table number for the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumTables</MethodName>
            <MethodComment>/** 
 * Get the number of tables in the current statement from this CompilerContext.
 * @return int	The number of tables in the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextSubqueryNumber</MethodName>
            <MethodComment>/** 
 * Get the current next subquery number from this CompilerContext.
 * @return int	The next subquery number for the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumSubquerys</MethodName>
            <MethodComment>/** 
 * Get the number of subquerys in the current statement from this CompilerContext.
 * @return int	The number of subquerys in the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextResultSetNumber</MethodName>
            <MethodComment>/** 
 * Get the current next ResultSet number from this CompilerContext.
 * @return int	The next ResultSet number for the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetNextResultSetNumber</MethodName>
            <MethodComment>/** 
 * Reset the next ResultSet number from this CompilerContext.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumResultSets</MethodName>
            <MethodComment>/** 
 * Get the number of Results in the current statement from this CompilerContext.
 * @return The number of ResultSets in the current statement.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueClassName</MethodName>
            <MethodComment>/** 
 * Get a unique Class name from this CompilerContext. Ensures it is globally unique for this JVM.
 * @return String	A unique-enough class name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentDependent</MethodName>
            <MethodComment>/** 
 * Set the current dependent from this CompilerContext. This should be called at the start of a compile to register who has the dependencies needed for the compilation.
 * @param d	The Dependent currently being compiled.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentAuxiliaryProviderList</MethodName>
            <MethodComment>/** 
 * Get the current auxiliary provider list from this CompilerContext.
 * @return	The current AuxiliaryProviderList.
 */
</MethodComment>
            <ReturnType>ProviderList</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentAuxiliaryProviderList</MethodName>
            <MethodComment>/** 
 * Set the current auxiliary provider list for this CompilerContext.
 * @param apl	The new current AuxiliaryProviderList.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>apl</ParamName>
                    <ParamType>ProviderList</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDependency</MethodName>
            <MethodComment>/** 
 * Add a dependency for the current dependent.
 * @param p	The Provider of the dependency.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDependency</MethodName>
            <MethodComment>/** 
 * Add a dependency between two objects.
 * @param d	The Dependent object.
 * @param p	The Provider of the dependency.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSavedObject</MethodName>
            <MethodComment>/** 
 * Add an object to the pool that is created at compile time and used at execution time.  Use the integer to reference it in execution constructs.  Execution code will have to generate: &lt;pre&gt; (#objectType) (this.getPreparedStatement().getSavedObject(#int)) &lt;/pre&gt;
 * @param o object to add to the pool of saved objects
 * @return the entry # for the object
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSavedObjects</MethodName>
            <MethodComment>/** 
 * Get the saved object pool (for putting into the prepared statement). This turns it into its storable form, an array of objects.
 * @return the saved object pool.
 */
</MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSavedObjects</MethodName>
            <MethodComment>/** 
 * Set the saved object pool (for putting into the prepared statement).
 * @param objs	 The new saved objects
 * @throws NullPointerException if {@code objs} is null
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objs</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInUse</MethodName>
            <MethodComment>/** 
 * Set the in use state for the compiler context.
 * @param inUse	 The new inUse state for the compiler context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inUse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInUse</MethodName>
            <MethodComment>/** 
 * Return the in use state for the compiler context.
 * @return boolean	The in use state for the compiler context.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstOnStack</MethodName>
            <MethodComment>/** 
 * Mark this CompilerContext as the first on the stack, so we can avoid continually popping and pushing a CompilerContext.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isFirstOnStack</MethodName>
            <MethodComment>/** 
 * Is this the first CompilerContext on the stack?
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReliability</MethodName>
            <MethodComment>/** 
 * Sets which kind of query fragments are NOT allowed. Basically, these are fragments which return unstable results. CHECK CONSTRAINTS and CREATE PUBLICATION want to forbid certain kinds of fragments.
 * @param reliability	bitmask of types of query fragments to be forbiddensee the reliability bitmasks above
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reliability</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReliability</MethodName>
            <MethodComment>/** 
 * Return the reliability requirements of this clause. See setReliability() for a definition of clause reliability.
 * @return a bitmask of which types of query fragments are to be forbidden
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompilationSchema</MethodName>
            <MethodComment>/** 
 * Get the compilation schema descriptor for this compilation context. Will be null if no default schema lookups have occured. Ie. the statement is independent of the current schema.
 * @return the compilation schema descirptor
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCompilationSchema</MethodName>
            <MethodComment>/** 
 * Set the compilation schema descriptor for this compilation context.
 * @param newDefault compilation schema
 * @return the previous compilation schema descirptor
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newDefault</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCompilationSchema</MethodName>
            <MethodComment>/** 
 * Push a default schema to use when compiling. &lt;p&gt; Sometimes, we need to temporarily change the default schema, for example when recompiling a view, since the execution time default schema may differ from the required default schema when the view was defined. Another case is when compiling generated columns which reference unqualified user functions. &lt;/p&gt;
 * @param sd schema to use
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popCompilationSchema</MethodName>
            <MethodComment>/** 
 * Pop the default schema to use when compiling.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStoreCostController</MethodName>
            <MethodComment>/** 
 * Get a StoreCostController for the given conglomerate.
 * @param conglomerateNumber	The conglomerate for which to get aStoreCostController.
 * @return	The appropriate StoreCostController.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>StoreCostController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSortCostController</MethodName>
            <MethodComment>/** 
 * Get a SortCostController.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SortCostController</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setParameterList</MethodName>
            <MethodComment>/** 
 * Set the parameter list.
 * @param parameterList	The parameter list.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterList</ParamName>
                    <ParamType>ParameterNode</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterList</MethodName>
            <MethodComment>/** 
 * Get the parameter list.
 * @return	The parameter list.
 */
</MethodComment>
            <ReturnType>ParameterNode</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReturnParameterFlag</MethodName>
            <MethodComment>/** 
 * If callable statement uses ? = form
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReturnParameterFlag</MethodName>
            <MethodComment>/** 
 * Is the callable statement uses ? for return parameter.
 * @return	true if ? = call else false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCursorInfo</MethodName>
            <MethodComment>/** 
 * Get the cursor info stored in the context.
 * @return the cursor info
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCursorInfo</MethodName>
            <MethodComment>/** 
 * Set params
 * @param cursorInfo the cursor info
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cursorInfo</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setScanIsolationLevel</MethodName>
            <MethodComment>/** 
 * Set the isolation level for the scans in this query.
 * @param isolationLevel	The isolation level to use.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanIsolationLevel</MethodName>
            <MethodComment>/** 
 * Get the isolation level for the scans in this query.
 * @return	The isolation level for the scans in this query.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextEquivalenceClass</MethodName>
            <MethodComment>/** 
 * Get the next equivalence class for equijoin clauses.
 * @return The next equivalence class for equijoin clauses.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWarning</MethodName>
            <MethodComment>/** 
 * Add a compile time warning.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>warning</ParamName>
                    <ParamType>SQLWarning</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWarnings</MethodName>
            <MethodComment>/** 
 * Get the chain of compile time warnings.
 */
</MethodComment>
            <ReturnType>SQLWarning</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCurrentPrivType</MethodName>
            <MethodComment>/** 
 * Sets the current privilege type context and pushes the previous on onto a stack. Column and table nodes do not know how they are being used. Higher level nodes in the query tree do not know what is being referenced. Keeping the context allows the two to come together.
 * @param privType One of the privilege types in org.apache.derby.iapi.sql.conn.Authorizer.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>privType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popCurrentPrivType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredColumnPriv</MethodName>
            <MethodComment>/** 
 * Add a column privilege to the list of used column privileges.
 * @param column
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredTablePriv</MethodName>
            <MethodComment>/** 
 * Add a table or view privilege to the list of used table privileges.
 * @param table
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredSchemaPriv</MethodName>
            <MethodComment>/** 
 * Add a schema privilege to the list of used privileges.
 * @param schema	Schema name of the object that is being accessed
 * @param aid		Requested authorizationId for new schema
 * @param privType	CREATE_SCHEMA_PRIV, MODIFY_SCHEMA_PRIV or DROP_SCHEMA_PRIV
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredRoutinePriv</MethodName>
            <MethodComment>/** 
 * Add a routine execute privilege to the list of used routine privileges.
 * @param routine
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routine</ParamName>
                    <ParamType>AliasDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredUsagePriv</MethodName>
            <MethodComment>/** 
 * Add a usage privilege to the list of required privileges.
 * @param usableObject
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>usableObject</ParamName>
                    <ParamType>PrivilegedSQLObject</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRequiredRolePriv</MethodName>
            <MethodComment>/** 
 * Add a required role privilege to the list of privileges.
 * @see CompilerContext#addRequiredRolePriv
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRequiredPermissionsList</MethodName>
            <MethodComment>/** 
 * @return The list of required privileges.
 */
</MethodComment>
            <ReturnType>StatementPermission</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addReferencedSequence</MethodName>
            <MethodComment>/** 
 * Add a sequence descriptor to the list of referenced sequences.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReferenced</MethodName>
            <MethodComment>/** 
 * Report whether the given sequence has been referenced already.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPrivilegeFilter</MethodName>
            <MethodComment>/** 
 * Add a filter for determining which QueryTreeNodes give rise to privilege checks at run time. The null filter (the default) says that all QueryTreeNodes potentially give rise to privilege checks.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vf</ParamName>
                    <ParamType>VisitableFilter</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removePrivilegeFilter</MethodName>
            <MethodComment>/** 
 * Remove a filter for determining which QueryTreeNodes give rise to privilege checks at run time.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vf</ParamName>
                    <ParamType>VisitableFilter</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>passesPrivilegeFilters</MethodName>
            <MethodComment>/** 
 * Return true if a QueryTreeNode passes all of the filters which determine whether the QueryTreeNode gives rise to run time privilege checks.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>visitable</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginScope</MethodName>
            <MethodComment>/** 
 * Record that the compiler is entering a named scope. Increment the depth counter for that scope.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scopeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endScope</MethodName>
            <MethodComment>/** 
 * Record that the compiler is exiting a named scope. Decrement the depth counter for that scope.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scopeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>scopeDepth</MethodName>
            <MethodComment>/** 
 * Get the current depth for the named scope. For instance, if we are processing a WHERE clause inside a subquery which is invoked inside an outer WHERE clause, the depth of the whereScope would be 2. Returns 0 if the compiler isn't inside any such scope.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scopeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipTypePrivileges</MethodName>
            <MethodComment>/** 
 * Set whether we should skip adding USAGE privileges for user-defined types. Returns the previous setting of this variable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>skip</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skippingTypePrivileges</MethodName>
            <MethodComment>/** 
 * Return whether we are skipping USAGE privileges for user-defined types 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>