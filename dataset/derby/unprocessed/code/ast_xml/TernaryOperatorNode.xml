<Class>
    <Id>1662</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>TernaryOperatorNode</ClassName>
    <SuperClass>OperatorNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TernaryOperatorNode  /** 
 * A TernaryOperatorNode represents a built-in ternary operators. This covers  built-in functions like  {@code substr()}. Java operators are not represented here: the JSQL language allows Java methods to be called from expressions, but not Java operators.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>K_TRIM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_LOCATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_SUBSTRING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_LIKE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_TIMESTAMPADD</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>K_TIMESTAMPDIFF</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>kind</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>operator</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>methodName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>receiver</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>leftOperand</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>rightOperand</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>resultInterfaceType</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>receiverInterfaceType</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>leftInterfaceType</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>rightInterfaceType</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>trimType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TernaryOperators</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>TernaryMethodNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>TernaryResultType</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>TernaryArgType</FieldName>
            <FieldType>String[][]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>TernaryOperatorNode</MethodName>
            <MethodComment>/** 
 * Constructor for a TernaryOperatorNode
 * @param receiver      The receiver (e.g., string being operated on in{@code substr()})
 * @param leftOperand	The left operand of the node
 * @param rightOperand	The right operand of the node
 * @param kind          The kind of the operand
 * @param cm            The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[receiver, leftOperand, rightOperand, -1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TernaryOperatorNode</MethodName>
            <MethodComment>/** 
 * Constructor for a TernaryOperatorNode
 * @param receiver      The receiver (e.g., string being operated on in{@code substr()})
 * @param leftOperand   The left operand of the node
 * @param rightOperand  The right operand of the node
 * @param kind          The kind of the operand
 * @param trimType      The trim type
 * @param cm            The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kind</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>trimType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[receiver, leftOperand, rightOperand, trimType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constructorMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiver</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>trimType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This means binding the sub-expressions, as well as figuring out what the return type is for this expression.
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess an expression tree.  We do a number of transformations here (including subqueries, IN lists, LIKE and BETWEEN) plus subquery flattening. NOTE: This is done before the outer ResultSetNode is preprocessed.
 * @param numTables			Number of tables in the DML Statement
 * @param outerFromList		FromList from outer query block
 * @param outerSubqueryList	SubqueryList from outer query block
 * @param outerPredicateList	PredicateList from outer query block
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerSubqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerPredicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Do code generation for this ternary operator.
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [nargs=0]</InnerVar>
                <InnerVar>String [receiverType=null]</InnerVar>
                <InnerVar>LocalField [field=acb.newFieldDeclaration(Modifier.PRIVATE,resultInterfaceType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>receiver;generateExpression;[acb, mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultInterfaceType, nargs]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;putField;[field]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLeftOperand</MethodName>
            <MethodComment>/** 
 * Set the leftOperand to the specified ValueNode
 * @param newLeftOperand	The new leftOperand
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newLeftOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLeftOperand</MethodName>
            <MethodComment>/** 
 * Get the leftOperand
 * @return The current leftOperand.
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRightOperand</MethodName>
            <MethodComment>/** 
 * Set the rightOperand to the specified ValueNode
 * @param newRightOperand	The new rightOperand
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newRightOperand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRightOperand</MethodName>
            <MethodComment>/** 
 * Get the rightOperand
 * @return The current rightOperand.
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate. If the source of this ColumnReference (at the next underlying level)  is not a ColumnReference or a VirtualColumnNode then this predicate will not be pushed down. For example, in: select * from (select 1 from s) a (x) where x = 1 we will not push down x = 1. NOTE: It would be easy to handle the case of a constant, but if the inner SELECT returns an arbitrary expression, then we would have to copy that tree into the pushed predicate, and that tree could contain subqueries and method calls. RESOLVE - revisit this issue once we have views.
 * @param referencedTabs	JBitSet with bit map of referenced FromTables
 * @param simplePredsOnly	Whether or not to consider methodcalls, field references and conditional nodes when building bit map
 * @return boolean		Whether or not source.expression is a ColumnReferenceor a VirtualColumnNode.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTabs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>simplePredsOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushable]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferencesToExpressions</MethodName>
            <MethodComment>/** 
 * Remap all ColumnReferences in this tree to be clones of the underlying expression.
 * @return ValueNode			The remapped expression tree.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstantExpression</MethodName>
            <MethodComment>/** 
 * Return whether or not this expression tree represents a constant expression.
 * @return	Whether or not this expression tree represents a constant expression.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantExpression</MethodName>
            <MethodComment>/** 
 * @see ValueNode#constantExpression 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>whereClause</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trimBind</MethodName>
            <MethodComment>/** 
 * Bind trim expression.  The variable receiver is the string that needs to be trimmed. The variable leftOperand is the character that needs to be trimmed from receiver.
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TypeId [receiverType]</InnerVar>
                <InnerVar>TypeId [resultType=TypeId.getBuiltInTypeId(Types.VARCHAR)]</InnerVar>
                <InnerVar>TypeId [leftCTI]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindToBuiltIn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setResultType;[resultType]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCollationInfo;[receiver.getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultType</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[new DataTypeDescriptor(resultType,true,receiver.getTypeServices().getMaximumWidth())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateBind</MethodName>
            <MethodComment>/** 
 * Bind locate operator The variable receiver is the string which will searched The variable leftOperand is the search character that will looked in the receiver variable.
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TypeId [firstOperandType, secondOperandType, offsetType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindToBuiltIn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[new DataTypeDescriptor(TypeId.INTEGER_ID,receiver.getTypeServices().isNullable())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>castArgToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vn</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeCompiler [vnTC=vn.getTypeCompiler()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>substrBind</MethodName>
            <MethodComment>/** 
 * Bind substr expression.  
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TypeId [receiverType]</InnerVar>
                <InnerVar>TypeId [resultType=TypeId.getBuiltInTypeId(Types.VARCHAR)]</InnerVar>
                <InnerVar>int [resultLen=receiver.getTypeServices().getMaximumWidth()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindToBuiltIn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[new DataTypeDescriptor(resultType,true,resultLen)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCollationInfo;[receiver.getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>timestampAddBind</MethodName>
            <MethodComment>/** 
 * Bind TIMESTAMPADD expression.  
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindDateTimeArg;[receiver, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>timestampDiffBind</MethodName>
            <MethodComment>/** 
 * Bind TIMESTAMPDIFF expression.  
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindDateTimeArg;[rightOperand, 2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindDateTimeArg;[receiver, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindDateTimeArg</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>argNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindParameter</MethodName>
            <MethodComment>/** 
 * This method gets called for non-character string types and hence no need  to set any collation info. Collation applies only to character string types.
 * @param arg Check if arg is a ? param and if yes, then set it's type tojdbcType if arg doesn't have a type associated with it.
 * @param jdbcType Associate this type with arg if arg is a ? param with notype associated with it
 * @return true if arg is a ? param with no type associated with it
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReceiver</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwBadType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>funcName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindToBuiltIn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarcharDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSameNodeKind</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>