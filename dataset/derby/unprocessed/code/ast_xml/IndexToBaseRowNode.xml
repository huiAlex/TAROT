<Class>
    <Id>1166</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>IndexToBaseRowNode</ClassName>
    <SuperClass>FromTable</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>IndexToBaseRowNode  /** 
 * This node type translates an index row to a base row.  It takes a FromBaseTable as its source ResultSetNode, and generates an IndexRowToBaseRowResultSet that takes a TableScanResultSet on an index conglomerate as its source.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>source</FieldName>
            <FieldType>FromBaseTable</FieldType>
        </Field>
        <Field>
            <FieldName>baseCD</FieldName>
            <FieldType>ConglomerateDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>cursorTargetTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>restrictionList</FieldName>
            <FieldType>PredicateList</FieldType>
        </Field>
        <Field>
            <FieldName>forUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>heapReferencedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>indexReferencedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>allReferencedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>heapOnlyReferencedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>IndexToBaseRowNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseCD</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cursorTargetTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapReferencedCols</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexReferencedCols</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restrictionList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setResultColumns;[resultColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forUpdate</MethodName>
            <MethodComment>/** 
 * @see Optimizable#forUpdate 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTrulyTheBestAccessPath</MethodName>
            <MethodComment>/** 
 * @see Optimizable#getTrulyTheBestAccessPath 
 */
</MethodComment>
            <ReturnType>AccessPath</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCostEstimate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFinalCostEstimate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOrderedOn</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying ResultSet tree is ordered on the specified columns. RESOLVE - This method currently only considers the outermost table  of the query block.
 * @param crs					The specified ColumnReference[]
 * @param permuteOrdering		Whether or not the order of the CRs in the array can be permuted
 * @param fbtHolder           List that is to be filled with the FromBaseTable
 * @return	Whether the underlying ResultSet treeis ordered on the specified column.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>crs</ParamName>
                    <ParamType>ColumnReference[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permuteOrdering</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fbtHolder</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Generation of an IndexToBaseRowNode creates an IndexRowToBaseRowResultSet, which uses the RowLocation in the last column of an index row to get the row from the base conglomerate (heap).
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb the method  for the method to be built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [restriction=null]</InnerVar>
                <InnerVar>int [heapColRefItem=-1]</InnerVar>
                <InnerVar>int [allColRefItem=-1]</InnerVar>
                <InnerVar>int [heapOnlyColRefItem=-1]</InnerVar>
                <InnerVar>int [indexColMapItem=acb.addItem(new ReferencedColumnsDescriptorImpl(getIndexColMapping()))]</InnerVar>
                <InnerVar>long [heapConglomNumber=baseCD.getConglomerateNumber()]</InnerVar>
                <InnerVar>StaticCompiledOpenConglomInfo [scoci=getLanguageConnectionContext().getTransactionCompile().getStaticCompiledConglomInfo(heapConglomNumber)]</InnerVar>
                <InnerVar>boolean [skipPropagatedCols=indexReferencedCols != null &amp;&amp; indexReferencedCols.getNumBitsSet() != 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;assignResultSetNumber;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCostEstimate;[getFinalCostEstimate()]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[heapConglomNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[acb.addItem(scoci)]</InnerMethodInvoke>
                <InnerMethodInvoke>source;generate;[acb, mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;upCast;[ClassName.NoPutResultSet]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[acb.addItem(getResultColumns().buildRowTemplate(heapReferencedCols,skipPropagatedCols))]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getResultSetNumber()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[source.getBaseTableName()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[heapColRefItem]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[allColRefItem]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[heapOnlyColRefItem]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[indexColMapItem]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[forUpdate]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().rowCount()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().getEstimatedCost()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[source.getTableDescriptor().getNumberOfColumns()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, "getIndexRowToBaseRowResultSet", ClassName.NoPutResultSet, 15]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOneRowResultSet</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying ResultSet tree will return a single row, at most. This is important for join nodes where we can save the extra next on the right side if we know that it will return at most 1 row.
 * @return Whether or not the underlying ResultSet tree will return a single row.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNotExists</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying FBT is for NOT EXISTS.
 * @return Whether or not the underlying FBT is for NOT EXISTS.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementLevel</MethodName>
            <MethodComment>/** 
 * Decrement (query block) level (0-based) for this FromTable. This is useful when flattening a subquery.
 * @param decrement	The amount to decrement by.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>decrement</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;decrementLevel;[decrement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateTargetLockMode</MethodName>
            <MethodComment>/** 
 * Get the lock mode for the target of an update statement (a delete or update).  The update mode will always be row for CurrentOfNodes.  It will be table if there is no where clause.
 * @return	The lock mode
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * @see ResultSetNode#adjustForSortElimination
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;disableBulkFetch;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * @see ResultSetNode#adjustForSortElimination
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowOrdering</ParamName>
                    <ParamType>RequiredRowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;adjustForSortElimination;[]</InnerMethodInvoke>
                <InnerMethodInvoke>source;adjustForSortElimination;[rowOrdering]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexColMapping</MethodName>
            <MethodComment>/** 
 * Fill in the column mapping for those columns coming from the index.
 * @return The int[] with the mapping.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [rclSize=getResultColumns().size()]</InnerVar>
                <InnerVar>int[] [indexColMapping=new int[rclSize]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>