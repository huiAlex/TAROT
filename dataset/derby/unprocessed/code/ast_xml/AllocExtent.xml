<Class>
    <Id>1085</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>AllocExtent</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Externalizable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AllocExtent  /** 
 * An allocation extent row manages the page status of page in the extent. AllocExtent is externalizable and is written to the AllocPage directly, without being converted to a row first. &lt;P&gt; &lt;PRE&gt;
 * @derby.formatId	none, format implied by AllocPage's format
 * @derby.purpose	manage page status of page in extent
 * @derby.upgrade
 * @derby.diskLayout extentOffset(long) the begin physical byte offset of the first page of this extent extentStart(long) the first logical page mananged by this extent. extentEnd(long) the last page this extent can ever hope to manage  extentLength(int) the number of pages allocated in this extent extentStatus(int) status bits for the whole extent. HAS_DEALLOCATED - most likely, this extent has a deallocated  page somewhere If !HAD_DEALLOCATED, the extent has no deallocated page HAS_FREE - most likely, this extent has a free page somewhere If !HAS_FREE, there is no free page in the extent ALL_FREE - most likely, this extent only has free pages, good  candidate for shrinking the file. If !ALL_FREE, the extent is not all free HAS_UNFILLED_PAGES - most likely, this extent has unfilled pages. if !HAS_UNFILLED_PAGES, all pages are filled KEEP_UNFILLED_PAGES - this extent keeps track of unfilled pages (post v1.3).  If not set, this extent has no notion of unfilled page and has no unFilledPage bitmap. NO_DEALLOC_PAGE_MAP - this extents do not have a dealloc and a free page bit maps.  Prior to 2.0, there are 2 bit maps, a deallocate page bit map and a free page bit map.  Cloudscape 2.0 and later merged the dealloc page bit map into the free page bit map. RETIRED - this extent contains only 'retired' pages, never use  any page from this extent.  The pages don't actually  exist, i.e., it maps to nothing (physicalOffset is  garbage).  The purpose of this extent is to blot out a  range of logical page numbers that no longer exists  for this container.  Use this to reuse a physical page when a logical page has exhausted all recordId or for logical pages that has been shrunk out. preAllocLength(int)  the number of pages that have been preallocated reserved1(int) reserved2(long)	reserved for future use reserved3(long)	reserved for future use FreePages(bit)	bitmap of free pages Bit[i] is ON iff page i is free for immediate (re)use. [ on disk version before 2.0 deAllocPages(bit) bitmap of deallocated pages Bit[i] is ON iff page i has been deallocated. ] unFilledPages(bit)	bitmap of pages that has free space Bit[i] is ON if page i is likely to be &lt; 1/2 full org.apache.derby.iapi.services.io.FormatableBitSet is used to store the bit map.   FormatableBitSet is an externalizable class.
 * @derby.endFormat &lt;PRE&gt; A page can have the following logical state: &lt;BR&gt;Free - a page that is free to be used &lt;BR&gt;Valid - a page that is currently in use &lt;P&gt; There is another type of transitional pages which pages that have been allocated on disk but has not yet been used.  These pages are Free. &lt;P&gt; Bit[K] freePages Bit[i] is ON iff page i maybe free for reuse.  User must get the dealloc page lock on the free page to make sure the transaction. &lt;P&gt; K is the size of the bit array, it must be &gt;= length.
 * @see AllocPage
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>extentOffset</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>extentStart</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>extentEnd</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>extentLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>extentStatus</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>preAllocLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>reserved1</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>reserved2</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>reserved3</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>HAS_DEALLOCATED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>HAS_FREE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALL_FREE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>HAS_UNFILLED_PAGES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>KEEP_UNFILLED_PAGES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NO_DEALLOC_PAGE_MAP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RETIRED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALLOCATED_PAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEALLOCATED_PAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FREE_PAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>freePages</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>unFilledPages</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MAX_RANGE</MethodName>
            <MethodComment>/** 
 * Statically calculates how many pages this extent can manage given the availspace number of bytes to store this extent in if read/writeExternal changes, this must change too
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>availspace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bookkeeping=8 + 8 + 8+ 4+ 4+ 4+ 4+ 8+ 8]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AllocExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pagesize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxlength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numbits=(1 + (length / 8)) * 8]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AllocExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>original</ParamName>
                    <ParamType>AllocExtent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AllocExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeLong;[extentOffset]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[extentStart]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[extentEnd]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[extentLength]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[extentStatus]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[preAllocLength]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>freePages;writeExternal;[out]</InnerMethodInvoke>
                <InnerMethodInvoke>unFilledPages;writeExternal;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>freePages;readExternal;[in]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allocPage</MethodName>
            <MethodComment>/** 
 * Allocate this page - this is called underneath the log record
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bitnum=(int)(pagenum - extentStart)]</InnerVar>
                <InnerVar>int [numPageAlloced=(int)(pagenum - extentStart + 1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>freePages;clear;[bitnum]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deallocPage</MethodName>
            <MethodComment>/** 
 * Deallocate logical page pagenum - this is called underneath the log record. pagenum must be a page managed by this extent and it must be valid
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bitnum=(int)(pagenum - extentStart)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>freePages;set;[bitnum]</InnerMethodInvoke>
                <InnerMethodInvoke>unFilledPages;clear;[bitnum]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setExtentFreePageStatus;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compress</MethodName>
            <MethodComment>/** 
 * Compress free pages at end of this extent. &lt;p&gt; Search backward from end of extent and prepare data structures to return pages at end of extent to the OS. Returns the lowest page that can be returned to the OS. &lt;p&gt;
 * @return Return bit of page where all pages that follow canbe returned to the OS.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>owner</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alloc_page</ParamName>
                    <ParamType>AllocPage</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [compress_bitnum=-1]</InnerVar>
                <InnerVar>int [num_pages_compressed=0]</InnerVar>
                <InnerVar>int [new_highest_page=compress_bitnum - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressPages</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>new_highest_page</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_pages_truncated</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>undoCompressPages</MethodName>
            <MethodComment>/** 
 * Undo the compress space operation. &lt;p&gt; Undo of this operation doesn't really "undo" the operation, it just makes sure the data structures are ok after the undo.  We are  guaranteed at the point of the transaction doing the  Undo of the compress space operation fixes up the bit maps to only point at pages within the new_highest_page range. &lt;p&gt; Prior to logging the compress space operation all pages greater  than  There are only 2 possibilities at this point: 1) the truncate of pages greater than new_highest_page happened before the abort took place.  W 2) 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>new_highest_page</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_pages_truncated</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExtentEnd</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFreePageNumber</MethodName>
            <MethodComment>/** 
 * Get a page number that is free
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pnum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageOffset</MethodName>
            <MethodComment>/** 
 * Get the physical offset of pagenum. If deallocOK is true, then even if pagenum is deallocated, it is OK. If deallocOK is false, then an exception is thrown if pagenum is deallocated. An exception is always thrown if pagenum is a free page
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pagesize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deallocOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRetired</MethodName>
            <MethodComment>/** 
 * Return the status of this extent
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mayHaveFreePage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setExtentFreePageStatus</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hasFree</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canAddFreePage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastAllocatedPage</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageStatus</MethodName>
            <MethodComment>/** 
 * Return the status of a particular page
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [status=0]</InnerVar>
                <InnerVar>int [bitnum=(int)(pagenum - extentStart)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstPagenum</MethodName>
            <MethodComment>/** 
 * Get the first logical page number managed by this extent.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastPagenum</MethodName>
            <MethodComment>/** 
 * Get the last logical page number managed by this extent.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPagenum</MethodName>
            <MethodComment>/** 
 * translate bit position in map to page number. &lt;p&gt;
 * @return The page number of this "bit" in the extent map.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bit_pos</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastPreallocPagenum</MethodName>
            <MethodComment>/** 
 * get the last preallocated pagenumber managed by this alloc page
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastPreallocPagenum</MethodName>
            <MethodComment>/** 
 * preallocated N pages, passed in the last preallocated page number.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>preAllocPagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextValidPageNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prevPageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [pageNum]</InnerVar>
                <InnerVar>long [lastpage=getLastPagenum()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastValidPageNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long [pageNum=getLastPagenum()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkInRange</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateUnfilledPageInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputExtent</ParamName>
                    <ParamType>AllocExtent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>trackUnfilledPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unfilled</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bitnum=(int)(pagenumber - extentStart)]</InnerVar>
                <InnerVar>boolean [bitSet=unFilledPages.isSet(bitnum)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkInRange;[pagenumber]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnfilledPageNumber</MethodName>
            <MethodComment>/** 
 * Get a page number that is unfilled, pagenum is the last page that was rejected.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=unFilledPages.anySetBit()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllocatedPageCount</MethodName>
            <MethodComment>/** 
 * Get the number of used page in this extent
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [allocatedPageCount=extentLength]</InnerVar>
                <InnerVar>byte[] [free=freePages.getByteArray()]</InnerVar>
                <InnerVar>int [numBytes=free.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnfilledPageCount</MethodName>
            <MethodComment>/** 
 * Get the number of unfilled pages in this extent
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [unfilledPageCount=0]</InnerVar>
                <InnerVar>int [freePagesSize=freePages.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTotalPageCount</MethodName>
            <MethodComment>/** 
 * Get the total number of pages in this extent
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDebugString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>