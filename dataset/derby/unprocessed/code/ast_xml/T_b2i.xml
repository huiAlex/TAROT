<Class>
    <Id>1319</Id>
    <Package>org.apache.derbyTesting.unitTests.store</Package>
    <ClassName>T_CreateConglomRet</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>testService</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>store_module</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>contextService</FieldName>
            <FieldType>ContextService</FieldType>
        </Field>
        <Field>
            <FieldName>base_conglomid</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>index_conglomid</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>index_template_row</FieldName>
            <FieldType>DataValueDescriptor[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>setupTest</MethodName>
            <MethodComment>/** 
 * Routine one once per invocation of the test by the driver. &lt;p&gt; Do work that should only be done once, no matter how many times runTests() may be executed.
 * @exception T_Fail  Thrown on any error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>startParams;put;[Property.NO_AUTO_BOOT, Boolean.TRUE.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>startParams;put;[Property.DELETE_ON_CREATE, Boolean.TRUE.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getModuleToTestProtocolName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runTestSet</MethodName>
            <MethodComment>/** 
 * Driver routine for the btree secondary index tests. &lt;p&gt;
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>AccessFactory [store=null]</InnerVar>
                <InnerVar>TransactionController [tc=null]</InnerVar>
                <InnerVar>boolean [pass=false]</InnerVar>
                <InnerVar>ContextManager [cm1=contextService.newContextManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;println;["executing b2i test"]</InnerMethodInvoke>
                <InnerMethodInvoke>contextService;setCurrentContextManager;[cm1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["(unitTestMain) Testing " + testService]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createCongloms</MethodName>
            <MethodComment>/** 
 * Utility routine to create base table for tests. &lt;p&gt; A little utility routine to create base tables for tests.  Just here to make tests a little more readable.  It currently just  creates a heap table with "num_cols" SQLLongint columns.
 * @param num_cols the number of columns in the base table.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_cols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unique</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>varying_first_col</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_btreerows_per_page</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ret_val</ParamName>
                    <ParamType>T_CreateConglomRet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(num_cols)]</InnerVar>
                <InnerVar>long [base_conglomid=0]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>RowLocation [base_rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,num_cols + 1,(unique ? num_cols : num_cols + 1),true,base_conglomid,num_cols)]</InnerVar>
                <InnerVar>long [index_conglomid=tc.createConglomerate("BTREE",index_row.getRow(),null,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>index_row;init;[base_row, base_rowloc, num_cols + 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input_properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_allowduplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_nkeyfields</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_nuniquecolumns</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_maintainparentlinks</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_baseconglomerateid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_rowlocationcolumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [properties=((input_properties == null) ? new Properties() : input_properties)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>properties;put;["allowDuplicates", String.valueOf(input_allowduplicates)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["nKeyFields", String.valueOf(input_nkeyfields)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["nUniqueColumns", String.valueOf(input_nuniquecolumns)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["maintainParentLinks", String.valueOf(input_maintainparentlinks)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["baseConglomerateId", String.valueOf(input_baseconglomerateid)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["rowLocationColumn", String.valueOf(input_rowlocationcolumn)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_scan</MethodName>
            <MethodComment>/** 
 * Test a single scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start_key</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start_op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stop_key</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stop_op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expect_numrows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expect_key</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=tc.openScan(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,start_key,start_op,qualifier,stop_key,stop_op)]</InnerVar>
                <InnerVar>long [key=-42]</InnerVar>
                <InnerVar>long [numrows=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>((B2IForwardScan)scan);checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_delete</MethodName>
            <MethodComment>/** 
 * delete a single key, given key value.  assumes 3 column table, first column = 1, second column is a unique key, and 3rd column is a  RecordHandle into the base table.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>search_key</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>useUpdateLocks</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLLongint [column0=new SQLLongint(-1)]</InnerVar>
                <InnerVar>SQLLongint [column1=new SQLLongint(-1)]</InnerVar>
                <InnerVar>int [openmode=TransactionController.OPENMODE_FORUPDATE]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(conglomid,false,openmode,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,search_key,ScanController.GE,null,search_key,ScanController.GT)]</InnerVar>
                <InnerVar>long [expect_key=((SQLLongint)search_key[1]).getLong()]</InnerVar>
                <InnerVar>int [numrows=0]</InnerVar>
                <InnerVar>DataValueDescriptor[] [partialRow=new DataValueDescriptor[2]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_001</MethodName>
            <MethodComment>/** 
 * Test BTreeController.insert() &lt;p&gt; Just verify that insert code works for a secondary index.  Just call the interface and make sure the row got there.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r2=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row2=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc2=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
                <InnerVar>ScanInfo [scan_info=scan.getScanInfo()]</InnerVar>
                <InnerVar>Properties [prop=scan_info.getAllScanInfo(null)]</InnerVar>
                <InnerVar>int [compare_result=base_rowloc1.compare(base_rowloc2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_001"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row2;init;[r2, base_rowloc2, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row2.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;delete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Calling scan.tostring(): " + scan]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_001"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_002</MethodName>
            <MethodComment>/** 
 * Test backout during critical times of splits. &lt;p&gt; Use trace points to force errors in split at critical points: leaf_split_abort{1,2,3,4}
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>String[] [debug_strings={"leaf_split_growRoot1","leaf_split_growRoot2","leaf_split_growRoot3","leaf_split_growRoot4","leaf_split_growRoot5","leaf_split_abort1","leaf_split_abort2","leaf_split_abort3","leaf_split_abort4","branch_split_abort1","branch_split_abort2","branch_split_abort3","branch_split_abort4","BTreeController_doIns2"}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_002"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_002"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_003_scan_test_cases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>T_SecondaryIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>DataValueDescriptor[] [start_key=TemplateRow.newU8Row(1)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [stop_key=TemplateRow.newU8Row(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5 and x &lt;= 7)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[7]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["max on btree, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["max on btree, table locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["max on btree, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["max on btree, table locked."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_003</MethodName>
            <MethodComment>/** 
 * Test BTree.openScan(), BtreeScan.init(), BtreeScan.next(),  BtreeScan.fetch().
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(4)]</InnerVar>
                <InnerVar>String [string_1500char=new String()]</InnerVar>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>long [value=-1]</InnerVar>
                <InnerVar>long [col1[]={1,3,4,4,4,5,5,5,6,7,9}]</InnerVar>
                <InnerVar>long [col2[]={1,1,2,4,6,2,4,6,1,1,1}]</InnerVar>
                <InnerVar>long [col3[]={11,12,13,14,15,16,17,18,19,20,21}]</InnerVar>
                <InnerVar>long [d_col1[]={0,2,3,4,4,5,5,5,6,7,8,10,11,12}]</InnerVar>
                <InnerVar>long [d_col2[]={1,1,2,3,5,0,3,5,0,0,1,42,42,1}]</InnerVar>
                <InnerVar>long [d_col3[]={91,92,93,94,95,96,97,98,99,100,101,102,103,104}]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,5,5,true,base_conglomid,4)]</InnerVar>
                <InnerVar>long [index_conglomid=tc.createConglomerate("BTREE",index_row.getRow(),null,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [template=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [row_loc=base_cc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_003"]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, base_cc.newRowLocationTemplate(), 5]</InnerMethodInvoke>
                <InnerMethodInvoke>template;init;[base_row, row_loc, 5]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((B2IController)index_cc);debugConglomerate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_003"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_004</MethodName>
            <MethodComment>/** 
 * Test qualifiers.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,4,4,true,create_ret.base_conglomid,3)]</InnerVar>
                <InnerVar>T_QualifierTest [q_test=new T_QualifierTest("BTREE",properties,false,out,T_QualifierTest.ORDER_FORWARD)]</InnerVar>
                <InnerVar>boolean [test_result=q_test.t_testqual(tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_004"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_004"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_005</MethodName>
            <MethodComment>/** 
 * Test Branch splits - number of rows necessary to cause splits is raw store implementation dependant (currently 5 rows per page in in-memory implementation).
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [delete_key=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>RawStoreFactory [rawstore=(RawStoreFactory)findServiceModule(this.store_module,RawStoreFactory.MODULE)]</InnerVar>
                <InnerVar>ScanController [empty_scan=tc.openScan(create_ret.index_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_005"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;idle;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_005"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_006</MethodName>
            <MethodComment>/** 
 * Test unimplemented interfaces.   The following ScanController interfaces are not supported by the btree implementation, because row locations are not returned outside the interface.  At some point we may package a key as a row location but that does not really give any more functionality than using scan to find your key: ScanController.fetchLocation() ScanController.newRowLocationTemplate() ScanController.replace() ConglomerateController.delete() ConglomerateController.fetch() ConglomerateController.insertAndFetchLocation() ConglomerateController.newRowLocationTemplate() ConglomerateController.replace()
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>RowLocation [base_rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row_from_base_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(create_ret.index_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
                <InnerVar>int [numrows=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_006"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row_from_base_row;init;[base_row, base_rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[TemplateRow.newU8Row(2), base_cc.newRowLocationTemplate(), 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, base_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_006"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_007</MethodName>
            <MethodComment>/** 
 * Test multiple scans in a single page/no split 
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>RowLocation [row_loc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(create_ret.index_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
                <InnerVar>long [key=((SQLLongint)(index_row.getRow()[1])).getLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_007"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, row_loc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)(index_row.getRow()[0]));setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)(index_row.getRow()[1]));setValue;[3]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, row_loc]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)(index_row.getRow()[1]));setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, row_loc]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)(index_row.getRow()[1]));setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, row_loc]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)(index_row.getRow()[1]));setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, row_loc]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_007"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_008</MethodName>
            <MethodComment>/** 
 * Test multiple scans in a single table/with splits
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>RowLocation [base_rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row_from_base_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>ScanController [scan=tc.openScan(create_ret.index_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
                <InnerVar>long [key=((SQLLongint)(index_row.getRow()[1])).getLong()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_008"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row_from_base_row;init;[base_row, base_rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[TemplateRow.newU8Row(2), base_cc.newRowLocationTemplate(), 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, base_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[3000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, base_rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;fetch;[index_row.getRow()]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>scan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_008"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_009</MethodName>
            <MethodComment>/** 
 * Test unique/nonunique indexes - both positive and negative cases. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [delete_key=TemplateRow.newU8Row(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_009"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, true, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[1]);setValue;[1000]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_009"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_010</MethodName>
            <MethodComment>/** 
 * Test restoreToNull
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>B2I [testbtree=new B2I()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,3,2,true,-42,2)]</InnerVar>
                <InnerVar>TransactionManager [tm=(TransactionManager)tc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_006"]</InnerMethodInvoke>
                <InnerMethodInvoke>testbtree;restoreToNull;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[base_row, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_010"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_011</MethodName>
            <MethodComment>/** 
 * Test Special cases of split. &lt;p&gt; Testing: restartSplitFor() call in LeafControlRow(). The first case is where we split down the tree and reach the leaf, pick a split point, and then find that there is not enough room to insert row into parent branch page. The second case is the same as the first except the calling code is trying to split a branch page and the parent branch page doesn't have room for the row.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_011"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, true, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("a",1000)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("m",1000)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("a",1000)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("z",500)]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[create_ret.index_conglomid]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[create_ret.base_conglomid]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_011"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_012</MethodName>
            <MethodComment>/** 
 * Test Special cases of split. &lt;p&gt; Testing: restartSplitFor() call in BranchControlRow(). The second case is the same as the first except the calling code is trying to split a branch page and the parent branch page doesn't have room for the row.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_011"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, true, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("a",1000)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("ma",500)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("m",1000)]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLChar)base_row[0]);setValue;[T_b2i.repeatString("a",600)]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_012"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_013</MethodName>
            <MethodComment>/** 
 * Test backout during critical times of splits. &lt;p&gt; Force logical undo of an operation which generated an internal update of a btree record: case 1: o insert into unique btree key1, rowlocation_1 o delete from btree        key1, rowlocation_1 - this will mark the record logically deleted. o insert enough records to move the logically deleted row to another page to exercise logical undo of the delete. o insert into btree        key1, rowlocation_2 - this internally will generate a logical update field on the record. o insert enough records to move the logically deleted row to another page to exercise logical undo of the delete. o abort. case 2: o same as case 1 but don't change the rowlocation_1 value.  This  simulates what the language will generate on an update of a key field.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r2=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row2=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc2=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>ScanController [empty_scan=tc.openScan(create_ret.index_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,null,ScanController.NA,null,null,ScanController.NA)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_013"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, true, false, 5, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row2;init;[r2, base_rowloc2, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[100]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;delete;[base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[100]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_013"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_014</MethodName>
            <MethodComment>/** 
 * Test getTableProperties() of BTreeController. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,3,2,true,base_conglomid,2)]</InnerVar>
                <InnerVar>TransactionManager [tm=(TransactionManager)tc]</InnerVar>
                <InnerVar>long [conglomid=tc.createConglomerate("BTREE",index_row1.getRow(),null,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [cc=tc.openConglomerate(conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [ret_prop=new Properties()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_014"]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[base_row, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;[Property.PAGE_SIZE_PARAMETER, "8192"]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;[RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, "99"]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;[RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, "42"]</InnerMethodInvoke>
                <InnerMethodInvoke>ret_prop;put;[Property.PAGE_SIZE_PARAMETER, ""]</InnerMethodInvoke>
                <InnerMethodInvoke>ret_prop;put;[RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, ""]</InnerMethodInvoke>
                <InnerMethodInvoke>ret_prop;put;[RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, ""]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;getTableProperties;[ret_prop]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_014"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_015</MethodName>
            <MethodComment>/** 
 * Test latch release during critical time during row level locking. &lt;p&gt; Use trace points to force errors in split at critical points: leaf_split_abort{1,2,3,4}
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>String[] [latch_debug_strings={"B2iRowLocking3_1_lockScanRow1","B2iRowLocking3_2_lockScanRow1","BTreeScan_positionAtStartPosition1","BTreeScan_fetchNextGroup1"}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_015"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_015"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_016</MethodName>
            <MethodComment>/** 
 * Test deadlocks during critical times of row level locking. &lt;p&gt; Use trace points to force errors in split at critical points: leaf_split_abort{1,2,3,4}
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>String[] [deadlock_debug_strings={"B2iRowLocking3_1_lockScanRow2","B2iRowLocking3_2_lockScanRow2","BTreeScan_positionAtStartPosition2","BTreeScan_fetchNextGroup2"}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_016"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;abort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_016"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_perf</MethodName>
            <MethodComment>/** 
 * Test simple btree insert performance 
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [rowloc=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>long [startms=System.currentTimeMillis()]</InnerVar>
                <InnerVar>long [endms=System.currentTimeMillis()]</InnerVar>
                <InnerVar>long [elapsedms=endms - startms]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_005"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 0, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, rowloc, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)base_row[1]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[base_row, rowloc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>System.out;println;["  Elapsed (ms)      " + elapsedms]</InnerMethodInvoke>
                <InnerMethodInvoke>System.out;println;["  inserts/second " + (1000 * 1000 / elapsedms)]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_011"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_desc_scan_test_cases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>T_SecondaryIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>DataValueDescriptor[] [start_key=TemplateRow.newU8Row(1)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [stop_key=TemplateRow.newU8Row(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5 and x &lt;= 7)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[7]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["minimum on btree, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["min on btree, table locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["min on btree, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["min on btree, table locked."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_017</MethodName>
            <MethodComment>/** 
 * Test BTree.openScan(), BtreeScan.init(), BtreeScan.next(),  BtreeScan.fetch() with descending indexes.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(4)]</InnerVar>
                <InnerVar>String [string_1500char=new String()]</InnerVar>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>long [value=-1]</InnerVar>
                <InnerVar>long [col1[]={1,3,4,4,4,5,5,5,6,7,9}]</InnerVar>
                <InnerVar>long [col2[]={1,1,2,4,6,2,4,6,1,1,1}]</InnerVar>
                <InnerVar>long [col3[]={11,12,13,14,15,16,17,18,19,20,21}]</InnerVar>
                <InnerVar>long [d_col1[]={0,2,3,4,4,5,5,5,6,7,8,10,11,12}]</InnerVar>
                <InnerVar>long [d_col2[]={1,1,2,3,5,0,3,5,0,0,1,42,42,1}]</InnerVar>
                <InnerVar>long [d_col3[]={91,92,93,94,95,96,97,98,99,100,101,102,103,104}]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,5,5,true,base_conglomid,4)]</InnerVar>
                <InnerVar>ColumnOrdering [order[]=new ColumnOrdering[5]]</InnerVar>
                <InnerVar>long [index_conglomid=tc.createConglomerate("BTREE",index_row.getRow(),order,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [template=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [row_loc=base_cc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_017"]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, base_cc.newRowLocationTemplate(), 5]</InnerMethodInvoke>
                <InnerMethodInvoke>template;init;[base_row, row_loc, 5]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((B2IController)index_cc);debugConglomerate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_017"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_ascdesc_scan_test_cases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>T_SecondaryIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>DataValueDescriptor[] [start_key=TemplateRow.newU8Row(1)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [stop_key=TemplateRow.newU8Row(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5 and x &lt;= 7)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[7]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["minimum on btree, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, table locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, table locked."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_018</MethodName>
            <MethodComment>/** 
 * Test BTree.openScan(), BtreeScan.init(), BtreeScan.next(),  BtreeScan.fetch() with alternating ascending and descending coulmn  sort order indexes.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(4)]</InnerVar>
                <InnerVar>String [string_1500char=new String()]</InnerVar>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>long [value=-1]</InnerVar>
                <InnerVar>long [col1[]={1,3,4,4,4,5,5,5,6,7,9}]</InnerVar>
                <InnerVar>long [col2[]={1,1,2,4,6,2,4,6,1,1,1}]</InnerVar>
                <InnerVar>long [col3[]={11,12,13,14,15,16,17,18,19,20,21}]</InnerVar>
                <InnerVar>long [d_col1[]={0,2,3,4,4,5,5,5,6,7,8,10,11,12}]</InnerVar>
                <InnerVar>long [d_col2[]={1,1,2,3,5,0,3,5,0,0,1,42,42,1}]</InnerVar>
                <InnerVar>long [d_col3[]={91,92,93,94,95,96,97,98,99,100,101,102,103,104}]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,5,5,true,base_conglomid,4)]</InnerVar>
                <InnerVar>ColumnOrdering [order[]=new ColumnOrdering[5]]</InnerVar>
                <InnerVar>long [index_conglomid=tc.createConglomerate("BTREE",index_row.getRow(),order,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [template=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [row_loc=base_cc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_018"]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, base_cc.newRowLocationTemplate(), 5]</InnerMethodInvoke>
                <InnerMethodInvoke>template;init;[base_row, row_loc, 5]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((B2IController)index_cc);debugConglomerate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_018"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_ascdesc1_scan_test_cases</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>T_SecondaryIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>DataValueDescriptor[] [start_key=TemplateRow.newU8Row(1)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [stop_key=TemplateRow.newU8Row(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt;= 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 5 and x &lt;= 7)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[7]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 5 and y &lt; 5)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &lt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x &gt;= 2 and x &lt;= 7)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[7]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2 and y &gt; 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 2 and y &gt;= 2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["scan (x = 4 and y &lt;=2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)start_key[0]);setValue;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[0]);setValue;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)stop_key[1]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, table locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, row locked."]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["last row in the last leaf, table locked."]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_019</MethodName>
            <MethodComment>/** 
 * Test BTree.openScan(), BtreeScan.init(), BtreeScan.next(),  BtreeScan.fetch() with alternating ascending and descending coulmn  sort order indexes.
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>T_SecondaryIndexRow [index_row=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [base_row=TemplateRow.newU8Row(4)]</InnerVar>
                <InnerVar>String [string_1500char=new String()]</InnerVar>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>long [value=-1]</InnerVar>
                <InnerVar>long [col1[]={1,3,4,4,4,5,5,5,6,7,9}]</InnerVar>
                <InnerVar>long [col2[]={1,1,2,4,6,2,4,6,1,1,1}]</InnerVar>
                <InnerVar>long [col3[]={11,12,13,14,15,16,17,18,19,20,21}]</InnerVar>
                <InnerVar>long [d_col1[]={0,2,3,4,4,5,5,5,6,7,8,10,11,12}]</InnerVar>
                <InnerVar>long [d_col2[]={1,1,2,3,5,0,3,5,0,0,1,42,42,1}]</InnerVar>
                <InnerVar>long [d_col3[]={91,92,93,94,95,96,97,98,99,100,101,102,103,104}]</InnerVar>
                <InnerVar>long [base_conglomid=tc.createConglomerate("heap",base_row,null,null,null,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>Properties [properties=createProperties(null,false,5,5,true,base_conglomid,4)]</InnerVar>
                <InnerVar>ColumnOrdering [order[]=new ColumnOrdering[5]]</InnerVar>
                <InnerVar>long [index_conglomid=tc.createConglomerate("BTREE",index_row.getRow(),order,null,properties,TransactionController.IS_DEFAULT)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [template=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [row_loc=base_cc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_019"]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row;init;[base_row, base_cc.newRowLocationTemplate(), 5]</InnerMethodInvoke>
                <InnerMethodInvoke>template;init;[base_row, row_loc, 5]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;checkConsistency;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((B2IController)index_cc);debugConglomerate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_019"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_020</MethodName>
            <MethodComment>/** 
 * Test read uncommitted cases on scan. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 * @exception T_Fail  Throws T_Fail on any test failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [scan=null]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_020"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[10000]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_020"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>t_021</MethodName>
            <MethodComment>/** 
 * Test latch release at critical time during delete on an index scan that uses update locks.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=true]</InnerVar>
                <InnerVar>T_CreateConglomRet [create_ret=new T_CreateConglomRet()]</InnerVar>
                <InnerVar>ConglomerateController [base_cc=tc.openConglomerate(create_ret.base_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>ConglomerateController [index_cc=tc.openConglomerate(create_ret.index_conglomid,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [r1=TemplateRow.newU8Row(2)]</InnerVar>
                <InnerVar>T_SecondaryIndexRow [index_row1=new T_SecondaryIndexRow()]</InnerVar>
                <InnerVar>RowLocation [base_rowloc1=base_cc.newRowLocationTemplate()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [delete_key=TemplateRow.newU8Row(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;REPORT;["Starting t_021"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createCongloms;[tc, 2, false, false, 2, create_ret]</InnerMethodInvoke>
                <InnerMethodInvoke>index_row1;init;[r1, base_rowloc1, 3]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)r1[1]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>base_cc;insertAndFetchLocation;[r1, base_rowloc1]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[0]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>((SQLLongint)delete_key[1]);setValue;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;REPORT;["Ending t_021"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>T_Fail</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>repeatString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>repeat</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [s=data]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isdbActive</MethodName>
            <MethodComment>/** 
 * Check wheather the database is active or not
 * @return {@code true} if the database is active, {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=(LanguageConnectionContext)getContextOrNull(LanguageConnectionContext.CONTEXT_ID)]</InnerVar>
                <InnerVar>Database [db=(Database)(lcc != null ? lcc.getDatabase() : null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextOrNull</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPersistentService</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>