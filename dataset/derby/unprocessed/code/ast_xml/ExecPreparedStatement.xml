<Class>
    <Id>1404</Id>
    <Package>org.apache.derby.iapi.sql.execute</Package>
    <ClassName>ExecPreparedStatement</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>PreparedStatement</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ExecPreparedStatement  /** 
 * Execution extends prepared statement to add methods it needs for execution purposes (that should not be on the Database API).
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>setSource</MethodName>
            <MethodComment>/** 
 * set the statement text
 * @param txt the source text
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>txt</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstantAction</MethodName>
            <MethodComment>/** 
 * Get the Execution constants. This routine is called at Execution time.
 * @return	ConstantAction	The big structure enclosing the Execution constants.
 */
</MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSavedObject</MethodName>
            <MethodComment>/** 
 * Get a saved object by number.  This is called during execution to access objects created at compile time.  These are meant to be read-only at run time.
 * @return	Object	A saved object.  The caller has to know whatit is requesting and cast it back to the expected type.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSavedObjects</MethodName>
            <MethodComment>/** 
 * Get all the saved objects.  Used for stored prepared statements.
 * @return a list with all the saved objects
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCursorInfo</MethodName>
            <MethodComment>/** 
 * Get the saved cursor info.  Used for stored prepared statements.
 * @return	Object	the cursor info
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActivationClass</MethodName>
            <MethodComment>/** 
 * Get the class generated for this prepared statement. Used to confirm compatability with auxilary structures.
 * @exception StandardException on error obtaining class(probably when a stored prepared statement is loading)
 */
</MethodComment>
            <ReturnType>GeneratedClass</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upToDate</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Checks whether this PreparedStatement is up to date and its activation class is identical to the supplied generated class. A call to  {@code upToDate(gc)} is supposed to perform the same work as the following codein one atomic operation: &lt;/p&gt; &lt;pre&gt; getActivationClass() == gc &amp;amp;&amp;amp; upToDate() &lt;/pre&gt;
 * @param gc a generated class that must be identical to {@code getActivationClass()} for this method to return {@code true}
 * @return {@code true} if this statement is up to date and its activationclass is identical to  {@code gc},  {@code false} otherwise
 * @see PreparedStatement#upToDate()
 * @see #getActivationClass()
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>gc</ParamName>
                    <ParamType>GeneratedClass</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment>/** 
 * Mark the statement as unusable, i.e. the system is finished with it and no one should be able to use it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsSavepoint</MethodName>
            <MethodComment>/** 
 * Does this statement need a savpoint
 * @return true if needs a savepoint
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClone</MethodName>
            <MethodComment>/** 
 * Get a new prepared statement that is a shallow copy of the current one.
 * @return a new prepared statement
 * @exception StandardException on error 
 */
</MethodComment>
            <ReturnType>ExecPreparedStatement</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateMode</MethodName>
            <MethodComment>/** 
 * the update mode of the cursor
 * @return	The update mode of the cursor
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTargetTable</MethodName>
            <MethodComment>/** 
 * the target table of the cursor
 * @return	target table of the cursor
 */
</MethodComment>
            <ReturnType>ExecCursorTableReference</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasUpdateColumns</MethodName>
            <MethodComment>/** 
 * Check if this prepared statement has a cursor with columns that can be updated.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUpdateColumn</MethodName>
            <MethodComment>/** 
 * Check if the specified column name is one of the update columns.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValid</MethodName>
            <MethodComment>/** 
 * set this prepared statement to be valid
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSPSAction</MethodName>
            <MethodComment>/** 
 * Indicate that the statement represents an SPS action
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRequiredPermissionsList</MethodName>
            <MethodComment>/** 
 * @return the list of permissions required to execute this statement. May be null ifthe database does not use SQL standard authorization
 */
</MethodComment>
            <ReturnType>StatementPermission</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementExecutionCount</MethodName>
            <MethodComment>/** 
 * Increment and return the execution count for this statement.
 * @return execution count for this statement after the last compilation
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInitialRowCount</MethodName>
            <MethodComment>/** 
 * Get the initial row count of the specified result set. If the initial row count has not yet been set, initialize it with the value of the current row count.
 * @param rsNum the result set to get the initial row count for
 * @param currentRowCount the current row count for the result set
 * @return the row count from the first execution of the result set
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentRowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStalePlanCheckInterval</MethodName>
            <MethodComment>/** 
 * Set the stale plan check interval.
 * @param interval the stale plan check interval
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>interval</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStalePlanCheckInterval</MethodName>
            <MethodComment>/** 
 * Get the stale plan check interval.
 * @return the stale plan check interval, or zero if it has not beeninitialized yet
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>