<Class>
    <Id>634</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>ByteHolder</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ByteHolder  /** 
 * Holder for a growing sequence of bytes. The ByteHolder supports a writing phase in which a caller appends bytes to the ByteHolder.  Later the caller may read the bytes out of the ByteHolder in the order they were written.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * Write a byte to this ByteHolder. &lt;P&gt;The ByteHolder must be in writing mode to call this.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * Write len bytes of data starting at 'offset' to this ByteHolder. &lt;P&gt;The ByteHolder must be in writing mode to call this.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>write</MethodName>
            <MethodComment>/** 
 * Write up to count bytes from an input stream to this ByteHolder. This may write fewer bytes if it encounters an end of file on the input stream.
 * @return the number of bytes written.
 * @exception IOException thrown when reading in causes anerror.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Clear the bytes from the ByteHolder and place it in writing mode. This may not free the memory the ByteHolder uses to store data.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startReading</MethodName>
            <MethodComment>/** 
 * Place a ByteHolder in reading mode. After this call, reads scan bytes sequentially in the order they were written to the ByteHolder starting from the first byte. When the ByteHolder is already in readmode this simply arranges for reads to start at the beginning of the sequence of saved bytes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment>/** 
 * Read a byte from this ByteHolder. &lt;P&gt;The ByteHolder must be in reading mode to call this.
 * @return The byte or -1 if there are no bytes available.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment>/** 
 * Read up to 'len' bytes from this ByteHolder and store them in an array at offset 'off'. &lt;P&gt;The ByteHolder must be in reading mode to call this.
 * @return the number of bytes read or -1 if the this ByteHolderhas no more bytes.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>off</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment>/** 
 * Read from the ByteHolder. &lt;p&gt; Read up to 'len' bytes from this ByteHolder and write them to the OutputStream &lt;P&gt;The ByteHolder must be in reading mode to call this.
 * @return the number of bytes read or -1 if the this ByteHolderhas no more bytes.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shiftToFront</MethodName>
            <MethodComment>/** 
 * shift the remaining unread bytes to the beginning of the byte holder
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>available</MethodName>
            <MethodComment>/** 
 * Return the number of bytes that can be read from this ByteHolder without blocking on an IO.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numBytesSaved</MethodName>
            <MethodComment>/** 
 * Return the number of bytes that have been saved to this byte holder. This result is different from available() as it is unaffected by the current read position on the ByteHolder.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skip</MethodName>
            <MethodComment>/** 
 * Skip over the specified number of bytes in a ByteHolder.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writingMode</MethodName>
            <MethodComment>/** 
 * Return true if this is in writing mode.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneEmpty</MethodName>
            <MethodComment>/** 
 * Return a byte holder matching existing type and size of current ByteHolder, but don't bother to fill the bytes. Normal usage is expected to reset the holding stream to the beginning, so the copy of current state would be wasted.
 * @return An empty &lt;code&gt;ByteHolder&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>ByteHolder</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>