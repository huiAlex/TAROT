<Class>
    <Id>1179</Id>
    <Package>org.apache.derby.iapi.sql.compile</Package>
    <ClassName>OptTrace</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>OptTrace  /** 
 * Interface for optimizer tracing.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>traceStartStatement</MethodName>
            <MethodComment>/** 
 * Start the start of tracing a statement. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statementText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceStartQueryBlock</MethodName>
            <MethodComment>/** 
 * Start optimizer tracing for a query block. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeOptimizationStarted</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizableList</ParamName>
                    <ParamType>OptimizableList</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceEndQueryBlock</MethodName>
            <MethodComment>/** 
 * End tracing the optimization of a query block. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceTimeout</MethodName>
            <MethodComment>/** 
 * Say that the optimizer ran out of time. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentTime</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bestCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceVacuous</MethodName>
            <MethodComment>/** 
 * Say that there's nothing to optimizer. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCompleteJoinOrder</MethodName>
            <MethodComment>/** 
 * Say that we have a complete join order. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSortCost</MethodName>
            <MethodComment>/** 
 * Report the sort cost. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sortCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceNoBestPlan</MethodName>
            <MethodComment>/** 
 * Say that we couldn't find a best plan. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceModifyingAccessPaths</MethodName>
            <MethodComment>/** 
 * Say that we're modifying access paths. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizerID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceShortCircuiting</MethodName>
            <MethodComment>/** 
 * Say that we short-circuited a join order. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeExceeded</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>thisOpt</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSkippingJoinOrder</MethodName>
            <MethodComment>/** 
 * Say that we're skipping the join order starting with the next optimizable. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nextOptimizable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>proposedJoinOrder</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>assignedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceIllegalUserJoinOrder</MethodName>
            <MethodComment>/** 
 * Say that the user specified an impossible join order. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceUserJoinOrderOptimized</MethodName>
            <MethodComment>/** 
 * Say that we have optimized the user-specified join order. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceJoinOrderConsideration</MethodName>
            <MethodComment>/** 
 * Say that we're considering a join order. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>joinPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>proposedJoinOrder</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>assignedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostWithoutSortAvoidance</MethodName>
            <MethodComment>/** 
 * Report the cost without a sort. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostWithSortAvoidance</MethodName>
            <MethodComment>/** 
 * Report the cost with sort avoidance.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentSortAvoidanceCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCurrentPlanAvoidsSort</MethodName>
            <MethodComment>/** 
 * Say that the current plan avoids a sort. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bestCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentSortAvoidanceCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCheapestPlanSoFar</MethodName>
            <MethodComment>/** 
 * Report the cost of the cheapest plan so far. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>planType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSortNeededForOrdering</MethodName>
            <MethodComment>/** 
 * Report that this plan needs a sort 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>planType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requiredRowOrdering</ParamName>
                    <ParamType>RequiredRowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingBestJoinOrder</MethodName>
            <MethodComment>/** 
 * Say that we are remembering the current plan as the best join order so far. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>joinPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bestJoinOrder</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>planType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>planCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>assignedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSkippingBecauseTooMuchMemory</MethodName>
            <MethodComment>/** 
 * Say that we are skipping a plan because it consumes too much memory. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>maxMemoryPerTable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostOfNScans</MethodName>
            <MethodComment>/** 
 * Report the cost of scanning a table a certain number of times 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSkipUnmaterializableHashJoin</MethodName>
            <MethodComment>/** 
 * Say that we won't consider a hash join because the result can't be materialized 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSkipHashJoinNoHashKeys</MethodName>
            <MethodComment>/** 
 * Say we won't consider a hash join because there are no hash key columns. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceHashKeyColumns</MethodName>
            <MethodComment>/** 
 * Report the columns being traced 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashKeyColumns</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceOptimizingJoinNode</MethodName>
            <MethodComment>/** 
 * Say that we're starting to optimize a join node 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceConsideringJoinStrategy</MethodName>
            <MethodComment>/** 
 * Say that we're considering a particular join strategy on a particular table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>js</ParamName>
                    <ParamType>JoinStrategy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingBestAccessPath</MethodName>
            <MethodComment>/** 
 * Report that we've found a best access path. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>accessPath</ParamName>
                    <ParamType>AccessPath</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>planType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceNoMoreConglomerates</MethodName>
            <MethodComment>/** 
 * Say that we have exhausted the conglomerate possibilities for a table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceConsideringConglomerate</MethodName>
            <MethodComment>/** 
 * Report that we are considering a conglomerate for a table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceScanningHeapWithUniqueKey</MethodName>
            <MethodComment>/** 
 * Say that we're considering scanning a heap even though we have a unique key match. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceAddingUnorderedOptimizable</MethodName>
            <MethodComment>/** 
 * Say that we're adding an unordered optimizable. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicateCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceChangingAccessPathForTable</MethodName>
            <MethodComment>/** 
 * Say that we're considering a different access path for a table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceNoStartStopPosition</MethodName>
            <MethodComment>/** 
 * Say that we're setting the lock mode to MODE_TABLE because there is no start/stop position. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceNonCoveringIndexCost</MethodName>
            <MethodComment>/** 
 * Say that we're considering a non-covering index. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceConstantStartStopPositions</MethodName>
            <MethodComment>/** 
 * Say that we're setting the lock mode to MODE_RECORD because the start and stop positions are all constant. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceEstimatingCostOfConglomerate</MethodName>
            <MethodComment>/** 
 * Report the cost of using a particular conglomerate to scan a table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceLookingForSpecifiedIndex</MethodName>
            <MethodComment>/** 
 * Say that we're looking for an index specified by optimizer hints. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceSingleMatchedRowCost</MethodName>
            <MethodComment>/** 
 * Report the cost of a scan which will match exactly one row. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingExtra1stColumnSelectivity</MethodName>
            <MethodComment>/** 
 * Report the cost of a scan given the selectivity of an extra first column. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceNextAccessPath</MethodName>
            <MethodComment>/** 
 * Report that we are advancing to the next access path for the table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicateCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingExtraStartStop</MethodName>
            <MethodComment>/** 
 * Report the cost if we include an extra start/stop. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingExtraQualifierSelectivity</MethodName>
            <MethodComment>/** 
 * Report the cost if we include an extra qualifier. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingExtraNonQualifierSelectivity</MethodName>
            <MethodComment>/** 
 * Report the cost if we include an extra non-qualifier. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostOfNoncoveringIndex</MethodName>
            <MethodComment>/** 
 * Report the cost of using a non-covering index. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingJoinStrategy</MethodName>
            <MethodComment>/** 
 * Say that we've found a new best join strategy for the table. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>joinStrategy</ParamName>
                    <ParamType>JoinStrategy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingBestAccessPathSubstring</MethodName>
            <MethodComment>/** 
 * Report the best access path for the table so far. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ap</ParamName>
                    <ParamType>AccessPath</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingBestSortAvoidanceAccessPathSubstring</MethodName>
            <MethodComment>/** 
 * Report the best sort-avoiding access path for this table so far. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ap</ParamName>
                    <ParamType>AccessPath</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceRememberingBestUnknownAccessPathSubstring</MethodName>
            <MethodComment>/** 
 * Report an optimizer failure, e.g., while optimizing an outer join 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ap</ParamName>
                    <ParamType>AccessPath</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostOfConglomerateScan</MethodName>
            <MethodComment>/** 
 * Report the cost of a conglomerate scan. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>costEstimate</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numExtraFirstColumnPreds</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extraFirstColumnSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numExtraStartStopPreds</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extraStartStopSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startStopPredCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statStartStopSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numExtraQualifiers</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extraQualifierSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numExtraNonQualifiers</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>extraNonQualifierSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingCompositeSelectivityFromStats</MethodName>
            <MethodComment>/** 
 * Report the cost based on selectivities coming out of SYSSTATISTICS. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCompositeSelectivityFromStatistics</MethodName>
            <MethodComment>/** 
 * Report the selectivity calculated from SYSSTATISTICS. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statCompositeSelectivity</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>traceCostIncludingStatsForIndex</MethodName>
            <MethodComment>/** 
 * Report the cost based on index statistics. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printToWriter</MethodName>
            <MethodComment>/** 
 * Print the trace so far. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>PrintWriter</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>