<Class>
    <Id>1456</Id>
    <Package>org.apache.derby.iapi.sql.conn</Package>
    <ClassName>SQLSessionContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SQLSessionContext  /** 
 * An implementation of this interface encapsulates some of the SQL session context's state variables, cf. SQL 2003, section 4.37.3, notably those which we need to save and restore when entering a stored procedure or function (which can contain SQL and thus a nested connection), cf. 4.37.3, 4.27.3 and 4.34.1.1.  &lt;p&gt; Presently this set contains the following properties: &lt;ul&gt; &lt;li&gt;current role&lt;/li&gt; &lt;li&gt;current schema&lt;/li&gt; &lt;/ul&gt; The standard specifies that the authorization stack be copied onto the new SQL session context before it is pushed (and possibly modifed) with a new cell for the authorization ids (user, role). In our implementation we merge these two stacks for now. Also, the authorization id of current user is not represented yet, since it can not be modified in a session; Derby can not run routines with definer's rights yet. &lt;p&gt; SQL session context is implemented as follows: Statements at root connection level use the instance held by the the lcc, nested connections maintain instances of SQLSessionContext, held by the activation of the calling statement. This forms a logical stack as required by the standard. The statement context also holds a reference to the current SQLSessionContext. &lt;p&gt; When a dynamic result set references e.g. current role, the value retrieved will always be that of the current role when the statement is logically executed (inside procedure/function), not the current value when the result set is accessed outside the stored procedure/function.  This works since the nested SQL session context is kept by the caller activation, so even though the statement context of the call has been popped, we can get at the final state of the nested SQL session context since the caller's activation is alive as long as dynamic result sets need it). &lt;p&gt; If more than one nested connection is used inside a shared procedure, they will share the same nested SQL session context. Since the same dynamic call context is involved, this seems correct.
 * @see LanguageConnectionContext#pushNestedSessionContext
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>setRole</MethodName>
            <MethodComment>/** 
 * Set the SQL role of this SQL connection context
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRole</MethodName>
            <MethodComment>/** 
 * Get the SQL role of this SQL connection context
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUser</MethodName>
            <MethodComment>/** 
 * Set the SQL current user of this SQL connection context
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>user</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentUser</MethodName>
            <MethodComment>/** 
 * Get the SQL current user of this SQL connection context
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultSchema</MethodName>
            <MethodComment>/** 
 * Set the schema of this SQL connection context
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultSchema</MethodName>
            <MethodComment>/** 
 * Get the schema of this SQL connection context
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintModes</MethodName>
            <MethodComment>/** 
 * Get a handle to the session's constraint modes. The caller is responsible for any cloning needed.
 * @return constraint modes map
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConstraintModes</MethodName>
            <MethodComment>/** 
 * Initialize a inferior session context with the constraint mode map of the parent session context.
 * @param hm constraint mode map
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hm</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeferred</MethodName>
            <MethodComment>/** 
 * Set the constraint mode for this constraint to  {@code deferred}. If  {@code deferred} is {@code false}, to immediate checking, if  {@code true} to deferred checking.
 * @param constraintId The constraint id
 * @param deferred  The new constraint mode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDeferred</MethodName>
            <MethodComment>/** 
 * Return  {@code Boolean.TRUE} if the constraint mode for thisconstraint/index has been set to deferred,  {@code Boolean.FALSE} ifit has been set to immediate.  Any ALL setting is considered also. If the constraint mode hasn't been set for this constraint, return  {@code null}. The constraint mode is the effectively the initial constraint mode in this case.
 * @param constraintId the constraint id
 * @return {@code Boolean.TRUE} if the constraint mode for thisconstraint/index has been set to deferred,  {@code Boolean.FALSE} ifit has been set to immediate.
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetConstraintModes</MethodName>
            <MethodComment>/** 
 * Clear deferred information for this transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeferredAll</MethodName>
            <MethodComment>/** 
 * Set the constraint mode for all deferrable constraints to {@code deferred}. If  {@code deferred} is {@code false}, set to immediate checking, if  {@code true} to deferred checking.{@code null} is allowed: it means no ALL setting exists.
 * @param deferred the mode to set
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>Boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeferredAll</MethodName>
            <MethodComment>/** 
 * Get state of DEFERRED ALL setting.
 * @return {@code True} is deferred all constraint mode has beenset for this session context. {@code False} is deferred immediate has been set for thissession context. {@code null} means no ALL setting has been made for this context
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>