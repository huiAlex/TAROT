<Class>
    <Id>213</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>NewInvocationNode</ClassName>
    <SuperClass>MethodCallNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>NewInvocationNode  /** 
 * A NewInvocationNode represents a new object() invocation.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>singleInstantiation</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>delimitedIdentifier</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isBuiltinVTI</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>NewInvocationNode</MethodName>
            <MethodComment>/** 
 * Constructor for a NewInvocationNode. Parameters are:
 * @param javaClassName     The full package.class name of the class
 * @param params            The parameter list for the constructor
 * @param delimitedIdentifier
 * @param cm                The context manager
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delimitedIdentifier</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addParms;[params]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>NewInvocationNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vtiTableFuncName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delimitedIdentifier</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [vtiName=vtiTableFuncName]</InnerVar>
                <InnerVar>TableDescriptor [td=tableDescriptor]</InnerVar>
                <InnerVar>boolean [isTableFunctionVTI=(vtiTableFuncName != null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addParms;[params]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBuiltinVTI</MethodName>
            <MethodComment>/** 
 * Report whether this node represents a builtin VTI.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSingleInstantiation</MethodName>
            <MethodComment>/** 
 * Mark this node as only needing to to a single instantiation.  (We can reuse the object after newing it.)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This means binding the sub-expressions, as well as figuring out what the return type is for this expression.
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList  The subquery list being built as we find SubqueryNodes
 * @param aggregates    The aggregate list being built as we find AggregateNodes
 * @return	Nothing
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>JavaValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [parmTypeNames=getObjectSignature()]</InnerVar>
                <InnerVar>boolean[] [isParam=getIsParam()]</InnerVar>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bindParameters;[fromList, subqueryList, aggregates]</InnerMethodInvoke>
                <InnerMethodInvoke>null;verifyClassExist;[javaClassName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setJavaTypeName;[javaClassName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate. If the source of this ColumnReference (at the next underlying level)  is not a ColumnReference or a VirtualColumnNode then this predicate will not be pushed down. For example, in: select * from (select 1 from s) a (x) where x = 1 we will not push down x = 1. NOTE: It would be easy to handle the case of a constant, but if the inner SELECT returns an arbitrary expression, then we would have to copy that tree into the pushed predicate, and that tree could contain subqueries and method calls. RESOLVE - revisit this issue once we have views.
 * @param referencedTabs	JBitSet with bit map of referenced FromTables
 * @param simplePredsOnly	Whether or not to consider methodcalls, field references and conditional nodes when building bit map
 * @return boolean		Whether or not source.expression is a ColumnReferenceor a VirtualColumnNode.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTabs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>simplePredsOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushable=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assignableTo</MethodName>
            <MethodComment>/** 
 * Is this class assignable to the specified class? This is useful for the VTI interface where we want to see if the class implements java.sql.ResultSet.
 * @param toClassName	The java class name we want to assign to
 * @return boolean		Whether or not this class is assignable tothe specified class
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findPublicMethod</MethodName>
            <MethodComment>/** 
 * Is this class have a public method with the specified signiture This is useful for the VTI interface where we want to see if the class has the option static method for returning the ResultSetMetaData.
 * @param methodName	The method name we are looking for
 * @param staticMethod	Whether or not the method we are looking for is static
 * @return Member		The Member representing the method (or nullif the method doesn't exist).
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staticMethod</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Member [publicMethod]</InnerVar>
                <InnerVar>String[] [parmTypeNames=getObjectSignature()]</InnerVar>
                <InnerVar>boolean[] [isParam=getIsParam()]</InnerVar>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Do code generation for this method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LocalField [objectFieldLF=null]</InnerVar>
                <InnerVar>int [nargs=generateParameters(acb,mb)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;pushNewStart;[javaClassName]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;pushNewComplete;[nargs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>