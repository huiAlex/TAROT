<Class>
    <Id>37</Id>
    <Package>org.apache.derby.iapi.sql.conn</Package>
    <ClassName>LanguageConnectionContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Context</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LanguageConnectionContext  /** 
 * LanguageConnectionContext keeps the result sets, and activations in use by the current connection. &lt;p&gt; More stable items, like other factories, are accessible through the LanguageConnectionFactory or the LanguageFactory.
 * @see LanguageConnectionFactory
 * @see org.apache.derby.iapi.sql.LanguageFactory
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>CONTEXT_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>OUTERMOST_STATEMENT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SQL92_SCHEMAS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>USER_NAME_SCHEMA</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NO_SCHEMAS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>xidStr</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>lccStr</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>dbnameStr</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>drdaStr</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SINGLE_TRANSACTION_LOCK</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MULTI_TRANSACTION_LOCK</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>UNKNOWN_CASING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ANSI_CASING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ANTI_ANSI_CASING</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * Initialize. For use after pushing the contexts that initialization needs.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogStatementText</MethodName>
            <MethodComment>/** 
 * Get value of logStatementText. (Whether or not to write info on currently executing statement to error log.)
 * @return value of logStatementText
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLogStatementText</MethodName>
            <MethodComment>/** 
 * Set value of logStatementText (Whether or not to write info on currently executing statement to error log.)
 * @param logStatementText	Whether or not logStatementText property is set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logStatementText</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogQueryPlan</MethodName>
            <MethodComment>/** 
 * Get value of logQueryPlan. (Whether or not to write query plan info on currently executing statement to error log.)
 * @return value of logQueryPlan
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockEscalationThreshold</MethodName>
            <MethodComment>/** 
 * get the lock escalation threshold to use with this connection.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addActivation</MethodName>
            <MethodComment>/** 
 * Add the activation to those known about by this connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notifyUnusedActivation</MethodName>
            <MethodComment>/** 
 * Make a note that some activations are marked unused
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeActivation</MethodName>
            <MethodComment>/** 
 * Remove the activation from those known about by this connection.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActivationCount</MethodName>
            <MethodComment>/** 
 * Return the number of activation known for this connection.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupCursorActivation</MethodName>
            <MethodComment>/** 
 * See if a given cursor is available for use.  This is used to locate the cursor during its execution.
 * @return the activation for the given cursor, null if none exists.
 */
</MethodComment>
            <ReturnType>CursorActivation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cursorName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastActivation</MethodName>
            <MethodComment>/** 
 * Return the last activation added This is used to find the drop activation in dropViewCascade so we can add warning messages to the activation
 */
</MethodComment>
            <ReturnType>Activation</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueCursorName</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated name for a cursor.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueSavepointName</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated name for an unnamed savepoint.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueSavepointID</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated id for an unnamed savepoint.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIfAnyDeclaredGlobalTempTablesForThisConnection</MethodName>
            <MethodComment>/** 
 * Check if there are any global temporary tables declared for this connection.
 * @return true if there are declared temp tables for this connectoin else false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markTempTableAsModifiedInUnitOfWork</MethodName>
            <MethodComment>/** 
 * Mark the passed temporary table as modified in the current unit of work. That information will be used at rollback time The compile phase will generate code to call this method if the DML is on a temporary table
 * @param tableName Mark the passed temporary table name as modified
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * Add the declared global temporary table to the list of temporary tables known by this connection.
 * @param td Corresponding to the temporary table
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * Drop (mark the declared global temporary table for dropping) from the list of temporary tables known by this connection.
 * @param tableName look for this table name in the saved list and drop it if found
 * @return true if dropped the temporary table. False if no such temporary table exists.
 * @see org.apache.derby.impl.sql.conn.TempTableInfo
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptorForDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * Get table descriptor for the declared global temporary table from the list of temporary tables known by this connection.
 * @param tableName Get table descriptor for the passed table name
 * @return TableDescriptor if found the temporary table. Else return null
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetFromPool</MethodName>
            <MethodComment>/** 
 * Reset the connection before it is returned (indirectly) by a PooledConnection object. See EmbeddedConnection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalCommit</MethodName>
            <MethodComment>/** 
 * Do a commit, as internally needed by Derby.  E.g. a commit for sync, or a commit for autocommit.  Skips checks that a user isn't doing something bad like issuing a commit in a nested xact.
 * @param commitStore	true if we should commit the Store transaction
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitStore</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalCommitNoSync</MethodName>
            <MethodComment>/** 
 * Similar to internalCommit() but has logic for an unsynchronized commit
 * @param commitflag	the flags to pass to commitNoSync in the store'sTransactionController
 * @exception StandardException	thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userCommit</MethodName>
            <MethodComment>/** 
 * Do a commit, as issued directly by a user (e.g. via Connection.commit() or the JSQL 'COMMIT' statement.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xaCommit</MethodName>
            <MethodComment>/** 
 * Commit a distrubuted transaction.
 * @param onePhase if true, allow it to commit without first going thru aprepared state.
 * @exception StandardException	thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onePhase</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalRollback</MethodName>
            <MethodComment>/** 
 * Do a rollback, as internally needed by Derby.  E.g. a rollback for sync, or a rollback for an internal error.  Skips checks that a user isn't doing something bad like issuing a rollback in a nested xact.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userRollback</MethodName>
            <MethodComment>/** 
 * Do a rollback, as issued directly by a user (e.g. via Connection.rollback() or the JSQL 'ROLLBACK' statement.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalRollbackToSavepoint</MethodName>
            <MethodComment>/** 
 * Let the context deal with a rollback to savepoint
 * @param savepointName	Name of the savepoint that needs to be rolled back
 * @param refreshStyle	boolean indicating whether or not the controller should closeopen conglomerates and scans. Also used to determine if language should close open activations.
 * @param kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refreshStyle</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseSavePoint</MethodName>
            <MethodComment>/** 
 * Let the context deal with a release of a savepoint
 * @param savepointName	Name of the savepoint that needs to be released
 * @param kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xaRollback</MethodName>
            <MethodComment>/** 
 * Roll back a distrubuted transaction.
 * @exception StandardException	thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>languageSetSavePoint</MethodName>
            <MethodComment>/** 
 * Sets a savepoint. Causes the Store to set a savepoint.
 * @param savepointName	name of savepoint
 * @param kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginNestedTransaction</MethodName>
            <MethodComment>/** 
 * Begin a nested transaction.
 * @param readOnly The nested transaction would be read only if param value true
 * @exception StandardException on error.
 * @see TransactionController#startNestedUserTransaction
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>readOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commitNestedTransaction</MethodName>
            <MethodComment>/** 
 * commit a nested transaction. We do not provide a abortNestedTransaction.  If a nested xaction is aborted, then this results in the parent xaction also being aborted. This is not what we need for releasing compile time locks or autoincrement-- hence we do not provide  abortNestedTransaction. 
 * @exception StandardException thrown on erro
 * @see TransactionController#startNestedUserTransaction
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionCompile</MethodName>
            <MethodComment>/** 
 * Get the transaction controller to use with this language connection context at compile time.
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionExecute</MethodName>
            <MethodComment>/** 
 * Get the transaction controller to use with this language connection context during execute time.
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDictionary</MethodName>
            <MethodComment>/** 
 * Get the data dictionary 
 * @return the data dictionary
 */
</MethodComment>
            <ReturnType>DataDictionary</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Get the data value factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageFactory</MethodName>
            <MethodComment>/** 
 * Get the language factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>LanguageFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerFactory</MethodName>
            <MethodComment>/** 
 * get the optimizer factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>OptimizerFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageConnectionFactory</MethodName>
            <MethodComment>/** 
 * Get the language connection factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>LanguageConnectionFactory</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentUserId</MethodName>
            <MethodComment>/** 
 * Get the Authorization Id of the current user
 * @param a activation
 * @return String the authorization id
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSessionUserId</MethodName>
            <MethodComment>/** 
 * Get the Authorization Id of the session user
 * @return String   the authorization id
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultSchema</MethodName>
            <MethodComment>/** 
 * Get the default schema (used at compile-time when no activation is yet available, cf. the activation argument overload version.
 * @return SchemaDescriptor	the default schema
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultSchema</MethodName>
            <MethodComment>/** 
 * Get the default schema (used at execution time).  At execution time, the current statement context is not always a reliable place to find the correct SQL session context, viz. when a dynamic result set referencing CURRENT SCHEMA is accessed after a called procedure has returned only the activation of the call is live and still holds the correct session context.
 * @param a current activation
 * @return SchemaDescriptor	the default schema
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultSchema</MethodName>
            <MethodComment>/** 
 * Set the default schema (at compile-time, see explanations for getDefaultSchema overloads).
 * @param sd the new default schema.If null, then the default schema descriptor is used.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultSchema</MethodName>
            <MethodComment>/** 
 * Set the default schema (at execution time, see explanations for getDefaultSchema overloads); This version is used by SET SCHEMA.
 * @param a current activation
 * @param sd the new default schema.If null, then the default schema descriptor is used.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetSchemaUsages</MethodName>
            <MethodComment>/** 
 * Reset any occurence of schemaName as current default schema in the SQLSessionContext stack to the initial default, because schemaName is no longer a valid schema.
 * @param activation current activation
 * @param schemaName the schema name occurences of which is to be reset
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSchemaName</MethodName>
            <MethodComment>/** 
 * Get the current schema name (at compile-time, see explanations for getDefaultSchema overloads).
 * @return SchemaDescriptor	the current schema
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSchemaName</MethodName>
            <MethodComment>/** 
 * Get the current schema name (at execution time, see explanations for getDefaultSchema overloads); This version is used by CURRENT SCHEMA.
 * @return SchemaDescriptor	the current schema
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInitialDefaultSchema</MethodName>
            <MethodComment>/** 
 * Return true if this schema name is the initial default schema for the current session.
 * @param schemaName
 * @return true
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdentityValue</MethodName>
            <MethodComment>/** 
 * Get the identity column value most recently generated.
 * @return the generated identity column value
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIdentityValue</MethodName>
            <MethodComment>/** 
 * Set the field of most recently generated identity column value.
 * @param val the generated identity column value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyNoOpenResultSets</MethodName>
            <MethodComment>/** 
 * Verify that there are no activations with open result sets on the specified prepared statement.
 * @param pStmt		The prepared Statement
 * @param provider	The object precipitating a possible invalidation
 * @param action	The action causing the possible invalidation
 * @return Nothing.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pStmt</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>provider</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyAllHeldResultSetsAreClosed</MethodName>
            <MethodComment>/** 
 * Verify that there are no activations with open held result sets.
 * @return boolean  Found no open resultsets.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCompilerContext</MethodName>
            <MethodComment>/** 
 * Push a CompilerContext on the context stack with the current default schema as the default schema which we compile against.
 * @return the compiler context
 */
</MethodComment>
            <ReturnType>CompilerContext</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCompilerContext</MethodName>
            <MethodComment>/** 
 * Push a CompilerContext on the context stack with the passed in default schema as the default schema we compile against.
 * @param sd the default schema 
 * @return the compiler context
 */
</MethodComment>
            <ReturnType>CompilerContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popCompilerContext</MethodName>
            <MethodComment>/** 
 * Pop a CompilerContext off the context stack.
 * @param compilerContext  The compiler context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compilerContext</ParamName>
                    <ParamType>CompilerContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushStatementContext</MethodName>
            <MethodComment>/** 
 * Push a StatementContext on the context stack.
 * @param isAtomic whether a commit/rollback is permittedfrom a nested connection under this statement
 * @param stmtText the text of the statement.  Needed for any languagestatement (currently, for any statement that can cause a trigger to fire).  Please set this unless you are some funky jdbc setXXX method or something.
 * @param pvs parameter value set, if it has one
 * @param rollbackParentContext True if 1) the statement context isNOT a top-level context, AND 2) in the event of a statement-level exception, the parent context needs to be rolled back, too.
 * @param timeoutMillis Timeout value for this statement, in milliseconds.Zero means no timeout.
 * @return StatementContext The statement context.
 */
</MethodComment>
            <ReturnType>StatementContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isAtomic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isForReadOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmtText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pvs</ParamName>
                    <ParamType>ParameterValueSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rollbackParentContext</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeoutMillis</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popStatementContext</MethodName>
            <MethodComment>/** 
 * Pop a StatementContext of the context stack.
 * @param statementContext  The statement context.
 * @param error				The error, if any  (Only relevant for DEBUG)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statementContext</ParamName>
                    <ParamType>StatementContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushExecutionStmtValidator</MethodName>
            <MethodComment>/** 
 * Push a new execution statement validator.  An execution statement  validator is an object that validates the current statement to ensure that it is permitted given the current execution context. An example of a validator a trigger ExecutionStmtValidator that doesn't allow ddl on the trigger target table. &lt;p&gt; Multiple ExecutionStmtValidators may be active at any given time. This mirrors the way there can be multiple connection nestings at a single time.  The validation is performed by calling each validator's validateStatement() method.  This yields the union of all validations.
 * @param validator the validator to add
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>validator</ParamName>
                    <ParamType>ExecutionStmtValidator</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popExecutionStmtValidator</MethodName>
            <MethodComment>/** 
 * Remove the validator.  Does an object identity (validator == validator) comparison.  Asserts that the validator is found.
 * @param validator the validator to remove
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>validator</ParamName>
                    <ParamType>ExecutionStmtValidator</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateStmtExecution</MethodName>
            <MethodComment>/** 
 * Validate a statement.  Does so by stepping through all the validators and executing them.  If a validator throws and exception, then the checking is stopped and the exception is passed up.
 * @param constantAction the constantAction that is about to be executed (andshould be validated
 * @exception StandardException on validation failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constantAction</ParamName>
                    <ParamType>ConstantAction</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Push a new trigger execution context. &lt;p&gt; Multiple TriggerExecutionContexts may be active at any given time.
 * @param tec the trigger execution context
 * @exception StandardException on trigger recursion error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tec</ParamName>
                    <ParamType>TriggerExecutionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Remove the tec.  Does an object identity (tec == tec) comparison.  Asserts that the tec is found.
 * @param tec the tec to remove
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tec</ParamName>
                    <ParamType>TriggerExecutionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Get the topmost tec.  
 * @return the tec
 */
</MethodComment>
            <ReturnType>TriggerExecutionContext</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushTriggerTable</MethodName>
            <MethodComment>/** 
 * Set the trigger table descriptor.  Used to compile statements that may special trigger pseudo tables.
 * @param td the table that the trigger is defined upon
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popTriggerTable</MethodName>
            <MethodComment>/** 
 * Remove the trigger table descriptor.
 * @param td the table to remove from the stack.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerTable</MethodName>
            <MethodComment>/** 
 * Get the topmost trigger table descriptor
 * @return the table descriptor, or null if wearen't in the middle of compiling a create trigger.
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementBindCount</MethodName>
            <MethodComment>/** 
 * Increment the DataDictionary bind count.  This is for keeping track of nested binding, which can happen if SQL statements are bound from within static initializers.
 * @return	The new bind count
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementBindCount</MethodName>
            <MethodComment>/** 
 * Decrement the DataDictionary bind count.
 * @return	The new bind count
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBindCount</MethodName>
            <MethodComment>/** 
 * Get the DataDictionary bind count.
 * @return	The current bind count.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDataDictionaryWriteMode</MethodName>
            <MethodComment>/** 
 * Remember that the DataDictionary is in write mode, so we can take it out of write mode at the end of the transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataDictionaryInWriteMode</MethodName>
            <MethodComment>/** 
 * Return true if the data dictionary is in write mode (that is, this context was informed that is is in write mode by the method call setDataDictionaryWriteMode().
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRunTimeStatisticsMode</MethodName>
            <MethodComment>/** 
 * Turn RUNTIMESTATISTICS  on or off.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRunTimeStatisticsMode</MethodName>
            <MethodComment>/** 
 * Get the RUNTIMESTATISTICS mode.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStatisticsTiming</MethodName>
            <MethodComment>/** 
 * Turn STATISTICS TIMING on or off.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatisticsTiming</MethodName>
            <MethodComment>/** 
 * Get the STATISTICS TIMING mode.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRunTimeStatisticsObject</MethodName>
            <MethodComment>/** 
 * Set the RUNTIMESTATISTICS object. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>runTimeStatisticsObject</ParamName>
                    <ParamType>RunTimeStatistics</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRunTimeStatisticsObject</MethodName>
            <MethodComment>/** 
 * Get the RUNTIMESTATISTICS object. 
 */
</MethodComment>
            <ReturnType>RunTimeStatistics</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementDepth</MethodName>
            <MethodComment>/** 
 * Reports how many statement levels deep we are.
 * @return	a statement level &amp;gt;= OUTERMOST_STATEMENT
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabase</MethodName>
            <MethodComment>/** 
 * Returns the Database of this connection.
 */
</MethodComment>
            <ReturnType>Database</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIsolationLevelSetUsingSQLorJDBC</MethodName>
            <MethodComment>/** 
 * Returns true if isolation level has been set using JDBC/SQL.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetIsolationLevelFlagUsedForSQLandJDBC</MethodName>
            <MethodComment>/** 
 * Reset the isolation level flag used to keep correct isolation level state in BrokeredConnection. This resetting will happen at the start  and end of a global transaction, after the BrokeredConection's  isolation level state is brought upto date with the EmbedConnection's isolation state. The flag gets set to true when isolation level is set using JDBC/SQL.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIsolationLevel</MethodName>
            <MethodComment>/** 
 * Set current isolation level.
 * @param isolationLevel	The new isolationLevel.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentIsolationLevel</MethodName>
            <MethodComment>/** 
 * Get the current isolation level.
 * @return The current isolation level.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentIsolationLevelStr</MethodName>
            <MethodComment>/** 
 * Get the current isolation level in DB2 format.
 * @return The current isolation level as a 2 character string.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPrepareIsolationLevel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrepareIsolationLevel</MethodName>
            <MethodComment>/** 
 * Get the prepare isolation level. If the isolation level has been explicitly set with a SQL statement or embedded call to setTransactionIsolation, this will return TransactionControl.UNSPECIFIED_ISOLATION_LEVEL  SET ISOLATION always takes priority.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReadOnly</MethodName>
            <MethodComment>/** 
 * Set the readOnly status for the current connection. This can only be called when the current transaction has not done any work.
 * @param onOrOff true sets the connection to be readOnly andfalse sets it to readWrite.
 * @exception StandardException The call failed and the readOnlystatus has not changed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnly</MethodName>
            <MethodComment>/** 
 * Get the readOnly status for the current connection. 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuthorizer</MethodName>
            <MethodComment>/** 
 * Get an Authorizer for this connection.
 */
</MethodComment>
            <ReturnType>Authorizer</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementContext</MethodName>
            <MethodComment>/** 
 * Get the current StatementContext.
 */
</MethodComment>
            <ReturnType>StatementContext</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareInternalStatement</MethodName>
            <MethodComment>/** 
 * Return a PreparedStatement object for the query. This method first tries to locate the PreparedStatement object from a statement cache.  If the statement is not found in the cache, the query will be compiled and put into the cache.
 * @param compilationSchema schema
 * @param sqlText sql query string
 * @param isForReadOnly read only status for resultset. Set to true if the concurrency mode for the resultset is CONCUR_READ_ONLY
 * @param allowInternalSyntax If true, then this query is allowed to use internal sql syntax. One instance where this will be true is if a metadata query is getting executed.
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compilationSchema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isForReadOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowInternalSyntax</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareInternalStatement</MethodName>
            <MethodComment>/** 
 * Return a PreparedStatement object for the query. This method first tries to locate the PreparedStatement object from a statement cache.  If the statement is not found in the cache, the query will be compiled and  put into the cache. The schema used when compiling the statement is the same schema as returned by getDefaultSchema().  For internal statements, the read only status is set to true. Calling this method is equivalent to calling  prepareExternalStatement(lcc.getDefaultSchema(), sqlText, true);
 * @param sqlText sql query string
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOptimizerTracer</MethodName>
            <MethodComment>/** 
 * Install an optimizer tracer (to enable tracing) or uninstall the current optimizer tracer (to disable tracing).
 * @param tracer    Null if tracing is being turned off, otherwise an optimizer tracer
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tracer</ParamName>
                    <ParamType>OptTrace</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerTracer</MethodName>
            <MethodComment>/** 
 * Get the optimizer tracer (could be null if we aren't tracing the optimizer).
 */
</MethodComment>
            <ReturnType>OptTrace</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizerTracingIsOn</MethodName>
            <MethodComment>/** 
 * Get whether or not optimizer trace is on.
 * @return Whether or not optimizer trace is on.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTransactionPristine</MethodName>
            <MethodComment>/** 
 * Reports whether there is any outstanding work in the transaction.
 * @return		true if there is outstanding work in the transactionfalse otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lastAutoincrementValue</MethodName>
            <MethodComment>/** 
 * Returns the last autoincrement value inserted by this connection. If no values have been inserted into the given column a NULL value is returned.
 * @param schemaName
 * @param tableName
 * @param columnName
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrementUpdate</MethodName>
            <MethodComment>/** 
 * Sets autoincrementUpdate-- this variable allows updates to autoincrement columns if it is set to true. The default is ofcourse false; i.e  ai columns cannot be directly modified by the user. This is set to  true by AlterTableConstantAction, when a new ai column is being added  to an existing table.
 * @param flag 	the value for autoincrementUpdate (TRUE or FALSE)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoincrementUpdate</MethodName>
            <MethodComment>/** 
 * Returns the current value of autoincrementUpdate.
 * @return true if updates to autoincrement columns is permitted.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyHashtableToAIHT</MethodName>
            <MethodComment>/** 
 * Copy a map of autoincrement key value pairs into the cache of ai values stored in the language connection context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextAutoincrementValue</MethodName>
            <MethodComment>/** 
 * returns the &lt;b&gt;next&lt;/b&gt; value to be inserted into an autoincrement col. This is used internally by the system to generate autoincrement values which are going to be inserted into a autoincrement column. This is used when as autoincrement column is added to a table by an alter  table statemenet and during bulk insert.
 * @param schemaName
 * @param tableName
 * @param columnName identify the column uniquely in the system.
 * @exception StandardException on error.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>autoincrementFlushCache</MethodName>
            <MethodComment>/** 
 * Flush the cache of autoincrement values being kept by the lcc. This will result in the autoincrement values being written to the SYSCOLUMNS table as well as the mapping used by lastAutoincrementValue
 * @param tableUUID the table which is being flushed; we need this value toidentify the table for which the autoincrement counter is being maintained.
 * @exception StandardException thrown on error.
 * @see LanguageConnectionContext#lastAutoincrementValue
 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#lastAutoincrementValue
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>autoincrementCreateCounter</MethodName>
            <MethodComment>/** 
 * Create an autoincrement counter to be used on behalf of a SQL-J  statement. The counter is identified by (schemaName, tableName, columnName). The counter must be freed up by calling  autoincrementFlushCache at the end of the statement. It is expected that a ai-counter with the same signaure doesn't exist when the  method is called.
 * @param s					SchemaName
 * @param t					TableName
 * @param c					ColumnName
 * @param initialValue		initial value of the counter.
 * @param increment			increment for the counter.
 * @param position			column position (1-based).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>increment</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstanceNumber</MethodName>
            <MethodComment>/** 
 * Get the instance number of this LCC.
 * @return instance number of this LCC.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDrdaID</MethodName>
            <MethodComment>/** 
 * Get the DRDA ID of this LCC.
 * @return DRDA ID this LCC.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDrdaID</MethodName>
            <MethodComment>/** 
 * Set the DRDA ID of this LCC.
 * @param drdaID DRDA ID.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDbname</MethodName>
            <MethodComment>/** 
 * Get the database name of this LCC.
 * @return database name of this LCC.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesSqlAuthorization</MethodName>
            <MethodComment>/** 
 * Check if in SQL standard mode, with support for Grant and Revoke
 * @return True if SQL standard permissions are being used
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeUnusedActivations</MethodName>
            <MethodComment>/** 
 * Close any unused activations in this connection context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentRole</MethodName>
            <MethodComment>/** 
 * Set the current role
 * @param a activation of set role statement
 * @param role  the id of the role to be set to current
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRoleId</MethodName>
            <MethodComment>/** 
 * Get the current role authorization identifier of the dynamic call context associated with this activation.
 * @param a activation of statement needing current role
 * @return String	the role id
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRoleIdDelimited</MethodName>
            <MethodComment>/** 
 * Get the current role authorization identifier in external delimited form (not case normal form) of the dynamic call context associated with this activation.
 * @param a activation of statement needing current role
 * @return String the role id in delimited form (i.e. &lt;b&gt;not&lt;/b&gt;internal case normal form&lt;/b&gt;)
 * @throws StandardException  standard exception policy
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>roleIsSettable</MethodName>
            <MethodComment>/** 
 * Checks whether the given role can be legally set for the current user. This method will read (potentially) the dictionary, so it needs a transaction context.
 * @param a activation
 * @param role string containing role name
 * @return true if the role can be set
 * @throws StandardException standard exception policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNestedSessionContext</MethodName>
            <MethodComment>/** 
 * Create a new SQL session context for the current activation on the basis of the existing SQL session context. This happens when a stored procedure or function that can contain SQL is invoked, cf. SQL 2003 section 4.27.3, since this gives rise to a nested connection. &lt;p&gt; Called from generated code, see {@link org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext}. &lt;p&gt; The new SQL session context is also set in the current statement context (of the invocation).
 * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext
 * @see StatementContext#getSQLSessionContext
 * @see #setupSubStatementSessionContext
 * @param a activation of the statement which performs the call.
 * @param definersRights if the method should run with definer's rights
 * @param definer authorization id of the definer
 * @throws StandardException standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definersRights</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definer</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popNestedSessionContext</MethodName>
            <MethodComment>/** 
 * If returning from a routine that can execute SQL, perform any actions needed when popping the SQL session context.
 * @param a activation
 * @throws StandardException standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTopLevelSQLSessionContext</MethodName>
            <MethodComment>/** 
 * Get the value of top level session context of the top level connection.
 * @return the requested session context
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupSubStatementSessionContext</MethodName>
            <MethodComment>/** 
 * Used when a statement as part of its operation executes an other statement. In contrast to pushNestedSessionContext, the activation (for the substatement) just inherits the current session context from the parent statements activation, it does &lt;b&gt;not&lt;/b&gt; push a new copy on the stack of session contexts. Currently, this is used in the following situations: &lt;ul&gt; &lt;li&gt;With  {@code ALTER TABLE} adding a column which has a defaultvalues, the default value for all the existing rows is added using an  {@code UPDATE} substatement.&lt;li&gt;With  {@code ALTER TABLE} adding a a check constraint, we will usea substatement  {@code SELECT} to check if all rows satisfy theconstraint. &lt;li&gt; {@code ResultSet.insertRow},  {@code updateRow}and  {@code deleteRow}. &lt;li&gt;During trigger body execution. &lt;/ul&gt;
 * @see #pushNestedSessionContext
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSQLSessionContext</MethodName>
            <MethodComment>/** 
 * Create a fresh SQLSessionContext for this connection.
 * @return new SQLSessionContext
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastQueryTree</MethodName>
            <MethodComment>/** 
 * Debug method for remembering the last query tree.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryTree</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastQueryTree</MethodName>
            <MethodComment>/** 
 * Debug method for retrieving the last query tree.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrintedObjectsMap</MethodName>
            <MethodComment>/** 
 * Return a map of AST nodes that have already been printed during a compiler phase, so as to be able to avoid printing a node more than once.
 * @see org.apache.derby.impl.sql.compile.QueryTreeNode#treePrint(int)
 * @return the map
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainOnlyMode</MethodName>
            <MethodComment>/** 
 * sets the XplainOnlyMode. If a connection is in XplainOnlyMode, then the statements are not actually being executed, but are just being compiled and the runtime statistics collected into the XPLAIN tables. This can be set on and off by calling SYSCS_SET_XPLAIN_MODE.
 * @param onOrOff true if statements are to be XPLAINed only.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainOnlyMode</MethodName>
            <MethodComment>/** 
 * gets the current set XplainOnlyMode
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainSchema</MethodName>
            <MethodComment>/** 
 * sets the XplainSchema
 * @param schema the schema to use for storing XPLAIN'd statementsnull means don't store the xplain information non-null means persistent style, use the indicated schema
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainSchema</MethodName>
            <MethodComment>/** 
 * gets the current set XplainSchema
 * @return the Schema of Xplain, may be null.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setASTVisitor</MethodName>
            <MethodComment>/** 
 * Set a Visitor which walks the AST at various stages. This is useful for poking user-written inspectors into the parse, bind, and optimize phases.
 * @param visitor The Visitor which should walk the tree. Could be null.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>visitor</ParamName>
                    <ParamType>ASTVisitor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getASTVisitor</MethodName>
            <MethodComment>/** 
 * Get the Visitor which should walk the AST.
 * @return The Visitor for that phase. Could be null.
 */
</MethodComment>
            <ReturnType>ASTVisitor</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterruptedException</MethodName>
            <MethodComment>/** 
 * Set the exception created and associated with the detected interruped status flag.
 * @param e the created exception
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>StandardException</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInterruptedException</MethodName>
            <MethodComment>/** 
 * Get exception created when we detected interruped status flag.
 * @return saved exception
 */
</MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedColumnMap</MethodName>
            <MethodComment>/** 
 * Get the referenced column map for a table
 * @return the map
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReferencedColumnMap</MethodName>
            <MethodComment>/** 
 * Set the referenced column map for a table
 * @param td the table descriptor
 * @param map the map
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConstraintDeferred</MethodName>
            <MethodComment>/** 
 * Set the constraint mode for this constraint to  {@code deferred}. If  {@code deferred} is {@code false}, to immediate checking, if  {@code true} to deferred checking.
 * @param a         Activation
 * @param cd        The descriptor of the constraint
 * @param deferred  The new constraint mode
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEffectivelyDeferred</MethodName>
            <MethodComment>/** 
 * Determines if a check or foreign key constraint has deferred mode.
 * @param sc           The SQL session context for which we are asking the status
 * @param constraintId The constraint id we are inquiring about.
 * @return             {@code true} if the constraint is deferred
 * @throws StandardException Standard error policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sc</ParamName>
                    <ParamType>SQLSessionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeferredAll</MethodName>
            <MethodComment>/** 
 * Set the constraint mode of all deferrable constraints to the value of {@code deferred}. If the value is  {@code false}, this method might throw with a constraint violation error, i.e. if some constraint has deferred mode before this call and had seen violations.
 * @param a         The activation
 * @param deferred  The value which holds the constraint mode
 * @throws StandardException Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeferredHashTables</MethodName>
            <MethodComment>/** 
 * Get the set of disk backed hash tables containing any index rows saved for deferred unique/PK constraints in this transaction, keyed by the conglomerate id, or rows saved containing row locations violating rows for deferred check constraints.
 * @return the set
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIntegrity</MethodName>
            <MethodComment>/** 
 * Check that deferred constraints are valid, if not roll back the transaction.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSQLSessionContext</MethodName>
            <MethodComment>/** 
 * Get the SQL session context of the given activation.
 * @param activation The activation
 * @return           The SQL session object
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>