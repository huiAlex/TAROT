<Class>
    <Id>664</Id>
    <Package>org.apache.derby.impl.sql.catalog</Package>
    <ClassName>TabInfoImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TabInfoImpl  /** 
 * A poor mans structure used in DataDictionaryImpl.java. Used to save heapId, name pairs for non core tables.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>ROWNOTDUPLICATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>indexes</FieldName>
            <FieldType>IndexInfoImpl[]</FieldType>
        </Field>
        <Field>
            <FieldName>heapConglomerate</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>numIndexesSet</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>heapSet</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>crf</FieldName>
            <FieldType>CatalogRowFactory</FieldType>
        </Field>
        <Field>
            <FieldName>computedStreamStorableHeapColIds</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>streamStorableHeapColIds</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>TabInfoImpl</MethodName>
            <MethodComment>/** 
 * Constructor
 * @param crf				the associated CatalogRowFactory
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>crf</ParamName>
                    <ParamType>CatalogRowFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes=crf.getNumIndexes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeapConglomerate</MethodName>
            <MethodComment>/** 
 * Get the conglomerate for the heap.
 * @return long     The conglomerate for the heap.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHeapConglomerate</MethodName>
            <MethodComment>/** 
 * Set the heap conglomerate for this.
 * @param heapConglomerate  The new heap conglomerate.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>heapConglomerate</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexConglomerate</MethodName>
            <MethodComment>/** 
 * Get the conglomerate for the specified index.
 * @return long     The conglomerate for the specified index.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIndexConglomerate</MethodName>
            <MethodComment>/** 
 * Set the index conglomerate for the table.
 * @param index             Index number for index for table
 * @param indexConglomerate The conglomerate for that index
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexConglomerate</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>indexes[index];setConglomerateNumber;[indexConglomerate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIndexConglomerate</MethodName>
            <MethodComment>/** 
 * Set the index conglomerate for the table.
 * @param cd    The ConglomerateDescriptor for one of the indexfor this table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [index]</InnerVar>
                <InnerVar>String [indexName=cd.getConglomerateName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableName</MethodName>
            <MethodComment>/** 
 * Get the table name.
 * @return String   The table name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexName</MethodName>
            <MethodComment>/** 
 * Get the index name.
 * @param indexId   Index number for index for table
 * @return String   The index name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogRowFactory</MethodName>
            <MethodComment>/** 
 * Get the CatalogRowFactory for this.
 * @return CatalogRowFactory    The CatalogRowFactory for this.
 */
</MethodComment>
            <ReturnType>CatalogRowFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isComplete</MethodName>
            <MethodComment>/** 
 * Is this fully initialized.   (i.e., is all conglomerate info initialized)
 * @return boolean  Whether or not this is fully initialized.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexColumnCount</MethodName>
            <MethodComment>/** 
 * Get the column count for the specified index number.
 * @param indexNumber   The index number.
 * @return int          The column count for the specified index.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexRowGenerator</MethodName>
            <MethodComment>/** 
 * Get the IndexRowGenerator for the specified index number.
 * @param indexNumber   The index number.
 * @return IndexRowGenerator    The IRG for the specified index number.
 */
</MethodComment>
            <ReturnType>IndexRowGenerator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIndexRowGenerator</MethodName>
            <MethodComment>/** 
 * Set the IndexRowGenerator for the specified index number.
 * @param indexNumber   The index number.
 * @param irg           The IndexRowGenerator for the specified index number.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>irg</ParamName>
                    <ParamType>IndexRowGenerator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>indexes[indexNumber];setIndexRowGenerator;[irg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumberOfIndexes</MethodName>
            <MethodComment>/** 
 * Get the number of indexes on this catalog.
 * @return int  The number of indexes on this catalog.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBaseColumnPosition</MethodName>
            <MethodComment>/** 
 * Get the base column position for a column within a catalog given the (0-based) index number for this catalog and the (0-based) column number for the column within the index.
 * @param indexNumber   The index number
 * @param colNumber     The column number within the index
 * @return int      The base column position for the column.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIndexUnique</MethodName>
            <MethodComment>/** 
 * Return whether or not this index is declared unique
 * @param indexNumber   The index number
 * @return boolean      Whether or not this index is declared unique
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertRow</MethodName>
            <MethodComment>/** 
 * Inserts a base row into a catalog and inserts all the corresponding index rows.
 * @param row			row to insert
 * @param tc			transaction
 * @return	row number (&amp;gt;= 0) if duplicate row inserted into an indexROWNOTDUPLICATE otherwise
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowLocation[] [notUsed=new RowLocation[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertRowList</MethodName>
            <MethodComment>/** 
 * Inserts a list of base rows into a catalog and inserts all the corresponding index rows.
 * @param rowList		List of rows to insert
 * @param tc			transaction controller
 * @return	row  number (&amp;gt;= 0) if duplicate row inserted into an indexROWNOTDUPLICATE otherwise
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowList</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowLocation[] [notUsed=new RowLocation[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertRowListImpl</MethodName>
            <MethodComment>/** 
 * Insert logic to insert a list of rows into a table. This logic has two odd features. &lt;OL&gt; &lt;LI&gt;Returns an indication if any returned row was a duplicate. &lt;LI&gt;Returns the RowLocation of the last row inserted. &lt;/OL&gt;
 * @param rowList the list of rows to insert
 * @param tc	transaction controller
 * @param rowLocationOut on output rowLocationOut[0] is set to thelast RowLocation inserted.
 * @return row number (&amp;gt;= 0) if duplicate row inserted into an indexROWNOTDUPLICATE otherwise
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowList</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocationOut</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapController]</InnerVar>
                <InnerVar>RowLocation [heapLocation]</InnerVar>
                <InnerVar>ExecIndexRow [indexableRow]</InnerVar>
                <InnerVar>int [insertRetCode]</InnerVar>
                <InnerVar>int [retCode=ROWNOTDUPLICATE]</InnerVar>
                <InnerVar>int [indexCount=crf.getNumIndexes()]</InnerVar>
                <InnerVar>ConglomerateController[] [indexControllers=new ConglomerateController[indexCount]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heapController;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteRow</MethodName>
            <MethodComment>/** 
 * Given a key row, delete all matching heap rows and their index rows. &lt;p&gt; LOCKING: row locking if there is a key; otherwise,  table locking.
 * @param tc          transaction controller
 * @param key         key to delete by.
 * @param indexNumber Key is appropriate for this index.
 * @return the number of rows deleted. If key is not unique,this may be more than one.
 * @exception StandardException        Thrown on failure
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteRows</MethodName>
            <MethodComment>/** 
 * Delete the set of rows defined by a scan on an index from the table. Most of the parameters are simply passed to TransactionController.openScan. Please refer to the TransactionController documentation for details. &lt;p&gt; LOCKING: row locking if there is a start and a stop key; otherwise, table locking
 * @param tc          transaction controller
 * @param startKey    key to start the scan.
 * @param startOp     operation to start the scan.
 * @param stopKey     key to start the scan.
 * @param qualifier   a qualifier for the scan.
 * @param filter      filter on base rows
 * @param stopOp      operation to start the scan.
 * @param indexNumber Key is appropriate for this index.
 * @return the number of rows deleted.
 * @exception StandardException        Thrown on failure
 * @see TransactionController#openScan
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKey</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startOp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>TupleFilter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKey</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopOp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteRows</MethodName>
            <MethodComment>/** 
 * @inheritDoc
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKey</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startOp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>filter</ParamName>
                    <ParamType>TupleFilter</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKey</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopOp</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
                <InnerVar>ScanController [drivingScan]</InnerVar>
                <InnerVar>ExecIndexRow [drivingIndexRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>RowChanger [rc]</InnerVar>
                <InnerVar>ExecRow [baseRow=crf.makeEmptyRow()]</InnerVar>
                <InnerVar>int [rowsDeleted=0]</InnerVar>
                <InnerVar>boolean [passedFilter=true]</InnerVar>
                <InnerVar>int [lockMode=((startKey != null) &amp;&amp; (stopKey != null)) ? TransactionController.MODE_RECORD : TransactionController.MODE_TABLE]</InnerVar>
                <InnerVar>int [isolation=((startKey != null) &amp;&amp; (stopKey != null) &amp;&amp; (startKey == stopKey)) ? TransactionController.ISOLATION_REPEATABLE_READ : TransactionController.ISOLATION_SERIALIZABLE]</InnerVar>
                <InnerVar>DataValueDescriptor[] [startKeyRow=startKey == null ? null : startKey.getRowArray()]</InnerVar>
                <InnerVar>DataValueDescriptor[] [stopKeyRow=stopKey == null ? null : stopKey.getRowArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rc;open;[lockMode, wait]</InnerMethodInvoke>
                <InnerMethodInvoke>heapCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>drivingScan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRow</MethodName>
            <MethodComment>/** 
 * Given a key row, return the first matching heap row. &lt;p&gt; LOCKING: shared row locking.
 * @param tc          transaction controller
 * @param key         key to read by.
 * @param indexNumber Key is appropriate for this index.
 * @exception StandardException        Thrown on failure
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowLocation</MethodName>
            <MethodComment>/** 
 * Given an index row and index number return the RowLocation in the heap of the first matching row. Used by the autoincrement code to get the RowLocation in syscolumns given a &amp;lt;tablename, columname&amp;gt; pair.
 * @see DataDictionaryImpl#computeRowLocation(TransactionController,TableDescriptor,String)
 * @param tc		  Transaction Controller to use.
 * @param key		  Index Row to search in the index.
 * @param indexNumber Identifies the index to use.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRow</MethodName>
            <MethodComment>/** 
 * Given a key row, return the first matching heap row. &lt;p&gt; LOCKING: shared row locking.
 * @param tc          transaction controller
 * @param heapCC      heap to look in
 * @param key         key to read by.
 * @param indexNumber Key is appropriate for this index.
 * @exception StandardException        Thrown on failure
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapCC</ParamName>
                    <ParamType>ConglomerateController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowLocation [rl[]=new RowLocation[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowInternal</MethodName>
            <MethodComment>/** 
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapCC</ParamName>
                    <ParamType>ConglomerateController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ScanController [drivingScan]</InnerVar>
                <InnerVar>ExecIndexRow [drivingIndexRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>ExecRow [baseRow=crf.makeEmptyRow()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateRow</MethodName>
            <MethodComment>/** 
 * Updates a base row in a catalog and updates all the corresponding index rows.
 * @param key			key row
 * @param newRow		new version of the row
 * @param indexNumber	index that key operates
 * @param indicesToUpdate	array of booleans, one for each index on the catalog.if a boolean is true, that means we must update the corresponding index because changes in the newRow affect it.
 * @param colsToUpdate	array of ints indicating which columns (1 based)to update.  If null, do all.
 * @param tc			transaction controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indicesToUpdate</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToUpdate</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow[] [newRows=new ExecRow[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateRow;[key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateRow</MethodName>
            <MethodComment>/** 
 * Updates a set of base rows in a catalog with the same key on an index and updates all the corresponding index rows. 
 * @param key			key row
 * @param newRows		new version of the array of rows
 * @param indexNumber	index that key operates
 * @param indicesToUpdate	array of booleans, one for each index on the catalog.if a boolean is true, that means we must update the corresponding index because changes in the newRow affect it.
 * @param colsToUpdate	array of ints indicating which columns (1 based)to update.  If null, do all.
 * @param tc			transaction controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newRows</ParamName>
                    <ParamType>ExecRow[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indicesToUpdate</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToUpdate</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
                <InnerVar>ScanController [drivingScan]</InnerVar>
                <InnerVar>ExecIndexRow [drivingIndexRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>ExecRow [baseRow=crf.makeEmptyRow()]</InnerVar>
                <InnerVar>RowChanger [rc=getRowChanger(tc,colsToUpdate,baseRow)]</InnerVar>
                <InnerVar>int [rowNum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rc;openForUpdate;[indicesToUpdate, TransactionController.MODE_RECORD, true]</InnerMethodInvoke>
                <InnerMethodInvoke>rc;finish;[]</InnerMethodInvoke>
                <InnerMethodInvoke>heapCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>drivingScan;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCreateHeapProperties</MethodName>
            <MethodComment>/** 
 * Get the Properties associated with creating the heap.
 * @return The Properties associated with creating the heap.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCreateIndexProperties</MethodName>
            <MethodComment>/** 
 * Get the Properties associated with creating the specified index.
 * @param indexNumber	The specified index number.
 * @return The Properties associated with creating the specified index.
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowChanger</MethodName>
            <MethodComment>/** 
 * Gets a row changer for this catalog.
 * @param tc	transaction controller
 * @param changedCols	the columns to change (1 based), may be null
 * @param baseRow used to detemine column types at creation timeonly. The row changer does ***Not*** keep a referance to this row or change it in any way.
 * @return	a row changer for this catalog.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>RowChanger</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>changedCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowChanger [rc]</InnerVar>
                <InnerVar>int [indexCount=crf.getNumIndexes()]</InnerVar>
                <InnerVar>IndexRowGenerator[] [irgs=new IndexRowGenerator[indexCount]]</InnerVar>
                <InnerVar>long[] [cids=new long[indexCount]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStreamStorableHeapColIds</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexRowFromHeapRow</MethodName>
            <MethodComment>/** 
 * Get an index row based on a row from the heap.
 * @param irg		IndexRowGenerator to use
 * @param rl		RowLocation for heap
 * @param heapRow	Row from the heap
 * @return ExecIndexRow	Index row.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ExecIndexRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>irg</ParamName>
                    <ParamType>IndexRowGenerator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [indexRow]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>irg;getIndexRow;[heapRow, rl, indexRow, (FormatableBitSet)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>