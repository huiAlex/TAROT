<Class>
    <Id>1094</Id>
    <Package>org.apache.derby.impl.sql.conn</Package>
    <ClassName>GenericLanguageConnectionContext</ClassName>
    <SuperClass>ContextImpl</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>LanguageConnectionContext</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>GenericLanguageConnectionContext  /** 
 * LanguageConnectionContext keeps the pool of prepared statements, activations, and cursors in use by the current connection. &lt;p&gt; The generic impl does not provide statement caching.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>NON_XA</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XA_ONE_PHASE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XA_TWO_PHASE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>acts</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>acts</FieldName>
            <FieldType>Activation</FieldType>
        </Field>
        <Field>
            <FieldName>unusedActs</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>maxActsSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>bindCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ddWriteMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>runTimeStatisticsSetting</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>statisticsTiming</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>xplainOnlyMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>xplain_schema</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>xplain_statements</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>xplain_statements</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>allDeclaredGlobalTempTables</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>allDeclaredGlobalTempTables</FieldName>
            <FieldType>TempTableInfo</FieldType>
        </Field>
        <Field>
            <FieldName>currentSavepointLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextCursorId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>nextSavepointId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>runTimeStatisticsObject</FieldName>
            <FieldType>RunTimeStatistics</FieldType>
        </Field>
        <Field>
            <FieldName>sb</FieldName>
            <FieldType>StringBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>db</FieldName>
            <FieldType>Database</FieldType>
        </Field>
        <Field>
            <FieldName>instanceNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>drdaID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>dbname</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>lastQueryTree</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>tran</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>readOnlyNestedTransaction</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>queryNestingDepth</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>dataFactory</FieldName>
            <FieldType>DataValueFactory</FieldType>
        </Field>
        <Field>
            <FieldName>langFactory</FieldName>
            <FieldType>LanguageFactory</FieldType>
        </Field>
        <Field>
            <FieldName>tcf</FieldName>
            <FieldType>TypeCompilerFactory</FieldType>
        </Field>
        <Field>
            <FieldName>of</FieldName>
            <FieldType>OptimizerFactory</FieldType>
        </Field>
        <Field>
            <FieldName>connFactory</FieldName>
            <FieldType>LanguageConnectionFactory</FieldType>
        </Field>
        <Field>
            <FieldName>statementContexts</FieldName>
            <FieldType>StatementContext[]</FieldType>
        </Field>
        <Field>
            <FieldName>statementDepth</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>outermostTrigger</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>authorizer</FieldName>
            <FieldType>Authorizer</FieldType>
        </Field>
        <Field>
            <FieldName>userName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>topLevelSSC</FieldName>
            <FieldType>SQLSessionContext</FieldType>
        </Field>
        <Field>
            <FieldName>cachedInitialDefaultSchemaDescr</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>defaultIsolationLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isolationLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isolationLevelExplicitlySet</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isolationLevelSetUsingSQLorJDBC</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>prepareIsolationLevel</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>logStatementText</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>logQueryPlan</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>istream</FieldName>
            <FieldType>HeaderPrintWriter</FieldType>
        </Field>
        <Field>
            <FieldName>lockEscalationThreshold</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stmtValidators</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>stmtValidators</FieldName>
            <FieldType>ExecutionStmtValidator</FieldType>
        </Field>
        <Field>
            <FieldName>triggerExecutionContexts</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>triggerExecutionContexts</FieldName>
            <FieldType>TriggerExecutionContext</FieldType>
        </Field>
        <Field>
            <FieldName>triggerTables</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>triggerTables</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>optimizerTracer</FieldName>
            <FieldType>OptTrace</FieldType>
        </Field>
        <Field>
            <FieldName>autoincrementHT</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>autoincrementHT</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>autoincrementUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>identityVal</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>identityNotNull</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>autoincrementCacheHashtable</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>autoincrementCacheHashtable</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>astWalker</FieldName>
            <FieldType>ASTVisitor</FieldType>
        </Field>
        <Field>
            <FieldName>interruptedException</FieldName>
            <FieldType>StandardException</FieldType>
        </Field>
        <Field>
            <FieldName>referencedColumnMap</FieldName>
            <FieldType>WeakHashMap</FieldType>
        </Field>
        <Field>
            <FieldName>referencedColumnMap</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>deferredHashTables</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>deferredHashTables</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>sessionUser</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>printedObjectsMap</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>printedObjectsMap</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>GenericLanguageConnectionContext</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tranCtrl</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lf</ParamName>
                    <ParamType>LanguageFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcf</ParamName>
                    <ParamType>LanguageConnectionFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>db</ParamName>
                    <ParamType>Database</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>instanceNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [logStatementProperty=PropertyUtil.getServiceProperty(getTransactionCompile(),"derby.language.logStatementText")]</InnerVar>
                <InnerVar>String [logQueryPlanProperty=PropertyUtil.getServiceProperty(getTransactionCompile(),"derby.language.logQueryPlan")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setRunTimeStatisticsMode;[logQueryPlan]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDefaultSchema;[initDefaultSchemaDescriptor()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initDefaultSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Compute the initial default schema and set cachedInitialDefaultSchemaDescr accordingly.
 * @return computed initial default schema value for this session
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInitialDefaultSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the computed value for the initial default schema.
 * @return the schema descriptor of the computed initial default schema
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogStatementText</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getLogStatementText
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLogStatementText</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setLogStatementText
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logStatementText</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogQueryPlan</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getLogQueryPlan
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesSqlAuthorization</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#usesSqlAuthorization
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockEscalationThreshold</MethodName>
            <MethodComment>/** 
 * get the lock escalation threshold.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addActivation</MethodName>
            <MethodComment>/** 
 * Add the activation to those known about by this connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>acts;add;[a]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeUnusedActivations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notifyUnusedActivation</MethodName>
            <MethodComment>/** 
 * Make a note that some activations are marked unused
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIfAnyDeclaredGlobalTempTablesForThisConnection</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#checkIfAnyDeclaredGlobalTempTablesForThisConnection
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#addDeclaredGlobalTempTable
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TempTableInfo [tempTableInfo=new TempTableInfo(td,currentSavepointLevel)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>allDeclaredGlobalTempTables;add;[tempTableInfo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#dropDeclaredGlobalTempTable
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TempTableInfo [tempTableInfo=findDeclaredGlobalTempTable(tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tempTablesReleaseSavepointLevels</MethodName>
            <MethodComment>/** 
 * After a release of a savepoint, we need to go through our temp tables  list. If there are tables with their declare or drop or modified in  savepoint levels set to savepoint levels higher than the current  savepoint level, then we should change them to the current savepoint level
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tempTablesAndCommit</MethodName>
            <MethodComment>/** 
 * Do the necessary work at commit time for temporary tables &lt;p&gt; 1)If a temporary table was marked as dropped in this transaction, then  remove it from the list of temp tables for this connection 2)If a temporary table was not dropped in this transaction, then mark  it's declared savepoint level and modified savepoint level as -1 3)After savepoint fix up, then handle all ON COMMIT DELETE ROWS with no open held cursor temp tables. &lt;p&gt;
 * @param in_xa_transaction if true, then transaction is an XA transaction,and special nested transaction may be necessary to cleanup internal containers supporting the temp tables at commit time.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in_xa_transaction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tempTablesXApostCommit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetFromPool</MethodName>
            <MethodComment>/** 
 * Reset the connection before it is returned (indirectly) by a PooledConnection object. See EmbeddedConnection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropAllDeclaredGlobalTempTables;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setDefaultSchema;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>getCurrentSQLSessionContext();setRole;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>getCurrentSQLSessionContext();setUser;[getSessionUserId()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastQueryTree</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryTree</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastQueryTree</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllDeclaredGlobalTempTables</MethodName>
            <MethodComment>/** 
 * Drop all the declared global temporary tables associated with this  connection. This gets called when a getConnection() is done on a  PooledConnection. This will ensure all the temporary tables declared on earlier connection handle associated with this physical database  connection are dropped before a new connection handle is issued on that  same physical database connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DependencyManager [dm=getDataDictionary().getDependencyManager()]</InnerVar>
                <InnerVar>StandardException [topLevelStandardException=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tempTablesAndRollback</MethodName>
            <MethodComment>/** 
 * do the necessary work at rollback time for temporary tables 1)If a temp table was declared in the UOW, then drop it and remove it  from list of temporary tables. 2)If a temp table was declared and dropped in the UOW, then remove it  from list of temporary tables. 3)If an existing temp table was dropped in the UOW, then recreate it  with no data. 4)If an existing temp table was modified in the UOW, then get rid of  all the rows from the table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateCleanupDroppedTable</MethodName>
            <MethodComment>/** 
 * Invalidate a dropped temp table 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getDataDictionary().getDependencyManager();invalidateFor;[td, DependencyManager.DROP_TABLE, this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanupTempTableOnCommitOrRollback;[td, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * This is called at the commit time for temporary tables with  ON COMMIT DELETE ROWS If a temp table with ON COMMIT DELETE ROWS doesn't have any held cursor  open on them, we delete the data from them by dropping the conglomerate  and recreating the conglomerate. In order to store the new conglomerate information for the temp table, we need to replace the existing table  descriptor with the new table descriptor which has the new conglomerate information
 * @param tableName Temporary table name whose table descriptor is getting changed
 * @param td        New table descriptor for the temporary table
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TempTableInfo [tempTableInfo=findDeclaredGlobalTempTable(tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tempTableInfo;setDroppedInSavepointLevel;[-1]</InnerMethodInvoke>
                <InnerMethodInvoke>tempTableInfo;setDeclaredInSavepointLevel;[-1]</InnerMethodInvoke>
                <InnerMethodInvoke>tempTableInfo;setTableDescriptor;[td]</InnerMethodInvoke>
                <InnerMethodInvoke>allDeclaredGlobalTempTables;set;[allDeclaredGlobalTempTables.indexOf(tempTableInfo), tempTableInfo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptorForDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getTableDescriptorForDeclaredGlobalTempTable
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TempTableInfo [tempTableInfo=findDeclaredGlobalTempTable(tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDeclaredGlobalTempTable</MethodName>
            <MethodComment>/** 
 * Find the declared global temporary table in the list of temporary tables known by this connection.
 * @param tableName look for this table name in the saved list
 * @return data structure defining the temporary table if found. Else, return null 
 */
</MethodComment>
            <ReturnType>TempTableInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markTempTableAsModifiedInUnitOfWork</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#markTempTableAsModifiedInUnitOfWork
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TempTableInfo [tempTableInfo=findDeclaredGlobalTempTable(tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tempTableInfo;setModifiedInSavepointLevel;[currentSavepointLevel]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareInternalStatement</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#prepareInternalStatement
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compilationSchema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isForReadOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forMetaData</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareInternalStatement</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#prepareInternalStatement
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeActivation</MethodName>
            <MethodComment>/** 
 * Remove the activation to those known about by this connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>acts;remove;[a]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActivationCount</MethodName>
            <MethodComment>/** 
 * Return the number of activations known for this connection. Note that some of these activations may not be in use (when a prepared statement is finalized, its activations are marked as unused and later closed and removed on the next commit/rollback).
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupCursorActivation</MethodName>
            <MethodComment>/** 
 * See if a given cursor is available for use. if so return its activation. Returns null if not found. For use in execution.
 * @return the activation for the given cursor, nullif none was found.
 */
</MethodComment>
            <ReturnType>CursorActivation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cursorName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=acts.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeStatement</MethodName>
            <MethodComment>/** 
 * This method will remove a statement from the  statement cache. It should only be called if there is an exception preparing the statement. The caller must have set the flag {@code preparedStmt.compilingStatement} in the {@code GenericStatement}before calling this method in order to prevent race conditions when calling  {@link CacheManager#remove(Cacheable)}.
 * @param statement Statement to remove
 * @exception StandardException thrown if lookup goes wrong.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>GenericStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheManager [statementCache=getLanguageConnectionFactory().getStatementCache()]</InnerVar>
                <InnerVar>Cacheable [cachedItem=statementCache.findCached(statement)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupStatement</MethodName>
            <MethodComment>/** 
 * See if a given statement has already been compiled for this user, and if so use its prepared statement. Returns null if not found.
 * @exception StandardException thrown if lookup goes wrong.
 * @return the prepared statement for the given string, nullif none was found.
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>GenericStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheManager [statementCache=getLanguageConnectionFactory().getStatementCache()]</InnerVar>
                <InnerVar>Cacheable [cachedItem=statementCache.find(statement)]</InnerVar>
                <InnerVar>CachedStatement [cs=(CachedStatement)cachedItem]</InnerVar>
                <InnerVar>GenericPreparedStatement [ps=cs.getPreparedStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>statementCache;release;[cachedItem]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueCursorName</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated name for a cursor.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueSavepointName</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated name for an unnamed savepoint.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUniqueSavepointID</MethodName>
            <MethodComment>/** 
 * Get a connection unique system generated id for an unnamed savepoint.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNameString</MethodName>
            <MethodComment>/** 
 * Build a String for a statement name.
 * @param prefix    The prefix for the statement name.
 * @param number    The number to append for uniqueness
 * @return  A unique String for a statement name.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>number</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb.append(prefix);append;[number]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalCommit</MethodName>
            <MethodComment>/** 
 * Do a commit as appropriate for an internally generated commit (e.g. as needed by sync, or autocommit).
 * @param commitStore true if we should commit the Store transaction
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitStore</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doCommit;[commitStore, true, NON_XA, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userCommit</MethodName>
            <MethodComment>/** 
 * Do a commmit as is appropriate for a user requested commit (e.g. a java.sql.Connection.commit() or a language 'COMMIT' statement.  Does some extra checking to make sure that users aren't doing anything bad.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doCommit;[true, true, NON_XA, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalCommitNoSync</MethodName>
            <MethodComment>/** 
 * Commit the language transaction by doing a commitNoSync() on the store's TransactionController. &lt;p&gt; Do *NOT* tell the data dictionary that the transaction is finished. The reason is that this would allow other transactions to see comitted DDL that could be undone in the event of a system crash.
 * @param commitflag  the flags to pass to commitNoSync in the store'sTransactionController
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doCommit;[true, false, commitflag, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xaCommit</MethodName>
            <MethodComment>/** 
 * Same as userCommit except commit a distributed transaction.    This commit always commit store and sync the commit.
 * @param onePhase if true, allow it to commit without first going thru aprepared state.
 * @exception StandardException    thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onePhase</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doCommit;[true, true, onePhase ? XA_ONE_PHASE : XA_TWO_PHASE, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCommit</MethodName>
            <MethodComment>/** 
 * This is where the work on internalCommit(), userCOmmit() and  internalCommitNoSync() actually takes place. &lt;p&gt; When a commit happens, the language connection context will close all open activations/cursors and commit the Store transaction. &lt;p&gt; REVISIT: we talked about having a LanguageTransactionContext, but since store transaction management is currently in flux and our context might want to delegate to that context, for now all commit/rollback actions are handled directly by the language connection context. REVISIT: this may need additional alterations when RELEASE SAVEPOINT/ROLLBACK TO SAVEPOINT show up. &lt;P&gt; Since the access manager's own context takes care of its own resources on commit, and the transaction stays open, there is nothing that this context has to do with the transaction controller. &lt;p&gt; Also, tell the data dictionary that the transaction is finished, if necessary (that is, if the data dictionary was put into DDL mode in this transaction.
 * @param commitStore true if we should commit the Store transaction
 * @param sync        true means do a synchronized commit,false means do an unsynchronized commit
 * @param commitflag  if this is an unsynchronized commit, the flags topass to commitNoSync in the store's TransactionController.  If this is a synchronized commit, this flag is overloaded for xacommit.
 * @param requestedByUser    False iff the commit is for internal use andwe should ignore the check to prevent commits in an atomic statement.
 * @exception StandardException     Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitStore</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sync</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requestedByUser</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StatementContext [statementContext=getStatementContext()]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIntegrity;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;endTransactionActivationHandling;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupTempTableOnCommitOrRollback</MethodName>
            <MethodComment>/** 
 * If dropAndRedeclare is true, that means we have come here for temp  tables with on commit delete rows and no held curosr open on them. We  will drop the existing conglomerate and redeclare a new conglomerate similar to old conglomerate. This is a more efficient way of deleting  all rows from the table. If dropAndRedeclare is false, that means we have come here for the  rollback cleanup work. We are trying to restore old definition of the  temp table (because the drop on it is being rolled back).
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dropAndRedeclare</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
                <InnerVar>long [conglomId=tc.createConglomerate("heap",td.getEmptyExecRow().getRowArray(),null,td.getColumnCollationIds(),null,(TransactionController.IS_TEMPORARY | TransactionController.IS_KEPT))]</InnerVar>
                <InnerVar>long [cid=td.getHeapConglomerateId()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cgd=td.getConglomerateDescriptor(cid)]</InnerVar>
                <InnerVar>ConglomerateDescriptorList [conglomList=td.getConglomerateDescriptorList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>td.getConglomerateDescriptorList();dropConglomerateDescriptorByUUID;[cgd.getUUID()]</InnerMethodInvoke>
                <InnerMethodInvoke>conglomList;add;[cgd]</InnerMethodInvoke>
                <InnerMethodInvoke>td;resetHeapConglomNumber;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalRollback</MethodName>
            <MethodComment>/** 
 * Do a rollback as appropriate for an internally generated rollback (e.g. as needed by sync, or autocommit). When a rollback happens, we  close all open activations and invalidate their prepared statements.  We then tell the cache to age out everything else, which effectively invalidates them.  Thus, all prepared statements will be compiled anew on their 1st execution after a rollback. &lt;p&gt; The invalidated statements can revalidate themselves without a full recompile if they verify their dependencies' providers still exist unchanged. REVISIT when invalidation types are created. &lt;p&gt; REVISIT: this may need additional alterations when RELEASE SAVEPOINT/ROLLBACK TO SAVEPOINT show up. &lt;p&gt; Also, tell the data dictionary that the transaction is finished, if necessary (that is, if the data dictionary was put into DDL mode in this transaction.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doRollback;[false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userRollback</MethodName>
            <MethodComment>/** 
 * Do a rollback as is appropriate for a user requested rollback (e.g. a java.sql.Connection.rollback() or a language 'ROLLBACk' statement.  Does some extra checking to make sure that users aren't doing anything bad.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doRollback;[false, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xaRollback</MethodName>
            <MethodComment>/** 
 * Same as userRollback() except rolls back a distrubuted transaction.
 * @exception StandardException    thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doRollback;[true, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doRollback</MethodName>
            <MethodComment>/** 
 * When a rollback happens, the language connection context will close all open activations and invalidate their prepared statements. Then the language will abort the Store transaction. &lt;p&gt; The invalidated statements can revalidate themselves without a full recompile if they verify their dependencies' providers still exist unchanged. REVISIT when invalidation types are created. &lt;p&gt; REVISIT: this may need additional alterations when RELEASE SAVEPOINT/ROLLBACK TO SAVEPOINT show up. &lt;p&gt; Also, tell the data dictionary that the transaction is finished, if necessary (that is, if the data dictionary was put into DDL mode in this transaction.
 * @param xa    true if this is an xa rollback
 * @param requestedByUser   true if requested by user
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xa</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requestedByUser</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StatementContext [statementContext=getStatementContext()]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;clearDeferreds;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;endTransactionActivationHandling;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;finishDDTransaction;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetSavepoints</MethodName>
            <MethodComment>/** 
 * Reset all statement savepoints. Traverses the StatementContext stack from bottom to top, calling resetSavePoint() on each element.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ContextManager [cm=getContextManager()]</InnerVar>
                <InnerVar>List&lt;Context&gt; [stmts=cm.getContextStack(ContextId.LANG_STATEMENT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalRollbackToSavepoint</MethodName>
            <MethodComment>/** 
 * Let the context deal with a rollback to savepoint
 * @param savepointName   Name of the savepoint that needs to be rolled back
 * @param refreshStyle    boolean indicating whether or not the controller should closeopen conglomerates and scans. Also used to determine if language should close open activations.
 * @param kindOfSavepoint  A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refreshStyle</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseSavePoint</MethodName>
            <MethodComment>/** 
 * Let the context deal with a release of a savepoint
 * @param savepointName   Name of the savepoint that needs to be released
 * @param kindOfSavepoint  A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>languageSetSavePoint</MethodName>
            <MethodComment>/** 
 * Sets a savepoint. Causes the Store to set a savepoint.
 * @param savepointName   name of savepoint
 * @param kindOfSavepoint  A NULL value means it is an internal savepoint (ie not a user defined savepoint)Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint A String value for kindOfSavepoint would mean it is SQL savepoint A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savepointName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginNestedTransaction</MethodName>
            <MethodComment>/** 
 * Start a Nested User Transaction (NUT) with the store. If a NUT is  already active simply increment a counter, queryNestingDepth, to keep track of how many times we have tried to start a NUT.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>readOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commitNestedTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionCompile</MethodName>
            <MethodComment>/** 
 * Get the transaction controller to use at compile time with this language connection context. If a NUT is active then return NUT else return parent transaction.
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionExecute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Get the data value factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageFactory</MethodName>
            <MethodComment>/** 
 * Get the language factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>LanguageFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OptimizerFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageConnectionFactory</MethodName>
            <MethodComment>/** 
 * Get the language connection factory to use with this language connection context.
 */
</MethodComment>
            <ReturnType>LanguageConnectionFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIfAnyActivationHasHoldCursor</MethodName>
            <MethodComment>/** 
 * check if there are any activations that reference this temporary table
 * @param tableName look for any activations referencing this table name
 * @return boolean  false if found no activations
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyAllHeldResultSetsAreClosed</MethodName>
            <MethodComment>/** 
 * Verify that there are no activations with open held result sets.
 * @return boolean  Found no open (held) resultsets.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [seenOpenResultSets=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;gc;[]</InnerMethodInvoke>
                <InnerMethodInvoke>System;runFinalization;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyNoOpenResultSets</MethodName>
            <MethodComment>/** 
 * Verify that there are no activations with open result sets on the specified prepared statement.
 * @param pStmt     The prepared Statement
 * @param provider  The object precipitating a possible invalidation
 * @param action    The action causing the possible invalidation
 * @return Nothing.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pStmt</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>provider</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [seenOpenResultSets=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;gc;[]</InnerMethodInvoke>
                <InnerMethodInvoke>System;runFinalization;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSessionUserId</MethodName>
            <MethodComment>/** 
 * Get the session user
 * @return String the authorization id of the session user.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getDefaultSchema
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getDefaultSchema(Activation a)
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSchemaName</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentSchemaName()
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [s=getDefaultSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSchemaName</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentSchemaName(Activation a)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [s=getDefaultSchema(a)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInitialDefaultSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#isInitialDefaultSchema
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setDefaultSchema(SchemaDescriptor sd)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext();setDefaultSchema;[sd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setDefaultSchema(Activation a,SchemaDescriptor sd)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext(a);setDefaultSchema;[sd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetSchemaUsages</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#resetSchemaUsages(Activation activation,String schemaName)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Activation [parent=activation.getParentActivation()]</InnerVar>
                <InnerVar>SchemaDescriptor [defaultSchema=getInitialDefaultSchemaDescriptor()]</InnerVar>
                <InnerVar>SQLSessionContext [top=getTopLevelSQLSessionContext()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=top.getDefaultSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdentityValue</MethodName>
            <MethodComment>/** 
 * Get the identity column value most recently generated.
 * @return the generated identity column value
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIdentityValue</MethodName>
            <MethodComment>/** 
 * Set the field of most recently generated identity column value.
 * @param val the generated identity column value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCompilerContext</MethodName>
            <MethodComment>/** 
 * Push a CompilerContext on the context stack with the current default schema as the default schema which we compile against.
 * @return the compiler context
 */
</MethodComment>
            <ReturnType>CompilerContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushCompilerContext</MethodName>
            <MethodComment>/** 
 * Push a CompilerContext on the context stack with the passed in schema sd as the default schema we compile against.
 * @param sd the default schema 
 * @return the compiler contextFor the parameter sd, there are 3 possible values(of interest) that can  get passed into this method: a) A null SchemaDescriptor which indicates to the system to use the  CURRENT SCHEMA as the compilation schema. b) A SchemaDescriptor with its UUID == null, this indicates that either  the schema has not been physically created yet or that the LCC's  getDefaultSchema() is not yet up-to-date with its actual UUID.  The system will use the CURRENT SCHEMA as the compilation schema.  c) A SchemaDescriptor with its UUID != null, this means that the schema  has been physically created.  The system will use this schema as the  compilation schema (e.g.: for trigger or view recompilation cases,  etc.).  The compiler context's compilation schema will be set accordingly based  on the given input above.   
 */
</MethodComment>
            <ReturnType>CompilerContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc]</InnerVar>
                <InnerVar>boolean [firstCompilerContext=false]</InnerVar>
                <InnerVar>StatementContext [sc=getStatementContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;setInUse;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popCompilerContext</MethodName>
            <MethodComment>/** 
 * Pop a CompilerContext off the context stack.
 * @param cc  The compiler context.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cc</ParamName>
                    <ParamType>CompilerContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;setCurrentDependent;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;setInUse;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushStatementContext</MethodName>
            <MethodComment>/** 
 * Push a StatementContext on the context stack. Inherit SQL session state a priori (statementContext will get its own SQL session state if this statement executes a call, cf. pushNestedSessionContext.
 * @param isAtomic whether this statement is atomic or not
 * @param isForReadOnly whether this statement is for a read only resultset
 * @param stmtText the text of the statement.  Needed for any languagestatement (currently, for any statement that can cause a trigger to fire).  Please set this unless you are some funky jdbc setXXX method or something.
 * @param pvs parameter value set, if it has one
 * @param rollbackParentContext True if 1) the statement context isNOT a top-level context, AND 2) in the event of a statement-level exception, the parent context needs to be rolled back, too.
 * @param timeoutMillis timeout value for this statement, in milliseconds.The value 0 means that no timeout is set.
 * @return StatementContext  The statement context.
 */
</MethodComment>
            <ReturnType>StatementContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isAtomic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isForReadOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmtText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pvs</ParamName>
                    <ParamType>ParameterValueSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rollbackParentContext</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>timeoutMillis</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [parentStatementDepth=statementDepth]</InnerVar>
                <InnerVar>boolean [inTrigger=false]</InnerVar>
                <InnerVar>boolean [parentIsAtomic=false]</InnerVar>
                <InnerVar>StatementContext [statementContext=statementContexts[0]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;incrementStatementDepth;[]</InnerMethodInvoke>
                <InnerMethodInvoke>statementContext;setInUse;[inTrigger, isAtomic || parentIsAtomic, isForReadOnly, stmtText, pvs, timeoutMillis]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popStatementContext</MethodName>
            <MethodComment>/** 
 * Pop a StatementContext of the context stack.
 * @param statementContext  The statement context.
 * @param error             The error, if any  (Only relevant for DEBUG)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statementContext</ParamName>
                    <ParamType>StatementContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>error</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;decrementStatementDepth;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushExecutionStmtValidator</MethodName>
            <MethodComment>/** 
 * Push a new execution statement validator.  An execution statement  validator is an object that validates the current statement to ensure that it is permitted given the current execution context. An example of a validator a trigger ExecutionStmtValidator that doesn't allow ddl on the trigger target table. &lt;p&gt; Multiple ExecutionStmtValidators may be active at any given time. This mirrors the way there can be multiple connection nestings at a single time.  The validation is performed by calling each validator's validateStatement() method.  This yields the union of all validations.
 * @param validator the validator to add
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>validator</ParamName>
                    <ParamType>ExecutionStmtValidator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmtValidators;add;[validator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popExecutionStmtValidator</MethodName>
            <MethodComment>/** 
 * Remove the validator.  Does an object identity (validator == validator) comparison.  Asserts that the validator is found.
 * @param validator the validator to remove
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>validator</ParamName>
                    <ParamType>ExecutionStmtValidator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [foundElement=stmtValidators.remove(validator)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Push a new trigger execution context. &lt;p&gt; Multiple TriggerExecutionContexts may be active at any given time.
 * @param tec the trigger execution context
 * @exception StandardException on trigger recursion error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tec</ParamName>
                    <ParamType>TriggerExecutionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>triggerExecutionContexts;add;[tec]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Remove the tec.  Does an object identity (tec == tec) comparison.  Asserts that the tec is found.
 * @param tec the tec to remove
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tec</ParamName>
                    <ParamType>TriggerExecutionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [foundElement=triggerExecutionContexts.remove(tec)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Get the topmost tec.  
 * @return the tec
 */
</MethodComment>
            <ReturnType>TriggerExecutionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateStmtExecution</MethodName>
            <MethodComment>/** 
 * Validate a statement.  Does so by stepping through all the validators and executing them.  If a validator throws and exception, then the checking is stopped and the exception is passed up.
 * @param constantAction the constantAction that is about to be executed (andshould be validated
 * @exception StandardException on validation failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constantAction</ParamName>
                    <ParamType>ConstantAction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushTriggerTable</MethodName>
            <MethodComment>/** 
 * Set the trigger table descriptor.  Used to compile statements that may special trigger pseudo tables.
 * @param td the table that the trigger is defined upon
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>triggerTables;add;[td]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popTriggerTable</MethodName>
            <MethodComment>/** 
 * Remove the trigger table descriptor.
 * @param td the table to remove from the stack.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [foundElement=triggerTables.remove(td)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerTable</MethodName>
            <MethodComment>/** 
 * Get the topmost trigger table descriptor
 * @return the table descriptor, or null if wearen't in the middle of compiling a create trigger.
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabase</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getDatabase
 */
</MethodComment>
            <ReturnType>Database</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementBindCount</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#incrementBindCount 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementBindCount</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#decrementBindCount 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBindCount</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getBindCount 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDataDictionaryWriteMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setDataDictionaryWriteMode 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataDictionaryInWriteMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#dataDictionaryInWriteMode 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRunTimeStatisticsMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setRunTimeStatisticsMode 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRunTimeStatisticsMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getRunTimeStatisticsMode 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStatisticsTiming</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setStatisticsTiming 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatisticsTiming</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getStatisticsTiming 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRunTimeStatisticsObject</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setRunTimeStatisticsObject 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>runTimeStatisticsObject</ParamName>
                    <ParamType>RunTimeStatistics</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRunTimeStatisticsObject</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getRunTimeStatisticsObject 
 */
</MethodComment>
            <ReturnType>RunTimeStatistics</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementDepth</MethodName>
            <MethodComment>/** 
 * Reports how many statement levels deep we are.
 * @return a statement level &amp;gt;= OUTERMOST_STATEMENT
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIsolationLevelSetUsingSQLorJDBC</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#isIsolationLevelSetUsingSQLorJDBC
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetIsolationLevelFlagUsedForSQLandJDBC</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#resetIsolationLevelFlagUsedForSQLandJDBC
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIsolationLevel</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setIsolationLevel
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StatementContext [stmtCtxt=getStatementContext()]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentIsolationLevel</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentIsolationLevel
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentIsolationLevelStr</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentIsolationLevel
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPrepareIsolationLevel</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setPrepareIsolationLevel
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrepareIsolationLevel</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getPrepareIsolationLevel
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementContext</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getStatementContext
 */
</MethodComment>
            <ReturnType>StatementContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOptimizerTracer</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setOptimizerTracer
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tracer</ParamName>
                    <ParamType>OptTrace</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerTracer</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getOptimizerTracer
 */
</MethodComment>
            <ReturnType>OptTrace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizerTracingIsOn</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#optimizerTracingIsOn
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTransactionPristine</MethodName>
            <MethodComment>/** 
 * Reports whether there is any outstanding work in the transaction.
 * @return true if there is outstanding work in the transactionfalse otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanupOnError</MethodName>
            <MethodComment>/** 
 * If worse than a transaction error, everything goes; we rely on other contexts to kill the context manager for this session. &lt;p&gt; If a transaction error, act like we saw a rollback. &lt;p&gt; If more severe or a java error, the outer cleanup will shutdown the connection, so we don't have to clean up. &lt;p&gt; REMIND: connection should throw out all contexts and start over when the connection is closed... perhaps by throwing out the context manager? &lt;p&gt; REVISIT: If statement error, should we do anything? &lt;P&gt; Since the access manager's own context takes care of its own resources on errors, there is nothing that this context has to do with the transaction controller.
 * @exception StandardException thrown on error. REVISIT: don't wantcleanupOnError's to throw exceptions.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>error</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [severity=(error instanceof StandardException) ? ((StandardException)error).getSeverity() : ExceptionSeverity.SESSION_SEVERITY]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLastHandler</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.services.context.Context#isLastHandler
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>severity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endTransactionActivationHandling</MethodName>
            <MethodComment>/** 
 * If we are called as part of rollback code path, then we will reset all  the activations that have resultset returning rows associated with  them. DERBY-3304 Resultsets that do not return rows should be left  alone when the rollback is through the JDBC Connection object. If the  rollback is caused by an exception, then at that time, all kinds of resultsets should be closed.  If we are called as part of commit code path, then we will do one of  the following if the activation has resultset assoicated with it. Also, we will clear the conglomerate used while scanning for update/delete 1)Close result sets that return rows and are not held across commit. 2)Clear the current row of the resultsets that return rows and are held across commit. 3)Leave the result sets untouched if they do not return rows Additionally, clean up (close()) activations that have been marked as unused during statement finalization.
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forRollback</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishDDTransaction</MethodName>
            <MethodComment>/** 
 * Finish the data dictionary transaction, if any.
 * @exception StandardException    Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>incrementStatementDepth</MethodName>
            <MethodComment>/** 
 * Increments the statement depth.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementStatementDepth</MethodName>
            <MethodComment>/** 
 * Decrements the statement depth
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetStatementDepth</MethodName>
            <MethodComment>/** 
 * Resets the statementDepth.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDictionary</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataDictionary</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReadOnly</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setReadOnly
 * @exception StandardException The operation is disallowed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>on</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>authorizer;setReadOnlyConnection;[on, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnly</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#isReadOnly
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuthorizer</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getAuthorizer
 */
</MethodComment>
            <ReturnType>Authorizer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lastAutoincrementValue</MethodName>
            <MethodComment>/** 
 * lastAutoincrementValue searches for the last autoincrement value inserted into a column specified by the user. The search for the "last" value supports nesting levels caused by triggers (Only triggers cause nesting, not server side JDBC).  If lastAutoincrementValue is called from within a trigger, the search space for ai-values are those values that are inserted by this trigger as well as previous triggers;  i.e if a SQL statement fires trigger T1, which in turn does something that fires trigger t2, and if lastAutoincrementValue is called from within t2, then autoincrement values genereated by t1 are visible to it. By the same logic, if it is called from within t1, then it does not see values inserted by t2.
 * @see LanguageConnectionContext#lastAutoincrementValue
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [aiKey=AutoincrementCounter.makeIdentity(schemaName,tableName,columnName)]</InnerVar>
                <InnerVar>int [size=triggerExecutionContexts.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrementUpdate</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setAutoincrementUpdate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoincrementUpdate</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getAutoincrementUpdate
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>autoincrementCreateCounter</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#autoincrementCreateCounter
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>increment</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [key=AutoincrementCounter.makeIdentity(s,t,c)]</InnerVar>
                <InnerVar>AutoincrementCounter [aic=autoincrementCacheHashtable.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>autoincrementCacheHashtable;put;[key, aic]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextAutoincrementValue</MethodName>
            <MethodComment>/** 
 * returns the &lt;b&gt;next&lt;/b&gt; value to be inserted into an autoincrement col. This is used internally by the system to generate autoincrement values which are going to be inserted into a autoincrement column. This is used when as autoincrement column is added to a table by an alter  table statemenet and during bulk insert.
 * @param schemaName
 * @param tableName
 * @param columnName identify the column uniquely in the system.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [key=AutoincrementCounter.makeIdentity(schemaName,tableName,columnName)]</InnerVar>
                <InnerVar>AutoincrementCounter [aic=autoincrementCacheHashtable.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>autoincrementFlushCache</MethodName>
            <MethodComment>/** 
 * Flush the cache of autoincrement values being kept by the lcc. This will result in the autoincrement values being written to the SYSCOLUMNS table as well as the mapping used by lastAutoincrementValue
 * @exception StandardException thrown on error.
 * @see LanguageConnectionContext#lastAutoincrementValue
 * @see GenericLanguageConnectionContext#lastAutoincrementValue
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>autoincrementCacheHashtable;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyHashtableToAIHT</MethodName>
            <MethodComment>/** 
 * Copies an existing autoincrement mapping into autoincrementHT, the cache of autoincrement values  kept in the languageconnectioncontext.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>autoincrementHT;putAll;[from]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstanceNumber</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getInstanceNumber
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDrdaID</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getDrdaID
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDrdaID</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setDrdaID
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDbname</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getDbname
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastActivation</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getLastActivation
 */
</MethodComment>
            <ReturnType>Activation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendErrorInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StringBuffer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
                <InnerVar>StringBuffer [sb=new StringBuffer(200)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sb;append;[LanguageConnectionContext.xidStr]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[tc.getTransactionIdString()]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["), "]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[LanguageConnectionContext.lccStr]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[Integer.toString(getInstanceNumber())]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["), "]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[LanguageConnectionContext.dbnameStr]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[getDbname()]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["), "]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[LanguageConnectionContext.drdaStr]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;[getDrdaID()]</InnerMethodInvoke>
                <InnerMethodInvoke>sb;append;["), "]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentRole</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setCurrentRole(Activation a,String role)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext(a);setRole;[role]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRoleId</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentRoleId(Activation a)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentUserId</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentUserId(Activation a)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRoleIdDelimited</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getCurrentRoleIdDelimited(Activation a)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [role=getCurrentSQLSessionContext(a).getRole()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>roleIsSettable</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#roleIsSettable(Activation a,String role)
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>String [dbo=dd.getAuthorizationDatabaseOwner()]</InnerVar>
                <InnerVar>RoleGrantDescriptor [grantDesc]</InnerVar>
                <InnerVar>String [currentUser=getCurrentUserId(a)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSQLSessionContext</MethodName>
            <MethodComment>/** 
 * Return the current SQL session context of the activation
 * @param activation the activation
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLSessionContext [curr]</InnerVar>
                <InnerVar>Activation [parent=activation.getParentActivation()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSQLSessionContext</MethodName>
            <MethodComment>/** 
 * Return the current SQL session context based on statement context
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StatementContext [ctx=getStatementContext()]</InnerVar>
                <InnerVar>SQLSessionContext [curr]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushNestedSessionContext</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definersRights</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definer</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setupSessionContextMinion;[a, true, definersRights, definer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupSessionContextMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>push</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definersRights</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>definer</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLSessionContext [sc=a.setupSQLSessionContextForChildren(push)]</InnerVar>
                <InnerVar>SQLSessionContext [ssc=getCurrentSQLSessionContext(a)]</InnerVar>
                <InnerVar>StatementContext [stmctx=getStatementContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sc;setDeferredAll;[ssc.getDeferredAll()]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;setConstraintModes;[ssc.getConstraintModes()]</InnerMethodInvoke>
                <InnerMethodInvoke>stmctx;setSQLSessionContext;[sc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popNestedSessionContext</MethodName>
            <MethodComment>/** 
 * @param a {@inheritDoc}
 * @throws StandardException {@inheritDoc}
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SQLSessionContext [nested=a.getSQLSessionContextForChildren()]</InnerVar>
                <InnerVar>SQLSessionContext [caller=getCurrentSQLSessionContext(a)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;compareConstraintModes;[nested, caller]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareConstraintModes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nested</ParamName>
                    <ParamType>SQLSessionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>caller</ParamName>
                    <ParamType>SQLSessionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEffectivelyDeferred</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sc</ParamName>
                    <ParamType>SQLSessionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Boolean [deferred=sc.isDeferred(constraintId)]</InnerVar>
                <InnerVar>boolean [effectivelyDeferred]</InnerVar>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupSubStatementSessionContext</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setupSubStatementSessionContext(Activation a)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setupSessionContextMinion;[a, false, false, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTopLevelSQLSessionContext</MethodName>
            <MethodComment>/** 
 * @see GenericLanguageConnectionContext#topLevelSSC
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSQLSessionContext</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#createSQLSessionContext
 */
</MethodComment>
            <ReturnType>SQLSessionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrintedObjectsMap</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.conn.LanguageConnectionContext#getPrintedObjectsMap
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainOnlyMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getXplainOnlyMode() 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainOnlyMode</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setXplainOnlyMode(boolean) 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onOrOff</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#getXplainSchema() 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainSchema</MethodName>
            <MethodComment>/** 
 * @see LanguageConnectionContext#setXplainSchema(String) 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXplainStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xplain_statements;put;[key, stmt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXplainStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setASTVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>visitor</ParamName>
                    <ParamType>ASTVisitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getASTVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ASTVisitor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInterruptedException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>e</ParamName>
                    <ParamType>StandardException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInterruptedException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedColumnMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReferencedColumnMap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>referencedColumnMap;put;[td, map]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConstraintDeferred</MethodName>
            <MethodComment>/** 
 * Set the constraint mode to deferred for the specified constraint.
 * @param a             activation
 * @param cd            the constraint descriptor
 * @param deferred      the constraint mode
 * @throws StandardException standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext(a);setDeferred;[cd.getUUID(), deferred]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIntegrity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;validateDeferredConstraints;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearDeferreds;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDeferreds</MethodName>
            <MethodComment>/** 
 * Clear deferred information for this transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext();resetConstraintModes;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeferredAll</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCurrentSQLSessionContext(a);setDeferredAll;[Boolean.valueOf(deferred)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeferredHashTables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateDeferredConstraints</MethodName>
            <MethodComment>/** 
 * Validate all deferred constraints.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rollbackOnError</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateDeferredConstraint</MethodName>
            <MethodComment>/** 
 * Validate a deferred constraint.
 * @param cd the descriptor of the constraint to validate
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [key=cd.hasBackingIndex() ? cd.getUUID() : cd.getTableId()]</InnerVar>
                <InnerVar>ValidationInfo [vi=deferredHashTables.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>vi;validateConstraint;[this, cd.getUUID(), false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>