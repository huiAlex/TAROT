<Class>
    <Id>173</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>RAFContainer</ClassName>
    <SuperClass>FileContainer</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>PrivilegedExceptionAction</SuperInterface>
        <SuperInterface>Object</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>RAFContainer  /** 
 * RAFContainer (short for RandomAccessFileContainer) is a concrete subclass of FileContainer for FileContainers which are implemented on java.io.RandomAccessFile.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>fileData</FieldName>
            <FieldType>StorageRandomAccessFile</FieldType>
        </Field>
        <Field>
            <FieldName>needsSync</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionCode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_FILE_NAME_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_CONTAINER_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REMOVE_FILE_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>OPEN_CONTAINER_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>STUBBIFY_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_RANDOM_ACCESS_FILE_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REOPEN_CONTAINER_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>actionIdentity</FieldName>
            <FieldType>ContainerKey</FieldType>
        </Field>
        <Field>
            <FieldName>actionStub</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionErrorOK</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionTryAlternatePath</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionFile</FieldName>
            <FieldType>StorageFile</FieldType>
        </Field>
        <Field>
            <FieldName>actionInstant</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>inBackup</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inRemove</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>fileName</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>RAFContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factory</ParamName>
                    <ParamType>BaseDataFileFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDirty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeContainer</MethodName>
            <MethodComment>/** 
 * Remove the container
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leaveStub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readPage</MethodName>
            <MethodComment>/** 
 * Read a page into the supplied array. &lt;BR&gt; MT - thread safe
 * @exception IOException exception reading page
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [pageOffset=pageNumber * pageSize]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePage</MethodName>
            <MethodComment>/** 
 * Write a page from the supplied array. &lt;BR&gt; MT - thread safe
 * @exception StandardException Standard Derby error policy
 * @exception IOException IO error accessing page
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>syncPage</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatePageArray</MethodName>
            <MethodComment>/** 
 * Updates the page array with container header if the page is a first allocation page and encrypts the page data if the database is encrypted.
 * @param pageNumber the page number of the page
 * @param pageData  byte array that has the actual page data.
 * @param encryptionBuf buffer that is used to store encrypted version ofthe page, or  {@code null} if encryption is to be skipped
 * @param encryptWithNewEngine whether to use the new encryption engine forencryption (only considered if  {@code encryptionBuf != null})
 * @return byte array of the the page data as it should be on the disk.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageData</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encryptionBuf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>encryptWithNewEngine</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padFile</MethodName>
            <MethodComment>/** 
 * Pad the file upto the passed in page offset. Returns true if the file needed padding.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [currentEOF=file.length()]</InnerVar>
                <InnerVar>byte [zero[]=new byte[pageSize]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>file;seek;[currentEOF]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clean</MethodName>
            <MethodComment>/** 
 * Clean the container. &lt;p&gt; Write out the container header and sync all dirty pages of this container to disk before returning. &lt;p&gt; checkpoint calls this interface through callbacks by telling the cache manager to clean all containers in the open container cache.  This sync of the file happens as part of writing and then syncing the container header in writeRAFHeader(). &lt;p&gt;
 * @param forRemove Is clean called because container is being removed?
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forRemove</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [waited=false]</InnerVar>
                <InnerVar>boolean [success=false]</InnerVar>
                <InnerVar>int [maxTries=InterruptStatus.MAX_INTERRUPT_RETRIES]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDirty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preAllocate</MethodName>
            <MethodComment>/** 
 * Preallocate some pages if need be
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastPreallocPagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preAllocSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [n=doPreAllocatePages(lastPreallocPagenum,preAllocSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncatePages</MethodName>
            <MethodComment>/** 
 * Truncate pages of a container. &lt;p&gt; Truncate all pages from lastValidPagenum+1 through the end of the file. &lt;p&gt;
 * @param lastValidPagenum  The page number of the last valid page of thefile.  All pages after this one are truncated.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastValidPagenum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeRAFHeader</MethodName>
            <MethodComment>/** 
 * Write the header of a random access file and sync it
 * @param create if true, the container is being createdif false, the container already exist
 * @param syncFile if true, sync the file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageRandomAccessFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>syncFile</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [epage]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeHeader;[identity, file, create, epage]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushAll</MethodName>
            <MethodComment>/** 
 * flush the cache to ensure all of my pages are written to disk
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pageCache;clean;[identity]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clean;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StorageFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errorOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tryAlternatePath</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privGetFileName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StorageFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errorOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tryAlternatePath</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StorageFile [container=dataFactory.getContainerPath(identity,stub)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyFile</MethodName>
            <MethodComment>/** 
 * Copy the contents of a  {@code StorageFile} to a {@code java.io.File}.
 * @param from the file to copy from
 * @param to the file to copy to
 * @throws StandardException if the copying failed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>to</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PrivilegedAction&lt;Boolean&gt; [pa=() -&gt; FileUtil.copyFile(dataFactory.getStorageFactory(),from,to)]</InnerVar>
                <InnerVar>boolean [success=AccessController.doPrivileged(pa)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFile</MethodName>
            <MethodComment>/** 
 * Remove a file.
 * @param file the file to remove
 * @throws StandardException if the file could not be removed
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PrivilegedAction&lt;Boolean&gt; [pa=() -&gt; !file.exists() || file.delete()]</InnerVar>
                <InnerVar>boolean [success=AccessController.doPrivileged(pa)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SecurityException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privRemoveFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeContainer;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;writeInProgress;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenContainer</MethodName>
            <MethodComment>/** 
 * Only used by RAFContainer4 (NIO) to reopen RAF when its channel gets closed due to interrupts.
 * @param currentIdentity
 * @throws StandardException standard exception policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentIdentity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stubbify</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDroppedState;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setCommittedDropState;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>backupContainer</MethodName>
            <MethodComment>/** 
 * Backup the  container. The container is written to the backup by reading  the pages through the page cache, and then writing into the backup container. If the container is dropped(commitetd drop), only container stub is copied to the  backup using simple file copy.  MT -  At any given time only one backup thread is allowed, but when backup in  progress DML/DDL operations can run in parallel. Pages are latched while  writing them to the backup to avoid copying partial changes to the pages. Online backup does not acquire any user level locks , so users can drop tables when backup is in progress. So it is possible that Container  Removal request can come in when container backup is in progress.   This case is handled by using the synchronization on this object monitor  and using inRemove and inBackup flags. Conatiner removal checks if backup is in progress and wait for the backup to yield to continue the removal.  Basic idea is to give preference to remove by stopping the backup of the  container temporarily,  when the remove container is requested by another  thread. Generally, it takes more  time to backup a regular container than  the stub becuase  stub is just one page. After each page copy, a check is made to find  if a remove is requested and if it is then backup of the  container is aborted and the backup thread puts itself into the wait state until remove  request thread notifies that the remove is complete. When  remove request compeletes stub is copied into the backup. Compress is blocked when backup is in progesss, so truncation of the container can not happen when backup is in progess. No need to synchronize backup of the container with truncation. 
 * @param handle the container handle.
 * @param backupLocation location of the backup container. 
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>backupLocation</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [backupCompleted=false]</InnerVar>
                <InnerVar>File [backupFile=null]</InnerVar>
                <InnerVar>RandomAccessFile [backupRaf=null]</InnerVar>
                <InnerVar>boolean [isStub=false]</InnerVar>
                <InnerVar>BasePage [page=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encryptOrDecryptContainer</MethodName>
            <MethodComment>/** 
 * Creates encrypted or decrypted version of the container. Reads all the pages of the container from the original container through the page cache, then either encrypts page data with the new encryption mechanism or leaves the page data un-encrypted, and finally writes the data to the specified new container file. &lt;p&gt; The encryption and decryption engines used to carry out the cryptographic operation(s) are configured through the raw store, and accessed via the data factory. Note that the pages have already been decrypted before being put into the page cache.
 * @param handle the container handle
 * @param newFilePath file to store the new version of the container in
 * @param doEncrypt tells whether to encrypt or not
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newFilePath</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doEncrypt</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [page=null]</InnerVar>
                <InnerVar>StorageFile [newFile=dataFactory.getStorageFactory().newStorageFile(newFilePath)]</InnerVar>
                <InnerVar>StorageRandomAccessFile [newRaf=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRandomAccessFile</MethodName>
            <MethodComment>/** 
 * Get a RandomAccessFile for accessing a file in read-write mode.
 * @param file the file to access
 * @return a RandomAccessFile
 * @throws FileNotFoundException if {@code file} cannot be opened inread-write mode
 * @throws IOException if some other I/O error happens
 */
</MethodComment>
            <ReturnType>RandomAccessFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RandomAccessFile</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [preExisting=file.exists()]</InnerVar>
                <InnerVar>RandomAccessFile [raf=new RandomAccessFile(file,"rw")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRandomAccessFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StorageRandomAccessFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SecurityException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>