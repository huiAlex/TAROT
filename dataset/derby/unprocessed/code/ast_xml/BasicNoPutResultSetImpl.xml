<Class>
    <Id>1250</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>BasicNoPutResultSetImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>NoPutResultSet</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BasicNoPutResultSetImpl  /** 
 * Abstract ResultSet for for operations that return rows but do not allow the caller to put data on output pipes. This basic implementation does not include support for an Activiation. See NoPutResultSetImpl.java for an implementaion with support for an activiation. &lt;p&gt; This abstract class does not define the entire ResultSet interface, but leaves the 'get' half of the interface for subtypes to implement. It is package-visible only, with its methods being public for exposure by its subtypes. &lt;p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>isOpen</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>finished</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>currentRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>isTopResultSet</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>warnings</FieldName>
            <FieldType>SQLWarning</FieldType>
        </Field>
        <Field>
            <FieldName>numOpens</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>rowsSeen</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>rowsFiltered</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>startExecutionTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>endExecutionTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>beginTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>constructorTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>openTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>nextTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>closeTime</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>optimizerEstimatedRowCount</FieldName>
            <FieldType>double</FieldType>
        </Field>
        <Field>
            <FieldName>optimizerEstimatedCost</FieldName>
            <FieldType>double</FieldType>
        </Field>
        <Field>
            <FieldName>statementContext</FieldName>
            <FieldType>StatementContext</FieldType>
        </Field>
        <Field>
            <FieldName>subqueryTrackingArray</FieldName>
            <FieldType>NoPutResultSet[]</FieldType>
        </Field>
        <Field>
            <FieldName>compactRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>activation</FieldName>
            <FieldType>Activation</FieldType>
        </Field>
        <Field>
            <FieldName>statisticsTimingOn</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>resultDescription</FieldName>
            <FieldType>ResultDescription</FieldType>
        </Field>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>baseColumnMap</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BasicNoPutResultSetImpl</MethodName>
            <MethodComment>/** 
 * Constructor. &lt;BR&gt; Sets beginTime for all children to use to measue constructor time.
 * @param resultDescription the result description. May be null.
 * @param activation			The activation
 * @param optimizerEstimatedRowCount	The optimizer's estimate of thetotal number of rows for this result set
 * @param optimizerEstimatedCost		The optimizer's estimated cost forthis result set
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultDescription</ParamName>
                    <ParamType>ResultDescription</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordConstructorTime</MethodName>
            <MethodComment>/** 
 * Allow sub-classes to record the total time spent in their constructor time.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActivation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Activation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isXplainOnlyMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenCore</MethodName>
            <MethodComment>/** 
 * This is the default implementation of reopenCore(). It simply does a close() followed by an open().  If there are optimizations to be made (caching, etc), this is a good place to do it -- this will be overridden by a number of resultSet imlementations.  and SHOULD be overridden by any node that can get between a base table and a join.
 * @see NoPutResultSet#openCore
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;openCore;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowCore</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#getNextRowCore
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPointOfAttachment</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#getPointOfAttachment
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsTopResultSet</MethodName>
            <MethodComment>/** 
 * Mark the ResultSet as the topmost one in the ResultSet tree. Useful for closing down the ResultSet on an error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanIsolationLevel</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#getScanIsolationLevel
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#getEstimatedRowCount 
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>requiresRelocking</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#requiresRelocking
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>open</MethodName>
            <MethodComment>/** 
 * open a scan on the table. scan parameters are evaluated at each open, so there is probably some way of altering their values... NOTE: This method should only be called on the top ResultSet of a ResultSet tree to ensure that the entire ResultSet tree gets closed down on an error.  the openCore() method will be called for all other ResultSets in the tree.
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
                <InnerMethodInvoke>activation;checkStatementValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAbsoluteRow</MethodName>
            <MethodComment>/** 
 * Returns the row at the absolute position from the query,  and returns NULL when there is no such position. (Negative position means from the end of the result set.) Moving the cursor to an invalid position leaves the cursor positioned either before the first row (negative position) or after the last row (positive position). NOTE: An exception will be thrown on 0.
 * @param row	The position.
 * @return	The row at the absolute position, or NULL if no such position.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRelativeRow</MethodName>
            <MethodComment>/** 
 * Returns the row at the relative position from the current cursor position, and returns NULL when there is no such position. (Negative position means toward the beginning of the result set.) Moving the cursor to an invalid position leaves the cursor positioned either before the first row (negative position) or after the last row (positive position). NOTE: 0 is valid. NOTE: An exception is thrown if the cursor is not currently positioned on a row.
 * @param row	The position.
 * @return	The row at the relative position, or NULL if no such position.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeforeFirstRow</MethodName>
            <MethodComment>/** 
 * Sets the current position to before the first row and returns NULL because there is no current row.
 * @return	NULL.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRowPosition</MethodName>
            <MethodComment>/** 
 * Determine if the cursor is before the first row in the result  set.   
 * @return true if before the first row, false otherwise. Returnsfalse when the result set contains no rows.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowNumber</MethodName>
            <MethodComment>/** 
 * Returns the row number of the current row.  Row numbers start from 1 and go to 'n'.  Corresponds to row numbering used to position current row in the result set (as per JDBC).
 * @return	the row number, or 0 if not on a row
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstRow</MethodName>
            <MethodComment>/** 
 * Returns the first row from the query, and returns NULL when there are no rows.
 * @return	The first row, or NULL if no rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRow</MethodName>
            <MethodComment>/** 
 * Return the requested values computed from the next row (if any) for which the restriction evaluates to true. &lt;p&gt; restriction and projection parameters are evaluated for each row. NOTE: This method should only be called on the top ResultSet of a ResultSet tree to ensure that the entire ResultSet tree gets closed down on an error.  the getNextRowCore() method will be called for all other ResultSets in the tree.
 * @exception StandardException thrown on failure.
 * @exception StandardException ResultSetNotOpen thrown if not yet open.
 * @return the next row in the result
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreviousRow</MethodName>
            <MethodComment>/** 
 * Returns the previous row from the query, and returns NULL when there are no more previous rows.
 * @return	The previous row, or NULL if no more previous rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastRow</MethodName>
            <MethodComment>/** 
 * Returns the last row from the query, and returns NULL when there are no rows.
 * @return	The last row, or NULL if no rows.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;attachStatementContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAfterLastRow</MethodName>
            <MethodComment>/** 
 * Sets the current position to after the last row and returns NULL because there is no current row.
 * @return	NULL.
 * @exception StandardException		Thrown on failure
 * @see Row
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnsRows</MethodName>
            <MethodComment>/** 
 * Returns true.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifiedRowCount</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUp</MethodName>
            <MethodComment>/** 
 * Clean up on error
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosed</MethodName>
            <MethodComment>/** 
 * Report if closed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;finishAndRTS;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishAndRTS</MethodName>
            <MethodComment>/** 
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultDescription</MethodName>
            <MethodComment>/** 
 * Returns the description of the table's rows
 */
</MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecuteTime</MethodName>
            <MethodComment>/** 
 * Get the execution time in milliseconds.
 * @return long		The execution time in milliseconds.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBeginExecutionTimestamp</MethodName>
            <MethodComment>/** 
 * Get the Timestamp for the beginning of execution.
 * @return Timestamp		The Timestamp for the beginning of execution.
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEndExecutionTimestamp</MethodName>
            <MethodComment>/** 
 * Get the Timestamp for the end of execution.
 * @return Timestamp		The Timestamp for the end of execution.
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubqueryTrackingArray</MethodName>
            <MethodComment>/** 
 * @see ResultSet#getSubqueryTrackingArray
 */
</MethodComment>
            <ReturnType>NoPutResultSet[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numSubqueries</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentTimeMillis</MethodName>
            <MethodComment>/** 
 * Return the current time in milliseconds, if DEBUG and RunTimeStats is on, else return 0.  (Only pay price of system call if need to.)
 * @return long		Current time in milliseconds.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoGeneratedKeysResultset</MethodName>
            <MethodComment>/** 
 * @see ResultSet#getAutoGeneratedKeysResultset
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getElapsedMillis</MethodName>
            <MethodComment>/** 
 * Return the elapsed time in milliseconds, between now and the beginTime, if DEBUG and RunTimeStats is on, else return 0.   (Only pay price of system call if need to.)
 * @return long		Elapsed time in milliseconds.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beginTime</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dumpTimeStats</MethodName>
            <MethodComment>/** 
 * Dump out the time information for run time stats.
 * @return Nothing.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indent</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subIndent</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>attachStatementContext</MethodName>
            <MethodComment>/** 
 * Attach this result set to the top statement context on the stack. Result sets can be directly read from the JDBC layer. The JDBC layer will push and pop a statement context around each ResultSet.getNext(). There's no guarantee that the statement context used for the last getNext() will be the context used for the current getNext(). The last statement context may have been popped off the stack and so will not be available for cleanup if an error occurs. To make sure that we will be cleaned up, we always attach ourselves to the top	 context. The fun and games occur in nested contexts: using JDBC result sets inside user code that is itself invoked from queries or CALL statements.
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageConnectionContext</MethodName>
            <MethodComment>/** 
 * Cache the language connection context. Return it.
 * @return	the language connection context
 */
</MethodComment>
            <ReturnType>LanguageConnectionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resultSetNumber</MethodName>
            <MethodComment>/** 
 * @see NoPutResultSet#resultSetNumber() 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecutionFactory</MethodName>
            <MethodComment>/** 
 * Get a execution factory
 * @return the execution factory
 */
</MethodComment>
            <ReturnType>ExecutionFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionController</MethodName>
            <MethodComment>/** 
 * Get the current transaction controller.
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompactRow</MethodName>
            <MethodComment>/** 
 * Get a compacted version of the candidate row according to the columns specified in the bit map. Share the holders between rows. If there is no bit map, use the candidate row as the compact row. Also, create an array of ints mapping base column positions to compact column positions, to make it cheaper to copy columns to the compact row, if we ever have to do it again.
 * @param candidate		The row to get the columns from
 * @param accessedCols	A bit map of the columns that are accessed inthe candidate row
 * @param isKeyed		Tells whether to return a ValueRow or an IndexRow
 * @return		A compact row.
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>candidate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accessedCols</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isKeyed</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numCandidateCols=candidate.nColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCompactRow</MethodName>
            <MethodComment>/** 
 * Copy columns from the candidate row from the store to the given compact row. If there is no column map, just use the candidate row. This method assumes the above method (getCompactRow()) was called first. getCompactRow() sets up the baseColumnMap.
 * @param candidateRow	The candidate row from the store
 * @param compactRow	The compact row to fill in
 * @return	The compact row to use
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>candidateRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compactRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [retval]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCompatRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compactRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [destRow=compactRow.getRowArray()]</InnerVar>
                <InnerVar>int[] [lbcm=baseColumnMap]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isForUpdate</MethodName>
            <MethodComment>/** 
 * Is this ResultSet or it's source result set for update This method will be overriden in the inherited Classes if it is true
 * @return Whether or not the result set is for update.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkCancellationFlag</MethodName>
            <MethodComment>/** 
 * Checks whether the currently executing statement has been cancelled. This is done by checking the statement's allocated StatementContext object.
 * @see StatementContext
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>StatementContext [localStatementContext=lcc.getStatementContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>InterruptStatus;throwIf;[lcc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWarning</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>w</ParamName>
                    <ParamType>SQLWarning</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWarnings</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SQLWarning</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>SQLWarning [w=warnings]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toXML</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Element</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentNode</ParamName>
                    <ParamType>Element</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tag</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toXML</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Pretty-print a ResultSet as an xml child of a parent node. Return the node representing the ResultSet child. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Element</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentNode</ParamName>
                    <ParamType>Element</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>childTag</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Element [result=parentNode.getOwnerDocument().createElement(childTag)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;setAttribute;["type", stripPackage(rs.getClass().getName())]</InnerMethodInvoke>
                <InnerMethodInvoke>parentNode;appendChild;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stripPackage</MethodName>
            <MethodComment>/** 
 * Strip the package location from a class name 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>childrenToXML</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Pretty-print the inner ResultSet fields inside an outer ResultSet. Returns the outerNode. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Element</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerNode</ParamName>
                    <ParamType>Element</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerRS</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;Field&gt; [fieldList=new ArrayList&lt;Field&gt;()]</InnerVar>
                <InnerVar>Field[] [fields=new Field[fieldList.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findResultSetFields;[fieldList, outerRS.getClass()]</InnerMethodInvoke>
                <InnerMethodInvoke>fieldList;toArray;[fields]</InnerMethodInvoke>
                <InnerMethodInvoke>Arrays;sort;[fields, new FieldComparator()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findResultSetFields</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Find all fields of type ResultSet. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldList</ParamName>
                    <ParamType>Field</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>klass</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Field[] [fields=AccessController.doPrivileged(new PrivilegedAction&lt;Field[]&gt;(){
  public Field[] run(){
    return klass.getDeclaredFields();
  }
}
)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;findResultSetFields;[fieldList, klass.getSuperclass()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Field[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>Field</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>Field</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>