<Class>
    <Id>2146</Id>
    <Package>org.apache.derby.impl.store.raw.log</Package>
    <ClassName>FlushedScan</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>StreamLogScan</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FlushedScan  /** 
 * Scan the the log which is implemented by a series of log files.n This log scan knows how to move across log file if it is positioned at the boundary of a log file and needs to getNextRecord. &lt;PRE&gt; 4 bytes - length of user data, i.e. N 8 bytes - long representing log instant N bytes of supplied data 4 bytes - length of user data, i.e. N &lt;/PRE&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>scan</FieldName>
            <FieldType>StorageRandomAccessFile</FieldType>
        </Field>
        <Field>
            <FieldName>logFactory</FieldName>
            <FieldType>LogToFile</FieldType>
        </Field>
        <Field>
            <FieldName>open</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>currentLogFileNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>currentLogFileFirstUnflushedPosition</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>currentInstant</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>firstUnflushed</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>firstUnflushedFileNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>firstUnflushedFilePosition</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_REC_LEN_BYTE_LENGTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextRecordLength</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>readNextRecordLength</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FlushedScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logFactory</ParamName>
                    <ParamType>LogToFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startAt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRecord</MethodName>
            <MethodComment>/** 
 * Read a log record into the byte array provided.  Resize the input stream byte array if necessary.
 * @return the length of the data written into data, or -1 if the end of thescan has been reached.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>LogRecord</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>ArrayInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tranId</ParamName>
                    <ParamType>TransactionId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>groupmask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetPosition</MethodName>
            <MethodComment>/** 
 * Reset the scan to the given LogInstant.
 * @param instant the position to reset to
 * @exception IOException scan cannot access the log at the new position.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogRecordEnd</MethodName>
            <MethodComment>/** 
 * Get the log instant that is right after the record just retrived
 * @return INVALID_LOG_INSTANT if this is not a FORWARD scan or, norecord have been returned yet or the scan has completed.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLogEndFuzzy</MethodName>
            <MethodComment>/** 
 * returns true if there is partially writen log records before the crash  in the last log file. Partiall wrires are identified during forward  scans for log recovery.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstant</MethodName>
            <MethodComment>/** 
 * Return the log instant (as an integer) the scan is currently on - this is the log instant of the log record that was returned by getNextRecord.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogInstant</MethodName>
            <MethodComment>/** 
 * Return the log instant the scan is currently on - this is the log instant of the log record that was returned by getNextRecord.
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the scan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFirstUnflushed</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogInstant [firstUnflushedInstant=logFactory.getFirstUnflushedInstant()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCurrentLogFileFirstUnflushedPosition;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentLogFileFirstUnflushedPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>switchLogFile</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>currentLogFileHasUnflushedRecord</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long [curPos=scan.getFilePointer()]</InnerVar>
                <InnerVar>int [bytesNeeded=nextRecordLength + LOG_REC_LEN_BYTE_LENGTH]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionToNextRecord</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setFirstUnflushed;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>