<Class>
    <Id>1486</Id>
    <Package>org.apache.derby.iapi.store.access</Package>
    <ClassName>BackingStoreHashtable</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BackingStoreHashtable  /** 
 * &lt;p&gt; A BackingStoreHashtable is a utility class which will store a set of rows into an in memory hash table, or overflow the hash table to a tempory on disk  structure. &lt;/p&gt; &lt;p&gt; All rows must contain the same number of columns, and the column at position N of all the rows must have the same format id.  If the BackingStoreHashtable needs to be overflowed to disk, then an arbitrary row will be chosen and used as a template for creating the underlying overflow container. &lt;/p&gt; &lt;p&gt; The hash table will be built logically as follows (actual implementation may differ).  The important points are that the hash value is the standard java hash value on the row[key_column_numbers[0], if key_column_numbers.length is 1, or row[key_column_numbers[0, 1, ...]] if key_column_numbers.length &amp;gt; 1,  and that duplicate detection is done by the standard java duplicate detection provided by  java.util.Hashtable. &lt;/p&gt; &lt;pre&gt; import java.util.Hashtable; hash_table = new Hashtable(); Object row; // is a DataValueDescriptor[] or a LocatedRow boolean  needsToClone = rowSource.needsToClone(); while((row = rowSource.getNextRowFromRowSource()) != null) { if (needsToClone) row = clone_row_from_row(row); Object key = KeyHasher.buildHashKey(row, key_column_numbers); if ((duplicate_value =  hash_table.put(key, row)) != null) { Vector row_vec; // inserted a duplicate if ((duplicate_value instanceof vector)) { row_vec = (Vector) duplicate_value; } else { // allocate vector to hold duplicates row_vec = new Vector(2); // insert original row into vector row_vec.addElement(duplicate_value); // put the vector as the data rather than the row hash_table.put(key, row_vec); } // insert new row into vector row_vec.addElement(row); } } &lt;/pre&gt; &lt;p&gt; What actually goes into the hash table is a little complicated. That is because the row may either be an array of column values (i.e. DataValueDescriptor[]) or a LocatedRow (i.e., a structure holding the columns plus a RowLocation). In addition, the hash value itself may either be one of these rows or (in the case of multiple rows which hash to the same value) a bucket (List) of rows. To sum this up, the values in a hash table which does not spill to disk may be the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;DataValueDescriptor[] and ArrayList&lt;DataValueDescriptor&gt;&lt;/li&gt; &lt;li&gt;or LocatedRow and ArrayList&lt;LocatedRow&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; If rows spill to disk, then they just become arrays of columns. In this case, a LocatedRow becomes a DataValueDescriptor[], where the last cell contains the RowLocation. &lt;/p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>hash_table</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>hash_table</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>key_column_numbers</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>remove_duplicates</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>skipNullKeyColumns</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>auxillary_runtimestats</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>row_source</FieldName>
            <FieldType>RowSource</FieldType>
        </Field>
        <Field>
            <FieldName>max_inmemory_rowcnt</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>inmemory_rowcnt</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>max_inmemory_size</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>keepAfterCommit</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>ARRAY_LIST_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>diskHashtable</FieldName>
            <FieldType>DiskHashtable</FieldType>
        </Field>
        <Field>
            <FieldName>memoryIterator</FieldName>
            <FieldType>Iterator</FieldType>
        </Field>
        <Field>
            <FieldName>memoryIterator</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>diskEnumeration</FieldName>
            <FieldType>Enumeration</FieldType>
        </Field>
        <Field>
            <FieldName>diskEnumeration</FieldName>
            <FieldType>Object</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BackingStoreHashtable</MethodName>
            <MethodComment>/** 
 * Constructors for This class:
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BackingStoreHashtable</MethodName>
            <MethodComment>/** 
 * Create the BackingStoreHashtable from a row source. &lt;p&gt; This routine drains the RowSource.  The performance characteristics depends on the number of rows inserted and the parameters to the  constructor. RowLocations are supported iff row_source is null. RowLocations in a non-null row_source can be added later if there is a use-case that stresses this behavior. &lt;p&gt; If the number of rows is &amp;lt;= "max_inmemory_rowcnt", then the rows are inserted into a java.util.HashMap. In this case no TransactionController is necessary, a "null" tc is valid. &lt;p&gt; If the number of rows is &amp;gt; "max_inmemory_rowcnt", then the rows will be all placed in some sort of Access temporary file on disk.  This  case requires a valid TransactionController.
 * @param tc                An open TransactionController to be used if thehash table needs to overflow to disk.
 * @param row_source        RowSource to read rows from.
 * @param key_column_numbers The column numbers of the columns in thescan result row to be the key to the HashMap. "0" is the first column in the scan result row (which may be different than the first row in the table of the scan).
 * @param remove_duplicates Should the HashMap automatically removeduplicates, or should it create the list of duplicates?
 * @param estimated_rowcnt  The estimated number of rows in the hash table.Pass in -1 if there is no estimate.
 * @param max_inmemory_rowcnt The maximum number of rows to insert into the  inmemory Hash table before overflowing to disk. Pass in -1 if there is no maximum.
 * @param initialCapacity   If not "-1" used to initialize the java HashMap
 * @param loadFactor        If not "-1" used to initialize the java HashMap
 * @param skipNullKeyColumns	Skip rows with a null key column, if true.
 * @param keepAfterCommit If true the hash table is kept after a commit,if false the hash table is dropped on the next commit.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row_source</ParamName>
                    <ParamType>RowSource</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key_column_numbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remove_duplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>estimated_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_inmemory_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadFactor</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>skipNullKeyColumns</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keepAfterCommit</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>includeRowLocations</MethodName>
            <MethodComment>/** 
 * Return true if we should include RowLocations with the rows stored in this hash table.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowFromRowSource</MethodName>
            <MethodComment>/** 
 * Call method to either get next row or next row with non-null key columns. Currently, RowLocation information is not included in rows siphoned out of a RowSource. That functionality is only supported if the rows come from the scan of a base table.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [row=row_source.getNextRowFromRowSource()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneRow</MethodName>
            <MethodComment>/** 
 * Return a cloned copy of the row.
 * @return The cloned row row to use.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>old_row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [new_row=new DataValueDescriptor[old_row.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shallowCloneRow</MethodName>
            <MethodComment>/** 
 * Return a shallow cloned row
 * @return The cloned row row to use.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>old_row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [new_row=new DataValueDescriptor[old_row.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>add_row_to_hash_table</MethodName>
            <MethodComment>/** 
 * Do the work to add one row to the hash table. &lt;p&gt;
 * @param columnValues               Row to add to the hash table.
 * @param rowLocation   Location of row in conglomerate; could be null.
 * @param needsToClone      If the row needs to be cloned
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnValues</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needsToClone</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [key=KeyHasher.buildHashKey(columnValues,key_column_numbers)]</InnerVar>
                <InnerVar>Object [hashValue=!includeRowLocations() ? columnValues : new LocatedRow(columnValues,rowLocation)]</InnerVar>
                <InnerVar>Object [duplicate_value=hash_table.put(key,hashValue)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doSpaceAccounting</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>firstDuplicate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spillToDisk</MethodName>
            <MethodComment>/** 
 * Determine whether a new row should be spilled to disk and, if so, do it.
 * @param columnValues  Actual columns from source row.
 * @param rowLocation       Optional row location.
 * @return true if the row was spilled to disk, false if not
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnValues</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [diskRow=null]</InnerVar>
                <InnerVar>Object [key=KeyHasher.buildHashKey(columnValues,key_column_numbers)]</InnerVar>
                <InnerVar>Object [duplicateValue=hash_table.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>diskHashtable;put;[key, diskRow]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeDiskRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Make a full set of columns from an object which is either already an array of column or otherwise a LocatedRow. The full set of columns is what's stored on disk when we spill to disk. This is the inverse of makeInMemoryRow(). &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>raw</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor[] [allColumns=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeInMemoryRows</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Turn a list of disk rows into a list of in-memory rows. The on disk rows are always of type DataValueDescriptor[]. But the in-memory rows could be of type LocatedRow. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>List</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>diskRows</ParamName>
                    <ParamType>List</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeInMemoryRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Make an in-memory row from an on-disk row. This is the inverse of makeDiskRow(). &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>diskRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeDiskRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Construct a full set of columns, which may need to end with the row location.The full set of columns is what's stored on disk when we spill to disk. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnValues</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedMemUsage</MethodName>
            <MethodComment>/** 
 * Take a value which will go into the hash table and return an estimate of how much memory that value will consume. The hash value could be either an array of columns or a LocatedRow.
 * @param hashValue The object for which we want to know the memory usage.
 * @return A guess as to how much memory the current hash value willuse.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>hashValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [rowMem=0]</InnerVar>
                <InnerVar>DataValueDescriptor[] [row=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the BackingStoreHashtable. &lt;p&gt; Perform any necessary cleanup after finishing with the hashtable.  Will deallocate/dereference objects as necessary.  If the table has gone to disk this will drop any on disk files used to support the hash table. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>elements</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Return an Enumeration that can be used to scan the entire table. The objects in the Enumeration can be either of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;a row - This is a single row with a unique hash key.&lt;/li&gt; &lt;li&gt;or a bucket of rows - This is a list of rows which all have the same hash key.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; The situation is a little more complicated because the row representation is different depending on whether the row includes a RowLocation. If includeRowLocations()== true, then the row is a LocatedRow. Otherwise, the row is an array of DataValueDescriptor. Putting all of this together, if the row contains a RowLocation, then the objects in the Enumeration returned by this method can be either of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;a LocatedRow&lt;/li&gt; &lt;li&gt;or a List&amp;lt;LocatedRow&amp;gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; But if the row does not contain a RowLocation, then the objects in the Enumeration returned by this method can be either of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;a DataValueDescriptor[]&lt;/li&gt; &lt;li&gt;or a List&amp;lt;DataValueDescriptor[]&amp;gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; RESOLVE - is it worth it to support this routine when we have a disk overflow hash table? &lt;/p&gt;
 * @return The Enumeration.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get data associated with given key. &lt;/p&gt; &lt;p&gt; There are 2 different types of objects returned from this routine. &lt;/p&gt; &lt;p&gt; In both cases, the key value is either the object stored in  row[key_column_numbers[0]], if key_column_numbers.length is 1,  otherwise it is a KeyHasher containing the objects stored in row[key_column_numbers[0, 1, ...]]. For every qualifying unique row value an entry is placed into the  hash table. &lt;/p&gt; &lt;p&gt; For row values with duplicates, the value of the data is a list of rows. &lt;/p&gt; &lt;p&gt; The situation is a little more complicated because the row representation is different depending on whether the row includes a RowLocation. If includeRowLocations() == true, then the row is a LocatedRow. Otherwise, the row is an array of DataValueDescriptor. Putting all of this together, if the row contains a RowLocation, then the objects returned by this method can be either of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;a LocatedRow&lt;/li&gt; &lt;li&gt;or a List&amp;lt;LocatedRow&amp;gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; But if the row does not contain a RowLocation, then the objects returned by this method can be either of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;a DataValueDescriptor[]&lt;/li&gt; &lt;li&gt;or a List&amp;lt;DataValueDescriptor[]&amp;gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; The caller will have to call "instanceof" on the data value object if duplicates are expected, to determine if the data value of the hash table entry is a row or is a list of rows. &lt;/p&gt; &lt;p&gt; See the javadoc for elements() for more information on the objects returned by this method. &lt;/p&gt; &lt;p&gt; The BackingStoreHashtable "owns" the objects returned from the get() routine.  They remain valid until the next access to the  BackingStoreHashtable.  If the client needs to keep references to these objects, it should clone copies of the objects.  A valid  BackingStoreHashtable can place all rows into a disk based conglomerate, declare a row buffer and then reuse that row buffer for every get() call. &lt;/p&gt;
 * @return The value to which the key is mapped in this hashtable; null if the key is not mapped to any value in this hashtable.
 * @param key    The key to hash on.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [obj=hash_table.get(key)]</InnerVar>
                <InnerVar>Object [diskHashtableValue=diskHashtable.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllRuntimeStats</MethodName>
            <MethodComment>/** 
 * Return runtime stats to caller by adding them to prop. &lt;p&gt;
 * @param prop   The set of properties to append to.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prop</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remove</MethodName>
            <MethodComment>/** 
 * remove a row from the hash table. &lt;p&gt; a remove of a duplicate removes the entire duplicate list.
 * @param key          The key of the row to remove.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [obj=hash_table.remove(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAuxillaryRuntimeStats</MethodName>
            <MethodComment>/** 
 * Set the auxillary runtime stats. &lt;p&gt; getRuntimeStats() will return both the auxillary stats and any BackingStoreHashtable() specific stats.  Note that each call to setAuxillaryRuntimeStats() overwrites the Property set that was set previously.
 * @param prop   The set of properties to append from.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prop</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putRow</MethodName>
            <MethodComment>/** 
 * Put a row into the hash table. &lt;p&gt; The in memory hash table will need to keep a reference to the row after the put call has returned.  If "needsToClone" is true then the hash table will make a copy of the row and put that, else if  "needsToClone" is false then the hash table will keep a reference to the row passed in and no copy will be made. &lt;p&gt; If routine returns false, then no reference is kept to the duplicate row which was rejected (thus allowing caller to reuse the object).
 * @param needsToClone does this routine have to make a copy of the row,in order to keep a reference to it after return?
 * @param row          The row to insert into the table.
 * @param rowLocation  Location of row in conglomerate; could be null.
 * @return true if row was inserted into the hash table.  Returnsfalse if the BackingStoreHashtable is eliminating  duplicates, and the row being inserted is a duplicate, or if we are skipping rows with 1 or more null key columns and we find a null key column.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>needsToClone</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [key=KeyHasher.buildHashKey(row,key_column_numbers)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Return number of unique rows in the hash table. &lt;p&gt;
 * @return The number of unique rows in the hash table.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BackingStoreHashtableEnumeration</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasMoreElements</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextElement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RowList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>