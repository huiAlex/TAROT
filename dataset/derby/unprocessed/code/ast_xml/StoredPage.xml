<Class>
    <Id>134</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>StoredPage</ClassName>
    <SuperClass>CachedPage</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StoredPage  /** 
 * StoredPage is a sub class of CachedPage that stores page data in a fixed size byte array and is designed to be written out to a file through a DataInput/DataOutput interface. A StoredPage can exist in its clean or dirty state without the FileContainer it was created from being in memory. &lt;P&gt;&lt;B&gt;Page Format&lt;/B&gt;&lt;BR&gt; The page is broken into five sections &lt;PRE&gt; +----------+-------------+-------------------+-------------------+----------+ | formatId | page header | records           | slot offset table | checksum | +----------+-------------+-------------------+-------------------+----------+ &lt;/PRE&gt; &lt;BR&gt;&lt;B&gt;FormatId&lt;/B&gt;&lt;BR&gt; The formatId is a 4 bytes array, it contains the format Id of this page. &lt;BR&gt;&lt;B&gt;Page Header&lt;/B&gt;&lt;BR&gt; The page header is a fixed size, 56 bytes  &lt;PRE&gt; 1 byte  boolean           is page an overflow page 1 byte  byte              page status (a field maintained in base page) 8 bytes long              pageVersion (a field maintained in base page) 2 bytes unsigned short    number of slots in slot offset table 4 bytes integer           next record identifier 4 bytes integer           generation number of this page (Future Use) 4 bytes integer           previous generation of this page (Future Use) 8 bytes bipLocation       the location of the beforeimage page (Future Use) 2 bytes unsigned short    number of deleted rows on page. (new release 2.0) 2 bytes unsigned short    % of the page to keep free for updates 2 bytes short             spare for future use 4 bytes long              spare for future use (encryption uses to write  random bytes here). 8 bytes long              spare for future use 8 bytes long              spare for future use &lt;/PRE&gt; Note that spare space has been guaranteed to be writen with "0", so that future use of field should not either not use "0" as a valid data  item or pick 0 as a valid default value so that on the fly upgrade can  assume that 0 means field was never assigned. &lt;BR&gt;&lt;B&gt;Records&lt;/B&gt; The records section contains zero or more records, the format of each record follows. minimumRecordSize is the minimum user record size, excluding the space we use for the record header and field headers.  When a record is inserted, it is stored in a space at least as large as the sum of the minimumRecordSize and total header size. For example, If minimumRecordSize is 10 bytes, the user record is 7 bytes, we used 5 bytes for record and field headers, this record will take (10 + 5) bytes of space, extra 3 bytes is  put into reserve. If minimumRecordSize is 10 bytes, user record is 17 bytes, we used 5 bytes for record and field headers, this record will take (17 + 5) bytes of space, no reserve space  here. minimumRecordSize is defined by user on per container basis. The default for minimumRecordSize is set to 1. This implementation always keeps occupied bytes at the low end of the record  section.  Thus removing (purging) a record moves all other records down, and their slots are also moved down. A page has no empty slot (an empty page has no slot) &lt;BR&gt;&lt;B&gt;Record and Field Format&lt;/B&gt; Record Header format is defined in the StoredRecordHeader class. &lt;PRE&gt;    &lt;BR&gt;&lt;B&gt;Fields&lt;/B&gt; 1 byte    Boolean - is null, if true no more data follows. 4 bytes   Integer - length of field that follows (excludes these four bytes). StoredPage will use the static method provided by StoredFieldHeader to read/write field status and field data length. Field Header format is defined in the StoredFieldHeader class. &lt;data&gt; &lt;/PRE&gt; &lt;BR&gt;&lt;B&gt;Slot Offset Table&lt;/B&gt;&lt;BR&gt; The slot offset table is a table of 6 or 12 bytes per record, depending on the pageSize being less or greater than 64K: 2 bytes (unsigned short) or 4 bytes (int) page offset for the record that is assigned to the slot, and 2 bytes (unsigned short) or 4 bytes (int)  for the length of the record on this page. 2 bytes (unsigned short) or 4 bytes (int) for the length of the reserved  number of bytes for this record on this page. First slot is slot 0.  The slot table grows backwards. Slots are never left empty. &lt;BR&gt;&lt;B&gt;Checksum&lt;/B&gt;&lt;BR&gt; 8 bytes of a java.util.zip.CRC32 checksum of the entire's page contents  without the 8 bytes representing the checksum. &lt;P&gt;&lt;B&gt;Page Access&lt;/B&gt; The page data is accessed in this class by one of three methods. &lt;OL&gt; &lt;LI&gt;As a byte array using pageData (field in cachedPage). This is the  fastest. &lt;LI&gt;As an ArrayInputStream (rawDataIn) and ArrayOutputStream (rawDataOut), this is used to set limits on any one reading the page logically. &lt;LI&gt;Logically through rawDataIn (ArrayInputStream) and  logicalDataOut (FormatIdOutputStream), this provides the methods to write logical data (e.g. booleans and integers etc.) and the ObjectInput and ObjectOutput interfaces for DataValueDescriptor's. These logical streams are constructed using the array streams. &lt;/OL&gt;
 * @see java.util.zip.CRC32
 * @see ArrayInputStream
 * @see ArrayOutputStream
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>FORMAT_NUMBER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PAGE_HEADER_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PAGE_HEADER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RECORD_SPACE_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PAGE_VERSION_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALL_SLOT_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LARGE_SLOT_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHECKSUM_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>OVERFLOW_POINTER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>OVERFLOW_PTR_FIELD_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>bh</FieldName>
            <FieldType>ByteHolder</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMN_NONE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMN_FIRST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMN_LONG</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMN_CREATE_NULL</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>maxFieldSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isOverflowPage</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>slotsInUse</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>generation</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>prevGeneration</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>bipLocation</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>deletedRowCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>headerOutOfDate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>checksum</FieldName>
            <FieldType>CRC32</FieldType>
        </Field>
        <Field>
            <FieldName>minimumRecordSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>userRowSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>slotFieldSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>slotEntrySize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>slotTableOffsetToFirstEntry</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>slotTableOffsetToFirstRecordLengthField</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>slotTableOffsetToFirstReservedSpaceField</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>totalSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>freeSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>firstFreeByte</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>spareSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>overflowRecordHeader</FieldName>
            <FieldType>StoredRecordHeader</FieldType>
        </Field>
        <Field>
            <FieldName>rawDataIn</FieldName>
            <FieldType>ArrayInputStream</FieldType>
        </Field>
        <Field>
            <FieldName>rawDataOut</FieldName>
            <FieldType>ArrayOutputStream</FieldType>
        </Field>
        <Field>
            <FieldName>logicalDataOut</FieldName>
            <FieldType>FormatIdOutputStream</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Return my format identifier.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>StoredPage</MethodName>
            <MethodComment>/** 
 * Simple no-arg constructor for StoredPage.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverFlowRecordHeader</MethodName>
            <MethodComment>/** 
 * get scratch space for over flow record header. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * Initialize the StoredPage. &lt;p&gt; Initialize the object, ie. perform work normally perfomed in constructor. Called by setIdentity() and createIdentity() - the Cacheable interfaces which are used to move a page in/out of cache.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createOutStreams</MethodName>
            <MethodComment>/** 
 * Create the output streams. &lt;p&gt; Create the output streams, these are created on demand to avoid creating unrequired objects for pages that are never modified during their lifetime in the cache. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setData;[pageData]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOutputStream</MethodName>
            <MethodComment>/** 
 * Tie the logical output stream to a passed in OutputStream. &lt;p&gt; Tie the logical output stream to a passed in OutputStream with no limit as to the number of bytes that can be written.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logicalDataOut;setOutput;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetOutputStream</MethodName>
            <MethodComment>/** 
 * Reset the logical output stream. &lt;p&gt; Reset the logical output stream (logicalDataOut) to be attached to the page array stream as is the norm, no limits are placed  on any writes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logicalDataOut;setOutput;[rawDataOut]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usePageBuffer</MethodName>
            <MethodComment>/** 
 * use this passed in page buffer as this object's page data. &lt;p&gt; The page content may not have been read in from disk yet. For pagesize smaller than 64K: Size of the record offset stored in a slot (unsigned short) Size of the record portion length stored in a slot (unsigned short) Size of the record portion length stored in a slot (unsigned short) For pagesize greater than 64K, but less than 2gig: Size of the record offset stored in a slot (int) Size of the record portion length stored in a slot (int) Size of the record portion length stored in a slot (int) &lt;p&gt;
 * @param pageBuffer    The array of bytes to use as the page buffer.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageBuffer</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [pageSize=pageData.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initSpace;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>calculateSlotFieldSize</MethodName>
            <MethodComment>/** 
 * Calculate the slot field size from the page size.
 * @param pageSize page size in bytes
 * @return slot field size in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPage</MethodName>
            <MethodComment>/** 
 * Create a new StoredPage. &lt;p&gt; Make this object represent a new page (ie. a page that never existed before, as opposed to reading in an existing page from disk). &lt;p&gt;
 * @param newIdentity   The key describing page (segment,container,page).
 * @param args          information stored about the page, once in the container header and passed in through the object.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>PageCreationArgs</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setPageArray;[args.pageSize]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanPage;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setPageVersion;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createOutStreams;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initFromData</MethodName>
            <MethodComment>/** 
 * Initialize the page from values in the page buffer. &lt;p&gt; Initialize in memory structure using the buffer in pageData.  This is how a StoredPage object is intialized to represent page read in from disk. &lt;p&gt;
 * @param myContainer   The container to read the page in from.
 * @param newIdentity   The key representing page being read in (segment,container, page number)
 * @exception StandardException If the page cannot be read correctly, or is inconsistent.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myContainer</ParamName>
                    <ParamType>FileContainer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateChecksum</MethodName>
            <MethodComment>/** 
 * Validate the check sum on the page. &lt;p&gt; Compare the check sum stored in the page on disk with the checksum calculated from the bytes on the page. &lt;p&gt;
 * @param id     The key that describes the page.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [onDiskChecksum]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>checksum;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;update;[pageData, 0, getPageSize() - CHECKSUM_SIZE]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateChecksum</MethodName>
            <MethodComment>/** 
 * Recalculate checksum and write it to the page array. &lt;p&gt; Recalculate the checksum of the page, and write the result back into the last bytes of the page.
 * @exception IOException  if writing to end of array fails.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>checksum;reset;[]</InnerMethodInvoke>
                <InnerMethodInvoke>checksum;update;[pageData, 0, getPageSize() - CHECKSUM_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[getPageSize() - CHECKSUM_SIZE]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[checksum.getValue()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePage</MethodName>
            <MethodComment>/** 
 * Write information about page from variables into page byte array. &lt;p&gt; This routine insures that all information about the page is reflected in the page byte buffer.  This involves moving information from local variables into encoded version on the page in page header and checksum. &lt;p&gt;
 * @param identity  The key of this page.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFormatId</MethodName>
            <MethodComment>/** 
 * Write out the format id of this page
 * @param identity  The key of this page.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseExclusive</MethodName>
            <MethodComment>/** 
 * Ensure that the page is released from the cache when it is unlatched.
 * @see org.apache.derby.impl.store.raw.data.BasePage#releaseExclusive
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pageCache;release;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTotalSpace</MethodName>
            <MethodComment>/** 
 * Return the total number of bytes used, reserved, or wasted by the record at this slot. &lt;p&gt; The amount of space the record on this slot is currently taking on the  page. If there is any reserve space or wasted space, count that in also Do NOT count the slot entry size &lt;p&gt;
 * @return The number of bytes used by the row at slot "slot".
 * @param slot  look at row at this slot.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForInsert</MethodName>
            <MethodComment>/** 
 * Is there minimal space for insert? &lt;p&gt; Does quick calculation to see if average size row on this page could be inserted on the page.  This is done because the actual row size being inserted isn't known until we actually copy the columns from their object form into their on disk form which is expensive.  So we use this calculation so that in the normal case we only do one  copy of the row directly onto the page. &lt;p&gt;
 * @return true if we think the page will allow an insert, false otherwise.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [usedSpace=totalSpace - freeSpace]</InnerVar>
                <InnerVar>int [bytesPerRow=usedSpace / slotsInUse]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForInsert</MethodName>
            <MethodComment>/** 
 * Is row guaranteed to be inserted successfully on this page? &lt;p&gt; Return true if this record is guaranteed to be inserted successfully  using insert() or insertAtSlot(). This guarantee is only valid while the row remains unchanged and the page latch is held. &lt;p&gt;
 * @return bolean indicating if row can be inserted on this page.
 * @param row                   The row to check for insert.
 * @param validColumns          bit map to interpret valid columns in row.
 * @param overflowThreshold     The percentage of the page to use for theinsert.  100 means use 100% of the page, 50 means use 50% of page (ie. make sure 2 rows fit per page).
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DynamicByteArrayOutputStream [out=new DynamicByteArrayOutputStream()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForInsert</MethodName>
            <MethodComment>/** 
 * Is row guaranteed to be inserted successfully on this page? &lt;p&gt; Return true if this record is guaranteed to be inserted successfully  using insert() or insertAtSlot(). This guarantee is only valid while the row remains unchanged and the page latch is held. &lt;p&gt; This is a private call only used when calculating whether an overflow page can be used to insert part of an overflow row/column.
 * @return bolean indicating if row can be inserted on this page.
 * @param row                   The row to check for insert.
 * @param validColumns          bit map to interpret valid columns in row.
 * @param overflowThreshold     The percentage of the page to use for theinsert.  100 means use 100% of the page, 50 means use 50% of page (ie. make sure 2 rows fit per page).
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceNeeded</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DynamicByteArrayOutputStream [out=new DynamicByteArrayOutputStream()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unfilled</MethodName>
            <MethodComment>/** 
 * Is this page unfilled? &lt;p&gt; Returns true if page is relatively unfilled,  which means the page is &amp;lt; 1/2 full and has enough space to insert an "average" sized row onto the page. &lt;p&gt;
 * @return true if page is relatively unfilled.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allowInsert</MethodName>
            <MethodComment>/** 
 * Is there enough space on the page to insert a minimum size row? &lt;p&gt; Calculate whether there is enough space on the page to insert a  minimum size row.  The calculation includes maintaining the required reserved space on the page for existing rows to grow on the page. &lt;p&gt;
 * @return boolean indicating if a minimum sized row can be inserted.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [spaceAvailable=freeSpace]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForCopy</MethodName>
            <MethodComment>/** 
 * Does this page have enough space to insert the input rows? &lt;p&gt; Can the rows with lengths spaceNeeded[0..num_rows-1] be copied onto this page? &lt;p&gt;
 * @return true if the sum of the lengths will fit on the page.
 * @param num_rows      number of rows to check for.
 * @param spaceNeeded   array of lengths of the rows to insert.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>num_rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceNeeded</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bytesNeeded=slotEntrySize * num_rows]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForCopy</MethodName>
            <MethodComment>/** 
 * Does this page have enough space to move the row to it. &lt;p&gt; Calculate if a row of length "spaceNeeded" with current record id "source_id" will fit on this page.
 * @param spaceNeeded   length of the row encoded with source_id record id.
 * @param source_id     record id of the row being moved. 
 * @return true if the record will fit on this page, after being given anew record id as the next id on this page.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spaceNeeded</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bytesNeeded=slotEntrySize + (spaceNeeded &gt;= minimumRecordSize ? spaceNeeded : minimumRecordSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreRecordFromSlot</MethodName>
            <MethodComment>/** 
 * Read the record at the given slot into the given row. &lt;P&gt; This reads and initializes the columns in the row array from the raw  bytes stored in the page associated with the given slot.  If validColumns is non-null then it will only read those columns indicated by the bit set, otherwise it will try to read into every column in row[].   &lt;P&gt; If there are more columns than entries in row[] then it just stops after every entry in row[] is full. &lt;P&gt; If there are more entries in row[] than exist on disk, the requested  excess columns will be set to null by calling the column's object's restoreToNull() routine (ie.  ((Object) column).restoreToNull() ). &lt;P&gt; If a qualifier list is provided then the row will only be read from disk if all of the qualifiers evaluate true.  Some of the columns may have been read into row[] in the process of evaluating the qualifier. &lt;p&gt; This routine should only be called on the head portion of a row, it will call a utility routine to read the rest of the row if it is a long row.
 * @param slot              the slot number
 * @param row (out)         filled in sparse row
 * @param fetchDesc         Information describing fetch, including whatcolumns to fetch and qualifiers.
 * @param recordToLock      the record handle for the row at top level,and is used in OverflowInputStream to lock the  row for Blobs/Clobs.
 * @param isHeadRow         The row on this page includes the head recordhandle.  Will be false for the overflow portions of a "long" row, where columns of a row span multiple pages.
 * @return  false if a qualifier_list is provided and the row does not qualifier (no row read in that case), else true.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchDesc</ParamName>
                    <ParamType>FetchDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isHeadRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreLongRecordFromSlot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchDesc</ParamName>
                    <ParamType>FetchDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent_recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(parent_recordHeader.getOverflowId(),Page.FIRST_SLOT_NUMBER)]</InnerVar>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordId</MethodName>
            <MethodComment>/** 
 * Create a new record handle. &lt;p&gt; Return the next record id for allocation.  Callers of this interface expect the next id to get bumped some where else - probably by storeRecordForInsert(). &lt;p&gt;
 * @return The next id to assing to a row.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordIdAndBump</MethodName>
            <MethodComment>/** 
 * Create a new record handle, and bump the id. &lt;p&gt; Create a new record handle, and bump the id while holding the latch so that no other user can ever see this record id.  This will lead to unused record id's in the case where an insert fails because there is not enough space on the page. &lt;p&gt;
 * @return The next id to assing to a row.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordId</MethodName>
            <MethodComment>/** 
 * Create a new record id based on current one passed in. &lt;p&gt; This interface is used for the "copy" insert interface of raw store where multiple rows are inserted into a page in a single logged  operation.  We don't want to bump the id until the operation is logged so we just allocated each id in order and then bump the next id at the end of the operation. &lt;p&gt;
 * @return the next id based on the input id.
 * @param recordId  The id caller just used, return the next one.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOverflowPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageSize</MethodName>
            <MethodComment>/** 
 * Get the full size of the page.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearSection</MethodName>
            <MethodComment>/** 
 * Zero out a portion of the page.
 * @param offset position of first byte to clear
 * @param length how many bytes to clear
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Arrays;fill;[pageData, offset, offset + length, (byte)0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxFreeSpace</MethodName>
            <MethodComment>/** 
 * The maximum free space on this page possible. &lt;p&gt; The the maximum amount of space that can be used on the page for the records and the slot offset table. NOTE: subclass may have overwitten it to report less freeSpace
 * @return the maximum free space on this page possible.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentFreeSpace</MethodName>
            <MethodComment>/** 
 * The current free space on the page.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readPageHeader</MethodName>
            <MethodComment>/** 
 * Read the page header from the page array. &lt;p&gt; Read the page header from byte form in the page array into in memory variables.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
                <InnerVar>long [spare]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[PAGE_HEADER_OFFSET]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setPageStatus;[lrdi.readByte()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setPageVersion;[lrdi.readLong()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatePageHeader</MethodName>
            <MethodComment>/** 
 * Update the page header in the page array. &lt;p&gt; Write the bytes of the page header, taking the values from those  in the in memory variables.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[PAGE_HEADER_OFFSET]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeBoolean;[isOverflowPage]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeByte;[getPageStatus()]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[getPageVersion()]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeShort;[slotsInUse]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeInt;[nextId]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeInt;[generation]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeInt;[prevGeneration]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[bipLocation]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeShort;[deletedRowCount + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeShort;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeInt;[dataFactory.random()]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatePageVersion</MethodName>
            <MethodComment>/** 
 * Update the page version number in the byte array
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[PAGE_VERSION_OFFSET]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[getPageVersion()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSlotOffset</MethodName>
            <MethodComment>/** 
 * Get the page offset of a given slot entry. &lt;p&gt; Get the page offset of a slot entry, this is not the offset of the record stored in the slot, but the offset of the actual slot.
 * @return The page offset of a given slot entry.
 * @param slot  The array entry of the slot to find.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordOffset</MethodName>
            <MethodComment>/** 
 * Get the page offset of the record associated with the input slot. &lt;p&gt; This is the actual offset on the page of the beginning of the record.
 * @return The page offset of the record associated with the input slot.
 * @param slot  The array entry of the slot to find.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [data=pageData]</InnerVar>
                <InnerVar>int [offset=slotTableOffsetToFirstEntry - (slot * slotEntrySize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRecordOffset</MethodName>
            <MethodComment>/** 
 * Set the page offset of the record associated with the input slot. &lt;p&gt; This is the actual offset on the page of the beginning of the record.
 * @param slot          The array entry of the slot to set.
 * @param recordOffset  the new offset to set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[getSlotOffset(slot)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordPortionLength</MethodName>
            <MethodComment>/** 
 * Return length of row on this page. &lt;p&gt; Return the total length of data and header stored on this page for  this record.  This length is stored as the second "field" of the slot table entry.
 * @return The length of the row on this page.
 * @param slot   the slot of the row to look up the length of.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[slotTableOffsetToFirstRecordLengthField - (slot * slotEntrySize)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReservedCount</MethodName>
            <MethodComment>/** 
 * Return reserved length of row on this page. &lt;p&gt; Return the reserved length of this record.   This length is stored as the third "field" of the slot table entry.
 * @return The reserved length of the row on this page.
 * @param slot   the slot of the row to look up the length of.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[slotTableOffsetToFirstReservedSpaceField - (slot * slotEntrySize)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateRecordPortionLength</MethodName>
            <MethodComment>/** 
 * Update the length of data stored on this page for this record &lt;p&gt; Update both the record length "field" and the reserved space "field" of the slot table entry associated with "slot".  This length is stored  as the second "field" of the slot table entry.  The changes to these 2 fields are represented as the delta to apply to each field as input in "delta" and "reservedDelta." &lt;p&gt;
 * @param slot              the slot of the record to set.
 * @param delta             The amount the record length changed.
 * @param reservedDelta     The amount the reserved length changed.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delta</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reservedDelta</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[slotTableOffsetToFirstRecordLengthField - (slot * slotEntrySize)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initSlotTable</MethodName>
            <MethodComment>/** 
 * Initialize the in-memory slot table. &lt;p&gt; Initialize the in-memory slot table, ie. that of our super-class  BasePage.  Go through all the records on the page and set the  freeSpace and firstFreeByte on page. &lt;p&gt;
 * @param newIdentity   The identity of the page we are trying to initialize, since we are in the middle of trying to build the page existing info in the class is not set up yet (like getIdentity()). 
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [localSlotsInUse=slotsInUse]</InnerVar>
                <InnerVar>int [lastSlotOnPage=-1]</InnerVar>
                <InnerVar>int [lastRecordOffset=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initializeHeaders;[localSlotsInUse]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearAllSpace;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSlotEntry</MethodName>
            <MethodComment>/** 
 * Set up a new slot entry. &lt;p&gt;
 * @param slot                  the slot to initialize.
 * @param recordOffset          the offset on the page to find the record.
 * @param recordPortionLength   the actual length of record+hdr on page.
 * @param reservedSpace         the reserved length associated with record.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordPortionLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reservedSpace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[getSlotOffset(slot)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSlotEntry</MethodName>
            <MethodComment>/** 
 * Insert a new slot entry into the current slot array. &lt;p&gt; Shift the existing slots from slot to (slotsInUse - 1) up by one. Up here means from low slot to high slot (e.g from slot 2 to slot 3). Our slot table grows backward so we have to be careful here.
 * @param slot                  Position the new slot will take
 * @param recordOffset          Offset of the record for the new slot
 * @param recordPortionLength   Length of the record stored in the new slot
 * @param reservedSpace         Length of reserved space of record in slot
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordPortionLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reservedSpace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [newSlotOffset]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setSlotEntry;[slot, recordOffset, recordPortionLength, reservedSpace]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeSlotEntry</MethodName>
            <MethodComment>/** 
 * Remove slot entry from slot array. &lt;p&gt; Remove a storage slot at slot. Shift the existing slots from slot+1 to (slotsInUse - 1) down by one.. Down here means from high slot to low slot (e.g from slot 3 to slot 2)
 * @param slot                  The slot to delete.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [oldEndOffset=getSlotOffset(slotsInUse - 1)]</InnerVar>
                <InnerVar>int [newEndOffset=getSlotOffset(slotsInUse - 2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;clearSection;[oldEndOffset, slotEntrySize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordHeaderOnDemand</MethodName>
            <MethodComment>/** 
 * create the record header for the specific slot. &lt;p&gt; Create a new record header object, initialize it, and add it to the array of cache'd record headers on this page.  Finally return reference to the initialized record header.
 * @return The record header for the specific slot.
 * @param slot   return record header of this slot.
 */
</MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=new StoredRecordHeader(pageData,getRecordOffset(slot))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setHeaderAtSlot;[slot, recordHeader]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entireRecordOnPage</MethodName>
            <MethodComment>/** 
 * Is entire record on the page? &lt;p&gt;
 * @return true if the entire record at slot is on this page, i.e, no overflow row or long columns.
 * @param slot   Check record at this slot.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeOverflowAtSlot</MethodName>
            <MethodComment>/** 
 * Purge one row on an overflow page.   &lt;p&gt; HeadRowHandle is the recordHandle pointing to the head row piece. &lt;p&gt;
 * @param slot              slot number of row to purge.
 * @param headRowHandle     recordHandle of the head row piece.
 * @param needDataLogged    when true data is logged for purges otherwise just headers.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needDataLogged</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>int[] [recordId=new int[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionPurge;[t, this, slot, 1, recordId, needDataLogged]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeOneColumnChain</MethodName>
            <MethodComment>/** 
 * Purge the column chain that starts at overflowPageId, overflowRecordId &lt;p&gt; Purge just the column chain that starts at the input address. The long column chain is pointed at by a field in a row.  The long column is then chained as a sequence of "rows", the last column then points to the next segment of the chain on each page. Long columns chains currently are only one row per page so the next slot of a row in a long row chain should always be the first slot. &lt;p&gt;
 * @param overflowPageId    The page where the long column chain starts.
 * @param overflowRecordId  The record id where long column chain starts.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>overflowPageId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowRecordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredPage [pageOnColumnChain=null]</InnerVar>
                <InnerVar>boolean [removePageHappened=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeColumnChains</MethodName>
            <MethodComment>/** 
 * purge long columns chains which eminate from this page. &lt;p&gt; Purge all the long column chains emanating from the record on this slot of this page.  The headRowHandle is the record handle of the head row piece of this row - if this page is the head row, then headRowHandle is the record handle at the slot.  Otherwise, headRowHandle points to a row on a different page, i.e., the head page. &lt;p&gt;
 * @param t             The raw transaction doing the purging.
 * @param slot          The slot of the row to purge.
 * @param headRowHandle The RecordHandle of the head row.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeRowPieces</MethodName>
            <MethodComment>/** 
 * Purge all the overflow columns and overflow rows of the record at slot. &lt;p&gt; Purge all the overflow columns and overflow rows of the record at slot. This is called by BasePage.purgeAtSlot, the head row piece is purged there.  &lt;p&gt;
 * @param t             The raw transaction doing the purging.
 * @param slot          The slot of the row to purge.
 * @param headRowHandle The RecordHandle of the head row.
 * @param needDataLogged    when true data is logged for purges otherwise just headers.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needDataLogged</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;purgeColumnChains;[t, slot, headRowHandle]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeOrphanedColumnChain</MethodName>
            <MethodComment>/** 
 * Remove a column chain that may have been orphaned by an update.   &lt;p&gt; Remove a column chain that may have been orphaned by an update.  This is executed as a post commit operation.  This page is the head page of the row which used to point to the column chain in question.  The location of the orphaned column chain is in the ReclaimSpace record. &lt;BR&gt; MT - latched.  No lock will be gotten, the head record must already be locked exclusive with no outstanding changes that can be rolled back. &lt;p&gt;
 * @param work          object describing the chain to remove.
 * @param containerHdl  open container handle to use to remove chain.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>ReclaimSpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerHdl</ParamName>
                    <ParamType>ContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredPage [headOfChain=(StoredPage)containerHdl.getPageNoWait(work.getColumnPageId())]</InnerVar>
                <InnerVar>boolean [pageUnchanged=headOfChain.equalTimeStamp(work.getPageTimeStamp())]</InnerVar>
                <InnerVar>RecordHandle [headRowHandle=work.getHeadRowHandle()]</InnerVar>
                <InnerVar>int [slot=findRecordById(headRowHandle.getId(),headRowHandle.getSlotNumberHint())]</InnerVar>
                <InnerVar>long [nextPageId=work.getColumnPageId()]</InnerVar>
                <InnerVar>int [nextRecordId=work.getColumnRecordId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>headOfChain;unlatch;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;purgeOneColumnChain;[nextPageId, nextRecordId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isColumnOrphaned</MethodName>
            <MethodComment>/** 
 * See if there is a orphaned long colum chain or not.   &lt;p&gt; See if there is a orphaned long colum chain or not.  This is a helper function for removeOrphanedChain.  This page, which may be a head page or overflow page, contains the column specified in columnId.  It used to point to a long column chain at oldPageId and oldRecordId.  Returns true if it no longer points to that long column chain. &lt;p&gt;
 * @return true if page no longer points to the long column chain.
 * @param recordHeader  record header which used to point at the long column
 * @param columnId      column id of the long column in head.
 * @param oldPageId     the page id where the long column used to be.
 * @param oldRecordId   the record id where the long column used to be.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldPageId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldRecordId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(recordHeader.getId(),Page.FIRST_SLOT_NUMBER)]</InnerVar>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
                <InnerVar>int [offset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [fieldStatus=StoredFieldHeader.readStatus(lrdi)]</InnerVar>
                <InnerVar>int [fieldLength=StoredFieldHeader.readFieldDataLength(lrdi,fieldStatus,slotFieldSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[offset + recordHeader.size()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextColumnPiece</MethodName>
            <MethodComment>/** 
 * Return the next recordHandle in a long column chain. &lt;p&gt; Return a recordHandle pointing to the next piece of the column chain. This page must be an overflow page that is in a column chain.  If this is the last piece of the overflow colum, return null. &lt;p&gt;
 * @return The next record handle in a long column chain.
 * @param slot   The slot of the current long column piece.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initSpace</MethodName>
            <MethodComment>/** 
 * initialize the in memory variables associated with space maintenance. &lt;p&gt; Get the total available space on an empty page. initSlotTable() must be called after the page has been read in.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearAllSpace</MethodName>
            <MethodComment>/** 
 * Initialize the freeSpace count and set the firstFreeByte on page
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressPage</MethodName>
            <MethodComment>/** 
 * Compress out the space specified by startByte and endByte. &lt;p&gt; As part of moving rows, updating rows, purging rows compact the space left between rows. &lt;p&gt;
 * @param startByte compress out space starting at startByte offset
 * @param endByte   compress out space ending   at endByte   offset
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startByte</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>endByte</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [lengthToClear=endByte + 1 - startByte]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;clearSection;[firstFreeByte, lengthToClear]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>expandPage</MethodName>
            <MethodComment>/** 
 * Free up required bytes by shifting rows "down" the page. &lt;p&gt; Expand page, move all the data from start Offset down the page by the amount required to free up the required bytes.
 * @param startOffset   offset on page to begin the shift
 * @param requiredBytes the number of bytes that must be freed.
 * @exception IOException   If IOException is raised during the page mod.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requiredBytes</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [totalLength=firstFreeByte - startOffset]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shrinkPage</MethodName>
            <MethodComment>/** 
 * Shrink page.  &lt;p&gt; move all the data from start Offset up the page by the amount shrunk. 
 * @param startOffset   offset on page to begin the shift
 * @param shrinkBytes   the number of bytes that must be moved.
 * @exception IOException   some IOException is raised during the page mod,(unlikely as this is just writing to array).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>shrinkBytes</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [totalLength=firstFreeByte - startOffset]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIsOverflow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logRow</MethodName>
            <MethodComment>/** 
 * Log a row into the StoreOuput stream. &lt;p&gt; Write the row in its record format to the stream. Record format is a  record header followed by each field with its field header. See this  class's description for the specifics of these headers. startColumn is used to specified which column for this logRow to  start logging.  When realStartColumn is specified, that means part of  the row has already been logged.  startColumn here indicates that the  first column was logged in the logBuffer, need to continue log the rest of the row starting at realStartColumn. This is used when a longColumn is encountered during a long row. After done logging the long column, we need to continue logging the  rest of the row. A -1 value for realStartColumn, means that it is not significant. logRow will not throw an noSpaceOnPage exception, if it is an overflow  page, and the record we are inserting is the only record on the page. We are supporting rows expanding multiple pages through this mechanism. logRow expects row to be a sparse row. &lt;p&gt;
 * @return the "realStartColumn" value, -1 if not a long row.
 * @param slot              the slot of the row being logged.
 * @param forInsert         this is logging an insert (not update/delete).
 * @param recordId          record id of the row being logged.
 * @param row               actual data of row in object form.  If row isnull then we are logging an overflow pointer.
 * @param validColumns      bit map describing valid columns in row.
 * @param out               stream to log to.
 * @param startColumn       what column to start with (see above for detail)
 * @param insertFlag        flag indicating mode we are in, INSERT_DEFAULT - default insert INSERT_SPLIT   - splitting a row/column  across pages.
 * @param realStartColumn   If -1 ignore variable, else part of row hasalready been logged, and should continue with this column.
 * @param realSpaceOnPage   Use this as space on page if realStartColumnis not -1.
 * @param overflowThreshold How much of the page to use before decidingto overflow a row.
 * @exception IOException        RESOLVE
 * @exception StandardException  Standard exception policy.
 * @see BasePage#logRow
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forInsert</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>realStartColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>realSpaceOnPage</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [spaceAvailable=freeSpace]</InnerVar>
                <InnerVar>int [beginPosition=out.getPosition()]</InnerVar>
                <InnerVar>boolean [calcMinimumRecordSize=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setOutputStream;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleIncompleteLogRow</MethodName>
            <MethodComment>/** 
 * Handle an update of a record portion that is incomplete. &lt;p&gt; Handle an update of a record portion that is incomplete. Ie. Columns have expanded that require other columns to move off the page into a new portion. &lt;P&gt;  This method works out of the columns that need to be moved which are not being updated and makes a copy of their data. It then throws an  exception with this data, much like the long column exception which will then allow the original insert to complete.   &lt;P&gt;  If no columns need to be saved (ie all the ones that would move are  being updated) then no exception is thrown, logRow() will return and the update completes normally. &lt;p&gt;
 * @param slot          slot of the current update.
 * @param startColumn   column to start at, handles start in middle of row
 * @param columnList    bit map indicating which columns are being updated.
 * @param out           place to lot to.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [rh=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>int [endFieldExclusive=rh.getFirstField() + rh.getNumberFields()]</InnerVar>
                <InnerVar>boolean [needSave=false]</InnerVar>
                <InnerVar>int [columnListSize=columnList.size()]</InnerVar>
                <InnerVar>Object[] [savedFields=new Object[endFieldExclusive - startColumn]]</InnerVar>
                <InnerVar>ByteArrayOutputStream [fieldStream=null]</InnerVar>
                <InnerVar>LongColumnException [lce=new LongColumnException()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lce;setExceptionInfo;[out, startColumn, -1]</InnerMethodInvoke>
                <InnerMethodInvoke>lce;setColumn;[savedFields]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreRecordFromStream</MethodName>
            <MethodComment>/** 
 * Restore a storable row from a LimitInputStream. &lt;p&gt; Restore a storable row from an LimitInputStream - user must supply two  streams on top of the same data, one implements ObjectInput interface  that knows how to restore the object, the other one implements  LimitInputStream. &lt;p&gt;
 * @param in           the limit input stream
 * @param row          (IN/OUT) row that is to be restored (sparse representation)
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>LimitObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=new StoredRecordHeader()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>recordHeader;read;[in]</InnerMethodInvoke>
                <InnerMethodInvoke>null;readRecordFromStream;[row, row.length - 1, (int[])null, (int[])null, in, recordHeader, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>qualifyRecordFromRow</MethodName>
            <MethodComment>/** 
 * Process the qualifier list on the row, return true if it qualifies. &lt;p&gt; A two dimensional array is to be used to pass around a AND's and OR's in conjunctive normal form.  The top slot of the 2 dimensional array is  optimized for the more frequent where no OR's are present.  The first  array slot is always a list of AND's to be treated as described above  for single dimensional AND qualifier arrays.  The subsequent slots are  to be treated as AND'd arrays or OR's.  Thus the 2 dimensional array  qual[][] argument is to be treated as the following, note if  qual.length = 1 then only the first array is valid and it is and an  array of and clauses: (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1]) and (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1]) and (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1]) ... and (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
 * @return true if the row qualifies.
 * @param row               The row being qualified.
 * @param qual_list         2 dimensional array representing conjunctivenormal form of simple qualifiers.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qual_list</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [row_qualifies=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readOneColumnFromPage</MethodName>
            <MethodComment>/** 
 * Read just one column from stream into row. &lt;p&gt; The routine reads just one column from the row, it is mostly code taken from readRecordFromStream, but highly optimized to just get one column from a non-overflow row.  It can only be called to read a row from the pageData array as it directly accesses the page array to avoid the Stream overhead while processing non-user data which does not need the limit functionality. &lt;p&gt; It is expected that this code will be called to read in a column  associated with a qualifiers which are applied one column at a time,  and has been specialized to proved the greatest peformance for  processing qualifiers.  This kind of access is done when scanning large datasets while applying qualifiers and thus any performance gain at this low level is multiplied by the large number of rows that may be iterated over. &lt;p&gt; The column is read into the object located in row[qual_colid].
 * @param row                   col is read into object in row[qual_colid].
 * @param offset_to_field_data  offset in bytes from top of page to field
 * @param colid                 the column id to read, colid N is row[N]
 * @param recordHeader          record header of row to read column from.
 * @param recordToLock          record handle to lock, used by overflow column code.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colid</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset_to_field_data</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ErrorObjectInput [inUserCode=null]</InnerVar>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>qualifyRecordFromSlot</MethodName>
            <MethodComment>/** 
 * Process the list of qualifiers on the row in the stream. &lt;p&gt; The rawDataIn stream is expected to be positioned after the record  header. &lt;p&gt; Check all qualifiers in the qualifier array against row.  Return true if all compares specified by the qualifier array return true, else return false. &lt;p&gt; This routine assumes client caller has already checked if the row is deleted or not.  The row that it get's is expected to match the partial column list of the scan.   &lt;p&gt; On entering this routine the stream should be positioned to the beginning of the row data, just after the row header.  On exit the stream will also be positioned there. A two dimensional array is to be used to pass around a AND's and OR's in conjunctive normal form.  The top slot of the 2 dimensional array is  optimized for the more frequent where no OR's are present.  The first  array slot is always a list of AND's to be treated as described above  for single dimensional AND qualifier arrays.  The subsequent slots are  to be treated as AND'd arrays or OR's.  Thus the 2 dimensional array  qual[][] argument is to be treated as the following, note if  qual.length = 1 then only the first array is valid and it is and an  array of and clauses: (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1]) and (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1]) and (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1]) ... and (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
 * @return Whether or not the row input qualifies.
 * @param row                   restore row into this object array.
 * @param offset_to_row_data    offset in bytes from top of page to row
 * @param fetchDesc             Description of fetch including which colsand qualifiers.
 * @param recordHeader          The record header of the row, it was read in from stream and dataIn is positioned  after it.
 * @param recordToLock          The head row to use for locking, used to lock head row of overflow columns/rows.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset_to_row_data</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchDesc</ParamName>
                    <ParamType>FetchDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [row_qualifies=true]</InnerVar>
                <InnerVar>Qualifier[][] [qual_list=fetchDesc.getQualifierList()]</InnerVar>
                <InnerVar>int[] [materializedCols=fetchDesc.getMaterializedColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readRecordFromStream</MethodName>
            <MethodComment>/** 
 * restore a record from a stream. &lt;p&gt; The rawDataIn stream is expected to be positioned after the record  header.
 * @return The identifier to be used to open the conglomerate later.
 * @param row               restore row into this object array.
 * @param max_colid         The maximum numbered column id that will be requested by caller.  It should be: min(row.length - 1, maximum bit set in vCols) It is used to stop the inner most loop from  looking at more columns in the row.
 * @param vCols             If not null, bit map indicates valid cols.
 * @param mCols             If not null, int array indicates columns alreadyread in from the stream.  A non-zero entry  means the column has already been read in.
 * @param dataIn            restore row from this stream.
 * @param recordHeader      The record header of the row, it was read in from stream and dataIn is positioned after it.
 * @param recordToLock      The head row to use for locking, used to lock head row of overflow columns/rows.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_colid</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataIn</ParamName>
                    <ParamType>LimitObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ErrorObjectInput [inUserCode=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readRecordFromArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_colid</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataIn</ParamName>
                    <ParamType>ArrayInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordToLock</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ErrorObjectInput [inUserCode=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restorePortionLongColumn</MethodName>
            <MethodComment>/** 
 * Restore a portion of a long column. &lt;p&gt; Restore a portion of a long column - user must supply two streams on top of the same data, one implements ObjectInput interface that knows how to restore the object, the other one implements LimitInputStream.
 * @param fetchStream  the stream to read the next portion of long col from
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fetchStream</ParamName>
                    <ParamType>OverflowInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(fetchStream.getOverflowId(),FIRST_SLOT_NUMBER)]</InnerVar>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>int [offset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [numberFields=recordHeader.getNumberFields()]</InnerVar>
                <InnerVar>int [fieldStatus=StoredFieldHeader.readStatus(rawDataIn)]</InnerVar>
                <InnerVar>int [fieldDataLength=StoredFieldHeader.readFieldDataLength(rawDataIn,fieldStatus,slotFieldSize)]</InnerVar>
                <InnerVar>ByteHolder [bh=fetchStream.getByteHolder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataIn;setPosition;[offset + recordHeader.size()]</InnerMethodInvoke>
                <InnerMethodInvoke>bh;write;[rawDataIn, fieldDataLength]</InnerMethodInvoke>
                <InnerMethodInvoke>fetchStream;setByteHolder;[bh]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logColumn</MethodName>
            <MethodComment>/** 
 * Log a Storable to a stream. &lt;p&gt; Log a Storable into a stream.  This is used by update field operations &lt;P&gt; Write the column in its field format to the stream. Field format is a  field header followed the data of the column as defined by the data  itself.  See this class's description for the specifics of the header.
 * @exception StandardException     Standard Derby error policy
 * @exception IOException           RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bytesAvailable=freeSpace]</InnerVar>
                <InnerVar>int [beginPosition=-1]</InnerVar>
                <InnerVar>int [fieldStatus=StoredFieldHeader.readStatus(rawDataIn)]</InnerVar>
                <InnerVar>int [fieldDataLength=StoredFieldHeader.readFieldDataLength(rawDataIn,fieldStatus,slotFieldSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataIn;setPosition;[getFieldOffset(slot,fieldId)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logLongColumn</MethodName>
            <MethodComment>/** 
 * Log a long column into a DataOuput. &lt;p&gt; Log a long column into a DataOuput.  This is used by insert operations &lt;P&gt; Write the column in its field format to the stream. Field format is a  field header followed the data of the column as defined by the data  itself.  See this class's description for the specifics of the header.
 * @param slot      slot of the row with the column
 * @param recordId  record id of the
 * @param column    the object form of the column to log 
 * @param out       where to log to the column to.
 * @exception StandardException Standard Derby error policy
 * @exception IOException       I/O exception from writing to an array.
 * @see BasePage#logColumn
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [spaceAvailable=freeSpace]</InnerVar>
                <InnerVar>int [beginPosition=out.getPosition()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setOutputStream;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logColumn</MethodName>
            <MethodComment>/** 
 * Log column from input row to the given output stream. &lt;p&gt; Read data from row[arrayPosition], and write the column data in raw store page format to the given column.  Along the way determine if the column will fit on the current page. &lt;p&gt; Action taken in this routine is determined by the kind of column as specified in the columnFlag: COLUMN_NONE   - the column is insignificant COLUMN_FIRST  - this is the first column in a logRow() call COLUMN_LONG   - this is a known long column, therefore we will  store part of the column on the current page and  overflow the rest if necessary. &lt;p&gt; Upon entry to this routine logicalDataOut is tied to the  DynamicByteArrayOutputStream out. &lt;BR&gt; If a column is a long column and it does not totally fit on the current page, then a LongColumnException is thrown.  We package up info about the current long column in the partially filled in exception so that callers can take correct action.  The column will now be set a as a stream.
 * @return The spaceAvailable after accounting for space for this column.
 * @param row           array of column from which to read the column from.
 * @param arrayPosition The array position of column to be reading from row.
 * @param out           The stream to write the raw store page format of thethe column to.
 * @param spaceAvailable    The number of bytes available on the page forthis column, this may differ from current page as it may include bytes used by previous  columns.
 * @param columnFlag    one of: COLUMN_NONE, COLUMN_FIRST, or COLUMN_LONG.
 * @exception StandardException    Standard exception policy.
 * @exception LongColumnException  Thrown if column will not fit on a single page. See notes above
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arrayPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceAvailable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object [column=(row != null ? row[arrayPosition] : null)]</InnerVar>
                <InnerVar>boolean [longColumnDone=true]</InnerVar>
                <InnerVar>int [fieldStatus=StoredFieldHeader.setFixed(StoredFieldHeader.setInitial(),true)]</InnerVar>
                <InnerVar>int [beginPosition=out.getPosition()]</InnerVar>
                <InnerVar>int [columnBeginPosition=0]</InnerVar>
                <InnerVar>int [headerLength]</InnerVar>
                <InnerVar>int [fieldDataLength=0]</InnerVar>
                <InnerVar>int [fieldSizeOnPage=StoredFieldHeader.size(fieldStatus,fieldDataLength,slotFieldSize) + fieldDataLength]</InnerVar>
                <InnerVar>boolean [fieldIsLong=isLong(fieldSizeOnPage,overflowThreshold)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;setPosition;[beginPosition]</InnerMethodInvoke>
                <InnerMethodInvoke>out;setPosition;[beginPosition + fieldDataLength + headerLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logOverflowRecord</MethodName>
            <MethodComment>/** 
 * Create and write a long row header to the log stream. &lt;p&gt; Called to log a new overflow record, will check for space available and throw an exception if the record header will not fit on the page. &lt;p&gt;
 * @return -1
 * @param slot           slot of record to log.
 * @param spaceAvailable spaceAvaliable on page.
 * @param out            stream to log the record to.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceAvailable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [pageRecordHeader=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>StoredRecordHeader [overflow_rh=getOverFlowRecordHeader()]</InnerVar>
                <InnerVar>int [oldSize=pageRecordHeader.size()]</InnerVar>
                <InnerVar>int [newSize=overflow_rh.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setOutputStream;[out]</InnerMethodInvoke>
                <InnerMethodInvoke>overflow_rh;setOverflowFields;[pageRecordHeader]</InnerMethodInvoke>
                <InnerMethodInvoke>overflow_rh;write;[logicalDataOut]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logRecordDataPortion;[slot, LOG_RECORD_DEFAULT, pageRecordHeader, (FormatableBitSet)null, logicalDataOut, (RecordHandle)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logOverflowField</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceAvailable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowPage</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [fieldStatus=StoredFieldHeader.setOverflow(StoredFieldHeader.setInitial(),true)]</InnerVar>
                <InnerVar>int [fieldSizeOnPage=CompressedNumber.sizeLong(overflowPage) + CompressedNumber.sizeInt(overflowId)]</InnerVar>
                <InnerVar>int [fieldDataLength=fieldSizeOnPage]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>StoredFieldHeader;write;[logicalDataOut, fieldStatus, fieldDataLength, slotFieldSize]</InnerMethodInvoke>
                <InnerMethodInvoke>CompressedNumber;writeLong;[out, overflowPage]</InnerMethodInvoke>
                <InnerMethodInvoke>CompressedNumber;writeInt;[out, overflowId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logRecord</MethodName>
            <MethodComment>/** 
 * Log a record to the ObjectOutput stream. &lt;p&gt; Write out the complete on-page record to the store stream.  Data is  preceeded by a  compressed int that gives the length of the following  data.
 * @exception StandardException Standard Derby error policy
 * @exception IOException       on error writing to log stream.
 * @see BasePage#logRecord
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logRecordDataPortion;[slot, flag, recordHeader, validColumns, out, headRowHandle]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logRecordDataPortion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [oldHeaderLength=recordHeader.size()]</InnerVar>
                <InnerVar>int [startField=recordHeader.getFirstField()]</InnerVar>
                <InnerVar>int [endField=startField + recordHeader.getNumberFields()]</InnerVar>
                <InnerVar>int [validColumnsSize=(validColumns == null) ? 0 : validColumns.getLength()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logField</MethodName>
            <MethodComment>/** 
 * Log a field to the ObjectOutput stream. &lt;P&gt; Find the field in the record and then write out the complete field, i.e. header and data.
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 * @see BasePage#logField
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=getFieldOffset(slot,fieldNumber)]</InnerVar>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
                <InnerVar>int [fieldStatus=StoredFieldHeader.readStatus(lrdi)]</InnerVar>
                <InnerVar>int [fieldDataLength=StoredFieldHeader.readFieldDataLength(lrdi,fieldStatus,slotFieldSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>StoredFieldHeader;write;[out, fieldStatus, fieldDataLength, slotFieldSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAtSlot</MethodName>
            <MethodComment>/** 
 * Override insertAtSlot to provide long row support.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateFieldAtSlot</MethodName>
            <MethodComment>/** 
 * Update field at specified slot
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNumFieldsAtSlot</MethodName>
            <MethodComment>/** 
 * Get the number of fields on the row at slot
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>BasePage [overflowPage=getOverflowPage(recordHeader.getOverflowPage())]</InnerVar>
                <InnerVar>int [count=overflowPage.fetchNumFieldsAtSlot(getOverflowSlot(overflowPage,recordHeader))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>overflowPage;unlatch;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>moveRecordForCompressAtSlot</MethodName>
            <MethodComment>/** 
 * Move record to a page toward the beginning of the file. &lt;p&gt; As part of compressing the table records need to be moved from the end of the file toward the beginning of the file.  Only the  contiguous set of free pages at the very end of the file can be given back to the OS.  This call is used to purge the row from the current page, insert it into a previous page, and return the new row location  Mark the record identified by position as deleted. The record may be  undeleted sometime later using undelete() by any transaction that sees  the record. &lt;p&gt; The interface is optimized to work on a number of rows at a time,  optimally processing all rows on the page at once.  The call will  process either all rows on the page, or the number of slots in the input arrays - whichever is smaller. &lt;B&gt;Locking Policy&lt;/B&gt; &lt;P&gt; MUST be called with table locked, no locks are requested.  Because it is called with table locks the call will go ahead and purge any row which is marked deleted.  It will also use purge rather than delete to remove the old row after it moves it to a new page.  This is ok since the table lock insures that no other transaction will use space on the table before this transaction commits. &lt;BR&gt; A page latch on the new page will be requested and released.
 * @param slot           slot of original row to move.
 * @param row            a row template to hold all columns of row.
 * @param old_handle     An array to be filled in by the call with the old handles of all rows moved.
 * @param new_handle     An array to be filled in by the call with the new handles of all rows moved.
 * @return the number of rows processed.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old_handle</ParamName>
                    <ParamType>RecordHandle[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_handle</ParamName>
                    <ParamType>RecordHandle[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [src_pageno=getPageNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logAction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDirty;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bumpPageVersion;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateLastLogInstant;[instant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDirty;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearSection;[0, getPageSize()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearAllSpace;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initPage</MethodName>
            <MethodComment>/** 
 * Initialize the page.   If reuse, then  Clean up any in memory or on disk structure to ready the page for reuse. This is not only reusing the page buffer, but reusing a free page  which may or may not be cleaned up the the client of raw store when it  was deallocated.
 * @exception StandardException Derby Standard Error Policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>status</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setPageStatus;[status]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPageStatus</MethodName>
            <MethodComment>/** 
 * Set page status
 * @exception StandardException Derby Standard Error Policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>status</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setPageStatus;[status]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReservedSpace</MethodName>
            <MethodComment>/** 
 * Set the row reserved space.
 * @exception StandardException Derby Standard Error Policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [delta=value - getReservedCount(slot)]</InnerVar>
                <InnerVar>int [nextRecordOffset=getRecordOffset(slot) + getTotalSpace(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[getSlotOffset(slot) + (2 * slotFieldSize)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeRecord</MethodName>
            <MethodComment>/** 
 * Store a record at the given slot.
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insert</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeRecordForInsert</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=shiftUp(slot)]</InnerVar>
                <InnerVar>int [recordOffset=firstFreeByte]</InnerVar>
                <InnerVar>int [offset=recordOffset]</InnerVar>
                <InnerVar>int [numberFields=recordHeader.getNumberFields()]</InnerVar>
                <InnerVar>int [userData=0]</InnerVar>
                <InnerVar>int [dataWritten=offset - firstFreeByte]</InnerVar>
                <InnerVar>int [reservedSpace=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bumpRecordCount;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>recordHeader;read;[in]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSlotEntry;[slot, recordOffset, dataWritten, reservedSpace]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeRecordForUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>StoredRecordHeader [newRecorderHeader=new StoredRecordHeader()]</InnerVar>
                <InnerVar>int [oldFieldCount=recordHeader.getNumberFields()]</InnerVar>
                <InnerVar>int [newFieldCount=newRecorderHeader.getNumberFields()]</InnerVar>
                <InnerVar>int [startField=recordHeader.getFirstField()]</InnerVar>
                <InnerVar>int [startingOffset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [newOffset=startingOffset]</InnerVar>
                <InnerVar>int [oldOffset=startingOffset]</InnerVar>
                <InnerVar>int [reservedSpaceFieldId=newFieldCount &lt; oldFieldCount ? newFieldCount - 1 : oldFieldCount - 1]</InnerVar>
                <InnerVar>DynamicByteArrayOutputStream [newDataToWrite=null]</InnerVar>
                <InnerVar>int [oldLength=recordHeader.size()]</InnerVar>
                <InnerVar>int [newLength=newRecorderHeader.size()]</InnerVar>
                <InnerVar>int [unusedSpace=oldLength]</InnerVar>
                <InnerVar>int [recordDelta=(newLength - oldLength)]</InnerVar>
                <InnerVar>int [oldFieldStatus=0]</InnerVar>
                <InnerVar>int [oldFieldDataLength=0]</InnerVar>
                <InnerVar>int [newFieldStatus=0]</InnerVar>
                <InnerVar>int [newFieldDataLength=0]</InnerVar>
                <InnerVar>int [oldEndFieldExclusive=startField + oldFieldCount]</InnerVar>
                <InnerVar>int [newEndFieldExclusive=startField + newFieldCount]</InnerVar>
                <InnerVar>int [reservedDelta]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newRecorderHeader;read;[in]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[newOffset]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateRecordPortionLength;[slot, recordDelta, reservedDelta]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setHeaderAtSlot;[slot, newRecorderHeader]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>moveSavedDataToPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>savedData</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unusedSpace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSpaceForUpdate</MethodName>
            <MethodComment>/** 
 * Create the space to update a portion of a record. This method ensures there is enough room to replace the old data of length oldLength at the given offset, with the new data of length newLength. This method does put any new data on the page, it moves old data around and zeros out any old data when newLength &amp;lt; oldLength. This method does update the information in the slot table. The passed in offset is the correct place to put the data when this method returns, ie. it only moves data that has an offset greater then this.
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [extraLength=newLength - oldLength]</InnerVar>
                <InnerVar>int [recordReservedSpace=getReservedCount(slot)]</InnerVar>
                <InnerVar>int [reservedDelta=0]</InnerVar>
                <InnerVar>int [spaceRequiredFromFreeSpace=extraLength - recordReservedSpace]</InnerVar>
                <InnerVar>int [remainingLength=shiftRemainingData(slot,offset,oldLength,newLength)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateRecordPortionLength;[slot, extraLength, reservedDelta]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeField</MethodName>
            <MethodComment>/** 
 * storeField
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=getFieldOffset(slot,fieldNumber)]</InnerVar>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
                <InnerVar>int [oldFieldStatus=StoredFieldHeader.readStatus(lrdi)]</InnerVar>
                <InnerVar>int [oldFieldDataLength=StoredFieldHeader.readFieldDataLength(lrdi,oldFieldStatus,slotFieldSize)]</InnerVar>
                <InnerVar>int [newFieldStatus=StoredFieldHeader.readStatus(in)]</InnerVar>
                <InnerVar>int [newFieldDataLength=StoredFieldHeader.readFieldDataLength(in,newFieldStatus,slotFieldSize)]</InnerVar>
                <InnerVar>int [oldFieldLength=StoredFieldHeader.size(oldFieldStatus,oldFieldDataLength,slotFieldSize) + oldFieldDataLength]</InnerVar>
                <InnerVar>int [newFieldLength=StoredFieldHeader.size(newFieldStatus,newFieldDataLength,slotFieldSize) + newFieldDataLength]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>lrdi;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createSpaceForUpdate;[slot, offset, oldFieldLength, newFieldLength]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[offset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reserveSpaceForSlot</MethodName>
            <MethodComment>/** 
 * reserveSpaceForSlot This method will reserve at least specified "spaceToReserve" bytes for the record in the slot.
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceToReserve</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [extraSpace=spaceToReserve - getReservedCount(slot)]</InnerVar>
                <InnerVar>int [startingOffset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [nextRecordOffset=startingOffset + getTotalSpace(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>null;expandPage;[nextRecordOffset, extraSpace]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setSlotEntry;[slot, startingOffset, getRecordPortionLength(slot), spaceToReserve]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipField</MethodName>
            <MethodComment>/** 
 * Skip a field header and its data on the given stream.
 * @exception IOException corrupt stream
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [fieldStatus=StoredFieldHeader.readStatus(in)]</InnerVar>
                <InnerVar>int [fieldDataLength=StoredFieldHeader.readFieldDataLength(in,fieldStatus,slotFieldSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipRecord</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=new StoredRecordHeader()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>recordHeader;read;[in]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shiftRemainingData</MethodName>
            <MethodComment>/** 
 * Shift data within a record to account for an update.
 * @param offset  Offset where the update starts, need not be on a field boundry.
 * @param oldLength length of the data being replaced
 * @param newLength length of the data replacing the old data
 * @return the length of the data in the record after the replaced data.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [remainingLength=(getRecordOffset(slot) + getRecordPortionLength(slot)) - (offset + oldLength)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeleteStatus</MethodName>
            <MethodComment>/** 
 * Set the deleted status
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 * @see BasePage#setDeleteStatus
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>rawDataOut;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>recordHeader;write;[logicalDataOut]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalDeletedRecordCount</MethodName>
            <MethodComment>/** 
 * get record count without checking for latch
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeRecord</MethodName>
            <MethodComment>/** 
 * purgeRecord from page.  Move following slots up by one.
 * @exception StandardException    Standard Derby error policy
 * @exception IOException          RESOLVE
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [startByte=getRecordOffset(slot)]</InnerVar>
                <InnerVar>int [endByte=startByte + getTotalSpace(slot) - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>null;compressPage;[startByte, endByte]</InnerMethodInvoke>
                <InnerMethodInvoke>null;removeSlotEntry;[slot]</InnerMethodInvoke>
                <InnerMethodInvoke>null;removeAndShiftDown;[slot]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFieldOffset</MethodName>
            <MethodComment>/** 
 * Get the offset of the field header of the given field for the record in the given slot. Field number is the absolute number for the complete record, not just this portion. E.g. if this is a record portion that starts at field 3 and has 6 fields then the second field on this *page* has field number 4.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=getRecordOffset(slot)]</InnerVar>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
                <InnerVar>int [startField=recordHeader.getFirstField()]</InnerVar>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[offset + recordHeader.size()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>currentTimeStamp</MethodName>
            <MethodComment>/** 
 * Get a time stamp for this page
 * @return page time stamp
 */
</MethodComment>
            <ReturnType>PageTimeStamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTimeStamp</MethodName>
            <MethodComment>/** 
 * Set given pageVersion to be the as what is on this page
 * @exception StandardException given time stamp is null or is not a timestamp implementation this page knows how to deal with
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ts</ParamName>
                    <ParamType>PageTimeStamp</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageVersion [pv=(PageVersion)ts]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pv;setPageNumber;[getPageNumber()]</InnerMethodInvoke>
                <InnerMethodInvoke>pv;setPageVersion;[getPageVersion()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalTimeStamp</MethodName>
            <MethodComment>/** 
 * compare given PageVersion with pageVersion on page
 * @param ts the page version gotton from this page via a currentTimeStampor setTimeStamp call earlier
 * @return true if the same
 * @exception StandardException given time stamp not gotton from this page
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ts</ParamName>
                    <ParamType>PageTimeStamp</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PageVersion [pv=(PageVersion)ts]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * debugging, print this page 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toUncheckedString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pagedataToHexDump</MethodName>
            <MethodComment>/** 
 * Provide a hex dump of the data in the in memory version of the page. &lt;p&gt; The output looks like: 00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ.............. 00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@....... 00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................ 00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................ 00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th 00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno 00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS  00000070: 6d6f 6465 2e0d 0a24 0000 0000 0000 0050  mode...$.......P 00000080: 4500 004c 0109 008b abfd 3000 0000 0000  E..L......0..... 00000090: 0000 00e0 000e 210b 0102 3700 3405 0000  ......!...7.4... 000000a0: 8401 0000 6400 0000 6004 0000 1000 0000  ....d...`....... 000000b0: 5005 0000 0008 6000 1000 0000 0200 0001  P.....`......... 000000c0: 0000 0000 0000 0004 0000 0000 0000 0000  ................ 000000d0: 9007 0000 0400 0009 a207 0002 0000 0000  ................ 000000e0: 0010 0000 1000 0000 0010 0000 1000 0000  ................ 000000f0: 0000 0010 0000 0000 6006 00ef 8100 0000  ........`....... 00000100: 5006 00e6 0c00 0000 0007 00d0 0400 0000  P............... 00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................ 00000120: 1007 00c8 7100 0000 0000 0000 0000 0000  ....q........... 00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................ &lt;p&gt;
 * @return The string with the hex dump in it.
 * @param data   array of bytes to dump.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>data</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pageHeaderToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageDumpString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverflowPage</MethodName>
            <MethodComment>/** 
 * Get the overflow page for a record that has already overflowed.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>StoredPage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredPage [overflowPage=(StoredPage)owner.getPage(pageNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewOverflowPage</MethodName>
            <MethodComment>/** 
 * Get an empty overflow page.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>FileContainer [myContainer=(FileContainer)containerCache.find(identity.getContainerId())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverflowSlot</MethodName>
            <MethodComment>/** 
 * Get the overflow slot for a record that has already overflowed.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>overflowPage</ParamName>
                    <ParamType>BasePage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=overflowPage.findRecordById(recordHeader.getOverflowId(),Page.FIRST_SLOT_NUMBER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverflowPageForInsert</MethodName>
            <MethodComment>/** 
 * Get a overflow page that potentially can handle a new overflowed record.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentSlot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverflowPageForInsert</MethodName>
            <MethodComment>/** 
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentSlot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long[] [pageList=new long[5]]</InnerVar>
                <InnerVar>int [pageCount=0]</InnerVar>
                <InnerVar>long [currentOverflowPageNumber=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateOverflowed</MethodName>
            <MethodComment>/** 
 * Update an already overflowed record.
 * @param slot Slot of the original record on its original page
 * @param row new version of the data
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [overflowPage=getOverflowPage(recordHeader.getOverflowPage())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateOverflowDetails</MethodName>
            <MethodComment>/** 
 * Update a record handle to point to an overflowed record portion. Note that the record handle need not be the current page.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [handlePageNumber=handle.getPageNumber()]</InnerVar>
                <InnerVar>StoredPage [handlePage=(StoredPage)owner.getPage(handlePageNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateOverflowDetails;[handlePage, handle, overflowHandle]</InnerMethodInvoke>
                <InnerMethodInvoke>handlePage;unlatch;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateOverflowDetails</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handlePage</ParamName>
                    <ParamType>StoredPage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=handlePage.getSlotNumber(handle)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>handlePage.getOverFlowRecordHeader();setOverflowDetails;[overflowHandle]</InnerMethodInvoke>
                <InnerMethodInvoke>handlePage;doUpdateAtSlot;[owner.getTransaction(), slot, handle.getId(), (Object[])null, (FormatableBitSet)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateFieldOverflowDetails</MethodName>
            <MethodComment>/** 
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [row=new Object[2]]</InnerVar>
                <InnerVar>FormatableBitSet [validColumns=new FormatableBitSet(2)]</InnerVar>
                <InnerVar>int [slot=getSlotNumber(handle)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>validColumns;set;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>null;doUpdateAtSlot;[owner.getTransaction(), slot, handle.getId(), row, validColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendOverflowFieldHeader</MethodName>
            <MethodComment>/** 
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logBuffer</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [fieldStatus=StoredFieldHeader.setInitial()]</InnerVar>
                <InnerVar>long [overflowPage=overflowHandle.getPageNumber()]</InnerVar>
                <InnerVar>int [overflowId=overflowHandle.getId()]</InnerVar>
                <InnerVar>int [fieldDataLength=CompressedNumber.sizeLong(overflowPage) + CompressedNumber.sizeInt(overflowId)]</InnerVar>
                <InnerVar>int [lenWritten=StoredFieldHeader.write(logBuffer,fieldStatus,fieldDataLength,slotFieldSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSlotsInUse</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxDataLength</MethodName>
            <MethodComment>/** 
 * return the max datalength allowed with the space available
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spaceAvailable</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxThresholdSpace=totalSpace * overflowThreshold / 100]</InnerVar>
                <InnerVar>int [maxAvailable=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLong</MethodName>
            <MethodComment>/** 
 * return whether the field has exceeded the max threshold for this page it compares the fieldSize with the largest possible field for this page
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fieldSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxThresholdSize=maxFieldSize * overflowThreshold / 100]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doUpdateAtSlot</MethodName>
            <MethodComment>/** 
 * Perform an update.
 * @exception StandardException Standard Derby policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RecordHandle [headRowHandle=isOverflowPage() ? null : getRecordHandleAtSlot(slot)]</InnerVar>
                <InnerVar>int [startColumn=RowUtil.nextColumn(row,validColumns,0)]</InnerVar>
                <InnerVar>boolean [rowHasReservedSpace=false]</InnerVar>
                <InnerVar>StoredPage [curPage=this]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRowReservedSpace</MethodName>
            <MethodComment>/** 
 * See if reserved space should be reclaimed for the input row. &lt;p&gt; See if the row on this page has reserved space that should be shrunk  once the update commits.  Will only indicate space should be reclaimed if at least RawTransaction.MINIMUM_RECORD_SIZE_DEFAULT bytes can be reclaimed.   &lt;p&gt;
 * @return true if space should be reclaimed from this row post commit.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [rowHasReservedSpace=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compactRecord</MethodName>
            <MethodComment>/** 
 * @see BasePage#compactRecord
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [reclaimThreshold=RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>