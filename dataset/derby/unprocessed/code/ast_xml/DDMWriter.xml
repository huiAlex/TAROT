<Class>
    <Id>2185</Id>
    <Package>org.apache.derby.impl.drda</Package>
    <ClassName>DDMWriter</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DDMWriter  /** 
 * The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is described in the DDMReader class. For more details, see DRDA Volume 3 (Distributed Data Management(DDM) Architecture (DDS definition)
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MAX_MARKS_NESTING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DEFAULT_BUFFER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_VARCHAR_BYTE_LENGTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>buffer</FieldName>
            <FieldType>ByteBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>markStack</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>top</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ebcdicCcsidManager</FieldName>
            <FieldType>EbcdicCcsidManager</FieldType>
        </Field>
        <Field>
            <FieldName>utf8CcsidManager</FieldName>
            <FieldType>Utf8CcsidManager</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidManager</FieldName>
            <FieldType>CcsidManager</FieldType>
        </Field>
        <Field>
            <FieldName>agent</FieldName>
            <FieldType>DRDAConnThread</FieldType>
        </Field>
        <Field>
            <FieldName>dssLengthLocation</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>correlationID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextCorrelationID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isDRDAProtocol</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dssTrace</FieldName>
            <FieldType>DssTrace</FieldType>
        </Field>
        <Field>
            <FieldName>prevHdrLocation</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>previousCorrId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>previousChainByte</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>isContinuationDss</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>lastDSSBeforeMark</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>encoder</FieldName>
            <FieldType>CharsetEncoder</FieldType>
        </Field>
        <Field>
            <FieldName>totalByteCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DDMWriter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>agent</ParamName>
                    <ParamType>DRDAConnThread</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dssTrace</ParamName>
                    <ParamType>DssTrace</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;reset;[dssTrace]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUtf8Ccsid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEbcdicCcsid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentCcsidManager</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CcsidManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reset</MethodName>
            <MethodComment>/** 
 * reset values for sending next message
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dssTrace</ParamName>
                    <ParamType>DssTrace</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBufferPosition</MethodName>
            <MethodComment>/** 
 * Get the current position in the output buffer.
 * @return current position
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBufferPosition</MethodName>
            <MethodComment>/** 
 * Change the current position in the output buffer.
 * @param position new position
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[position]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBufferContents</MethodName>
            <MethodComment>/** 
 * Get a copy of a subsequence of the output buffer, starting at the specified position and ending at the current buffer position.
 * @param startPos the position of the first byte to copy
 * @return all bytes from {@code startPos} up to the current position
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startPos</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [bytes=new byte[buffer.position() - startPos]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[buffer.array(), startPos, bytes, 0, bytes.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCMDProtocol</MethodName>
            <MethodComment>/** 
 * set protocol to CMD protocol
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDssReply</MethodName>
            <MethodComment>/** 
 * Create DSS reply object
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;beginDss;[DssConstants.DSSFMT_RPYDSS, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDssRequest</MethodName>
            <MethodComment>/** 
 * Create DSS request object NOTE: This is _ONLY_ used for testing the protocol (via the ProtocolTestAdapter.java file in this package)! We should never create a DSS request in normal DRDA processing (we should only create DSS replies and DSS objects).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;beginDss;[DssConstants.DSSFMT_RQSDSS, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDssObject</MethodName>
            <MethodComment>/** 
 * Create DSS data object
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;beginDss;[DssConstants.DSSFMT_OBJDSS, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markDssAsContinued</MethodName>
            <MethodComment>/** 
 * Mark the DSS that we're currently writing as a continued DSS, which is done by setting the high-order bit to "1", per DDM spec. This means: 1. One or more continuation DSSes will immediately follow the current (continued) DSS. 2. All continuation DSSes will have a 2-byte continuation header, followed by data; in other words, chaining state, correlation id, dss format info, and code point will NOT be included.  All of that info is present ONLY in the FIRST DSS in the list of continued DSSes. NOTE: A DSS can be a "continuation" DSS _and_ a "continued" DSS at the same time.  However, the FIRST DSS to be continued canNOT be a continuation DSS.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forLob</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endDss</MethodName>
            <MethodComment>/** 
 * End DSS header by writing the length in the length location and setting the chain bit.  Unlike the other two endDss methods, this one overrides the default chaining byte (which is set in beginDss) with the chaining byte that is passed in.  NOTE: This method is only used in association with createDssRequest, and thus is for TESTING purposes only (via ProtocolTestAdpater.java).  No calls should be made to this method in normal DRDA processing (because for normal processing, chaining must be determined automatically based on DSS requests).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chainByte</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;endDss;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>null;overrideChainByte;[dssLengthLocation + 3, chainByte]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>overrideChainByte</MethodName>
            <MethodComment>/** 
 * Override the default chaining byte with the chaining byte that is passed in.
 * @param pos the position on which the chaining byte is located
 * @param chainByte the chaining byte that overrides the default
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>chainByte</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [b=buffer.get(pos)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;put;[pos, b]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endDss</MethodName>
            <MethodComment>/** 
 * End DSS header by writing the length in the length location and setting the chain bit.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;endDss;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endDss</MethodName>
            <MethodComment>/** 
 * End DSS header by writing the length in the length location and setting the chain bit.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>finalizeLength</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endDdmAndDss</MethodName>
            <MethodComment>/** 
 * End final DDM and DSS header by writing the length in the length location
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;endDdm;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;endDss;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyDSSDataToEnd</MethodName>
            <MethodComment>/** 
 * Copy Data to End Create a buffer and copy from the position given to the end of data Note that the position given is treated as relative to the current DSS, for there may be other DSS blocks (chained, presumably) which are sitting unwritten in the buffer. The caller doesn't know this, though, and works only with the current DSS. getDSSLength, copyDSSDataToEnd, and truncateDSS work together to provide a sub-protocol for DRDAConnThread to use in its implementation of the LMTBLKPRC protocol. They enable the caller to determine when it has written too much data into the current DSS, to reclaim the extra data that won't fit, and to truncate that extra data once it has been reclaimed and stored elsewhere. Note that this support only works for the current DSS. Earlier, chained DSS blocks cannot be accessed using these methods. For additional background information, the interested reader should investigate bugs DERBY-491 and 492 at: http://issues.apache.org/jira/browse/DERBY-491 and http://issues.apache.org/jira/browse/DERBY-492
 * @param start
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [length=buffer.position() - start]</InnerVar>
                <InnerVar>byte[] [temp=new byte[length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[start]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;get;[temp]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startDdm</MethodName>
            <MethodComment>/** 
 * Mark the location of the length bytes for the collection so they can be updated later
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=buffer.position()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;position;[offset + 2]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDdm</MethodName>
            <MethodComment>/** 
 * Erase all writes for the current ddm and reset the top
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[markStack[top--]]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearBuffer</MethodName>
            <MethodComment>/** 
 * Clear the entire send buffer
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;clear;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>endDdm</MethodName>
            <MethodComment>/** 
 * End the current DDM
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [lengthLocation=markStack[--top]]</InnerVar>
                <InnerVar>int [length=buffer.position() - lengthLocation]</InnerVar>
                <InnerVar>int [extendedLengthByteCount=calculateExtendedLengthByteCount(length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;putShort;[lengthLocation, (short)length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDSSLength</MethodName>
            <MethodComment>/** 
 * Get the length of the current DSS block we're working on. This is used by the LMTBLKPRC protocol, which does its own conversational blocking protocol above the layer of the DRDA blocking. The LMTBLKPRC implementation (in DRDAConnThread) needs to be able to truncate a DSS block when splitting a QRYDTA response.
 * @return current DSS block length
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncateDSS</MethodName>
            <MethodComment>/** 
 * Truncate the current DSS. Before making this call, you should ensure that you have copied the data to be truncated somewhere else, by calling copyDSSDataToEnd
 * @param value DSS length
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[dssLengthLocation + value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeByte</MethodName>
            <MethodComment>/** 
 * Write byte
 * @param value   byte to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[(byte)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeNetworkShort</MethodName>
            <MethodComment>/** 
 * Write network short
 * @param value   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeNetworkInt</MethodName>
            <MethodComment>/** 
 * Write network int
 * @param value   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putInt;[value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBytes</MethodName>
            <MethodComment>/** 
 * Write byte array
 * @param buf byte array to be written
 * @param length  - length to write
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeBytes;[buf, 0, length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBytes</MethodName>
            <MethodComment>/** 
 * Write byte array
 * @param buf byte array to be written
 * @param start  - starting position
 * @param length  - length to write
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[length]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[buf, start, length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBytes</MethodName>
            <MethodComment>/** 
 * Write byte array
 * @param buf byte array to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeBytes;[buf, buf.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLDBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeLDBytes;[buf, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLDBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [writeLen=buf.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeShort;[writeLen]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeBytes;[buf, 0, writeLen]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeCodePoint4Bytes</MethodName>
            <MethodComment>/** 
 * Write code point and 4 bytes
 * @param codePoint - code point to write
 * @param value  - value to write after code point
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalar1Byte</MethodName>
            <MethodComment>/** 
 * Write scalar 1 byte object includes length, codepoint and value
 * @param codePoint - code point to write
 * @param value  - value to write after code point
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[5]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)0x0005]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[(byte)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalar2Bytes</MethodName>
            <MethodComment>/** 
 * Write scalar 2 byte object includes length, codepoint and value
 * @param codePoint - code point to write
 * @param value  - value to write after code point
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[6]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)0x0006]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalar2Bytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chainedWithSameCorrelator</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>EXTDTAInputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writeNullByte</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [spareDssLength=prepScalarStream(chainedWithSameCorrelator,codePoint,writeNullByte)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginDss</MethodName>
            <MethodComment>/** 
 * Begins a DSS stream (for writing LOB data).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chainedToNextStructure</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dssType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;beginDss;[dssType, false]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[dssLengthLocation, (short)0xFFFF]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[dssLengthLocation + 3, (byte)dssType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepScalarStream</MethodName>
            <MethodComment>/** 
 * prepScalarStream does the following prep for writing stream data: 1.  Flushes an existing DSS segment, if necessary 2.  Determines if extended length bytes are needed 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable If value of length was less than 0, this method processes streaming as Layer B Streaming. cf. page 315 of specification of DRDA, Version 3, Volume 3 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>chainedWithSameCorrelator</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>writeNullByte</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [nullIndicatorSize=writeNullByte ? 1 : 0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[DEFAULT_BUFFER_SIZE - buffer.position()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;beginDss;[chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeLengthCodePoint;[0x8004, codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doesRequestContainData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushScalarStreamSegment</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastSegment</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLengthCodePoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)length]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarHeader</MethodName>
            <MethodComment>/** 
 * Write scalar object header includes length and codepoint
 * @param codePoint - code point to write
 * @param dataLength - length of object data
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[dataLength + 4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)(dataLength + 4)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarString</MethodName>
            <MethodComment>/** 
 * Write scalar string object includes length, codepoint and value the string is converted into the appropriate codeset (EBCDIC)
 * @param codePoint - code point to write
 * @param string - string to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [stringLength=ccsidManager.getByteLength(string)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[(stringLength * 2) + 4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)(stringLength + 4)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>ccsidManager;convertFromJavaString;[string, buffer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarPaddedString</MethodName>
            <MethodComment>/** 
 * Write padded scalar string object includes length, codepoint and value the string is converted into the appropriate codeset (EBCDIC)
 * @param codePoint - code point to write
 * @param string - string to be written
 * @param paddedLength - length to pad string to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paddedLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [stringLength=ccsidManager.getByteLength(string)]</InnerVar>
                <InnerVar>int [fillLength=paddedLength - stringLength]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[paddedLength + 4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)(paddedLength + 4)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>ccsidManager;convertFromJavaString;[string, buffer]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padBytes;[ccsidManager.space, fillLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarPaddedString</MethodName>
            <MethodComment>/** 
 * Write padded scalar &lt;code&gt;DRDAString&lt;/code&gt; object value. The string is converted into the appropriate codeset.
 * @param drdaString string to be written
 * @param paddedLength length to pad string to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaString</ParamName>
                    <ParamType>DRDAString</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paddedLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [stringLength=drdaString.length()]</InnerVar>
                <InnerVar>int [fillLength=paddedLength - stringLength]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[paddedLength]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[drdaString.getBytes(), 0, stringLength]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padBytes;[ccsidManager.space, fillLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarPaddedBytes</MethodName>
            <MethodComment>/** 
 * Write padded scalar byte array object includes length, codepoint and value
 * @param codePoint - code point to write
 * @param buf - byte array to be written
 * @param paddedLength - length to pad string to
 * @param padByte - byte to be used for padding
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paddedLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>padByte</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[paddedLength + 4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)(paddedLength + 4)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[buf]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padBytes;[padByte, paddedLength - buf.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarPaddedBytes</MethodName>
            <MethodComment>/** 
 * Write padded scalar byte array object  value
 * @param buf - byte array to be written
 * @param paddedLength - length to pad string to
 * @param padByte - byte to be used for padding
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paddedLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>padByte</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[paddedLength]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[buf]</InnerMethodInvoke>
                <InnerMethodInvoke>null;padBytes;[padByte, paddedLength - buf.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeScalarBytes</MethodName>
            <MethodComment>/** 
 * Write scalar byte array object includes length, codepoint and value
 * @param codePoint - code point to write
 * @param buf - byte array to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>codePoint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[buf.length + 4]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)(buf.length + 4)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)codePoint]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[buf]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeShort</MethodName>
            <MethodComment>/** 
 * Write platform short
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeNetworkShort;[v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeShort</MethodName>
            <MethodComment>/** 
 * Write boolean as short
 * @param b boolean value true = 1 false = 0
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeNetworkShort;[b ? 1 : 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeInt</MethodName>
            <MethodComment>/** 
 * Write platform int
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeNetworkInt;[v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLong</MethodName>
            <MethodComment>/** 
 * Write platform long
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[8]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putLong;[v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFloat</MethodName>
            <MethodComment>/** 
 * Write platform float
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeInt;[Float.floatToIntBits(v)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeDouble</MethodName>
            <MethodComment>/** 
 * Write platform double
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeLong;[Double.doubleToLongBits(v)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBoolean</MethodName>
            <MethodComment>/** 
 * Write platform boolean
 * @param v   value to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeByte;[v ? 1 : 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLDString</MethodName>
            <MethodComment>/** 
 * Write length delimited string
 * @param s value to be written with integer
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeLDString;[s, 0, null, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeUDT</MethodName>
            <MethodComment>/** 
 * Write a value of a user defined type.
 * @param val object to be written
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [buffer=null]</InnerVar>
                <InnerVar>int [length=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>maxEncodedLength</MethodName>
            <MethodComment>/** 
 * Find the maximum number of bytes needed to represent the string in the default encoding.
 * @param s the string to encode
 * @return an upper limit for the number of bytes needed to encode thestring
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeLDString</MethodName>
            <MethodComment>/** 
 * Write length delimited string
 * @param s              value to be written with integer
 * @param index          column index to put in warning
 * @param stmt           the executing statement (null if not invoked aspart of statement execution)
 * @param isParameter    true if the value written is for an outputparameter in a procedure call
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isParameter</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [lengthPos=buffer.position()]</InnerVar>
                <InnerVar>int [stringPos=lengthPos + 2]</InnerVar>
                <InnerVar>int [maxByteLength=MAX_VARCHAR_BYTE_LENGTH]</InnerVar>
                <InnerVar>boolean [warnOnTruncation=true]</InnerVar>
                <InnerVar>AppRequester [appRequester=agent.getSession().appRequester]</InnerVar>
                <InnerVar>int [byteLength=buffer.position() - stringPos]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[2]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;position;[stringPos]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeString;[s]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[lengthPos, (short)byteLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isContinuationByte</MethodName>
            <MethodComment>/** 
 * Check if a byte value represents a continuation byte in a UTF-8 byte sequence. Continuation bytes in UTF-8 always match the bit pattern {@code 10xxxxxx}.
 * @param b the byte to check
 * @return {@code true} if {@code b} is a continuation byte, or{@code false} if it is the first byte in a UTF-8 sequence
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeString</MethodName>
            <MethodComment>/** 
 * Write string with default encoding
 * @param s value to be written
 * @exception DRDAProtocolException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CharBuffer [input=CharBuffer.wrap(s)]</InnerVar>
                <InnerVar>CoderResult [res=encoder.encode(input,buffer,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[maxEncodedLength(s)]</InnerMethodInvoke>
                <InnerMethodInvoke>encoder;reset;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padBytes</MethodName>
            <MethodComment>/** 
 * Write pad bytes using spaceChar
 * @param val value to be written
 * @param length      length to be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=buffer.position()]</InnerVar>
                <InnerVar>int [end=offset + length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Arrays;fill;[buffer.array(), offset, end, val]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;position;[end]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flush</MethodName>
            <MethodComment>/** 
 * Flush buffer to outputstream
 * @exception IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;flush;[agent.getOutputStream()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.io.IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flush</MethodName>
            <MethodComment>/** 
 * Flush buffer to specified stream
 * @param socketOutputStream
 * @exception IOException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>socketOutputStream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [bytes=buffer.array()]</InnerVar>
                <InnerVar>int [length=buffer.position()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.io.IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>beginDss</MethodName>
            <MethodComment>/** 
 * Write DSS header DSS Header format is 2 bytes - length 1 byte  - 'D0'  - indicates DDM data 1 byte  - DSS format |---|---------|----------| | 0 |   flags | type     | |---|---------|----------| | 0 | 1 2   3 | 4 5 6 7  | |---|---------|----------| bit 0 - '0' bit 1 - '0' - unchained, '1' - chained bit 2 - '0' - do not continue on error, '1' - continue on error bit 3 - '0' - next DSS has different correlator, '1' - next DSS has same correlator type - 1 - Request DSS - 2 - Reply DSS - 3 - Object DSS - 4 - Communications DSS - 5 - Request DSS where no reply is expected
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dssType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ensureLen</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[dssLengthLocation + 2]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[(byte)0xD0]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;put;[(byte)(dssType | DssConstants.DSSCHAIN_SAME_ID)]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;putShort;[(short)correlationID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finalizeDssLength</MethodName>
            <MethodComment>/** 
 * Finish a DSS Layer A object. The length of dss object will be calculated based on the difference between the start of the dss, saved on the beginDss call, and the current offset into the buffer which marks the end of the data.  In the event the length requires the use of continuation Dss headers, one for each 32k chunk of data, the data will be shifted and the continuation headers will be inserted with the correct values as needed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [offset=buffer.position()]</InnerVar>
                <InnerVar>int [totalSize=offset - dssLengthLocation]</InnerVar>
                <InnerVar>int [bytesRequiringContDssHeader=totalSize - DssConstants.MAX_DSS_LENGTH]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;putShort;[dssLengthLocation, (short)totalSize]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExtendedLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>size</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numbytes=calculateExtendedLengthByteCount(size)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>calculateExtendedLengthByteCount</MethodName>
            <MethodComment>/** 
 * Calculate extended length byte count which follows the DSS header for extended DDM.
 * @param ddmSize - size of DDM command
 * @return minimum number of extended length bytes needed. 0 indicates noextended length needed.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ddmSize</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureLength</MethodName>
            <MethodComment>/** 
 * Ensure that there is space in the buffer
 * @param length space required
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeBigDecimal</MethodName>
            <MethodComment>/** 
 * Write a Java &lt;code&gt;java.math.BigDecimal&lt;/code&gt; to packed decimal bytes.
 * @param b BigDecimal to write
 * @param precision Precision of decimal or numeric type
 * @param scale declared scale
 * @exception SQLException Thrown if # digits &amp;gt; 31
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>BigDecimal</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [encodedLength=precision / 2 + 1]</InnerVar>
                <InnerVar>int [offset=buffer.position()]</InnerVar>
                <InnerVar>int [declaredPrecision=precision]</InnerVar>
                <InnerVar>int [declaredScale=scale]</InnerVar>
                <InnerVar>String [unscaledStr=b.unscaledValue().abs().toString()]</InnerVar>
                <InnerVar>int [bigPrecision=unscaledStr.length()]</InnerVar>
                <InnerVar>int [bigScale=b.scale()]</InnerVar>
                <InnerVar>int [bigWholeIntegerLength=bigPrecision - bigScale]</InnerVar>
                <InnerVar>int [zeroBase='0']</InnerVar>
                <InnerVar>int [packedIndex=declaredPrecision - 1]</InnerVar>
                <InnerVar>int [bigIndex]</InnerVar>
                <InnerVar>byte [signByte=(byte)((b.signum() &gt;= 0) ? 12 : 13)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureLength;[encodedLength]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;position;[offset + encodedLength]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>socketOutputStream</ParamName>
                    <ParamType>java.io.OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;sendBytes;[socketOutputStream, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.io.IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sendBytes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>socketOutputStream</ParamName>
                    <ParamType>java.io.OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flashStream</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte[] [bytes=buffer.array()]</InnerVar>
                <InnerVar>int [length=buffer.position()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetChainState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>java.io.IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetChainState</MethodName>
            <MethodComment>/** 
 * Reset any chaining state that needs to be reset at time of the send
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrelationID</MethodName>
            <MethodComment>/** 
 * Looks at chaining info for previous DSS written, and use that to figure out what the correlation id for the current DSS should be.  Return that correlation id.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [cId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finalizeChain</MethodName>
            <MethodComment>/** 
 * Finalize the current DSS chain and send it if needed. Updates the chaining state of the most recently-written- to-buffer DSS to correspond to the most recently-read- from-client request.  If that chaining state indicates we've reached the end of a chain, then we go ahead and send the buffer across the wire.
 * @param socketOutputStream Output stream to which we're flushing.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currChainByte</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>socketOutputStream</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetChainState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DRDAProtocolException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markDSSClearPoint</MethodName>
            <MethodComment>/** 
 * Takes note of the location of the most recently completed DSS in the buffer, and then returns the current offset. This method is used in conjunction with "clearDSSesBackToMark" to allow for DRDAConnThread to "back-out" DSSes in the event of errors.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDSSesBackToMark</MethodName>
            <MethodComment>/** 
 * Does a logical "clear" of everything written to the buffer after the received mark.  It's assumed that this method will be used in error cases when we've started writing one or more DSSes, but then hit an error and need to back out.  After backing out, we'll always need to write _something_ back to the client to indicate an error (typically, we just write an SQLCARD) but what exactly gets written is handled in DRDAConnThread.  Here, we just do the necessary prep so that whatever comes next will succeed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mark</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;position;[mark]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekStream</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>in;mark;[1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLayerBStreamingBufferSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>placeLayerBStreamingBuffer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>original</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=getLayerBStreamingBufferSize()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>