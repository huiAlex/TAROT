<Class>
    <Id>519</Id>
    <Package>org.apache.derby.impl.sql.catalog</Package>
    <ClassName>DataDictionaryImpl</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DataDictionary</SuperInterface>
        <SuperInterface>CacheableFactory</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
        <SuperInterface>ModuleSupportable</SuperInterface>
        <SuperInterface>java.security.PrivilegedAction</SuperInterface>
        <SuperInterface>Properties</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataDictionaryImpl  /** 
 * Standard database implementation of the data dictionary that stores the information in the system catalogs.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>CFG_SYSTABLES_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSTABLES_INDEX1_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSTABLES_INDEX2_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCOLUMNS_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCOLUMNS_INDEX1_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCOLUMNS_INDEX2_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCONGLOMERATES_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCONGLOMERATES_INDEX1_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCONGLOMERATES_INDEX2_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSCONGLOMERATES_INDEX3_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSSCHEMAS_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSSCHEMAS_INDEX1_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CFG_SYSSCHEMAS_INDEX2_ID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCONGLOMERATES_CORE_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSTABLES_CORE_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSCOLUMNS_CORE_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSSCHEMAS_CORE_NUM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NUM_CORE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFUN_FUNCTIONS</FieldName>
            <FieldType>String[][]</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFUN_DETERMINISTIC_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFUN_VARARGS_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SYSFUN_FIRST_PARAMETER_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sysfunDescriptors</FieldName>
            <FieldType>AliasDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>coreInfo</FieldName>
            <FieldType>TabInfoImpl[]</FieldType>
        </Field>
        <Field>
            <FieldName>systemSchemaDesc</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>sysIBMSchemaDesc</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>declaredGlobalTemporaryTablesSchemaDesc</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>systemUtilSchemaDesc</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>nonCoreNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>NUM_NONCORE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>systemSchemaNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>dictionaryVersion</FieldName>
            <FieldType>DD_Version</FieldType>
        </Field>
        <Field>
            <FieldName>softwareVersion</FieldName>
            <FieldType>DD_Version</FieldType>
        </Field>
        <Field>
            <FieldName>authorizationDatabaseOwner</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>usesSqlAuthorization</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>noncoreInfo</FieldName>
            <FieldType>TabInfoImpl[]</FieldType>
        </Field>
        <Field>
            <FieldName>dataDescriptorGenerator</FieldName>
            <FieldType>DataDescriptorGenerator</FieldType>
        </Field>
        <Field>
            <FieldName>dvf</FieldName>
            <FieldType>DataValueFactory</FieldType>
        </Field>
        <Field>
            <FieldName>af</FieldName>
            <FieldType>AccessFactory</FieldType>
        </Field>
        <Field>
            <FieldName>exFactory</FieldName>
            <FieldType>ExecutionFactory</FieldType>
        </Field>
        <Field>
            <FieldName>uuidFactory</FieldName>
            <FieldType>UUIDFactory</FieldType>
        </Field>
        <Field>
            <FieldName>indexRefresher</FieldName>
            <FieldType>IndexStatisticsDaemon</FieldType>
        </Field>
        <Field>
            <FieldName>startupParameters</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>engineType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>booting</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>bootingTC</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>dmgr</FieldName>
            <FieldType>DependencyManager</FieldType>
        </Field>
        <Field>
            <FieldName>OIDTdCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>nameTdCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>spsNameCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>sequenceGeneratorCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>spsIdHash</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>spsIdHash</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>tdCacheSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stmtCacheSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>seqgenCacheSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>permissionsCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>permissionsCacheSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>cacheCoordinator</FieldName>
            <FieldType>ShExLockable</FieldType>
        </Field>
        <Field>
            <FieldName>lockFactory</FieldName>
            <FieldType>LockFactory</FieldType>
        </Field>
        <Field>
            <FieldName>cacheMode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ddlUsers</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>readersInDDLMode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sequenceIDs</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>sequenceIDs</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>readOnlyUpgrade</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexStatsUpdateDisabled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexStatsUpdateLogging</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexStatsUpdateTracing</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>systemSQLNameNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>calendarForLastSystemSQLName</FieldName>
            <FieldType>GregorianCalendar</FieldType>
        </Field>
        <Field>
            <FieldName>timeForLastSystemSQLName</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>sysUtilProceduresWithPublicAccess</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>sysUtilFunctionsWithPublicAccess</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>collationTypeOfSystemSchemas</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>collationTypeOfUserSchemas</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>EXISTS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>spsSet</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>colPrivTypeMap</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>colPrivTypeMapForGrant</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>DIAG_VTI_TABLE_CLASSES</FieldName>
            <FieldType>String[][]</FieldType>
        </Field>
        <Field>
            <FieldName>DIAG_VTI_TABLE_FUNCTION_CLASSES</FieldName>
            <FieldType>String[][]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DataDictionaryImpl</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canSupport</MethodName>
            <MethodComment>/** 
 * This is the data dictionary implementation for the standard database engine.
 * @return true if this service requested is for a database engine.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment>/** 
 * Start-up method for this instance of the data dictionary.
 * @param startParams	The start-up parameters
 * @exception StandardException	Thrown if the module fails to start
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionFactory [langConnFactory=(LanguageConnectionFactory)bootServiceModule(create,this,LanguageConnectionFactory.MODULE,startParams)]</InnerVar>
                <InnerVar>String [value=startParams.getProperty(Property.LANG_TD_CACHE_SIZE)]</InnerVar>
                <InnerVar>CacheFactory [cf=(CacheFactory)startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory)]</InnerVar>
                <InnerVar>ContextService [csf=getContextService()]</InnerVar>
                <InnerVar>ContextManager [cm=csf.getCurrentContextManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getBuiltinSystemSchemas;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initializeCatalogInfo;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setDependencyManager;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findDefaultBuiltinAlgorithm</MethodName>
            <MethodComment>/** 
 * Find the default message digest algorithm to use for BUILTIN authentication on this database.
 * @return the name of the algorithm to use as the default
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPermissionsCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CacheManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDependencyManager</MethodName>
            <MethodComment>/** 
 * sets the dependencymanager associated with this dd. subclasses can override this to install their own funky dependency manager.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependencyManager</MethodName>
            <MethodComment>/** 
 * returns the dependencymanager associated with this datadictionary.
 * @see DataDictionary#getDependencyManager
 */
</MethodComment>
            <ReturnType>DependencyManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment>/** 
 * Stop this module.  In this case, nothing needs to be done.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newCacheable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>CacheManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startReading</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.dictionary.DataDictionary#startReading
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bindCount=lcc.incrementBindCount()]</InnerVar>
                <InnerVar>int [localCacheMode]</InnerVar>
                <InnerVar>boolean [needRetry=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doneReading</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [bindCount=lcc.decrementBindCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startWriting</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [blocked=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transactionFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCacheMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCacheMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDescriptorGenerator</MethodName>
            <MethodComment>/** 
 * Get a DataDescriptorGenerator, through which we can create objects to be stored in the DataDictionary.
 * @return	A DataDescriptorGenerator
 */
</MethodComment>
            <ReturnType>DataDescriptorGenerator</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuthorizationDatabaseOwner</MethodName>
            <MethodComment>/** 
 * Get authorizationID of Database Owner
 * @return	authorizationID
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesSqlAuthorization</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#usesSqlAuthorization
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationTypeOfSystemSchemas</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getCollationTypeOfSystemSchemas() 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationTypeOfUserSchemas</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getCollationTypeOfUserSchemas() 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Get a DataValueFactory, through which we can create data value objects.
 * @return	A DataValueFactory
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecutionFactory</MethodName>
            <MethodComment>/** 
 * Get ExecutionFactory associated with this database.
 * @return	The ExecutionFactory
 */
</MethodComment>
            <ReturnType>ExecutionFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltinSystemSchemas</MethodName>
            <MethodComment>/** 
 * Set up the builtin schema descriptors for system schemas.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makePasswordHasher</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PasswordHasher</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [supportConfigurableHash=checkVersion(DataDictionary.DD_VERSION_DERBY_10_6,null)]</InnerVar>
                <InnerVar>boolean [supportKeyStretching=checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateRandomSalt</MethodName>
            <MethodComment>/** 
 * Generate an array of random bytes to use as salt when hashing credentials.
 * @param props database properties that possibly specify the desiredlength of the salt
 * @return random bytes
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [saltLength=getIntProperty(props,Property.AUTHENTICATION_BUILTIN_SALT_LENGTH,Property.AUTHENTICATION_BUILTIN_SALT_LENGTH_DEFAULT,0,Integer.MAX_VALUE)]</InnerVar>
                <InnerVar>SecureRandom [random=new SecureRandom()]</InnerVar>
                <InnerVar>byte[] [salt=new byte[saltLength]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>random;nextBytes;[salt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIntProperty</MethodName>
            <MethodComment>/** 
 * Get the value of an integer property.
 * @param props database properties
 * @param key the key of the property
 * @param defaultValue which value to return if the property is not set,or if the property value is not in the valid range
 * @param minValue lowest property value to accept
 * @param maxValue highest property value to accept
 * @return the value of the property
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaultValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>minValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [sVal=(String)PropertyUtil.getPropertyFromSet(props,key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the system schema. Schema descriptors include  authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemUtilSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the SYSCS_UTIL system schema.  Schema descriptors include authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSysIBMSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the SYSIBM schema. Schema descriptors include  authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeclaredGlobalTemporaryTablesSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the declared global temporary table schema which  is always named "SESSION".
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSystemSchemaName</MethodName>
            <MethodComment>/** 
 * Determine whether a string is the name of the system schema.
 * @param name
 * @return	true or false
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named schema. Schema descriptors include authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.  Will check default schema for a match before scanning a system table.
 * @param schemaName	The name of the schema we're interested in. Must not be null.
 * @param tc			TransactionController
 * @param raiseError    whether an exception should be thrown if the schema does not exist.
 * @return	The descriptor for the schema. Can be null (not found) if raiseError is false.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>raiseError</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [sd=locateSchemaRow(schemaName,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateSchemaRow</MethodName>
            <MethodComment>/** 
 * Get the target schema by searching for a matching row in SYSSCHEMAS by schemaId.  Read only scan.
 * @param schemaId		The id of the schema we're interested in.If non-null, overrides schemaName
 * @param tc			TransactionController.  If null, oneis gotten off of the language connection context.
 * @return	The row for the schema
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateSchemaRow</MethodName>
            <MethodComment>/** 
 * Get the target schema by searching for a matching row in SYSSCHEMAS by schemaId.  Read only scan.
 * @param schemaId		The id of the schema we're interested in.If non-null, overrides schemaName
 * @param isolationLevel Use this explicit isolation level. OnlyISOLATION_REPEATABLE_READ (normal usage) or ISOLATION_READ_UNCOMMITTED (corner cases) supported for now.
 * @param tc			TransactionController.  If null, oneis gotten off of the language connection context.
 * @return	The row for the schema
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateSchemaRowBody</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSSCHEMAS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locateSchemaRow</MethodName>
            <MethodComment>/** 
 * Get the target schema by searching for a matching row in SYSSCHEMAS by schema name.  Read only scan.
 * @param schemaName	The name of the schema we're interested in.If schemaId is null, used to qual.
 * @param tc			TransactionController.  If null, oneis gotten off of the language connection context.
 * @return	The row for the schema
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSSCHEMAS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, schemaNameOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the SchemaDescriptor for the given schema identifier. 
 * @param schemaId  The id of the schema we're interested in.
 * @param tc        The transaction controller to us when scanningSYSSCHEMAS
 * @return  The descriptor for the schema, null if no such schema exists.
 * @exception StandardException     Thrown on failure
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the SchemaDescriptor for the given schema identifier.
 * @param schemaId the uuid of the schema we want a descriptor for
 * @param isolationLevel use this explicit isolation level. OnlyISOLATION_REPEATABLE_READ (normal usage) or ISOLATION_READ_UNCOMMITTED (corner cases) supported for now.
 * @param tc transaction controller
 * @throws StandardException thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptorBody</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsSchemaOwnedBy</MethodName>
            <MethodComment>/** 
 * Return true of there exists a schema whose authorizationId equals authid, i.e.  SYS.SYSSCHEMAS contains a row whose column (AUTHORIZATIONID) equals authid.
 * @param authid authorizationId
 * @param tc TransactionController
 * @return true iff there is a matching schema
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSSCHEMAS_CORE_NUM]]</InnerVar>
                <InnerVar>SYSSCHEMASRowFactory [rf=(SYSSCHEMASRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=tc.openConglomerate(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ)]</InnerVar>
                <InnerVar>DataValueDescriptor [authIdOrderable=new SQLVarchar(authid)]</InnerVar>
                <InnerVar>ScanQualifier[][] [scanQualifier=exFactory.getScanQualifier(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ,(FormatableBitSet)null,(DataValueDescriptor[])null,0,scanQualifier,(DataValueDescriptor[])null,0)]</InnerVar>
                <InnerVar>boolean [result=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanQualifier[0][0];setQualifier;[SYSSCHEMASRowFactory.SYSSCHEMAS_SCHEMAAID - 1, authIdOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDescriptor</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#addDescriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>duplicatesAllowed</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=(catalogNumber &lt; NUM_CORE) ? coreInfo[catalogNumber] : getNonCoreTI(catalogNumber)]</InnerVar>
                <InnerVar>ExecRow [row=ti.getCatalogRowFactory().makeRow(td,parent)]</InnerVar>
                <InnerVar>int [insertRetCode=ti.insertRow(row,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>duplicateDescriptorException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tuple</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDescriptorArray</MethodName>
            <MethodComment>/** 
 * array version of addDescriptor.
 * @see DataDictionary#addDescriptor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TupleDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowDuplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=(catalogNumber &lt; NUM_CORE) ? coreInfo[catalogNumber] : getNonCoreTI(catalogNumber)]</InnerVar>
                <InnerVar>CatalogRowFactory [crf=ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow[] [rl=new ExecRow[td.length]]</InnerVar>
                <InnerVar>int [insertRetCode=ti.insertRowList(rl,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrant</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#dropRoleGrant
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [roleNameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [granteeOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [grantorOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, roleNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, granteeOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[3, grantorOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSROLESRowFactory.SYSROLES_INDEX_ID_EE_OR_IDX]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Drop the descriptor for a schema, given the schema's name
 * @param schemaName	The name of the schema to drop
 * @param tc			TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSSCHEMAS_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, schemaNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named table within the given schema. If the schema parameter is NULL, it looks for the table in the current (default) schema. Table descriptors include object ids, object types (table, view, etc.)
 * @param tableName	The name of the table to get the descriptor for
 * @param schema	The descriptor for the schema the table lives in.If null, use the system schema.
 * @return	The descriptor for the table, null if table does notexist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [retval=null]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=(schema == null) ? getSystemSchemaDescriptor() : schema]</InnerVar>
                <InnerVar>UUID [schemaUUID=sd.getUUID()]</InnerVar>
                <InnerVar>TableKey [tableKey=new TableKey(schemaUUID,tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptorIndex1Scan</MethodName>
            <MethodComment>/** 
 * Scan systables_index1 (tablename, schemaid) for a match.
 * @return TableDescriptor	The matching descriptor, if any.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaUUID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [tableNameOrderable]</InnerVar>
                <InnerVar>TableDescriptor [td]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedTableDescriptor</MethodName>
            <MethodComment>/** 
 * This method can get called from the DataDictionary cache.
 * @param tableKey	The TableKey of the table
 * @return	The descriptor for the table, null if the table doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableKey</ParamName>
                    <ParamType>TableKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the table with the given UUID. NOTE: I'm assuming that the object store will define an UUID for persistent objects. I'm also assuming that UUIDs are unique across schemas, and that the object store will be able to do efficient lookups across schemas (i.e. that no schema descriptor parameter is needed).
 * @param tableID	The UUID of the table to get the descriptor for
 * @return	The descriptor for the table, null if the table doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OIDTDCacheable [cacheEntry]</InnerVar>
                <InnerVar>TableDescriptor [retval=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedTableDescriptor</MethodName>
            <MethodComment>/** 
 * This method can get called from the DataDictionary cache.
 * @param tableID	The UUID of the table to get the descriptor for
 * @return	The descriptor for the table, null if the table doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptorIndex2Scan</MethodName>
            <MethodComment>/** 
 * Scan systables_index2 (tableid) for a match.
 * @return TableDescriptor	The matching descriptor, if any.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [tableIDOrderable]</InnerVar>
                <InnerVar>TableDescriptor [td]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishTableDescriptor</MethodName>
            <MethodComment>/** 
 * Finish filling in the TableDescriptor. (Build the various lists that hang off the TD.)
 * @param td	The TableDescriptor.
 * @return The completed TableDescriptor.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSchemaEmpty</MethodName>
            <MethodComment>/** 
 * Indicate whether there is anything in the  particular schema.  Checks for tables in the the schema, on the assumption that there cannot be any other objects in a schema w/o a table.
 * @param sd descriptor
 * @return true/false
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIdOrderable]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionCompile()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSchemaReferenced</MethodName>
            <MethodComment>/** 
 * Is the schema id referenced by the system table in question? Currently assumes that the schema id is in an index. NOTE: could be generalized a bit, and possibly used elsewhere...
 * @param tc	transaction controller
 * @param ti	table info for the system table
 * @param indexId	index id
 * @param indexCol	1 based index column
 * @param schemaIdOrderable	the schemaid in a char orderable
 * @return true if there is a reference to this schema
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexCol</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaIdOrderable</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC=null]</InnerVar>
                <InnerVar>ScanController [scanController=null]</InnerVar>
                <InnerVar>boolean [foundRow]</InnerVar>
                <InnerVar>FormatableBitSet [colToCheck=new FormatableBitSet(indexCol)]</InnerVar>
                <InnerVar>ScanQualifier[][] [qualifier=exFactory.getScanQualifier(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>colToCheck;set;[indexCol - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>qualifier[0][0];setQualifier;[indexCol - 1, schemaIdOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTableDescriptor</MethodName>
            <MethodComment>/** 
 * Drop the table descriptor.
 * @param td	The table descriptor to drop
 * @param schema		A descriptor for the schema the tableis a part of.  If this parameter is NULL, then the table is part of the current (default) schema
 * @param tc			TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [tableNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, tableNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow1;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSTABLESRowFactory.SYSTABLES_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateLockGranularity</MethodName>
            <MethodComment>/** 
 * Update the lockGranularity for the specified table.
 * @param td				The TableDescriptor for the table
 * @param schema			The SchemaDescriptor for the table
 * @param lockGranularity	The new lockGranularity
 * @param tc				The TransactionController to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockGranularity</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [tableNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSTABLESRowFactory [rf=(SYSTABLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow1=exFactory.getIndexableRow(2)]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[2]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, tableNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow1;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow1, row, SYSTABLESRowFactory.SYSTABLES_INDEX1_ID, bArray, (int[])null, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgradeCLOBGETSUBSTRING_10_6</MethodName>
            <MethodComment>/** 
 * 10.6 upgrade logic to update the return type of SYSIBM.CLOBGETSUBSTRING. The length of the return type was changed in 10.5 but old versions of the metadata were not upgraded at that time. See DERBY-4214.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSALIASES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(3)]</InnerVar>
                <InnerVar>DataValueDescriptor [aliasNameOrderable=new SQLVarchar("CLOBGETSUBSTRING")]</InnerVar>
                <InnerVar>DataValueDescriptor [nameSpaceOrderable=new SQLChar(new String(new char[]{AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR}))]</InnerVar>
                <InnerVar>AliasDescriptor [oldAD=getDescriptorViaIndex(SYSALIASESRowFactory.SYSALIASES_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,AliasDescriptor.class,true,TransactionController.ISOLATION_REPEATABLE_READ,tc)]</InnerVar>
                <InnerVar>RoutineAliasInfo [oldRai=(RoutineAliasInfo)oldAD.getAliasInfo()]</InnerVar>
                <InnerVar>TypeDescriptor [newReturnType=DataTypeDescriptor.getCatalogType(Types.VARCHAR,Limits.MAX_CLOB_RETURN_LEN)]</InnerVar>
                <InnerVar>RoutineAliasInfo [newRai=new RoutineAliasInfo(oldRai.getMethodName(),oldRai.getParameterCount(),oldRai.getParameterNames(),oldRai.getParameterTypes(),oldRai.getParameterModes(),oldRai.getMaxDynamicResultSets(),oldRai.getParameterStyle(),oldRai.getSQLAllowed(),oldRai.isDeterministic(),oldRai.hasVarargs(),oldRai.hasDefinersRights(),oldRai.calledOnNullInput(),newReturnType)]</InnerVar>
                <InnerVar>AliasDescriptor [newAD=new AliasDescriptor(this,oldAD.getUUID(),oldAD.getObjectName(),oldAD.getSchemaUUID(),oldAD.getJavaClassName(),oldAD.getAliasType(),oldAD.getNameSpace(),oldAD.getSystemAlias(),newRai,oldAD.getSpecificName())]</InnerVar>
                <InnerVar>ExecRow [newRow=ti.getCatalogRowFactory().makeRow(newAD,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, new SQLChar(SchemaDescriptor.SYSIBM_SCHEMA_UUID)]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, aliasNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[3, nameSpaceOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow, newRow, SYSALIASESRowFactory.SYSALIASES_INDEX1_ID, new boolean[]{false,false,false}, (int[])null, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgradeSYSROUTINEPERMS_10_6</MethodName>
            <MethodComment>/** 
 * 10.6 upgrade logic to update the permissions granted to SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE. If a 10.0 database was upgraded to 10.2, 10.3, or 10.4, then there will be an extra permissions tuple in SYSROUTINEPERMS--that tuple will have a null grantor field. We must delete this tuple. See DERBY-4215.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [aliasTI=getNonCoreTI(SYSALIASES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [aliasKeyRow=exFactory.getIndexableRow(3)]</InnerVar>
                <InnerVar>DataValueDescriptor [aliasNameOrderable=new SQLVarchar("SYSCS_INPLACE_COMPRESS_TABLE")]</InnerVar>
                <InnerVar>DataValueDescriptor [nameSpaceOrderable=new SQLChar(new String(new char[]{AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR}))]</InnerVar>
                <InnerVar>AliasDescriptor [oldAD=getDescriptorViaIndex(SYSALIASESRowFactory.SYSALIASES_INDEX1_ID,aliasKeyRow,(ScanQualifier[][])null,aliasTI,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,AliasDescriptor.class,true,TransactionController.ISOLATION_REPEATABLE_READ,tc)]</InnerVar>
                <InnerVar>UUID [aliasID=oldAD.getUUID()]</InnerVar>
                <InnerVar>TabInfoImpl [rpTI=getNonCoreTI(SYSROUTINEPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [rpKeyRow=exFactory.getIndexableRow(3)]</InnerVar>
                <InnerVar>int [deleteCount=rpTI.deleteRow(tc,rpKeyRow,SYSROUTINEPERMSRowFactory.GRANTEE_ALIAS_GRANTOR_INDEX_NUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>aliasKeyRow;setColumn;[1, new SQLChar(SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID)]</InnerMethodInvoke>
                <InnerMethodInvoke>aliasKeyRow;setColumn;[2, aliasNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>aliasKeyRow;setColumn;[3, nameSpaceOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>rpKeyRow;setColumn;[1, new SQLVarchar("PUBLIC")]</InnerMethodInvoke>
                <InnerMethodInvoke>rpKeyRow;setColumn;[2, new SQLChar(aliasID.toString())]</InnerMethodInvoke>
                <InnerMethodInvoke>rpKeyRow;setColumn;[3, new SQLVarchar((String)null)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptorByDefaultId</MethodName>
            <MethodComment>/** 
 * Get a ColumnDescriptor given its Default ID.
 * @param uuid	The UUID of the default
 * @return The ColumnDescriptor for the column.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptorsScan</MethodName>
            <MethodComment>/** 
 * Populate the ColumnDescriptorList for the specified TableDescriptor. MT synchronization: it is assumed that the caller has synchronized on the CDL in the given TD.
 * @param td				The TableDescriptor.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getColumnDescriptorsScan;[td.getUUID(), td.getColumnDescriptorList(), td]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptorsScan</MethodName>
            <MethodComment>/** 
 * Populate the ColumnDescriptorList for the specified TableDescriptor. MT synchronization: it is assumed that the caller has synchronized on the CDL in the given TD.
 * @param uuid				The referencing UUID
 * @param cdl			The column descriptor list
 * @param td				The parent tuple descriptor
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [cd]</InnerVar>
                <InnerVar>ColumnDescriptorList [cdlCopy=new ColumnDescriptorList()]</InnerVar>
                <InnerVar>DataValueDescriptor [refIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, refIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID, keyRow, (ScanQualifier[][])null, ti, td, cdl, ColumnDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Given a column name and a table ID, drops the column descriptor from the table.
 * @param tableID	The UUID of the table to drop the column from
 * @param columnName	The name of the column to drop
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [columnNameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIdOrderable]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, columnNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropColumnDescriptorCore;[tc, keyRow]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllColumnDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all column descriptors from the given table.  Useful for DROP TABLE.
 * @param tableID	The UUID of the table from which to dropall the column descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [tableIdOrderable]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropColumnDescriptorCore;[tc, keyRow]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllTableAndColPermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all table and column permission descriptors for the given table.
 * @param tableID	The UUID of the table from which to dropall the permission descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [tableIdOrderable]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropTablePermDescriptor;[tc, keyRow]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropColumnPermDescriptor;[tc, keyRow]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSYSCOLPERMSforAddColumnToUserTable</MethodName>
            <MethodComment>/** 
 * Need to update SYSCOLPERMS for a given table because a new column has  been added to that table. SYSCOLPERMS has a column called "COLUMNS" which is a bit map for all the columns in a given user table. Since ALTER TABLE .. ADD COLUMN .. has added one more column, we need to expand "COLUMNS" for that new column Currently, this code gets called during execution phase of ALTER TABLE .. ADD COLUMN .. 
 * @param tableID	The UUID of the table to which a column has been added
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;rewriteSYSCOLPERMSforAlterTable;[tableID, tc, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSYSCOLPERMSforDropColumn</MethodName>
            <MethodComment>/** 
 * Update SYSCOLPERMS due to dropping a column from a table. Since ALTER TABLE .. DROP COLUMN .. has removed a column from the table, we need to shrink COLUMNS by removing the corresponding bit position, and shifting all the subsequent bits "left" one position.
 * @param tableID	The UUID of the table from which a col has been dropped
 * @param tc		TransactionController for the transaction
 * @param columnDescriptor   Information about the dropped column
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDescriptor</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;rewriteSYSCOLPERMSforAlterTable;[tableID, tc, columnDescriptor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rewriteSYSCOLPERMSforAlterTable</MethodName>
            <MethodComment>/** 
 * Workhorse for ALTER TABLE-driven mods to SYSCOLPERMS This method finds all the SYSCOLPERMS rows for this table. Then it iterates through each row, either adding a new column to the end of the table, or dropping a column from the table, as appropriate. It updates each SYSCOLPERMS row to store the new COLUMNS value.
 * @param tableID	The UUID of the table being altered
 * @param tc		TransactionController for the transaction
 * @param columnDescriptor   Dropped column info, or null if adding
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDescriptor</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ColPermsDescriptor&gt; [permissionDescriptorsList]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIDOrderable=getIDValueAsCHAR(tableID)]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCOLPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSCOLPERMSRowFactory [rf=(SYSCOLPERMSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
                <InnerVar>ExecRow [curRow]</InnerVar>
                <InnerVar>ExecIndexRow [uuidKey]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[SYSCOLPERMSRowFactory.TOTAL_NUM_OF_INDEXES]]</InnerVar>
                <InnerVar>int[] [colsToUpdate={SYSCOLPERMSRowFactory.COLUMNS_COL_NUM}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSCOLPERMSRowFactory.TABLEID_INDEX_NUM, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, permissionDescriptorsList, ColPermsDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removePermEntryInCache</MethodName>
            <MethodComment>/** 
 * Remove PermissionsDescriptor from permissions cache if present
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>perm</ParamName>
                    <ParamType>PermissionsDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Cacheable [cacheEntry=getPermissionsCache().findCached(perm)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllRoutinePermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all routine permission descriptors for the given routine.
 * @param routineID	The UUID of the routine from which to dropall the permission descriptors
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routineID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROUTINEPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSROUTINEPERMSRowFactory [rf=(SYSROUTINEPERMSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>DataValueDescriptor [routineIdOrderable]</InnerVar>
                <InnerVar>ExecRow [curRow]</InnerVar>
                <InnerVar>PermissionsDescriptor [perm]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, routineIdOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrantsByGrantee</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#dropRoleGrantsByGrantee
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSROLESRowFactory [rf=(SYSROLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitRoleGrants;[ti, rf, rf.SYSROLES_GRANTEE_COLPOS_IN_INDEX_ID_EE_OR, grantee, tc, DataDictionaryImpl.DROP]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsRoleGrantByGrantee</MethodName>
            <MethodComment>/** 
 * Return true if there exists a role grant to authorization identifier.
 * @param grantee authorization identifier
 * @param tc      Transaction Controller
 * @return true if there exists such a grant
 * @exception StandardException Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSROLESRowFactory [rf=(SYSROLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropRoleGrantsByName</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#dropRoleGrantsByName
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSROLESRowFactory [rf=(SYSROLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitRoleGrants;[ti, rf, rf.SYSROLES_ROLEID_COLPOS_IN_INDEX_ID_EE_OR, roleName, tc, DataDictionaryImpl.DROP]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitRoleGrants</MethodName>
            <MethodComment>/** 
 * Scan the {roleid, grantee, grantor} index on SYSROLES, locate rows containing authId in column columnNo. The action argument can be either &lt;code&gt;EXISTS&lt;/code&gt; or &lt;code&gt;DROP&lt;/code&gt; (to check for existence, or to drop that row). If the scan proves too slow, we should add more indexes.  only.
 * @param ti &lt;code&gt;TabInfoImpl&lt;/code&gt; for SYSROLES.
 * @param rf row factory for SYSROLES
 * @param columnNo the column number to match &lt;code&gt;authId&lt;/code&gt; against
 * @param tc transaction controller
 * @param action drop matching rows (&lt;code&gt;DROP&lt;/code&gt;), or return&lt;code&gt;true&lt;/code&gt; if there is a matching row (&lt;code&gt;EXISTS&lt;/code&gt;)
 * @return action=EXISTS: return {@code true} if there is a matching rowelse return  {@code false}.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rf</ParamName>
                    <ParamType>SYSROLESRowFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC=tc.openConglomerate(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ)]</InnerVar>
                <InnerVar>DataValueDescriptor [authIdOrderable=new SQLVarchar(authId)]</InnerVar>
                <InnerVar>ScanQualifier[][] [scanQualifier=exFactory.getScanQualifier(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getIndexConglomerate(rf.SYSROLES_INDEX_ID_EE_OR_IDX),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ,(FormatableBitSet)null,(DataValueDescriptor[])null,0,scanQualifier,(DataValueDescriptor[])null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanQualifier[0][0];setQualifier;[columnNo - 1, authIdOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleGrantGraph</MethodName>
            <MethodComment>/** 
 * Return an in-memory representation of the role grant graph (sans grant of roles to users, only role-role relation.
 * @param tc        Transaction Controller
 * @param inverse   make graph on inverse grant relation
 * @return          hash map representing role grant graph.&lt;ul&gt;&lt;li&gt;Key: rolename,&lt;/li&gt; &lt;li&gt;Value: List&lt;RoleGrantDescriptor&gt; representing a grant of that rolename to another role (not user). &lt;/li&gt; &lt;/ul&gt; FIXME: Need to cache graph and invalidate when role graph is modified. Currently, we always read from SYSROLES.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inverse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashMap&lt;String,List&lt;RoleGrantDescriptor&gt;&gt; [hm=new HashMap&lt;String,List&lt;RoleGrantDescriptor&gt;&gt;()]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSROLESRowFactory [rf=(SYSROLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>DataValueDescriptor [isDefOrderable=new SQLVarchar("N")]</InnerVar>
                <InnerVar>ScanQualifier[][] [scanQualifier=exFactory.getScanQualifier(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ,(FormatableBitSet)null,(DataValueDescriptor[])null,0,scanQualifier,(DataValueDescriptor[])null,0)]</InnerVar>
                <InnerVar>ExecRow [outRow=rf.makeEmptyRow()]</InnerVar>
                <InnerVar>RoleGrantDescriptor [grantDescr]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanQualifier[0][0];setQualifier;[SYSROLESRowFactory.SYSROLES_ISDEF - 1, isDefOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createRoleClosureIterator</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#createRoleClosureIterator
 */
</MethodComment>
            <ReturnType>RoleClosureIterator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>role</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inverse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllPermsByGrantee</MethodName>
            <MethodComment>/** 
 * Drop all permission descriptors corresponding to a grant to the named authentication identifier
 * @param authId  The authentication identifier
 * @param tc      Transaction Controller
 * @exception StandardException Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropPermsByGrantee;[authId, tc, SYSTABLEPERMS_CATALOG_NUM, SYSTABLEPERMSRowFactory.GRANTEE_TABLE_GRANTOR_INDEX_NUM, SYSTABLEPERMSRowFactory.GRANTEE_COL_NUM_IN_GRANTEE_TABLE_GRANTOR_INDEX]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropPermsByGrantee;[authId, tc, SYSCOLPERMS_CATALOG_NUM, SYSCOLPERMSRowFactory.GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM, SYSCOLPERMSRowFactory.GRANTEE_COL_NUM_IN_GRANTEE_TABLE_TYPE_GRANTOR_INDEX]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropPermsByGrantee;[authId, tc, SYSROUTINEPERMS_CATALOG_NUM, SYSROUTINEPERMSRowFactory.GRANTEE_ALIAS_GRANTOR_INDEX_NUM, SYSROUTINEPERMSRowFactory.GRANTEE_COL_NUM_IN_GRANTEE_ALIAS_GRANTOR_INDEX]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropPermsByGrantee</MethodName>
            <MethodComment>/** 
 * Presently only used when dropping roles - user dropping is not under Derby control (well, built-in users are if properties are stored in database), any permissions granted to users remain in place even if the user is no more.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>granteeColnoInIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;visitPermsByGrantee;[authId, tc, catalog, indexNo, granteeColnoInIndex, DataDictionaryImpl.DROP]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsPermByGrantee</MethodName>
            <MethodComment>/** 
 * Return true if there exists a permission grant descriptor to this authorization id.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>granteeColnoInIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitPermsByGrantee</MethodName>
            <MethodComment>/** 
 * Scan &lt;code&gt;indexNo&lt;/code&gt; index on a permission table &lt;code&gt;catalog&lt;/code&gt;, looking for match(es) for the grantee column (given by granteeColnoInIndex for the catalog in question). The action argument can be either &lt;code&gt;EXISTS&lt;/code&gt; or &lt;code&gt;DROP&lt;/code&gt; (to check for existence, or to drop that row). There is no index on grantee column only on on any of the permissions tables, so we use the index which contain grantee and scan that, setting up a scan qualifier to match the grantee, then fetch the base row. If this proves too slow, we should add an index on grantee only.
 * @param authId grantee to match against
 * @param tc transaction controller
 * @param catalog the underlying permission table to visit
 * @param indexNo the number of the index by which to access the catalog
 * @param granteeColnoInIndex the column number to match&lt;code&gt;authId&lt;/code&gt; against
 * @param action drop matching rows (&lt;code&gt;DROP&lt;/code&gt;), or return&lt;code&gt;true&lt;/code&gt; if there is a matching row (&lt;code&gt;EXISTS&lt;/code&gt;)
 * @return action=EXISTS: return {@code true} if there is a matching rowelse return  {@code false}.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNo</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>granteeColnoInIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(catalog)]</InnerVar>
                <InnerVar>PermissionsCatalogRowFactory [rf=(PermissionsCatalogRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=tc.openConglomerate(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ)]</InnerVar>
                <InnerVar>DataValueDescriptor [authIdOrderable=new SQLVarchar(authId)]</InnerVar>
                <InnerVar>ScanQualifier[][] [scanQualifier=exFactory.getScanQualifier(1)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getIndexConglomerate(indexNo),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ,(FormatableBitSet)null,(DataValueDescriptor[])null,0,scanQualifier,(DataValueDescriptor[])null,0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanQualifier[0][0];setQualifier;[granteeColnoInIndex - 1, authIdOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumnDescriptorCore</MethodName>
            <MethodComment>/** 
 * Delete the appropriate rows from syscolumns when dropping 1 or more columns.
 * @param tc			The TransactionController
 * @param keyRow		Start/stop position.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTablePermDescriptor</MethodName>
            <MethodComment>/** 
 * Delete the appropriate rows from systableperms when dropping a table
 * @param tc			The TransactionController
 * @param keyRow		Start/stop position.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [curRow]</InnerVar>
                <InnerVar>PermissionsDescriptor [perm]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTABLEPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSTABLEPERMSRowFactory [rf=(SYSTABLEPERMSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumnPermDescriptor</MethodName>
            <MethodComment>/** 
 * Delete the appropriate rows from syscolperms when dropping a table
 * @param tc			The TransactionController
 * @param keyRow		Start/stop position.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [curRow]</InnerVar>
                <InnerVar>PermissionsDescriptor [perm]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCOLPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSCOLPERMSRowFactory [rf=(SYSCOLPERMSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Update the column descriptor in question.  Updates every row in the base conglomerate.  
 * @param cd					The ColumnDescriptor
 * @param formerUUID			The UUID for this column in SYSCOLUMNS,may differ from what is in cd if this is the column that is being set.
 * @param formerName			The name for this column in SYSCOLUMNSmay differ from what is in cd if this is the column that is being set.
 * @param colsToSet 			Array of ints of columns to be modified,1 based.  May be null (all cols).
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToSet</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [refIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [columnNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>SYSCOLUMNSRowFactory [rf=(SYSCOLUMNSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[rf.getNumIndexes()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, refIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow1;setColumn;[2, columnNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow1, row, SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID, bArray, colsToSet, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the viewDescriptor for the view with the given UUID.
 * @param uuid	The UUID for the view
 * @return  A descriptor for the view
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the viewDescriptor for the view given the TableDescriptor.
 * @param td	The TableDescriptor for the view.
 * @return	A descriptor for the view
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [tdi=(TableDescriptor)td]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getViewDescriptorScan</MethodName>
            <MethodComment>/** 
 * Get the information for the view from sys.sysviews.
 * @param tdi					The TableDescriptor for the view.
 * @return ViewDescriptor	The ViewDescriptor for the view.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ViewDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tdi</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ViewDescriptor [vd]</InnerVar>
                <InnerVar>DataValueDescriptor [viewIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSVIEWS_CATALOG_NUM)]</InnerVar>
                <InnerVar>UUID [viewID=tdi.getUUID()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, viewIdOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropViewDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the view descriptor from the data dictionary.
 * @param vd		A descriptor for the view to be dropped
 * @param tc		TransactionController to use
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vd</ParamName>
                    <ParamType>ViewDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [viewIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSVIEWS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, viewIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSVIEWSRowFactory.SYSVIEWS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptorIndex2Scan</MethodName>
            <MethodComment>/** 
 * Scan sysfiles_index2 (id) for a match.
 * @return TableDescriptor	The matching descriptor, or null.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [idOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSFILES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, idOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getFileInfoDescriptor
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptorIndex1Scan</MethodName>
            <MethodComment>/** 
 * Scan sysfiles_index1 (schemaid,name) for a match.
 * @return The matching descriptor or null.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [nameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSFILES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
                <InnerVar>FileInfoDescriptor [r=getDescriptorViaIndex(SYSFILESRowFactory.SYSFILES_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,FileInfoDescriptor.class,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, nameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getFileInfoDescriptor
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>FileInfoDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropFileInfoDescriptor</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#dropFileInfoDescriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fid</ParamName>
                    <ParamType>FileInfoDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [idOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSFILES_CATALOG_NUM)]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, idOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSFILESRowFactory.SYSFILES_INDEX2_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Get a SPSDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The SPSDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SPSDescriptor [sps]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getNonCoreTI;[SYSSTATEMENTS_CATALOG_NUM]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spsCacheEntryAdded</MethodName>
            <MethodComment>/** 
 * Add an entry to the hashtables for lookup from the cache.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>spsIdHash;put;[spsd.getUUID(), spsd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spsCacheEntryRemoved</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>spsIdHash;remove;[spsd.getUUID()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedSPSDescriptor</MethodName>
            <MethodComment>/** 
 * This method can get called from the DataDictionary cache.
 * @param stmtKey	The TableKey of the sps
 * @return	The descriptor for the sps, null if the sps doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmtKey</ParamName>
                    <ParamType>TableKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedSPSDescriptor</MethodName>
            <MethodComment>/** 
 * This method can get called from the DataDictionary cache.
 * @param stmtId	The UUID of the stmt to get the descriptor for
 * @return	The descriptor for the stmt, null if the table doesnot exist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmtId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptorIndex2Scan</MethodName>
            <MethodComment>/** 
 * Scan sysstatements_index2 (stmtid) for a match. Note that we do not do a lookup of parameter info.
 * @return SPSDescriptor	The matching descriptor, if any.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmtUUID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [stmtIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
                <InnerVar>SPSDescriptor [spsd=getDescriptorViaIndex(SYSSTATEMENTSRowFactory.SYSSTATEMENTS_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,SPSDescriptor.class,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, stmtIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Get a SPSDescriptor given its name. Currently no cacheing.  With caching we need to be very careful about invalidation. No caching means invalidations block on existing SPSD instances (since they were read in
 * @param stmtName	the statement name
 * @param sd	The SchemaDescriptor
 * @return The SPSDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmtName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SPSDescriptor [sps=null]</InnerVar>
                <InnerVar>TableKey [stmtKey]</InnerVar>
                <InnerVar>UUID [schemaUUID]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSDescriptorIndex1Scan</MethodName>
            <MethodComment>/** 
 * Scan sysschemas_index1 (stmtname, schemaid) for a match.
 * @return SPSDescriptor	The matching descriptor, if any.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmtName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaUUID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [stmtNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
                <InnerVar>SPSDescriptor [spsd=getDescriptorViaIndex(SYSSTATEMENTSRowFactory.SYSSTATEMENTS_INDEX2_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,SPSDescriptor.class,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, stmtNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Adds the given SPSDescriptor to the data dictionary, associated with the given table and constraint type.
 * @param descriptor	The descriptor to add
 * @param tc			The transaction controller
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSSTATEMENTSRowFactory [rf=(SYSSTATEMENTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>int [insertRetCode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addSPSParams;[descriptor, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSPSParams</MethodName>
            <MethodComment>/** 
 * Add a column in SYS.SYSCOLUMNS for each parameter in the parameter list.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [uuid=spsd.getUUID()]</InnerVar>
                <InnerVar>DataTypeDescriptor[] [params=spsd.getParams()]</InnerVar>
                <InnerVar>Object[] [parameterDefaults=spsd.getParameterDefaults()]</InnerVar>
                <InnerVar>int [pdlSize=params.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSParams</MethodName>
            <MethodComment>/** 
 * Get all the parameter descriptors for an SPS. Look up the params in SYSCOLUMNS and turn them into parameter descriptors.  
 * @param spsd	sps descriptor
 * @param defaults list for storing column defaults
 * @return array of data type descriptors
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaults</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptorList [cdl=new ColumnDescriptorList()]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
                <InnerVar>DataTypeDescriptor[] [params=new DataTypeDescriptor[cdlSize]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getColumnDescriptorsScan;[spsd.getUUID(), cdl, spsd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSPS</MethodName>
            <MethodComment>/** 
 * Updates SYS.SYSSTATEMENTS with the info from the SPSD. 
 * @param spsd	The descriptor to add
 * @param tc			The transaction controller
 * @param recompile Whether to recompile or invalidate
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsd</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recompile</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [idOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSSTATEMENTSRowFactory [rf=(SYSSTATEMENTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>int[] [updCols]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[2]]</InnerVar>
                <InnerVar>DataTypeDescriptor[] [params=spsd.getParams()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, idOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow1, row, SYSSTATEMENTSRowFactory.SYSSTATEMENTS_INDEX1_ID, bArray, updCols, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropAllColumnDescriptors;[spsd.getUUID(), tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSPSParams;[spsd, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateAllSPSPlans</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#invalidateAllSPSPlans
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=(LanguageConnectionContext)getContext(LanguageConnectionContext.CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;invalidateAllSPSPlans;[lcc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateAllSPSPlans</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#invalidateAllSPSPlans
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;startWriting;[lcc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearSPSPlans</MethodName>
            <MethodComment>/** 
 * Mark all SPS plans in the data dictionary invalid. This does not invalidate cached plans. This function is for use by the boot-up code.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionExecute()]</InnerVar>
                <InnerVar>FormatableBitSet [columnToReadSet=new FormatableBitSet(SYSSTATEMENTSRowFactory.SYSSTATEMENTS_COLUMN_COUNT)]</InnerVar>
                <InnerVar>FormatableBitSet [columnToUpdateSet=new FormatableBitSet(SYSSTATEMENTSRowFactory.SYSSTATEMENTS_COLUMN_COUNT)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [replaceRow=new DataValueDescriptor[SYSSTATEMENTSRowFactory.SYSSTATEMENTS_COLUMN_COUNT]]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getHeapConglomerate(),false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_REPEATABLE_READ,columnToReadSet,(DataValueDescriptor[])null,ScanController.NA,(Qualifier[][])null,(DataValueDescriptor[])null,ScanController.NA)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;faultInTabInfo;[ti]</InnerMethodInvoke>
                <InnerMethodInvoke>columnToUpdateSet;set;[SYSSTATEMENTSRowFactory.SYSSTATEMENTS_VALID - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>columnToUpdateSet;set;[SYSSTATEMENTSRowFactory.SYSSTATEMENTS_CONSTANTSTATE - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given SPSDescriptor.
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>SPSDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropSPSDescriptor;[descriptor.getUUID(), tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSPSDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given SPSDescriptor. 
 * @param uuid	the statement uuid
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [stmtIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, stmtIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSSTATEMENTSRowFactory.SYSSTATEMENTS_INDEX1_ID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropAllColumnDescriptors;[uuid, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllSPSDescriptors</MethodName>
            <MethodComment>/** 
 * Get every statement in this database. Return the SPSDescriptors in an list. The returned descriptors don't contain the compiled statement, so it it safe to call this method during upgrade when it isn't known if the saved statement can still be deserialized with the new version.
 * @return the list of descriptors
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SPSDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATEMENTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>List&lt;SPSDescriptor&gt; [list=newSList()]</InnerVar>
                <InnerVar>FormatableBitSet [cols=new FormatableBitSet(ti.getCatalogRowFactory().getHeapColumnCount())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getDescriptorViaHeap;[cols, (ScanQualifier[][])null, ti, (TupleDescriptor)null, list, SPSDescriptor.class]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Get every constraint in this database. Note that this list of ConstraintDescriptors is not going to be the same objects that are typically cached off of the table descriptors, so this will most likely instantiate some duplicate objects.
 * @return the list of descriptors
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ConstraintDescriptorList [list=new ConstraintDescriptorList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getConstraintDescriptorViaHeap;[(ScanQualifier[][])null, ti, (TupleDescriptor)null, list]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>examineTriggerNodeAndCols</MethodName>
            <MethodComment>/** 
 * Get the trigger action string associated with the trigger after the references to old/new transition tables/variables in trigger action sql provided by CREATE TRIGGER have been transformed eg DELETE FROM t WHERE c = old.c turns into DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory:: getTriggerExecutionContext().getOldRow(). getInt(columnNumberFor'C'inRuntimeResultset) or DELETE FROM t WHERE c in (SELECT c FROM OLD) turns into DELETE FROM t WHERE c in  (SELECT c FROM new TriggerOldTransitionTable OLD)
 * @param actionStmt This is needed to get access to the various nodesgenerated by the Parser for the trigger action sql. These nodes will be used to find REFERENCEs column nodes.
 * @param oldReferencingName The name specified by the user for REFERENCEsto old row columns
 * @param newReferencingName The name specified by the user for REFERENCEsto new row columns
 * @param triggerDefinition The original trigger action text provided bythe user during CREATE TRIGGER time.
 * @param referencedCols Trigger is defined on these columns (will be nullin case of INSERT AND DELETE Triggers. Can also be null for DELETE Triggers if UPDATE trigger is not defined on specific column(s))
 * @param referencedColsInTriggerAction	what columns does the trigger action reference through old/new transition variables (may be null)
 * @param actionOffset offset of start of action clause
 * @param triggerTableDescriptor Table descriptor for trigger table
 * @param triggerEventMask TriggerDescriptor.TRIGGER_EVENT_XXX
 * @param createTriggerTime True if here for CREATE TRIGGER,false if here because an invalidated row level trigger with  REFERENCEd columns has been fired and hence trigger action sql associated with SPSDescriptor may be invalid too.
 * @return Transformed trigger action sql
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actionStmt</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerDefinition</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedColsInTriggerAction</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createTriggerTime</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [in10_9_orHigherVersion=checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null)]</InnerVar>
                <InnerVar>StringBuilder [newText=new StringBuilder()]</InnerVar>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=triggerTableDescriptor.getNumberOfColumns()]</InnerVar>
                <InnerVar>int[] [triggerColsAndTriggerActionCols=new int[numberOfColsInTriggerTable]]</InnerVar>
                <InnerVar>int[] [triggerActionColsOnly=new int[numberOfColsInTriggerTable]]</InnerVar>
                <InnerVar>SortedSet&lt;ColumnReference&gt; [refs=getTransitionVariables(actionStmt,oldReferencingName,newReferencingName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>java.util.Arrays;fill;[triggerActionColsOnly, -1]</InnerMethodInvoke>
                <InnerMethodInvoke>Arrays;sort;[triggerColsAndTriggerActionCols]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerActionString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actionStmt</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerDefinition</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referencedColsInTriggerAction</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createTriggerTime</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [in10_9_orHigherVersion=checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null)]</InnerVar>
                <InnerVar>StringBuilder [newText=new StringBuilder()]</InnerVar>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=triggerTableDescriptor.getNumberOfColumns()]</InnerVar>
                <InnerVar>int[] [triggerColsAndTriggerActionCols=new int[numberOfColsInTriggerTable]]</InnerVar>
                <InnerVar>SortedSet&lt;ColumnReference&gt; [refs=getTransitionVariables(actionStmt,oldReferencingName,newReferencingName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newText;append;[triggerDefinition, start, triggerDefinition.length()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransitionVariables</MethodName>
            <MethodComment>/** 
 * Get all columns that reference transition variables in triggers. The columns should be returned in the same order as in the SQL text.
 * @param node the node in which to look for transition variables
 * @param oldReferencingName the name of the old transition variable
 * @param newReferencingName the name of the new transition variable
 * @return all references to transition variables
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SortedSet&lt;ColumnReference&gt; [refs=((QueryTreeNode)node).getOffsetOrderedNodes(ColumnReference.class)]</InnerVar>
                <InnerVar>Iterator&lt;ColumnReference&gt; [it=refs.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTransitionVariable</MethodName>
            <MethodComment>/** 
 * Check if a table name is actually a transition variable.
 * @param tableName the table name to check
 * @param oldReferencingName the name of the old transition variable
 * @param newReferencingName the name of the new transition variable
 * @return {@code true} if the table name is a transition variable,{@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>justTheRequiredColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnsArrary</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [countOfColsRefedInArray=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=triggerTableDescriptor.getNumberOfColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkInvalidTriggerReference</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newReferencingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genColumnReferenceSQL</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tabName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isOldTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colPositionInRuntimeResultSet</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [colDesc=null]</InnerVar>
                <InnerVar>DataTypeDescriptor [dts=colDesc.getType()]</InnerVar>
                <InnerVar>TypeId [typeId=dts.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Get a TriggerDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The TriggerDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTRIGGERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>DataValueDescriptor [triggerIdOrderable=getIDValueAsCHAR(uuid)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, triggerIdOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Get the stored prepared statement descriptor given  a sps name.
 * @param name	The sps name.
 * @param sd	The schema descriptor.
 * @return The TriggerDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [triggerNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTRIGGERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, triggerNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptors</MethodName>
            <MethodComment>/** 
 * Load up the trigger descriptor list for this table descriptor and return it.  If the descriptor list is already loaded up, it is retuned without further ado.
 * @param td			The table descriptor.
 * @return The ConstraintDescriptorList for the table
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TriggerDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TriggerDescriptorList [gdl]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTriggerDescriptorsScan</MethodName>
            <MethodComment>/** 
 * Populate the TriggerDescriptorList for the specified TableDescriptor. MT synchronization: it is assumed that the caller has synchronized on the CDL in the given TD.
 * @param td				The TableDescriptor.
 * @param forUpdate			Whether or not to open scan for update
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TriggerDescriptorList [gdl=(td).getTriggerDescriptorList()]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTRIGGERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSTRIGGERSRowFactory.SYSTRIGGERS_INDEX3_ID, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, gdl, TriggerDescriptor.class, forUpdate]</InnerMethodInvoke>
                <InnerMethodInvoke>gdl;setScanned;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given TriggerDescriptor.  WARNING: does not drop its SPSes!!!
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [idOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTRIGGERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, idOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSTRIGGERSRowFactory.SYSTRIGGERS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateTriggerDescriptor</MethodName>
            <MethodComment>/** 
 * Update the trigger descriptor in question.  Updates every row in the base conglomerate that matches the uuid.
 * @param triggerd				The Trigger descriptor
 * @param formerUUID			The UUID for this column in SYSTRIGGERS,may differ from what is in triggerd if this is the column that is being set.
 * @param colsToSet 			Array of ints of columns to be modified,1 based.  May be null (all cols).
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerd</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToSet</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [IDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSTRIGGERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSTRIGGERSRowFactory [rf=(SYSTRIGGERSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[3]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, IDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow1, row, SYSTRIGGERSRowFactory.SYSTRIGGERS_INDEX1_ID, bArray, colsToSet, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConstraintDescriptor given its UUID.  Please use getConstraintDescriptorById() is you have the constraints table descriptor, it is much faster.
 * @param uuid	The UUID
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConstraintDescriptor given its name and schema ID. Please use getConstraintDescriptorByName() if you have the constraint's table descriptor, it is much faster.
 * @param constraintName	Constraint name.
 * @param schemaID			The schema UUID
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [constraintNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, constraintNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatisticsDescriptors</MethodName>
            <MethodComment>/** 
 * Returns all the statistics descriptors for the given table. &lt;p&gt; NOTE: As opposed to most other data dictionary lookups, this operation is performed with isolation level READ_UNCOMMITTED. The reason is to avoid deadlocks with inserts into the statistics system table.
 * @param td {@code TableDescriptor} for which I need statistics
 * @return A list of tuple descriptors, possibly empty.
 */
</MethodComment>
            <ReturnType>StatisticsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATISTICS_CATALOG_NUM)]</InnerVar>
                <InnerVar>List&lt;StatisticsDescriptor&gt; [statDescriptorList=newSList()]</InnerVar>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSSTATISTICSRowFactory.SYSSTATISTICS_INDEX1_ID, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, statDescriptorList, StatisticsDescriptor.class, false, TransactionController.ISOLATION_READ_UNCOMMITTED, getTransactionCompile()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Load up the constraint descriptor list for this table descriptor and return it.  If the descriptor list is already loaded up, it is retuned without further ado.  If no table descriptor is passed in, then all constraint descriptors are retrieved.  Note that in  this case, the constraint descriptor objects may be duplicates of constraint descriptors that are hung off of the table descriptor cache.
 * @param td			The table descriptor.  If null,all constraint descriptors are returned.
 * @return The ConstraintDescriptorList for the table
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [cdl]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActiveConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Convert a constraint descriptor list into a list of active constraints, that is, constraints which must be enforced. For the Core product, these are just the constraints on the original list. However, during REFRESH we may have deferred some constraints until statement end. This method returns the corresponding list of constraints which AREN'T deferred.
 * @param cdl	The constraint descriptor list to wrap withan Active constraint descriptor list.
 * @return The corresponding Active ConstraintDescriptorList
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cdl</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>activeConstraint</MethodName>
            <MethodComment>/** 
 * Reports whether an individual constraint must be enforced. For the Core product, this routine always returns true. However, during REFRESH we may have deferred some constraints until statement end. This method returns false if the constraint deferred
 * @param constraint	the constraint to check
 * @return The corresponding Active ConstraintDescriptorList
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraint</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a table and the UUID String of the backing index.
 * @param td			The table descriptor.
 * @param uuid			the UUID for the backing index.
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorById</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a table and the UUID String of the constraint
 * @param td			The table descriptor.
 * @param uuid			The UUID for the constraint
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorByName</MethodName>
            <MethodComment>/** 
 * Get the constraint descriptor given a TableDescriptor and the constraint name.
 * @param td				The table descriptor.
 * @param sd				The schema descriptor for the constraint
 * @param constraintName	The constraint name.
 * @param forUpdate			Whether or not access is for update
 * @return The ConstraintDescriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorsScan</MethodName>
            <MethodComment>/** 
 * Populate the ConstraintDescriptorList for the specified TableDescriptor. MT synchronization: it is assumed that the caller has synchronized on the CDL in the given TD.
 * @param td				The TableDescriptor.
 * @param forUpdate			Whether or not to open scan for update
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [cdl=td.getConstraintDescriptorList()]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getConstraintDescriptorViaIndex;[SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_INDEX3_ID, keyRow, ti, td, cdl, forUpdate]</InnerMethodInvoke>
                <InnerMethodInvoke>cdl;setScanned;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorViaIndex</MethodName>
            <MethodComment>/** 
 * Return a (single or list of) ConstraintDescriptor(s) from SYSCONSTRAINTS where the access is from the index to the heap.
 * @param indexId	The id of the index (0 to # of indexes on table) to use
 * @param keyRow	The supplied ExecIndexRow for search
 * @param ti		The TabInfoImpl to use
 * @param td		The TableDescriptor, if supplied.
 * @param dList		The list to build, if supplied.  If null, then caller expectsa single descriptor
 * @param forUpdate			Whether or not to open scan for update
 * @return	The last matching descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dList</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SYSCONSTRAINTSRowFactory [rf=(SYSCONSTRAINTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
                <InnerVar>ConstraintDescriptor [cd=null]</InnerVar>
                <InnerVar>ExecIndexRow [indexRow1]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>TransactionController [tc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>heapCC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintDescriptorViaHeap</MethodName>
            <MethodComment>/** 
 * Return a (single or list of) catalog row descriptor(s) from SYSCONSTRAINTS through a heap scan 
 * @param scanQualifiers			qualifiers
 * @param ti						The TabInfoImpl to use
 * @param parentTupleDescriptor		The parentDescriptor, if applicable.
 * @param list						The list to build, if supplied.  If null, then caller expects a single descriptor
 * @return	The last matching descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TupleDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>ScanQualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTupleDescriptor</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SYSCONSTRAINTSRowFactory [rf=(SYSCONSTRAINTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>TransactionController [tc]</InnerVar>
                <InnerVar>ConstraintDescriptor [cd=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintTableDescriptor</MethodName>
            <MethodComment>/** 
 * Return a table descriptor corresponding to the TABLEID field in SYSCONSTRAINTS where CONSTRAINTID matches the constraintId passsed in.
 * @param constraintId	The id of the constraint
 * @return	the corresponding table descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;UUID&gt; [slist=getConstraints(constraintId,SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_INDEX1_ID,SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_TABLEID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getForeignKeys</MethodName>
            <MethodComment>/** 
 * Return a list of foreign keys constraints referencing this constraint.  Returns both enforced and not enforced foreign keys.  
 * @param constraintId	The id of the referenced constraint
 * @return	list of constraints, empty of there are none
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ConstraintDescriptorList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSFOREIGNKEYS_CATALOG_NUM)]</InnerVar>
                <InnerVar>List&lt;SubKeyConstraintDescriptor&gt; [fkList=newSList()]</InnerVar>
                <InnerVar>DataValueDescriptor [constraintIDOrderable=getIDValueAsCHAR(constraintId)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
                <InnerVar>TableDescriptor [td]</InnerVar>
                <InnerVar>ConstraintDescriptorList [cdl=new ConstraintDescriptorList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, constraintIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSFOREIGNKEYSRowFactory.SYSFOREIGNKEYS_INDEX2_ID, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, fkList, SubKeyConstraintDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraints</MethodName>
            <MethodComment>/** 
 * Return an List which of the relevant column matching the indexed criteria.  If nothing matches, returns an empty List (never returns null).
 * @param uuid	The id of the constraint
 * @param indexId		The index id in SYS.SYSCONSTRAINTS
 * @param columnNum		The column to retrieve
 * @return a list of UUIDs in an List.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [indexRow1]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=null]</InnerVar>
                <InnerVar>ScanController [scanController=null]</InnerVar>
                <InnerVar>TransactionController [tc]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSCONSTRAINTSRowFactory [rf=(SYSCONSTRAINTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>TableDescriptor [td=null]</InnerVar>
                <InnerVar>List&lt;UUID&gt; [slist=new ArrayList&lt;UUID&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Adds the given ConstraintDescriptor to the data dictionary, associated with the given table and constraint type.
 * @param descriptor	The descriptor to add
 * @param tc			The transaction controller
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [type=descriptor.getConstraintType()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addDescriptor;[descriptor, descriptor.getSchemaDescriptor(), SYSCONSTRAINTS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Update the constraint descriptor in question.  Updates every row in the base conglomerate.  
 * @param cd                    The Constraint descriptor
 * @param formerUUID			The UUID for this column in SYSCONSTRAINTS,may differ from what is in  {@code cd} if thisis the column that is being set.
 * @param colsToSet             Array of integers of columns to be modified,1 based.  May be null (all columns).
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>formerUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colsToSet</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [IDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSCONSTRAINTSRowFactory [rf=(SYSCONSTRAINTSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[3]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, IDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow1, row, SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_INDEX1_ID, bArray, colsToSet, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropConstraintDescriptor</MethodName>
            <MethodComment>/** 
 * Drops the given ConstraintDescriptor from the data dictionary.
 * @param descriptor	The descriptor to drop
 * @param tc			The TransactionController
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow=null]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [constraintNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCONSTRAINTS_CATALOG_NUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, constraintNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_INDEX2_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllConstraintDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all ConstraintDescriptors from the data dictionary that are associated with the given table,
 * @param table	The table from which to drop allconstraint descriptors
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConstraintDescriptorList [cdl=getConstraintDescriptors(table)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>table;setConstraintDescriptorList;[null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubKeyConstraint</MethodName>
            <MethodComment>/** 
 * Get a SubKeyConstraintDescriptor from syskeys or sysforeignkeys for the specified constraint id.  For primary foreign and and unique key constraints.
 * @param constraintId	The UUID for the constraint.
 * @param type	The type of the constraint (e.g. DataDictionary.FOREIGNKEY_CONSTRAINT)
 * @return SubKeyConstraintDescriptor	The Sub descriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SubKeyConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [constraintIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti]</InnerVar>
                <InnerVar>int [indexNum]</InnerVar>
                <InnerVar>int [baseNum]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, constraintIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSubKeyConstraint</MethodName>
            <MethodComment>/** 
 * Add the matching row to syskeys when adding a unique or primary key constraint
 * @param descriptor	The KeyConstraintDescriptor for the constraint.
 * @param tc			The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>KeyConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>TabInfoImpl [ti]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ti;insertRow;[row, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSubKeyConstraint</MethodName>
            <MethodComment>/** 
 * Drop the matching row from syskeys when dropping a primary key or unique constraint.
 * @param constraint	the constraint
 * @param tc			The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraint</ParamName>
                    <ParamType>ConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [constraintIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti]</InnerVar>
                <InnerVar>int [baseNum]</InnerVar>
                <InnerVar>int [indexNum]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, constraintIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, indexNum]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSubCheckConstraint</MethodName>
            <MethodComment>/** 
 * Get a SubCheckConstraintDescriptor from syschecks for the specified constraint id.  (Useful for check constraints.)
 * @param constraintId	The UUID for the constraint.
 * @return SubCheckConstraintDescriptor	The Sub descriptor for the constraint.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>SubCheckConstraintDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [constraintIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCHECKS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, constraintIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSubCheckConstraint</MethodName>
            <MethodComment>/** 
 * Drop the matching row from syschecks when dropping a check constraint.
 * @param constraintId	The constraint id.
 * @param tc			The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [checkRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [constraintIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSCHECKS_CATALOG_NUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>checkRow1;setColumn;[1, constraintIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, checkRow1, SYSCHECKSRowFactory.SYSCHECKS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashAllConglomerateDescriptorsByNumber</MethodName>
            <MethodComment>/** 
 * Get all of the ConglomerateDescriptors in the database and hash them by conglomerate number. This is useful as a performance optimization for the locking VTIs. NOTE:  This method will scan SYS.SYSCONGLOMERATES at READ UNCOMMITTED.
 * @param tc		TransactionController for the transaction
 * @return	A Hashtable with all of the ConglomerateDescriptorsin the database hashed by conglomerate number.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Hashtable&lt;Long,ConglomerateDescriptor&gt; [ht=new Hashtable&lt;Long,ConglomerateDescriptor&gt;()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cd=null]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSCONGLOMERATESRowFactory [rf=(SYSCONGLOMERATESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashAllTableDescriptorsByTableId</MethodName>
            <MethodComment>/** 
 * Get all of the TableDescriptors in the database and hash them by TableId This is useful as a performance optimization for the locking VTIs.  NOTE: This method will scan SYS.SYSTABLES and SYS.SYSSCHEMAS at READ UNCOMMITTED.
 * @param tc		TransactionController for the transaction
 * @return	A Hashtable with all of the Table descriptors in the databasehashed by TableId
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Hashtable&lt;UUID,TableDescriptor&gt; [ht=new Hashtable&lt;UUID,TableDescriptor&gt;()]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSTABLESRowFactory [rf=(SYSTABLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConglomerateDescriptor given its UUID.  If it is an index conglomerate shared by at least another duplicate index, this returns one of the ConglomerateDescriptors for those indexes. 
 * @param uuid	The UUID
 * @return A ConglomerateDescriptor for the conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cds=getConglomerateDescriptors(uuid)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Get an array of ConglomerateDescriptors given the UUID.  If it is a heap conglomerate or an index conglomerate not shared by a duplicate index, the size of the return array is 1. If the uuid argument is null, then this method retrieves descriptors for all of the conglomerates in the database.
 * @param uuid	The UUID
 * @return An array of ConglomerateDescriptors for the conglomerate.returns size 0 array if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
                <InnerVar>List&lt;ConglomerateDescriptor&gt; [cdl=newSList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Get a ConglomerateDescriptor given its conglomerate number.  If it is an index conglomerate shared by at least another duplicate index, this returns one of the ConglomerateDescriptors for those indexes. 
 * @param conglomerateNumber	The conglomerate number.
 * @return A ConglomerateDescriptor for the conglomerate.  Returns NULL ifno such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cds=getConglomerateDescriptors(conglomerateNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Get an array of conglomerate descriptors for the given conglomerate number.  If it is a heap conglomerate or an index conglomerate not shared by a duplicate index, the size of the return array is 1.
 * @param conglomerateNumber	The number for the conglomeratewe're interested in
 * @return	An array of ConglomerateDescriptors that share the requestedconglomerate. Returns size 0 array if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [conglomNumberOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSCONGLOMERATESRowFactory [rf=(SYSCONGLOMERATESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ScanQualifier[][] [scanQualifier=exFactory.getScanQualifier(1)]</InnerVar>
                <InnerVar>ConglomerateDescriptorList [cdl=new ConglomerateDescriptorList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanQualifier[0][0];setQualifier;[rf.SYSCONGLOMERATES_CONGLOMERATENUMBER - 1, conglomNumberOrderable, Orderable.ORDER_OP_EQUALS, false, false, false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaHeap;[null, scanQualifier, ti, null, cdl, ConglomerateDescriptor.class]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptorsScan</MethodName>
            <MethodComment>/** 
 * Populate the ConglomerateDescriptorList for the specified TableDescriptor by scanning sysconglomerates. MT synchronization: it is assumed that the caller has synchronized on the CDL in the given TD.
 * @param td			The TableDescriptor.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptorList [cdl=td.getConglomerateDescriptorList()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow3=null]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow3;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX3_ID, keyRow3, (ScanQualifier[][])null, ti, (TupleDescriptor)null, cdl, ConglomerateDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Gets a conglomerate descriptor for the named index in the given schema, getting an exclusive row lock on the matching row in  sys.sysconglomerates (for DDL concurrency) if requested.
 * @param indexName	The name of the index we're looking for
 * @param sd		The schema descriptor
 * @param forUpdate	Whether or not to get an exclusive row lock on the row in sys.sysconglomerates.
 * @return	A ConglomerateDescriptor describing the requestedconglomerate. Returns NULL if no such conglomerate.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow2=null]</InnerVar>
                <InnerVar>DataValueDescriptor [nameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow2;setColumn;[1, nameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow2;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Drops a conglomerate descriptor
 * @param conglomerate	The ConglomerateDescriptor for the conglomerate
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomerate</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow2=null]</InnerVar>
                <InnerVar>DataValueDescriptor [nameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable=null]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow2;setColumn;[1, nameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow2;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow2, SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX2_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllConglomerateDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all conglomerates associated with a table.
 * @param td		The TableDescriptor of the table 
 * @param tc		TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow3=null]</InnerVar>
                <InnerVar>DataValueDescriptor [tableIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow3;setColumn;[1, tableIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow3, SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX3_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Update the conglomerateNumber for a ConglomerateDescriptor. This is useful, in 1.3, when doing a bulkInsert into an  empty table where we insert into a new conglomerate. (This will go away in 1.4.)
 * @param cd					The ConglomerateDescriptor
 * @param conglomerateNumber	The new conglomerate number
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cds=new ConglomerateDescriptor[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateConglomerateDescriptor;[cds, conglomerateNumber, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSystemSchemaAuthorization</MethodName>
            <MethodComment>/** 
 * Update all system schemas to have new authorizationId. This is needed while upgrading pre-10.2 databases to 10.2 or later versions. From 10.2, all system schemas would be owned by database owner's authorizationId.
 * @param aid							AuthorizationID of Database Owner
 * @param tc							TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>aid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_CAT_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_FUN_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_PROC_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_STAT_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.IBM_SYSTEM_NULLID_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.STD_SQLJ_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.STD_SYSTEM_DIAG_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSchemaAuth;[SchemaDescriptor.STD_SYSTEM_UTIL_SCHEMA_NAME, aid, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;resetDatabaseOwner;[tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSchemaAuth</MethodName>
            <MethodComment>/** 
 * Update authorizationId of specified schemaName
 * @param schemaName			Schema Name of system schema
 * @param authorizationId		authorizationId of new schema owner
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSSCHEMAS_CORE_NUM]]</InnerVar>
                <InnerVar>SYSSCHEMASRowFactory [rf=(SYSSCHEMASRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [row=rf.makeEmptyRow()]</InnerVar>
                <InnerVar>boolean[] [bArray={false,false}]</InnerVar>
                <InnerVar>int[] [colsToUpdate={SYSSCHEMASRowFactory.SYSSCHEMAS_SCHEMAAID}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, schemaNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>row;setColumn;[SYSSCHEMASRowFactory.SYSSCHEMAS_SCHEMAAID, new SQLVarchar(authorizationId)]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow, row, SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX1_ID, bArray, colsToUpdate, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateConglomerateDescriptor</MethodName>
            <MethodComment>/** 
 * Update the conglomerateNumber for an array of ConglomerateDescriptors. In case of more than one ConglomerateDescriptor, each descriptor  should be updated separately, conglomerate id is not same for all  the descriptors. Even when indexes are sharing the same  conglomerate(conglomerate number), conglomerate ids are unique. This is useful, in 1.3, when doing a bulkInsert into an  empty table where we insert into a new conglomerate. (This will go away in 1.4.)
 * @param cds					The array of ConglomerateDescriptors
 * @param conglomerateNumber	The new conglomerate number
 * @param tc					The TransactionController to use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cds</ParamName>
                    <ParamType>ConglomerateDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [conglomIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCONGLOMERATES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSCONGLOMERATESRowFactory [rf=(SYSCONGLOMERATESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>boolean[] [bArray={false,false,false}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependentsDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets a list of the dependency descriptors for the given dependent's id.
 * @param dependentID		The ID of the dependent we're interested in
 * @return	List			Returns a list of DependencyDescriptors. Returns an empty List if no stored dependencies for the dependent's ID.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>DependencyDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;DependencyDescriptor&gt; [ddlList=newSList()]</InnerVar>
                <InnerVar>DataValueDescriptor [dependentIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDEPENDS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, dependentIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSDEPENDSRowFactory.SYSDEPENDS_INDEX1_ID, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, ddlList, DependencyDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProvidersDescriptorList</MethodName>
            <MethodComment>/** 
 * Gets a list of the dependency descriptors for the given provider's id.
 * @param providerID		The ID of the provider we're interested in
 * @return	List			Returns a list of DependencyDescriptors. Returns an empty List if no stored dependencies for the provider's ID.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>DependencyDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>providerID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;DependencyDescriptor&gt; [ddlList=newSList()]</InnerVar>
                <InnerVar>DataValueDescriptor [providerIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDEPENDS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, providerIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getDescriptorViaIndex;[SYSDEPENDSRowFactory.SYSDEPENDS_INDEX2_ID, keyRow, (ScanQualifier[][])null, ti, (TupleDescriptor)null, ddlList, DependencyDescriptor.class, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllDependencyDescriptorsList</MethodName>
            <MethodComment>/** 
 * Build and return an List with DependencyDescriptors for all of the stored dependencies.   This is useful for consistency checking.
 * @return List		List of all DependencyDescriptors.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TupleDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>TransactionController [tc]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>ExecRow [templateRow]</InnerVar>
                <InnerVar>List&lt;TupleDescriptor&gt; [ddl=newSList()]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDEPENDS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSDEPENDSRowFactory [rf=(SYSDEPENDSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStoredDependency</MethodName>
            <MethodComment>/** 
 * Drop a single dependency from the data dictionary.
 * @param dd	The DependencyDescriptor.
 * @param tc	TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DependencyDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>UUID [dependentID=dd.getUUID()]</InnerVar>
                <InnerVar>UUID [providerID=dd.getProviderID()]</InnerVar>
                <InnerVar>DataValueDescriptor [dependentIDOrderable=getIDValueAsCHAR(dependentID)]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDEPENDS_CATALOG_NUM)]</InnerVar>
                <InnerVar>TupleFilter [filter=new DropDependencyFilter(providerID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, dependentIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRows;[tc, keyRow1, ScanController.GE, null, filter, keyRow1, ScanController.GT, SYSDEPENDSRowFactory.SYSDEPENDS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDependentsStoredDependencies</MethodName>
            <MethodComment>/** 
 * Remove all of the stored dependencies for a given dependent's ID  from the data dictionary.
 * @param dependentsUUID	Dependent's uuid
 * @param tc				TransactionController for the transaction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropDependentsStoredDependencies;[dependentsUUID, tc, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropDependentsStoredDependencies</MethodName>
            <MethodComment>/** 
 * @inheritDoc
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependentsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow1=null]</InnerVar>
                <InnerVar>DataValueDescriptor [dependentIDOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDEPENDS_CATALOG_NUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, dependentIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSDEPENDSRowFactory.SYSDEPENDS_INDEX1_ID, wait]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUUIDFactory</MethodName>
            <MethodComment>/** 
 * Get the UUID Factory.  (No need to make the UUIDFactory a module.)
 * @return UUIDFactory	The UUID Factory for this DataDictionary.
 */
</MethodComment>
            <ReturnType>UUIDFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptorForUDT</MethodName>
            <MethodComment>/** 
 * Get the alias descriptor for an ANSI UDT.
 * @param tc The transaction to use: if null, use the compilation transaction
 * @param dtd The UDT's type descriptor
 * @return The UDT's alias descriptor if it is an ANSI UDT; null otherwise.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseTypeIdImpl [btii=dtd.getTypeId().getBaseTypeId()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSchemaDescriptor(btii.getSchemaName(),tc,true)]</InnerVar>
                <InnerVar>AliasDescriptor [ad=getAliasDescriptor(sd.getUUID().toString(),btii.getUnqualifiedName(),AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Get a AliasDescriptor given its UUID.
 * @param uuid	The UUID
 * @return The AliasDescriptor for the alias.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSALIASES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Get a AliasDescriptor by alias name and name space. NOTE: caller responsible for handling no match.
 * @param schemaId		schema identifier
 * @param aliasName		The alias name.
 * @param nameSpace		The alias type.
 * @return AliasDescriptor	AliasDescriptor for the alias name and name space
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aliasName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameSpace</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [aliasNameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [nameSpaceOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSALIASES_CATALOG_NUM)]</InnerVar>
                <InnerVar>char[] [charArray=new char[1]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, new SQLChar(schemaId)]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, aliasNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[3, nameSpaceOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineList</MethodName>
            <MethodComment>/** 
 * Get the list of routines matching the schema and routine name. While we only support a single alias for a given name,namespace just return a list of zero or one item. If the schema is SYSFUN then do not use the system catalogs, but instead look up the routines from the in-memory table driven by the contents of SYSFUN_FUNCTIONS.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>routineName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameSpace</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;AliasDescriptor&gt; [list=new ArrayList&lt;AliasDescriptor&gt;(1)]</InnerVar>
                <InnerVar>AliasDescriptor [ad=getAliasDescriptor(schemaID,routineName,nameSpace)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAliasDescriptor</MethodName>
            <MethodComment>/** 
 * Drop a AliasDescriptor from the DataDictionary
 * @param ad	The AliasDescriptor to drop
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ad</ParamName>
                    <ParamType>AliasDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSALIASES_CATALOG_NUM)]</InnerVar>
                <InnerVar>char[] [charArray=new char[1]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow1=(ExecIndexRow)exFactory.getIndexableRow(3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, getIDValueAsCHAR(ad.getSchemaUUID())]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow1;setColumn;[2, new SQLVarchar(ad.getDescriptorName())]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow1;setColumn;[3, new SQLChar(new String(charArray))]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSALIASESRowFactory.SYSALIASES_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateUser</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newDescriptor</ParamName>
                    <ParamType>UserDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSUSERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecRow [row=ti.getCatalogRowFactory().makeRow(newDescriptor,null)]</InnerVar>
                <InnerVar>boolean[] [bArray={false}]</InnerVar>
                <InnerVar>int[] [colsToUpdate={SYSUSERSRowFactory.HASHINGSCHEME_COL_NUM,SYSUSERSRowFactory.PASSWORD_COL_NUM,SYSUSERSRowFactory.LASTMODIFIED_COL_NUM}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, new SQLVarchar(newDescriptor.getUserName())]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow, row, SYSUSERSRowFactory.SYSUSERS_INDEX1_ID, bArray, colsToUpdate, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUser</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>UserDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [keyRow]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSUSERS_CATALOG_NUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dictionaryVersion;checkVersion;[DD_VERSION_DERBY_10_9, "NATIVE AUTHENTICATION"]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[1, new SQLVarchar(userName)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropUser</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSUSERS_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow1=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow1;setColumn;[1, new SQLVarchar(userName)]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow1, SYSUSERSRowFactory.SYSUSERS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadDictionaryTables</MethodName>
            <MethodComment>/** 
 * Initialize system catalogs. This is where we perform upgrade. It is our pious hope that we won't ever have to upgrade the core catalogs, other than to add fields inside Formatable columns in these catalogs. If we do have to upgrade the core catalogs, then we may need to move the loadCatalog calls into the upgrade machinery. It's do-able, just not pretty.
 * @param tc		TransactionController
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [nativeAuthenticationEnabled=PropertyUtil.nativeAuthenticationEnabled(startParams)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadCatalogs;[coreInfo]</InnerMethodInvoke>
                <InnerMethodInvoke>null;resetDatabaseOwner;[tc]</InnerMethodInvoke>
                <InnerMethodInvoke>softwareVersion;upgradeIfNeeded;[dictionaryVersion, tc, startParams]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetDatabaseOwner</MethodName>
            <MethodComment>/** 
 * Reset the database owner according to what is stored in the catalogs. This can change at upgrade time so we have factored this logic into a separately callable method.
 * @param tc		TransactionController
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [sd=locateSchemaRow(SchemaDescriptor.IBM_SYSTEM_SCHEMA_NAME,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>systemSchemaDesc;setAuthorizationId;[authorizationDatabaseOwner]</InnerMethodInvoke>
                <InnerMethodInvoke>sysIBMSchemaDesc;setAuthorizationId;[authorizationDatabaseOwner]</InnerMethodInvoke>
                <InnerMethodInvoke>systemUtilSchemaDesc;setAuthorizationId;[authorizationDatabaseOwner]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadCatalogs</MethodName>
            <MethodComment>/** 
 * Initialize indices for an array of catalogs
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogArray</ParamName>
                    <ParamType>TabInfoImpl[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [ictr]</InnerVar>
                <InnerVar>int [numIndexes]</InnerVar>
                <InnerVar>int [indexCtr]</InnerVar>
                <InnerVar>TabInfoImpl [catalog]</InnerVar>
                <InnerVar>int [catalogCount=catalogArray.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createDictionaryTables</MethodName>
            <MethodComment>/** 
 * Create all the required dictionary tables. Any classes that extend this class and need to create new tables should override this method, and then call this method as the first action in the new method, e.g. &lt;PRE&gt; protected Configuration createDictionaryTables(Configuration cfg, TransactionController tc, DataDescriptorGenerator ddg) throws StandardException { super.createDictionaryTables(params, tc, ddg); ... } &lt;/PRE&gt;
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ddg</ParamName>
                    <ParamType>DataDescriptorGenerator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [appSchemaDesc=new SchemaDescriptor(this,SchemaDescriptor.STD_DEFAULT_SCHEMA_NAME,SchemaDescriptor.DEFAULT_USER_NAME,uuidFactory.recreateUUID(SchemaDescriptor.DEFAULT_SCHEMA_UUID),false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>params;put;[CFG_SYSTABLES_ID, Long.toString(coreInfo[SYSTABLES_CORE_NUM].getHeapConglomerate())]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSTABLES_INDEX1_ID, Long.toString(coreInfo[SYSTABLES_CORE_NUM].getIndexConglomerate(((SYSTABLESRowFactory)coreInfo[SYSTABLES_CORE_NUM].getCatalogRowFactory()).SYSTABLES_INDEX1_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSTABLES_INDEX2_ID, Long.toString(coreInfo[SYSTABLES_CORE_NUM].getIndexConglomerate(((SYSTABLESRowFactory)coreInfo[SYSTABLES_CORE_NUM].getCatalogRowFactory()).SYSTABLES_INDEX2_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCOLUMNS_ID, Long.toString(coreInfo[SYSCOLUMNS_CORE_NUM].getHeapConglomerate())]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCOLUMNS_INDEX1_ID, Long.toString(coreInfo[SYSCOLUMNS_CORE_NUM].getIndexConglomerate(((SYSCOLUMNSRowFactory)coreInfo[SYSCOLUMNS_CORE_NUM].getCatalogRowFactory()).SYSCOLUMNS_INDEX1_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCOLUMNS_INDEX2_ID, Long.toString(coreInfo[SYSCOLUMNS_CORE_NUM].getIndexConglomerate(((SYSCOLUMNSRowFactory)coreInfo[SYSCOLUMNS_CORE_NUM].getCatalogRowFactory()).SYSCOLUMNS_INDEX2_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCONGLOMERATES_ID, Long.toString(coreInfo[SYSCONGLOMERATES_CORE_NUM].getHeapConglomerate())]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCONGLOMERATES_INDEX1_ID, Long.toString(coreInfo[SYSCONGLOMERATES_CORE_NUM].getIndexConglomerate(((SYSCONGLOMERATESRowFactory)coreInfo[SYSCONGLOMERATES_CORE_NUM].getCatalogRowFactory()).SYSCONGLOMERATES_INDEX1_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCONGLOMERATES_INDEX2_ID, Long.toString(coreInfo[SYSCONGLOMERATES_CORE_NUM].getIndexConglomerate(((SYSCONGLOMERATESRowFactory)coreInfo[SYSCONGLOMERATES_CORE_NUM].getCatalogRowFactory()).SYSCONGLOMERATES_INDEX2_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSCONGLOMERATES_INDEX3_ID, Long.toString(coreInfo[SYSCONGLOMERATES_CORE_NUM].getIndexConglomerate(((SYSCONGLOMERATESRowFactory)coreInfo[SYSCONGLOMERATES_CORE_NUM].getCatalogRowFactory()).SYSCONGLOMERATES_INDEX3_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSSCHEMAS_ID, Long.toString(coreInfo[SYSSCHEMAS_CORE_NUM].getHeapConglomerate())]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSSCHEMAS_INDEX1_ID, Long.toString(coreInfo[SYSSCHEMAS_CORE_NUM].getIndexConglomerate(((SYSSCHEMASRowFactory)coreInfo[SYSSCHEMAS_CORE_NUM].getCatalogRowFactory()).SYSSCHEMAS_INDEX1_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>params;put;[CFG_SYSSCHEMAS_INDEX2_ID, Long.toString(coreInfo[SYSSCHEMAS_CORE_NUM].getIndexConglomerate(((SYSSCHEMASRowFactory)coreInfo[SYSSCHEMAS_CORE_NUM].getCatalogRowFactory()).SYSSCHEMAS_INDEX2_ID))]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptor;[systemSchemaDesc, null, SYSSCHEMAS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.IBM_SYSTEM_CAT_SCHEMA_NAME, SchemaDescriptor.SYSCAT_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.IBM_SYSTEM_FUN_SCHEMA_NAME, SchemaDescriptor.SYSFUN_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.IBM_SYSTEM_PROC_SCHEMA_NAME, SchemaDescriptor.SYSPROC_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.IBM_SYSTEM_STAT_SCHEMA_NAME, SchemaDescriptor.SYSSTAT_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.IBM_SYSTEM_NULLID_SCHEMA_NAME, SchemaDescriptor.NULLID_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.STD_SQLJ_SCHEMA_NAME, SchemaDescriptor.SQLJ_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.STD_SYSTEM_DIAG_SCHEMA_NAME, SchemaDescriptor.SYSCS_DIAG_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemSchema;[SchemaDescriptor.STD_SYSTEM_UTIL_SCHEMA_NAME, SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptor;[appSchemaDesc, null, SYSSCHEMAS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSystemSchema</MethodName>
            <MethodComment>/** 
 * Add a system schema to the database. &lt;p&gt;
 * @param schema_name   name of the schema to add.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema_name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema_uuid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [schema_desc=new SchemaDescriptor(this,schema_name,authorizationDatabaseOwner,uuidFactory.recreateUUID(schema_uuid),true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addDescriptor;[schema_desc, null, SYSSCHEMAS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgradeMakeCatalog</MethodName>
            <MethodComment>/** 
 * called by the upgrade code (dd_xena etc) to add a new system catalog.
 * @param tc 				TransactionController to use.
 * @param catalogNumber	catalogNumber
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;makeCatalog;[ti, (catalogNumber == SYSDUMMY1_CATALOG_NUM) ? getSysIBMSchemaDescriptor() : getSystemSchemaDescriptor(), tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgradeJarStorage</MethodName>
            <MethodComment>/** 
 * Called by the upgrade code to upgrade the way we store jar files in the database.&lt;p/&gt; We now use UUID as part of the file name to avoid problems with path delimiters. Also, we henceforth use no schema subdirectories since there is no chance of name collision with the UUID.
 * @param tc TransactionController to use.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSFILES_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSFILESRowFactory [rf=(SYSFILESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [outRow=rf.makeEmptyRow()]</InnerVar>
                <InnerVar>ScanController [scanController=tc.openScan(ti.getHeapConglomerate(),false,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_REPEATABLE_READ,(FormatableBitSet)null,(DataValueDescriptor[])null,0,(Qualifier[][])null,(DataValueDescriptor[])null,0)]</InnerVar>
                <InnerVar>Map&lt;String,Object&gt; [schemas=new HashMap&lt;String,Object&gt;()]</InnerVar>
                <InnerVar>Iterator&lt;String&gt; [i=schemas.keySet().iterator()]</InnerVar>
                <InnerVar>FileResource [fh=tc.getFileHandler()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeCatalog</MethodName>
            <MethodComment>/** 
 * The dirty work of creating a catalog.
 * @param ti			TabInfoImpl describing catalog to create.
 * @param sd			Schema to create catalogs in.
 * @param tc			Transaction context.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDescriptorGenerator [ddg=getDataDescriptorGenerator()]</InnerVar>
                <InnerVar>Properties [heapProperties=ti.getCreateHeapProperties()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ti;setHeapConglomerate;[createConglomerate(ti.getTableName(),tc,ti.getCatalogRowFactory().makeEmptyRowForCurrentVersion(),heapProperties)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addSystemTableToDictionary;[ti, sd, tc, ddg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgradeFixSystemColumnDefinition</MethodName>
            <MethodComment>/** 
 * Upgrade an existing system catalog column's definition by setting it to the value it would have in a newly created database. This is only used to for a couple of columns that had incorrectly nullability. Other uses (e.g. changing column type) might require more work.
 * @param columnNumber			The column to change
 * @param tc						Transaction controller
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowFactory</ParamName>
                    <ParamType>CatalogRowFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SystemColumn [theColumn]</InnerVar>
                <InnerVar>SystemColumn[] [columns=rowFactory.buildColumnList()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSystemSchemaDescriptor()]</InnerVar>
                <InnerVar>TableDescriptor [td=getTableDescriptor(rowFactory.getCatalogName(),sd,tc)]</InnerVar>
                <InnerVar>ColumnDescriptor [cd=makeColumnDescriptor(theColumn,columnNumber,td)]</InnerVar>
                <InnerVar>String [columnName=cd.getColumnName()]</InnerVar>
                <InnerVar>int[] [columnNameColArray=new int[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;updateColumnDescriptor;[cd, td.getUUID(), columnName, columnNameColArray, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgrade_addColumns</MethodName>
            <MethodComment>/** 
 * Upgrade an existing catalog by adding columns.
 * @param rowFactory				Associated with this catalog.
 * @param newColumnIDs			Array of 1-based column ids.
 * @param tc						Transaction controller
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowFactory</ParamName>
                    <ParamType>CatalogRowFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newColumnIDs</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnID]</InnerVar>
                <InnerVar>SystemColumn [currentColumn]</InnerVar>
                <InnerVar>SystemColumn[] [columns=rowFactory.buildColumnList()]</InnerVar>
                <InnerVar>ExecRow [templateRow=rowFactory.makeEmptyRowForCurrentVersion()]</InnerVar>
                <InnerVar>int [columnCount=newColumnIDs.length]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSystemSchemaDescriptor()]</InnerVar>
                <InnerVar>TableDescriptor [td]</InnerVar>
                <InnerVar>long [conglomID]</InnerVar>
                <InnerVar>ColumnDescriptor[] [cdArray=new ColumnDescriptor[columnCount]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;widenConglomerate;[templateRow, newColumnIDs, conglomID, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptorArray;[cdArray, td, SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgrade_SYSCOLUMNS_AUTOINCCYCLE</MethodName>
            <MethodComment>/** 
 * Add autoinccycle columns to an SYSCOLUMNS system catalog
 * @param tc				Transaction controller.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;upgrade_addColumns;[ti.getCatalogRowFactory(), new int[]{10}, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgrade_addInvisibleColumns</MethodName>
            <MethodComment>/** 
 * Add invisible columns to an existing system catalog
 * @param rowFactory				Associated with this catalog.
 * @param newColumnIDs			Array of 1-based column ids.
 * @param tc						Transaction controller
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowFactory</ParamName>
                    <ParamType>CatalogRowFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newColumnIDs</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecRow [templateRow=rowFactory.makeEmptyRowForCurrentVersion()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSystemSchemaDescriptor()]</InnerVar>
                <InnerVar>long [conglomID=getTableDescriptor(rowFactory.getCatalogName(),sd,tc).getHeapConglomerateId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;widenConglomerate;[templateRow, newColumnIDs, conglomID, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>widenConglomerate</MethodName>
            <MethodComment>/** 
 * Adds columns to the conglomerate underlying a system table.
 * @param templateRow				Ultimate shape of base row of table
 * @param newColumnIDs			Array of 1-based column ids
 * @param conglomID				heap id
 * @param tc						Transaction controller
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templateRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newColumnIDs</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomID</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnCount=newColumnIDs.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUUIDForCoreTable</MethodName>
            <MethodComment>/** 
 * Get the UUID for the specified system table.  Prior to Plato, system tables did not have canonical UUIDs, so we need to scan systables to get the UUID when we are updating the core tables.
 * @param tableName		Name of the table
 * @param schemaUUID	UUID of schema
 * @param tc			TransactionController to user
 * @return UUID	The UUID of the core table.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaUUID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
                <InnerVar>ExecRow [row]</InnerVar>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [tableNameOrderable]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSTABLES_CORE_NUM]]</InnerVar>
                <InnerVar>SYSTABLESRowFactory [rf=(SYSTABLESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
                <InnerVar>ExecRow [indexTemplateRow=rf.buildEmptyIndexRow(SYSTABLESRowFactory.SYSTABLES_INDEX1_ID,heapCC.newRowLocationTemplate())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, tableNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>heapCC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>upgrade_initSystemTableCols</MethodName>
            <MethodComment>/** 
 * Initialize noncore columns to fixed values
 * @param tc					The TransactionController for the transaction to do theupgrade in.
 * @param isCoreTable			true if it is a core table
 * @param tableNum				the noncore table number
 * @param columnsToUpdateSet	a bit set of columns to update.  ZERO BASED	
 * @param replaceRow			an object array of Orderables for the new values
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isCoreTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnsToUpdateSet</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replaceRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=(isCoreTable) ? coreInfo[tableNum] : getNonCoreTIByNumber(tableNum)]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(ti.getHeapConglomerate(),false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_REPEATABLE_READ,RowUtil.EMPTY_ROW_BITSET,(DataValueDescriptor[])null,ScanController.NA,(Qualifier[][])null,(DataValueDescriptor[])null,ScanController.NA)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootStrapSystemIndexes</MethodName>
            <MethodComment>/** 
 * Infrastructure work for indexes on catalogs.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ddg</ParamName>
                    <ParamType>DataDescriptorGenerator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cgd=new ConglomerateDescriptor[ti.getNumberOfIndexes()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeAutoincRowLocations</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#computeAutoincRowLocations
 */
</MethodComment>
            <ReturnType>RowLocation[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size]</InnerVar>
                <InnerVar>RowLocation[] [rla=new RowLocation[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetAutoincrementValue</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getSetAutoincrementValue
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnNum=SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE]</InnerVar>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=null]</InnerVar>
                <InnerVar>SYSCOLUMNSRowFactory [rf=(SYSCOLUMNSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [row=rf.makeEmptyRow()]</InnerVar>
                <InnerVar>FormatableBitSet [columnToRead=new FormatableBitSet(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>columnToRead;set;[columnNum - 1]</InnerMethodInvoke>
                <InnerMethodInvoke>columnToRead;set;[columnNum]</InnerMethodInvoke>
                <InnerMethodInvoke>columnToRead;set;[columnNum + 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootstrapOneIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConglomerateDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ddg</ParamName>
                    <ParamType>DataDescriptorGenerator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapConglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isUnique]</InnerVar>
                <InnerVar>ConglomerateController [cc]</InnerVar>
                <InnerVar>ExecRow [baseRow]</InnerVar>
                <InnerVar>ExecIndexRow [indexableRow]</InnerVar>
                <InnerVar>int [numColumns]</InnerVar>
                <InnerVar>long [conglomId]</InnerVar>
                <InnerVar>RowLocation [rl]</InnerVar>
                <InnerVar>CatalogRowFactory [rf=ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>IndexRowGenerator [irg]</InnerVar>
                <InnerVar>ConglomerateDescriptor [conglomerateDescriptor]</InnerVar>
                <InnerVar>Properties [indexProperties=ti.getCreateIndexProperties(indexNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initSystemIndexVariables;[ti, indexNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>irg;getIndexRow;[baseRow, rl, indexableRow, (FormatableBitSet)null]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProperties;put;["baseConglomerateId", Long.toString(heapConglomerateNumber)]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProperties;put;["nUniqueColumns", Integer.toString(isUnique ? numColumns : numColumns + 1)]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProperties;put;["rowLocationColumn", Integer.toString(numColumns)]</InnerMethodInvoke>
                <InnerMethodInvoke>indexProperties;put;["nKeyFields", Integer.toString(numColumns + 1)]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;setIndexConglomerate;[conglomerateDescriptor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initSystemIndexVariables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numCols=ti.getIndexColumnCount(indexNumber)]</InnerVar>
                <InnerVar>int[] [baseColumnPositions=new int[numCols]]</InnerVar>
                <InnerVar>boolean[] [isAscending=new boolean[baseColumnPositions.length]]</InnerVar>
                <InnerVar>IndexRowGenerator [irg=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ti;setIndexRowGenerator;[indexNumber, irg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>populateSYSDUMMY1</MethodName>
            <MethodComment>/** 
 * Populate SYSDUMMY1 table with a single row.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSDUMMY1_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecRow [row=ti.getCatalogRowFactory().makeRow(null,null)]</InnerVar>
                <InnerVar>int [insertRetCode=ti.insertRow(row,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearCaches</MethodName>
            <MethodComment>/** 
 * Clear all of the DataDictionary caches.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;clearCaches;[true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearCaches</MethodName>
            <MethodComment>/** 
 * Clear the DataDictionary caches, including the sequence caches if requested..
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clearSequenceCaches</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>nameTdCache;cleanAll;[]</InnerMethodInvoke>
                <InnerMethodInvoke>nameTdCache;ageOut;[]</InnerMethodInvoke>
                <InnerMethodInvoke>OIDTdCache;cleanAll;[]</InnerMethodInvoke>
                <InnerMethodInvoke>OIDTdCache;ageOut;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearSequenceCaches</MethodName>
            <MethodComment>/** 
 * Flush sequence caches to disk so that we don't leak unused, pre-allocated numbers.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sequenceGeneratorCache;cleanAll;[]</InnerMethodInvoke>
                <InnerMethodInvoke>sequenceGeneratorCache;ageOut;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSystemTableToDictionary</MethodName>
            <MethodComment>/** 
 * Add the required entries to the data dictionary for a System table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ddg</ParamName>
                    <ParamType>DataDescriptorGenerator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CatalogRowFactory [crf=ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>String [name=ti.getTableName()]</InnerVar>
                <InnerVar>long [conglomId=ti.getHeapConglomerate()]</InnerVar>
                <InnerVar>SystemColumn[] [columnList=crf.buildColumnList()]</InnerVar>
                <InnerVar>UUID [heapUUID=crf.getCanonicalHeapUUID()]</InnerVar>
                <InnerVar>String [heapName=crf.getCanonicalHeapName()]</InnerVar>
                <InnerVar>TableDescriptor [td]</InnerVar>
                <InnerVar>UUID [toid]</InnerVar>
                <InnerVar>int [columnCount]</InnerVar>
                <InnerVar>SystemColumn [column]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cgd=ddg.newConglomerateDescriptor(conglomId,heapName,false,null,false,heapUUID,toid,sd.getUUID())]</InnerVar>
                <InnerVar>ColumnDescriptor[] [cdlArray=new ColumnDescriptor[columnCount]]</InnerVar>
                <InnerVar>ColumnDescriptorList [cdl=td.getColumnDescriptorList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>td;setUUID;[crf.getCanonicalTableUUID()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptor;[td, sd, SYSTABLES_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptor;[cgd, sd, SYSCONGLOMERATES_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addDescriptorArray;[cdlArray, td, SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Converts a SystemColumn to a ColumnDescriptor.
 * @param column	a SystemColumn
 * @param columnPosition Position of the column in the table, one based.
 * @param td		descriptor for table that column lives in
 * @return	a ColumnDes*criptor
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>SystemColumn</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConglomerate</MethodName>
            <MethodComment>/** 
 * Create a conglomerate for a system table
 * @param name 		Name of new catalog.
 * @param tc			Transaction context.
 * @param rowTemplate	Template for rows for the new table
 * @param properties	Properties for createConglomerate
 * @return	Conglomerate id.
 * @exception StandardException Standard Derby error policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowTemplate</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [conglomId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIDValueAsCHAR</MethodName>
            <MethodComment>/** 
 * Converts a UUID to an DataValueDescriptor.
 * @return	the UUID converted to an DataValueDescriptor
 */
</MethodComment>
            <ReturnType>SQLChar</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [uuidString=uuid.toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeCatalogInfo</MethodName>
            <MethodComment>/** 
 * Initialize catalog information. This method is overridden by children.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initializeCoreInfo;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initializeNoncoreInfo;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeCoreInfo</MethodName>
            <MethodComment>/** 
 * Initialized the core info array.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>TabInfoImpl[] [lcoreInfo=coreInfo=new TabInfoImpl[NUM_CORE]]</InnerVar>
                <InnerVar>UUIDFactory [luuidFactory=uuidFactory]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeNoncoreInfo</MethodName>
            <MethodComment>/** 
 * Initialized the noncore info array.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionCompile</MethodName>
            <MethodComment>/** 
 * Get the TransactionController to use, when not passed in as a parameter.  (This hides logic about whether or not we're at boot time in a single place.  NOTE:  There's no LCC at boot time.) NOTE: All &lt;get&gt; methods in the DD should call this method.
 * @return TransactionController	The TC to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionExecute</MethodName>
            <MethodComment>/** 
 * Get the TransactionController to use, when not passed in as a parameter.  (This hides logic about whether or not we're at boot time in a single place.  NOTE:  There's no LCC at boot time.) NOTE: All &lt;get&gt; methods in the DD should call this method.
 * @return TransactionController	The TC to use.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorViaIndex</MethodName>
            <MethodComment>/** 
 * Return a (single or list of) catalog row descriptor(s) from a system table where the access is from the index to the heap.
 * @param indexId	The id of the index (0 to # of indexes on table) to use
 * @param keyRow	The supplied ExecIndexRow for search
 * @param ti		The TabInfoImpl to use
 * @param parentTupleDescriptor		The parentDescriptor, if applicable.
 * @param list      The list to build, if supplied.  If null, thencaller expects a single descriptor
 * @param returnType The type of descriptor to return
 * @param forUpdate	Whether or not to open the index for update.
 * @return	The last matching descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>ScanQualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTupleDescriptor</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>? super T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionController [tc=getTransactionCompile()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorViaIndex</MethodName>
            <MethodComment>/** 
 * Return a (single or list of) catalog row descriptor(s) from a system table where the access is from the index to the heap. This overload variant takes an explicit tc, in contrast to the normal one which uses the one returned by getTransactionCompile.
 * @param indexId   The id of the index (0 to # of indexes on table) to use
 * @param keyRow    The supplied ExecIndexRow for search
 * @param ti        The TabInfoImpl to use
 * @param parentTupleDescriptor The parentDescriptor, if applicable.
 * @param list      The list to build, if supplied.  If null, thencaller expects a single descriptor
 * @param returnType The type of descriptor to return
 * @param forUpdate Whether or not to open the index for update.
 * @param isolationLevel Use this explicit isolation level. Only ISOLATION_REPEATABLE_READ (normal usage) or ISOLATION_READ_UNCOMMITTED (corner cases) supported for now.
 * @param tc        Transaction controller
 * @return The last matching descriptor. If isolationLevel isISOLATION_READ_UNCOMMITTED, the base row may be gone by the time we access it via the index; in such a case a null is returned.
 * @exception StandardException Thrown on error.
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>ScanQualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTupleDescriptor</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>? super T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorViaIndexMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyRow</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>ScanQualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTupleDescriptor</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>? super T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CatalogRowFactory [rf=ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ConglomerateController [heapCC]</InnerVar>
                <InnerVar>ExecIndexRow [indexRow1]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>RowLocation [baseRowLocation]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>T [td=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>heapCC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugGenerateInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>strbuf</ParamName>
                    <ParamType>StringBuffer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapCC</ParamName>
                    <ParamType>ConglomerateController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorViaHeap</MethodName>
            <MethodComment>/** 
 * Return a (single or list of) catalog row descriptor(s) from a system table where the access a heap scan
 * @param columns                   which columns to fetch from the systemtable, or null to fetch all columns
 * @param scanQualifiers			qualifiers
 * @param ti						The TabInfoImpl to use
 * @param parentTupleDescriptor		The parentDescriptor, if applicable.
 * @param list						The list to build, if supplied.  If null, then caller expects a single descriptor
 * @param returnType                The type of descriptor to look for
 * @return	The last matching descriptor
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>ScanQualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTupleDescriptor</ParamName>
                    <ParamType>TupleDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>? super T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CatalogRowFactory [rf=ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [outRow]</InnerVar>
                <InnerVar>ScanController [scanController]</InnerVar>
                <InnerVar>TransactionController [tc]</InnerVar>
                <InnerVar>T [td=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scanController;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNonCoreTI</MethodName>
            <MethodComment>/** 
 * Get a TabInfoImpl for a non-core table. (We fault in information about non-core tables as needed.)
 * @param catalogNumber	The index into noncoreTable[].
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TabInfoImpl</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTIByNumber(catalogNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;faultInTabInfo;[ti]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNonCoreTIByNumber</MethodName>
            <MethodComment>/** 
 * returns the tabinfo for a non core system catalog. Input is a catalogNumber (defined in DataDictionary). 
 */
</MethodComment>
            <ReturnType>TabInfoImpl</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [nonCoreNum=catalogNumber - NUM_CORE]</InnerVar>
                <InnerVar>TabInfoImpl [retval=noncoreInfo[nonCoreNum]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initSystemIndexVariables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes=ti.getNumberOfIndexes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearNoncoreTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nonCoreNum</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>faultInTabInfo</MethodName>
            <MethodComment>/** 
 * Finishes building a TabInfoImpl if it hasn't already been faulted in. NOP if TabInfoImpl has already been faulted in.
 * @param ti	TabInfoImpl to fault in.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ti</ParamName>
                    <ParamType>TabInfoImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numIndexes]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexRowFromHeapRow</MethodName>
            <MethodComment>/** 
 * Get an index row based on a row from the heap.
 * @param irg		IndexRowGenerator to use
 * @param rl		RowLocation for heap
 * @param heapRow	Row from the heap
 * @return ExecIndexRow	Index row.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ExecIndexRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>irg</ParamName>
                    <ParamType>IndexRowGenerator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [indexRow]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>irg;getIndexRow;[heapRow, rl, indexRow, (FormatableBitSet)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEngineType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSYSCOLUMNSHeapConglomerateNumber</MethodName>
            <MethodComment>/** 
 * Get the heap conglomerate number for SYS.SYSCOLUMNS. (Useful for adding new index to the table.)
 * @return The heap conglomerate number for SYS.SYSCOLUMNS.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSYSCOLUMNSIndex2Property</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index2ConglomerateNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>startupParameters;put;[CFG_SYSCOLUMNS_INDEX2_ID, Long.toString(index2ConglomerateNumber)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBootParameter</MethodName>
            <MethodComment>/** 
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>required</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [value=startParams.getProperty(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemSQLName</MethodName>
            <MethodComment>/** 
 * Returns a unique system generated name of the form SQLyymmddhhmmssxxn yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second, xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value, n - number between 0-9 The number at the end is to handle more than one system generated name request came at the same time. In that case, the timestamp will remain the same, we will just increment n at the end of the name. Following is how we get around the problem of more than 10 system generated name requestes at the same time: When the database boots up, we start a counter with value -1 for the last digit in the generated name. We also keep the time in millisec to keep track of when the last system name was generated. At the boot time, it will be default to 0L. In addition, we have a calendar object for the time in millisec That calendar object is used to fetch yy, mm, dd, etc for the string SQLyymmddhhmmssxxn When the first request for the system generated name comes, time of last system generated name will be less than the current time. We initialize the counter to 0, set the time of last system generated name to the current time truncated off to lower 10ms time. The first name request is the only time we know for sure the time of last system generated name will be less than the current time. After this first request, the next request could be at any time. We go through the following algorithm for every generated name request. First check if the current time(truncated off to lower 10ms) is greater than the timestamp for last system generated name If yes, then we change the timestamp for system generated name to the current timestamp and reset the counter to 0 and generate the name using the current timestamp and 0 as the number at the end of the generated name. If no, then it means this request for generated name has come at the same time as last one. Or it may come at a time less than the last generated name request. This could be because of seasonal time change or somebody manually changing the time on the computer. In any case, if the counter is less than 10(meaning this is not yet our 11th request for generated name at a given time), we use that in the generated name. But if the counter has reached 10(which means, this is the 11th name request at the same time), then we increment the system generated name timestamp by 10ms and reset the counter to 0 (notice, at this point, the timestamp for system generated names is not in sync with the real current time, but we need to have this mechanism to get around the problem of more than 10 generated name requests at a same physical time).
 * @return	system generated unique name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuffer [generatedSystemSQLName=new StringBuffer("SQL")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>twoDigits</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [retval]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrementValue</MethodName>
            <MethodComment>/** 
 * sets a new value in SYSCOLUMNS for a particular autoincrement column.
 * @param tc		 Transaction Controller to use.
 * @param columnName Name of the column.
 * @param aiValue	 Value to write to SYSCOLUMNS.
 * @param incrementNeeded whether to increment the value passed in by theuser (aiValue) or not before writing it to SYSCOLUMNS.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aiValue</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>incrementNeeded</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=null]</InnerVar>
                <InnerVar>SYSCOLUMNSRowFactory [rf=(SYSCOLUMNSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [row=rf.makeEmptyRow()]</InnerVar>
                <InnerVar>boolean[] [bArray=new boolean[2]]</InnerVar>
                <InnerVar>int[] [colsToUpdate=new int[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, getIDValueAsCHAR(tableUUID)]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, new SQLChar(columnName)]</InnerMethodInvoke>
                <InnerMethodInvoke>row;setColumn;[SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE, new SQLLongint(aiValue)]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;updateRow;[keyRow, row, SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID, bArray, colsToUpdate, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeRowLocation</MethodName>
            <MethodComment>/** 
 * Computes the RowLocation in SYSCOLUMNS for a particular  autoincrement column.
 * @param tc			Transaction Controller to use.
 * @param td			Table Descriptor.
 * @param columnName	Name of column which has autoincrement column.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=coreInfo[SYSCOLUMNS_CORE_NUM]]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=null]</InnerVar>
                <InnerVar>UUID [tableUUID=td.getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, getIDValueAsCHAR(tableUUID)]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, new SQLChar(columnName)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeSequenceRowLocation</MethodName>
            <MethodComment>/** 
 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also constructs the sequence descriptor.
 * @param tc			Transaction Controller to use.
 * @param sequenceIDstring UUID of the sequence as a string
 * @param rowLocation OUTPUT param for returing the row location
 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceIDstring</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceDescriptor</ParamName>
                    <ParamType>SequenceDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, new SQLChar(sequenceIDstring)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateCurrentSequenceValue</MethodName>
            <MethodComment>/** 
 * Set the current value of an ANSI/ISO sequence. This method does not perform any sanity checking but assumes that the caller knows what they are doing. If the old value on disk is not what we expect it to be, then we are in a race with another session. They won and we don't update the value on disk. However, if the old value is null, that is a signal to us that we should update the value on disk anyway.
 * @param tc			Transaction Controller to use.
 * @param rowLocation Row in SYSSEQUENCES to update.
 * @param wait True if we should wait for locks
 * @param oldValue What we expect to find in the CURRENTVALUE column.
 * @param newValue What to stuff into the CURRENTVALUE column.
 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
 * @exception StandardException thrown on failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnNum=SYSSEQUENCESRowFactory.SYSSEQUENCES_CURRENT_VALUE]</InnerVar>
                <InnerVar>FormatableBitSet [columnToUpdate=new FormatableBitSet(SYSSEQUENCESRowFactory.SYSSEQUENCES_COLUMN_COUNT)]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=null]</InnerVar>
                <InnerVar>SYSSEQUENCESRowFactory [rf=(SYSSEQUENCESRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecRow [row=rf.makeEmptyRow()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>columnToUpdate;set;[columnNum - 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentValueAndAdvance</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.dictionary.DataDictionary#getCurrentValueAndAdvance
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDstring</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SequenceUpdater [sequenceUpdater=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekAtIdentity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=getLCC()]</InnerVar>
                <InnerVar>TransactionController [tc=lcc.getTransactionExecute()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSchemaDescriptor(schemaName,tc,true)]</InnerVar>
                <InnerVar>TableDescriptor [td=getTableDescriptor(tableName,sd,tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekAtSequence</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [uuid=getSequenceID(schemaName,sequenceName)]</InnerVar>
                <InnerVar>SequenceUpdater [sequenceUpdater=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBulkInsertCounter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BulkInsertCounter</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restart</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SequenceUpdater [sequenceUpdater=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flushBulkInsertCounter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sequenceUUIDString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bic</ParamName>
                    <ParamType>BulkInsertCounter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SequenceUpdater [sequenceUpdater=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowLocationTemplate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowLocation [rl]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=null]</InnerVar>
                <InnerVar>TransactionController [tc=lcc.getTransactionCompile()]</InnerVar>
                <InnerVar>long [tableId=td.getHeapConglomerateId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTableDescriptorToOtherCache</MethodName>
            <MethodComment>/** 
 * Add a table descriptor to the "other" cache. The other cache is determined by the type of the object c.
 * @param td	TableDescriptor to add to the other cache.
 * @param c		Cacheable Object which lets us figure out the other cache.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Cacheable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheManager [otherCache=(c instanceof OIDTDCacheable) ? nameTdCache : OIDTdCache]</InnerVar>
                <InnerVar>Object [key]</InnerVar>
                <InnerVar>TDCacheable [otherCacheEntry=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStatisticsDescriptors</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#dropStatisticsDescriptors 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>referenceUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSTATISTICS_CATALOG_NUM)]</InnerVar>
                <InnerVar>DataValueDescriptor [first, second]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, first]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSSTATISTICSRowFactory.SYSSTATISTICS_INDEX1_ID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLCC</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LanguageConnectionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newSystemSchemaDesc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newDeclaredGlobalTemporaryTablesSchemaDesc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkVersion</MethodName>
            <MethodComment>/** 
 * Check to see if a database has been upgraded to the required level in order to use a language feature. 
 * @param requiredMajorVersion Data Dictionary major version
 * @param feature Non-null to throw an error, null to return the state of the version match.
 * @return True if the database has been upgraded to the required level, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requiredMajorVersion</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>feature</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnlyUpgrade</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReadOnlyUpgrade</MethodName>
            <MethodComment>/** 
 * Mark this database as a read only database whose stored prepared statements are invalid because some kind of upgrade is needed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSystemSps</MethodName>
            <MethodComment>/** 
 * Create system built-in metadata stored prepared statements.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;createSPSSet;[tc, false, getSystemSchemaDescriptor().getUUID()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createSPSSet;[tc, true, getSysIBMSchemaDescriptor().getUUID()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSPSSet</MethodName>
            <MethodComment>/** 
 * Create a set of stored prepared statements from a properties file. Key is the statement name, value is the SQL statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [p=getQueryDescriptions(net)]</InnerVar>
                <InnerVar>Enumeration [e=p.keys()]</InnerVar>
                <InnerVar>boolean [nocompile=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSystemProcedureOrFunction</MethodName>
            <MethodComment>/** 
 * Generic create procedure routine. &lt;p&gt; Takes the input procedure and inserts it into the appropriate catalog.   Assumes all arguments are "IN" type.
 * @param routine_name  name of the routine in java and the SQL procedure name.
 * @param arg_names     String array of procedure argument names in order.
 * @param arg_types     Internal SQL types of the arguments
 * @param routine_sql_control     One of the RoutineAliasInfo constants: MODIFIES_SQL_DATA READS_SQL_DATA CONTAINS_SQL NO_SQL
 * @param isDeterministic True if the procedure/function is DETERMINISTIC
 * @param return_type   null for procedure.  For functions the return typeof the function.
 * @param newlyCreatedRoutines evolving set of routines, some of which may need permissions later on
 * @param tc            an instance of the TransactionController
 * @param procClass     the fully qualified name of the class that containsjava definitions for the stored procedures
 * @return UUID 		UUID of system routine that got created.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routine_name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema_uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg_names</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg_types</ParamName>
                    <ParamType>TypeDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_out_param</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_result_sets</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>routine_sql_control</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isDeterministic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasVarargs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>return_type</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [num_args=0]</InnerVar>
                <InnerVar>int[] [arg_modes=null]</InnerVar>
                <InnerVar>RoutineAliasInfo [routine_alias_info=new RoutineAliasInfo(routine_name,num_args,arg_names,arg_types,arg_modes,num_result_sets,RoutineAliasInfo.PS_JAVA,routine_sql_control,isDeterministic,hasVarargs,false,true,return_type)]</InnerVar>
                <InnerVar>UUID [routine_uuid=getUUIDFactory().createUUID()]</InnerVar>
                <InnerVar>AliasDescriptor [ads=new AliasDescriptor(this,routine_uuid,routine_name,schema_uuid,procClass,(return_type == null) ? AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR,(return_type == null) ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR,false,routine_alias_info,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addDescriptor;[ads, null, DataDictionary.SYSALIASES_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>newlyCreatedRoutines;add;[routine_name]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSystemProcedureOrFunction</MethodName>
            <MethodComment>/** 
 * Generic create procedure routine. Takes the input procedure and inserts it into the appropriate catalog. Assumes all arguments are "IN" type.
 * @param routine_name  name of the routine in java and the SQLprocedure name.
 * @param arg_names     String array of procedure argument names in order.
 * @param arg_types     Internal SQL types of the arguments
 * @param routine_sql_control One of the RoutineAliasInfo constants: MODIFIES_SQL_DATA READS_SQL_DATA CONTAINS_SQL NO_SQL
 * @param isDeterministic True if the procedure/function is DETERMINISTIC
 * @param return_type   null for procedure.  For functions the return typeof the function.
 * @param newlyCreatedRoutines evolving set of routines, some of which may need permissions later on
 * @param tc            an instance of the TransactionController
 * @return UUID         UUID of system routine that got created.
 * @throws StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routine_name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema_uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg_names</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg_types</ParamName>
                    <ParamType>TypeDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_out_param</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_result_sets</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>routine_sql_control</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isDeterministic</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasVarargs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>return_type</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [routine_uuid=createSystemProcedureOrFunction(routine_name,schema_uuid,arg_names,arg_types,num_out_param,num_result_sets,routine_sql_control,isDeterministic,hasVarargs,return_type,newlyCreatedRoutines,tc,"org.apache.derby.catalog.SystemProcedures")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_SYSCS_procedures</MethodName>
            <MethodComment>/** 
 * Create system procedures &lt;p&gt; Used to add the system procedures to the database when it is created.  System procedures are currently added to either SYSCS_UTIL or SQLJ schemas. &lt;p&gt;
 * @param tc     transaction controller to use.  Counts on caller tocommit.
 * @param newlyCreatedRoutines evolving set of routines which may need to be given permissions later on
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDescriptor [varchar32672Type=DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)]</InnerVar>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
                <InnerVar>UUID [sqlJUUID=getSchemaDescriptor(SchemaDescriptor.STD_SQLJ_SCHEMA_NAME,tc,true).getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;create_10_1_system_procedures;[tc, newlyCreatedRoutines, sysUtilUUID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_2_system_procedures;[tc, newlyCreatedRoutines, sysUtilUUID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_3_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_5_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_6_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_9_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_10_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_11_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_12_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_13_system_procedures;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_SYSIBM_procedures</MethodName>
            <MethodComment>/** 
 * Create system procedures in SYSIBM &lt;p&gt; Used to add the system procedures to the database when it is created.  Full upgrade from version 5.1 or earlier also calls this method. &lt;p&gt;
 * @param newlyCreatedRoutines evolving set of routines which we're adding (some may need permissions later on)
 * @param tc     transaction controller to use.  Counts on caller tocommit.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysIBMUUID=getSysIBMSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>grantPublicAccessToSystemRoutines</MethodName>
            <MethodComment>/** 
 * Grant PUBLIC access to specific system routines. Currently, this is  done for some routines in SYSCS_UTIL schema. We grant access to routines which we have just added. Doing it this way lets us declare these routines in one place and re-use this logic during database creation and during upgrade.
 * @param tc	TransactionController to use
 * @param authorizationID	authorization ID of the permission grantor
 * @throws StandardException	Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>HashSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [schemaID=getSystemUtilSchemaDescriptor().getUUID().toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>grantPublicAccessToSystemRoutine</MethodName>
            <MethodComment>/** 
 * Grant PUBLIC access to a system routine. This method should be used only  for granting access to a system routine (other than routines in SYSFUN  schema). It expects the routine to be present in SYSALIASES catalog. 
 * @param schemaID	Schema ID
 * @param routineName	Routine Name
 * @param nameSpace	Indicates whether the routine is a function/procedure.
 * @param tc	TransactionController to use
 * @param authorizationID	authorization ID of the permission grantor
 * @throws StandardException	Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>routineName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nameSpace</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AliasDescriptor [ad=getAliasDescriptor(schemaID,routineName,nameSpace)]</InnerVar>
                <InnerVar>UUID [routineUUID=ad.getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;createRoutinePermPublicDescriptor;[routineUUID, tc, authorizationID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createRoutinePermPublicDescriptor</MethodName>
            <MethodComment>/** 
 * Create RoutinePermDescriptor to grant access to PUBLIC for this system routine using the grantor specified in authorizationID.
 * @param routineUUID	uuid of the routine
 * @param tc	TransactionController to use
 * @param authorizationID	authorization ID of the permission grantor
 * @throws StandardException	Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routineUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RoutinePermsDescriptor [routinePermDesc=new RoutinePermsDescriptor(this,"PUBLIC",authorizationID,routineUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addDescriptor;[routinePermDesc, null, DataDictionary.SYSROUTINEPERMS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_1_system_procedures</MethodName>
            <MethodComment>/** 
 * Create system procedures added in version 10.1. &lt;p&gt; Create 10.1 system procedures, called by either code creating new database, or code doing hard upgrade from previous version. &lt;p&gt;
 * @param tc                 booting transaction
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @param sysUtilUUID   uuid of the SYSUTIL schema.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sysUtilUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_2_system_procedures</MethodName>
            <MethodComment>/** 
 * Create system procedures added in version 10.2. &lt;p&gt; Create 10.2 system procedures, called by either code creating new database, or code doing hard upgrade from previous version. &lt;p&gt;
 * @param tc booting transaction
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @param sysUtilUUID   uuid of the SYSUTIL schema.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sysUtilUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_3_system_procedures_SYSIBM</MethodName>
            <MethodComment>/** 
 * Create system procedures added in version 10.3. Create 10.3 system procedures related to the LOB Methods , called by either code creating new database, or code doing hard upgrade from previous version.
 * @param tc            an instance of the TransactionController class.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @throws StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [schema_uuid=getSysIBMSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_5_system_procedures</MethodName>
            <MethodComment>/** 
 * Create the System procedures that are added to 10.5.
 * @param tc an instance of the TransactionController.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @throws StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_6_system_procedures</MethodName>
            <MethodComment>/** 
 * Create the System procedures that are added to 10.6.
 * @param tc an instance of the TransactionController.
 * @throws StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_3_system_procedures</MethodName>
            <MethodComment>/** 
 * Create the System procedures that are added in 10.3.
 * @param tc an instance of the TransactionController.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @throws StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;create_10_3_system_procedures_SYSCS_UTIL;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
                <InnerMethodInvoke>null;create_10_3_system_procedures_SYSIBM;[tc, newlyCreatedRoutines]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_3_system_procedures_SYSCS_UTIL</MethodName>
            <MethodComment>/** 
 * Create system procedures that are part of the SYSCS_UTIL schema added in version 10.3. &lt;p&gt; Create 10.3 system procedures, called by either code creating new database, or code doing hard upgrade from previous version. &lt;p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_9_system_procedures</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create system procedures that are part of the SYSCS_UTIL schema added in version 10.9. These include the procedures for managing NATIVE credentials. See DERBY-866. &lt;/p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_10_system_procedures</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create system procedures that are part of the SYSCS_UTIL schema, added in version 10.10. &lt;/p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
                <InnerVar>TypeDescriptor [varchar32672Type=DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_11_system_procedures</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create system procedures that are part of the SYSCS_UTIL schema, added in version 10.11. &lt;/p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_12_system_procedures</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create system procedures that are part of the SYSCS_UTIL schema, added in version 10.12. &lt;/p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create_10_13_system_procedures</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create system procedures that are part of the SYSCS_UTIL schema, added in version 10.13. &lt;/p&gt;
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newlyCreatedRoutines</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUID [sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID()]</InnerVar>
                <InnerVar>TypeDescriptor [varchar32672Type=DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQueryDescriptions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Properties [p=new Properties()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newSList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges on a table
 * @param tableUUID
 * @param authorizationId The user name
 * @return a TablePermsDescriptor or null if the user has no permissions on the table.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>TablePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TablePermsDescriptor [key=new TablePermsDescriptor(this,authorizationId,(String)null,tableUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablePermissions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TablePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tablePermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TablePermsDescriptor [key=new TablePermsDescriptor(this,tablePermsUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPermissions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>PermissionsDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Cacheable [entry=getPermissionsCache().find(key)]</InnerVar>
                <InnerVar>Object [perms=entry.getIdentity()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getPermissionsCache();release;[entry]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colPermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColPermsDescriptor [key=new ColPermsDescriptor(this,colPermsUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's column privileges for a table.
 * @param tableUUID
 * @param privType (as int) Authorizer.SELECT_PRIV, Authorizer.UPDATE_PRIV, or Authorizer.REFERENCES_PRIV
 * @param forGrant
 * @param authorizationId The user name
 * @return a ColPermsDescriptor or null if the user has no separate columnpermissions of the specified type on the table. Note that the user may have been granted permission on all the columns of the table (no column list), in which case this routine will return null. You must also call getTablePermissions to see if the user has permission on a set of columns.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forGrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [privTypeStr=forGrant ? colPrivTypeMapForGrant[privType] : colPrivTypeMap[privType]]</InnerVar>
                <InnerVar>ColPermsDescriptor [key=new ColPermsDescriptor(this,authorizationId,(String)null,tableUUID,privTypeStr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's column privileges for a table. This routine gets called  during revoke privilege processing
 * @param tableUUID
 * @param privTypeStr (as String) Authorizer.SELECT_PRIV, Authorizer.UPDATE_PRIV, or Authorizer.REFERENCES_PRIV
 * @param forGrant
 * @param authorizationId The user name
 * @return a ColPermsDescriptor or null if the user has no separate columnpermissions of the specified type on the table. Note that the user may have been granted permission on all the columns of the table (no column list), in which case this routine will return null. You must also call getTablePermissions to see if the user has permission on a set of columns.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privTypeStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forGrant</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColPermsDescriptor [key=new ColPermsDescriptor(this,authorizationId,(String)null,tableUUID,privTypeStr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutinePermissions</MethodName>
            <MethodComment>/** 
 * Get one user's permissions for a routine (function or procedure).
 * @param routineUUID
 * @param authorizationId The user's name
 * @return The descriptor of the users permissions for the routine.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>RoutinePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routineUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RoutinePermsDescriptor [key=new RoutinePermsDescriptor(this,authorizationId,(String)null,routineUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutinePermissions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RoutinePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routinePermsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RoutinePermsDescriptor [key=new RoutinePermsDescriptor(this,routinePermsUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRemovePermissionsDescriptor</MethodName>
            <MethodComment>/** 
 * Add or remove a permission to/from the permission database.
 * @param add if true then the permission is added, if false the permission is removed
 * @param perm
 * @param grantee
 * @param tc
 * @return True means revoke has removed a privilege from systemtable and hence the caller of this method should send invalidation  actions to PermssionDescriptor's dependents.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>add</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>perm</ParamName>
                    <ParamType>PermissionsDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [catalogNumber=perm.getCatalogNumber()]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(catalogNumber)]</InnerVar>
                <InnerVar>PermissionsCatalogRowFactory [rf=(PermissionsCatalogRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>int [primaryIndexNumber=rf.getPrimaryKeyIndexNumber()]</InnerVar>
                <InnerVar>ConglomerateController [heapCC=tc.openConglomerate(ti.getHeapConglomerate(),false,0,TransactionController.MODE_RECORD,TransactionController.ISOLATION_REPEATABLE_READ)]</InnerVar>
                <InnerVar>RowLocation [rl=null]</InnerVar>
                <InnerVar>ExecIndexRow [key=rf.buildIndexKeyRow(primaryIndexNumber,perm)]</InnerVar>
                <InnerVar>ExecRow [existingRow=ti.getRow(tc,key,primaryIndexNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>perm;setUUID;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>perm;setGrantee;[grantee]</InnerMethodInvoke>
                <InnerMethodInvoke>null;removePermEntryInCache;[perm]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedTablePermsDescriptor</MethodName>
            <MethodComment>/** 
 * Get a table permissions descriptor from the system tables, without going through the cache. This method is called to fill the permissions cache.
 * @return a TablePermsDescriptor that describes the table permissions granted to the grantee, nullif no table-level permissions have been granted to him on the table.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>TablePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>TablePermsDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedColPermsDescriptor</MethodName>
            <MethodComment>/** 
 * Get a column permissions descriptor from the system tables, without going through the cache. This method is called to fill the permissions cache.
 * @return a ColPermsDescriptor that describes the column permissions granted to the grantee, nullif no column permissions have been granted to him on the table.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>ColPermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>ColPermsDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedPermissionsDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(catalogNumber)]</InnerVar>
                <InnerVar>PermissionsCatalogRowFactory [rowFactory=(PermissionsCatalogRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=rowFactory.buildIndexKeyRow(indexNumber,key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedRoutinePermsDescriptor</MethodName>
            <MethodComment>/** 
 * Get a routine permissions descriptor from the system tables, without going through the cache. This method is called to fill the permissions cache.
 * @return a RoutinePermsDescriptor that describes the table permissions granted to the grantee, nullif no table-level permissions have been granted to him on the table.
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>RoutinePermsDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>RoutinePermsDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVTIClass</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getVTIClass(TableDescriptor,boolean)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>asTableFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltinVTIClass</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getBuiltinVTIClass(TableDescriptor,boolean)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>asTableFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleGrantDescriptor</MethodName>
            <MethodComment>/** 
 * @see DataDictionary#getRoleGrantDescriptor(UUID)
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleDefinitionDescriptor</MethodName>
            <MethodComment>/** 
 * Get the target role definition by searching for a matching row in SYSROLES by rolename where isDef==true.  Read only scan. Uses index on (rolename, isDef) columns.
 * @param roleName The name of the role we're interested in.
 * @return The descriptor (row) for the role
 * @exception StandardException Thrown on error
 * @see DataDictionary#getRoleDefinitionDescriptor
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [roleNameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [isDefOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, roleNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, isDefOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoleGrantDescriptor</MethodName>
            <MethodComment>/** 
 * Get the target role by searching for a matching row in SYSROLES by rolename, grantee and grantor.  Read only scan. Uses index on roleid, grantee and grantor columns.
 * @param roleName	    The name of the role we're interested in.
 * @param grantee       The grantee
 * @param grantor       The grantor
 * @return	            The descriptor for the role grant
 * @exception StandardException  Thrown on error
 * @see DataDictionary#getRoleGrantDescriptor(String,String,String)
 */
</MethodComment>
            <ReturnType>RoleGrantDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantee</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>grantor</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [roleNameOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [granteeOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [grantorOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSROLES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, roleNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, granteeOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[3, grantorOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>existsGrantToAuthid</MethodName>
            <MethodComment>/** 
 * Check all dictionary tables and return true if there is any GRANT descriptor containing &lt;code&gt;authId&lt;/code&gt; as its grantee.
 * @param authId grantee for which a grant exists or not
 * @param tc TransactionController for the transaction
 * @return boolean true if such a grant exists
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropJDBCMetadataSPSes</MethodName>
            <MethodComment>/** 
 * Remove metadata stored prepared statements.
 * @param tc the xact
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateMetadataSPSes</MethodName>
            <MethodComment>/** 
 * Drop and recreate metadata stored prepared statements.
 * @param tc the xact
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropJDBCMetadataSPSes;[tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createSystemSps;[tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSequenceDescriptor</MethodName>
            <MethodComment>/** 
 * Drops a sequence descriptor
 * @param descriptor The descriptor to drop
 * @param tc         The TransactionController.
 * @throws StandardException Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descriptor</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [sequenceIdOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=(ExecIndexRow)exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, sequenceIdOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>ti;deleteRow;[tc, keyRow, SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropSequenceID;[descriptor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSequenceDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SequenceDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [UUIDStringOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
                <InnerVar>SequenceDescriptor [sequenceDescriptor=getDescriptorViaIndex(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,SequenceDescriptor.class,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, UUIDStringOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;putSequenceID;[sequenceDescriptor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSequenceDescriptor</MethodName>
            <MethodComment>/** 
 * Get the sequence descriptor given a sequence name and a schema Id.
 * @param sequenceName The sequence name, guaranteed to be unique only within its schema.
 * @param sd           The schema descriptor.
 * @return The SequenceDescriptor for the constraints.
 * @throws StandardException Thrown on failure
 */
</MethodComment>
            <ReturnType>SequenceDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [schemaIDOrderable]</InnerVar>
                <InnerVar>DataValueDescriptor [sequenceNameOrderable]</InnerVar>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM)]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(2)]</InnerVar>
                <InnerVar>SequenceDescriptor [sequenceDescriptor=getDescriptorViaIndex(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX2_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List&lt;TupleDescriptor&gt;)null,SequenceDescriptor.class,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, schemaIDOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>keyRow;setColumn;[2, sequenceNameOrderable]</InnerMethodInvoke>
                <InnerMethodInvoke>null;putSequenceID;[sequenceDescriptor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>putSequenceID</MethodName>
            <MethodComment>/** 
 * Map ( schemaName, sequenceName ) to sequenceID 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [schema=sd.getSchemaDescriptor()]</InnerVar>
                <InnerVar>String [schemaName=schema.getSchemaName()]</InnerVar>
                <InnerVar>String [sequenceName=sd.getSequenceName()]</InnerVar>
                <InnerVar>String [uuid=sd.getUUID().toString()]</InnerVar>
                <InnerVar>HashMap&lt;String,String&gt; [sequencesInSchema=sequenceIDs.get(schemaName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropSequenceID</MethodName>
            <MethodComment>/** 
 * Drop a sequenceID from the ( schemaName, sequenceName ) map 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SequenceDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [schema=sd.getSchemaDescriptor()]</InnerVar>
                <InnerVar>String [schemaName=schema.getSchemaName()]</InnerVar>
                <InnerVar>String [sequenceName=sd.getSequenceName()]</InnerVar>
                <InnerVar>HashMap&lt;String,String&gt; [sequencesInSchema=(HashMap&lt;String,String&gt;)sequenceIDs.get(schemaName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSequenceID</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the uuid string of a sequence given its schema and sequence name. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashMap&lt;String,String&gt; [sequencesInSchema=sequenceIDs.get(schemaName)]</InnerVar>
                <InnerVar>SequenceDescriptor [desc=getSequenceDescriptor(getSchemaDescriptor(schemaName,getTransactionCompile(),true),sequenceName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUncachedGenericPermDescriptor</MethodName>
            <MethodComment>/** 
 * Get an object's permission descriptor from the system tables, without going through the cache. This method is called to fill the permissions cache.
 * @return a PermDescriptor that describes the table permissions granted to the grantee on an objcet, null if no table-level permissions have been granted to him on the table.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>PermDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>PermDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericPermissions</MethodName>
            <MethodComment>/** 
 * Get permissions granted to one user for an object using the object's Id and the user's authorization Id.
 * @param objectUUID The id of the protected object
 * @param objectType Type of the object (e.g., SEQUENCE)
 * @param privilege The kind of privilege needed (e.g., PermDescriptor.USAGE_PRIV)
 * @param granteeAuthId The user or role who wants to have permission on this object
 * @return The descriptor of the permissions for the object
 * @exception StandardException
 */
</MethodComment>
            <ReturnType>PermDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>objectType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>privilege</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>granteeAuthId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PermDescriptor [key=new PermDescriptor(this,null,objectType,objectUUID,privilege,null,granteeAuthId,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericPermissions</MethodName>
            <MethodComment>/** 
 * Get one user's privileges for an object using the permUUID.
 * @param permUUID
 * @return The descriptor of the user's permissions for the object.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>PermDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>permUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PermDescriptor [key=new PermDescriptor(this,permUUID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllPermDescriptors</MethodName>
            <MethodComment>/** 
 * Drops all permission descriptors for the object whose Id is given.
 * @param objectID The UUID of the object from which to dropall the permission descriptors
 * @param tc       TransactionController for the transaction
 * @throws StandardException Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>objectID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TabInfoImpl [ti=getNonCoreTI(SYSPERMS_CATALOG_NUM)]</InnerVar>
                <InnerVar>SYSPERMSRowFactory [rf=(SYSPERMSRowFactory)ti.getCatalogRowFactory()]</InnerVar>
                <InnerVar>DataValueDescriptor [objIdOrderable]</InnerVar>
                <InnerVar>ExecRow [curRow]</InnerVar>
                <InnerVar>PermissionsDescriptor [perm]</InnerVar>
                <InnerVar>ExecIndexRow [keyRow=exFactory.getIndexableRow(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>keyRow;setColumn;[1, objIdOrderable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>IndexStatisticsDaemon</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>asDaemon</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disableIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doCreateIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIndexStatsRefresher</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>db</ParamName>
                    <ParamType>Database</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dbName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependableFinder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDependableFinder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnBitMap</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIdentitySequences</MethodName>
            <MethodComment>/** 
 * Create sequence generators for all identity columns on upgrade to 10.11.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Hashtable&lt;UUID,TableDescriptor&gt; [tableMap=hashAllTableDescriptorsByTableId(tc)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createIdentitySequence</MethodName>
            <MethodComment>/** 
 * Create a sequence generator for an identity column on upgrade to 10.11.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd=cd.getType()]</InnerVar>
                <InnerVar>long[] [bounds=dtd.getNumericBounds()]</InnerVar>
                <InnerVar>long [currentValue=cd.getAutoincValue()]</InnerVar>
                <InnerVar>long [initialValue=cd.getAutoincStart()]</InnerVar>
                <InnerVar>long [minValue=bounds[DataTypeDescriptor.MIN_VALUE_IDX]]</InnerVar>
                <InnerVar>long [maxValue=bounds[DataTypeDescriptor.MAX_VALUE_IDX]]</InnerVar>
                <InnerVar>long [stepValue=cd.getAutoincInc()]</InnerVar>
                <InnerVar>SchemaDescriptor [sd=getSystemSchemaDescriptor()]</InnerVar>
                <InnerVar>SequenceDescriptor [seqDef=getDataDescriptorGenerator().newSequenceDescriptor(sd,getUUIDFactory().createUUID(),TableDescriptor.makeSequenceName(td.getUUID()),dtd,currentValue,initialValue,minValue,maxValue,stepValue,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addDescriptor;[seqDef, null, DataDictionary.SYSSEQUENCES_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextOrNull</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContext</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Privileged Monitor lookup. Must be package private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startSystemModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>