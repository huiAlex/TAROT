<Class>
    <Id>1299</Id>
    <Package>org.apache.derby.impl.jdbc</Package>
    <ClassName>EmbedDatabaseMetaData</ClassName>
    <SuperClass>ConnectionChild</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DatabaseMetaData</SuperInterface>
        <SuperInterface>java.security.PrivilegedAction</SuperInterface>
        <SuperInterface>Object</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EmbedDatabaseMetaData  /** 
 * This class provides information about the database as a whole. &lt;P&gt;Many of the methods here return lists of information in ResultSets. You can use the normal ResultSet methods such as getString and getInt to retrieve the data from these ResultSets.  If a given form of metadata is not available, these methods should throw a SQLException. &lt;P&gt;Some of these methods take arguments that are String patterns.  These arguments all have names such as fooPattern.  Within a pattern String, "%" means match any substring of 0 or more characters, and "_" means match any one character. Only metadata entries matching the search pattern are returned. If a search pattern argument is set to a null ref, it means that argument's criteria should be dropped from the search. &lt;P&gt;A SQLException will be thrown if a driver does not support a meta data method.  In the case of methods that return a ResultSet, either a ResultSet (which may be empty) is returned or a SQLException is thrown. &lt;p&gt; This implementation gets instructions from the Database for how to satisfy most requests for information.  Each instruction is either a simple string containing the desired information, or the text of a query that may be executed on the database connection to gather the information.  We get the instructions via an "InstructionReader," which requires the database Connection for initialization. &lt;p&gt; Those few pieces of metadata that are related to the driver, rather than the database, come from a separate InstructionReader.  Note that in that case it probably doesn't make sense to allow an instruction to specify a query.
 * @see &lt;a href="http://java.sun.com/products/jdbc/download.html#corespec30"&gt;JDBC 3.0 Specification&lt;/a&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>ILLEGAL_UDT_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>url</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>constantActionFactory</FieldName>
            <FieldType>GenericConstantActionFactory</FieldType>
        </Field>
        <Field>
            <FieldName>queryDescriptions</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>queryDescriptions_net</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>EmbedDatabaseMetaData</MethodName>
            <MethodComment>/** 
 * @exception SQLException on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQueryDescriptions</MethodName>
            <MethodComment>/** 
 * Return all queries found in either metadata.properties or metadata_net.properties.
 * @param net if &lt;code&gt;true&lt;/code&gt;, read metadata_net.properties;otherwise, read metadata.properties.
 * @return a &lt;code&gt;Properties&lt;/code&gt; value with the queries
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [p=net ? queryDescriptions_net : queryDescriptions]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadQueryDescriptions;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PBloadQueryDescriptions</MethodName>
            <MethodComment>/** 
 * Read the query descriptions from metadata.properties and metadata_net.properties. This method must be invoked from within a privileged block.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String[] [files={"metadata.properties","/org/apache/derby/impl/sql/catalog/metadata_net.properties"}]</InnerVar>
                <InnerVar>Properties[] [props=new Properties[files.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allProceduresAreCallable</MethodName>
            <MethodComment>/** 
 * Can all the procedures returned by getProcedures be called by the current user?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allTablesAreSelectable</MethodName>
            <MethodComment>/** 
 * Can all the tables returned by getTable be SELECTed by the current user?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getURL</MethodName>
            <MethodComment>/** 
 * What's the url for this database?
 * @return the url or null if it can't be generated
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [attributeStart=url.indexOf(';')]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserName</MethodName>
            <MethodComment>/** 
 * What's our user name as known to the database?
 * @return our database user name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnly</MethodName>
            <MethodComment>/** 
 * Is the database in read-only mode?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullsAreSortedHigh</MethodName>
            <MethodComment>/** 
 * Are NULL values sorted high?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullsAreSortedLow</MethodName>
            <MethodComment>/** 
 * Are NULL values sorted low?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullsAreSortedAtStart</MethodName>
            <MethodComment>/** 
 * Are NULL values sorted at the start regardless of sort order?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullsAreSortedAtEnd</MethodName>
            <MethodComment>/** 
 * Are NULL values sorted at the end regardless of sort order?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseProductName</MethodName>
            <MethodComment>/** 
 * What's the name of this database product?
 * @return database product name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseProductVersion</MethodName>
            <MethodComment>/** 
 * What's the version of this database product?
 * @return database version
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ProductVersionHolder [myPVH=EmbedConnection.getMonitor().getEngineVersion()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDriverName</MethodName>
            <MethodComment>/** 
 * What's the name of this JDBC driver?
 * @return JDBC driver name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDriverVersion</MethodName>
            <MethodComment>/** 
 * What's the version of this JDBC driver?
 * @return JDBC driver version
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDriverMajorVersion</MethodName>
            <MethodComment>/** 
 * What's this JDBC driver's major version number?
 * @return JDBC driver major version
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDriverMinorVersion</MethodName>
            <MethodComment>/** 
 * What's this JDBC driver's minor version number?
 * @return JDBC driver minor version number
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesLocalFiles</MethodName>
            <MethodComment>/** 
 * Does the database store tables in a local file?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>usesLocalFilePerTable</MethodName>
            <MethodComment>/** 
 * Does the database use a file for each table?
 * @return true if the database uses a local file for each table
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMixedCaseIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case unquoted SQL identifiers as case sensitive and as a result store them in mixed case? A JDBC-Compliant driver will always return false.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesUpperCaseIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case unquoted SQL identifiers as case insensitive and store them in upper case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesLowerCaseIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case unquoted SQL identifiers as case insensitive and store them in lower case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesMixedCaseIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case unquoted SQL identifiers as case insensitive and store them in mixed case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMixedCaseQuotedIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case quoted SQL identifiers as case sensitive and as a result store them in mixed case? A JDBC-Compliant driver will always return true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesUpperCaseQuotedIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case quoted SQL identifiers as case insensitive and store them in upper case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesLowerCaseQuotedIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case quoted SQL identifiers as case insensitive and store them in lower case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storesMixedCaseQuotedIdentifiers</MethodName>
            <MethodComment>/** 
 * Does the database treat mixed case quoted SQL identifiers as case insensitive and store them in mixed case?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdentifierQuoteString</MethodName>
            <MethodComment>/** 
 * What's the string used to quote SQL identifiers? This returns a space " " if identifier quoting isn't supported. A JDBC-Compliant driver always uses a double quote character.
 * @return the quoting string
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLKeywords</MethodName>
            <MethodComment>/** 
 * Get a comma separated list of all a database's SQL keywords that are NOT also SQL92 keywords. includes reserved and non-reserved keywords.
 * @return the list
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumericFunctions</MethodName>
            <MethodComment>/** 
 * Get a comma separated list of JDBC escaped numeric functions. Must be a complete or sub set of functions in appendix C.1  of JDBC 3.0 specification (pp. 183).
 * @return the list
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStringFunctions</MethodName>
            <MethodComment>/** 
 * Get a comma separated list of JDBC escaped string functions. Must be a complete or sub set of functions in appendix C.2 of JDBC 3.0 specification (pp. 184).
 * @return the list
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemFunctions</MethodName>
            <MethodComment>/** 
 * Get a comma separated list of JDBC escaped system functions. Must be a complete or sub set of functions in appendix C.4 of JDBC 3.0 specification (pp. 185).
 * @return the list
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeDateFunctions</MethodName>
            <MethodComment>/** 
 * Get a comma separated list of JDBC escaped time date functions. Must be a complete or sub set of functions in appendix C.3 of JDBC 3.0 specification.
 * @return the list
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSearchStringEscape</MethodName>
            <MethodComment>/** 
 * This is the string that can be used to escape '_' or '%' in the string pattern style catalog search parameters. we have no default escape value, so = is the end of the next line &lt;P&gt;The '_' character represents any single character. &lt;P&gt;The '%' character represents any sequence of zero or more characters.
 * @return the string used to escape wildcard characters
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExtraNameCharacters</MethodName>
            <MethodComment>/** 
 * Get all the "extra" characters that can be used in unquoted identifier names (those beyond a-z, A-Z, 0-9 and _).
 * @return the string containing the extra characters
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsAlterTableWithAddColumn</MethodName>
            <MethodComment>/** 
 * Is "ALTER TABLE" with add column supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsAlterTableWithDropColumn</MethodName>
            <MethodComment>/** 
 * Is "ALTER TABLE" with drop column supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsColumnAliasing</MethodName>
            <MethodComment>/** 
 * Is column aliasing supported? &lt;P&gt;If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns as required. A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nullPlusNonNullIsNull</MethodName>
            <MethodComment>/** 
 * Are concatenations between NULL and non-NULL values NULL? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsConvert</MethodName>
            <MethodComment>/** 
 * Is the CONVERT function between SQL types supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsConvert</MethodName>
            <MethodComment>/** 
 * Is CONVERT between the given SQL types supported?
 * @param fromType the type to convert from
 * @param toType the type to convert to
 * @return true if so
 * @see Types
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>toType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsTableCorrelationNames</MethodName>
            <MethodComment>/** 
 * Are table correlation names supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsDifferentTableCorrelationNames</MethodName>
            <MethodComment>/** 
 * If table correlation names are supported, are they restricted to be different from the names of the tables?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsExpressionsInOrderBy</MethodName>
            <MethodComment>/** 
 * Are expressions in "ORDER BY" lists supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOrderByUnrelated</MethodName>
            <MethodComment>/** 
 * Can an "ORDER BY" clause use columns not in the SELECT?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsGroupBy</MethodName>
            <MethodComment>/** 
 * Is some form of "GROUP BY" clause supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsGroupByUnrelated</MethodName>
            <MethodComment>/** 
 * Can a "GROUP BY" clause use columns not in the SELECT?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsGroupByBeyondSelect</MethodName>
            <MethodComment>/** 
 * Can a "GROUP BY" clause add columns not in the SELECT provided it specifies all the columns in the SELECT?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsLikeEscapeClause</MethodName>
            <MethodComment>/** 
 * Is the escape character in "LIKE" clauses supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMultipleResultSets</MethodName>
            <MethodComment>/** 
 * Are multiple ResultSets from a single execute supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMultipleTransactions</MethodName>
            <MethodComment>/** 
 * Can we have multiple transactions open at once (on different connections)?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsNonNullableColumns</MethodName>
            <MethodComment>/** 
 * Can columns be defined as non-nullable? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMinimumSQLGrammar</MethodName>
            <MethodComment>/** 
 * Is the ODBC Minimum SQL grammar supported? All JDBC-Compliant drivers must return true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCoreSQLGrammar</MethodName>
            <MethodComment>/** 
 * Is the ODBC Core SQL grammar supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsExtendedSQLGrammar</MethodName>
            <MethodComment>/** 
 * Is the ODBC Extended SQL grammar supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsANSI92EntryLevelSQL</MethodName>
            <MethodComment>/** 
 * Is the ANSI92 entry level SQL grammar supported? All JDBC-Compliant drivers must return true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsANSI92IntermediateSQL</MethodName>
            <MethodComment>/** 
 * Is the ANSI92 intermediate SQL grammar supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsANSI92FullSQL</MethodName>
            <MethodComment>/** 
 * Is the ANSI92 full SQL grammar supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsIntegrityEnhancementFacility</MethodName>
            <MethodComment>/** 
 * Is the SQL Integrity Enhancement Facility supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOuterJoins</MethodName>
            <MethodComment>/** 
 * Is some form of outer join supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsFullOuterJoins</MethodName>
            <MethodComment>/** 
 * Are full nested outer joins supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsLimitedOuterJoins</MethodName>
            <MethodComment>/** 
 * Is there limited support for outer joins?  (This will be true if supportFullOuterJoins is true.)
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaTerm</MethodName>
            <MethodComment>/** 
 * What's the database vendor's preferred term for "schema"?
 * @return the vendor term
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProcedureTerm</MethodName>
            <MethodComment>/** 
 * What's the database vendor's preferred term for "procedure"?
 * @return the vendor term
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogTerm</MethodName>
            <MethodComment>/** 
 * What's the database vendor's preferred term for "catalog"?
 * @return the vendor term
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCatalogAtStart</MethodName>
            <MethodComment>/** 
 * Does a catalog appear at the start of a qualified table name? (Otherwise it appears at the end)
 * @return true if it appears at the start
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogSeparator</MethodName>
            <MethodComment>/** 
 * What's the separator between catalog and table name?
 * @return the separator string
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSchemasInDataManipulation</MethodName>
            <MethodComment>/** 
 * Can a schema name be used in a data manipulation statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSchemasInProcedureCalls</MethodName>
            <MethodComment>/** 
 * Can a schema name be used in a procedure call statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSchemasInTableDefinitions</MethodName>
            <MethodComment>/** 
 * Can a schema name be used in a table definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSchemasInIndexDefinitions</MethodName>
            <MethodComment>/** 
 * Can a schema name be used in an index definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSchemasInPrivilegeDefinitions</MethodName>
            <MethodComment>/** 
 * Can a schema name be used in a privilege definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCatalogsInDataManipulation</MethodName>
            <MethodComment>/** 
 * Can a catalog name be used in a data manipulation statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCatalogsInProcedureCalls</MethodName>
            <MethodComment>/** 
 * Can a catalog name be used in a procedure call statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCatalogsInTableDefinitions</MethodName>
            <MethodComment>/** 
 * Can a catalog name be used in a table definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCatalogsInIndexDefinitions</MethodName>
            <MethodComment>/** 
 * Can a catalog name be used in an index definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCatalogsInPrivilegeDefinitions</MethodName>
            <MethodComment>/** 
 * Can a catalog name be used in a privilege definition statement?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsPositionedDelete</MethodName>
            <MethodComment>/** 
 * Is positioned DELETE supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsPositionedUpdate</MethodName>
            <MethodComment>/** 
 * Is positioned UPDATE supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsRefCursors</MethodName>
            <MethodComment>/** 
 * Added in JDBC 4.2. Derby does not support the Types.REF_CURSOR type.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSelectForUpdate</MethodName>
            <MethodComment>/** 
 * Is SELECT for UPDATE supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsStoredProcedures</MethodName>
            <MethodComment>/** 
 * Are stored procedure calls using the stored procedure escape syntax supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSubqueriesInComparisons</MethodName>
            <MethodComment>/** 
 * Are subqueries in comparison expressions supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSubqueriesInExists</MethodName>
            <MethodComment>/** 
 * Are subqueries in 'exists' expressions supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSubqueriesInIns</MethodName>
            <MethodComment>/** 
 * Are subqueries in 'in' statements supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSubqueriesInQuantifieds</MethodName>
            <MethodComment>/** 
 * Are subqueries in quantified expressions supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsCorrelatedSubqueries</MethodName>
            <MethodComment>/** 
 * Are correlated subqueries supported? A JDBC-Compliant driver always returns true.
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsUnion</MethodName>
            <MethodComment>/** 
 * Is SQL UNION supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsUnionAll</MethodName>
            <MethodComment>/** 
 * Is SQL UNION ALL supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOpenCursorsAcrossCommit</MethodName>
            <MethodComment>/** 
 * Can cursors remain open across commits?
 * @return true if cursors always remain open; false if they might not remain open
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOpenCursorsAcrossRollback</MethodName>
            <MethodComment>/** 
 * Can cursors remain open across rollbacks?
 * @return true if cursors always remain open; false if they might not remain open
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOpenStatementsAcrossCommit</MethodName>
            <MethodComment>/** 
 * Can statements remain open across commits?
 * @return true if statements always remain open; false if they might not remain open
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsOpenStatementsAcrossRollback</MethodName>
            <MethodComment>/** 
 * Can statements remain open across rollbacks?
 * @return true if statements always remain open; false if they might not remain open
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxBinaryLiteralLength</MethodName>
            <MethodComment>/** 
 * How many hex characters can you have in an inline binary literal?
 * @return max literal length
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxCharLiteralLength</MethodName>
            <MethodComment>/** 
 * What's the max length for a character literal?
 * @return max literal length
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnNameLength</MethodName>
            <MethodComment>/** 
 * What's the limit on column name length?
 * @return max literal length
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnsInGroupBy</MethodName>
            <MethodComment>/** 
 * What's the maximum number of columns in a "GROUP BY" clause?
 * @return max number of columns
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnsInIndex</MethodName>
            <MethodComment>/** 
 * What's the maximum number of columns allowed in an index?
 * @return max columns
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnsInOrderBy</MethodName>
            <MethodComment>/** 
 * What's the maximum number of columns in an "ORDER BY" clause?
 * @return max columns
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnsInSelect</MethodName>
            <MethodComment>/** 
 * What's the maximum number of columns in a "SELECT" list? we don't have a limit...
 * @return max columns
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxColumnsInTable</MethodName>
            <MethodComment>/** 
 * What's the maximum number of columns in a table?
 * @return max columns
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxConnections</MethodName>
            <MethodComment>/** 
 * How many active connections can we have at a time to this database?
 * @return max connections
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxCursorNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum cursor name length?
 * @return max cursor name length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxIndexLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of an index (in bytes)?
 * @return max index length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxLogicalLobSize</MethodName>
            <MethodComment>/** 
 * Added in JDBC 4.2. What's the maximum length of Derby LOB? This is the maximum number of bytes in a LOB. We return the default value of 0, which means "unknown". The maximum size of a CLOB is a complicated because it depends on how many bytes are needed to encode its string value on disk.
 * @return max index length in bytes
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxSchemaNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length allowed for a schema name?
 * @return max name length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxProcedureNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a procedure name?
 * @return max name length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxCatalogNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a catalog name?
 * @return max name length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxRowSize</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a single row?
 * @return max row size in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doesMaxRowSizeIncludeBlobs</MethodName>
            <MethodComment>/** 
 * Did getMaxRowSize() include LONGVARCHAR and LONGVARBINARY blobs?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxStatementLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a SQL statement?
 * @return max length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxStatements</MethodName>
            <MethodComment>/** 
 * How many active statements can we have open at one time to this database?
 * @return the maximum
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxTableNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a table name?
 * @return max name length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxTablesInSelect</MethodName>
            <MethodComment>/** 
 * What's the maximum number of tables in a SELECT?
 * @return the maximum
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxUserNameLength</MethodName>
            <MethodComment>/** 
 * What's the maximum length of a user name?
 * @return max name length  in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultTransactionIsolation</MethodName>
            <MethodComment>/** 
 * What's the database's default transaction isolation level?  The values are defined in java.sql.Connection.
 * @return the default isolation level
 * @see Connection
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsTransactions</MethodName>
            <MethodComment>/** 
 * Are transactions supported? If not, commit is a noop and the isolation level is TRANSACTION_NONE.
 * @return true if transactions are supported
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsTransactionIsolationLevel</MethodName>
            <MethodComment>/** 
 * Does the database support the given transaction isolation level? DatabaseMetaData.supportsTransactionIsolation() should return false for isolation levels that are not supported even if a higher level can be substituted.
 * @param level the values are defined in java.sql.Connection
 * @return true if so
 * @see Connection
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsDataDefinitionAndDataManipulationTransactions</MethodName>
            <MethodComment>/** 
 * Are both data definition and data manipulation statements within a transaction supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsDataManipulationTransactionsOnly</MethodName>
            <MethodComment>/** 
 * Are only data manipulation statements within a transaction supported?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataDefinitionCausesTransactionCommit</MethodName>
            <MethodComment>/** 
 * Does a data definition statement within a transaction force the transaction to commit?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataDefinitionIgnoredInTransactions</MethodName>
            <MethodComment>/** 
 * Is a data definition statement within a transaction ignored?
 * @return true if so
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProcedures</MethodName>
            <MethodComment>/** 
 * Get a description of stored procedures available in a catalog. &lt;P&gt;Only procedure descriptions matching the schema and procedure name criteria are returned.  They are ordered by PROCEDURE_SCHEM, and PROCEDURE_NAME. &lt;P&gt;Each procedure description has the the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String =&amp;gt; procedure catalog (may be null) &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String =&amp;gt; procedure schema (may be null) &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String =&amp;gt; procedure name &lt;LI&gt; reserved for future use &lt;LI&gt; reserved for future use &lt;LI&gt; reserved for future use &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&amp;gt; explanatory comment on the procedure &lt;LI&gt;&lt;B&gt;PROCEDURE_TYPE&lt;/B&gt; short =&amp;gt; kind of procedure: &lt;UL&gt; &lt;LI&gt; procedureResultUnknown - May return a result &lt;LI&gt; procedureNoResult - Does not return a result &lt;LI&gt; procedureReturnsResult - Returns a result &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String =&amp;gt; The name which uniquely  identifies this procedure within its schema (since JDBC 4.0) &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param procedureNamePattern a procedure name pattern
 * @return ResultSet - each row is a procedure description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProceduresForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of stored procedures available in a catalog.  Same as getProcedures() above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFunctions</MethodName>
            <MethodComment>/** 
 * Implements DatabaseMetaData.getFunctions() for an embedded database. Queries the database to get information about functions (procedures returning values). Executes the 'getFunctions' query from metadata.properties to obtain the ResultSet to return.&lt;p&gt; Compatibility: This is a new method in the API which is only available with with Derby versions &amp;gt; 10.1 and JDK versions &amp;gt;= 1.6 &lt;p&gt;Upgrade: Since this is a new query it does not have an SPS, and will be available as soon as any database, new or old, is booted with the new version of Derby, (in &lt;b&gt;soft and hard&lt;/b&gt; upgrade).
 * @param catalog limit the search to functions in this catalog (not used)
 * @param schemaPattern limit the search to functions in schemas matching this pattern
 * @param functionNamePattern limit the search to functions matching this pattern
 * @return a ResultSet with metadata information
 * @throws SQLException if any of the underlying jdbc methods fail
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>java.lang.String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>java.lang.String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>functionNamePattern</ParamName>
                    <ParamType>java.lang.String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetProcs</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getProcedures and getFunctions metadata calls.  See getProcedures() method above for parameter descriptions.
 * @param queryName Name of the query to execute; is usedto determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery(queryName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(procedureNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProcedureColumns</MethodName>
            <MethodComment>/** 
 * Get a description of a catalog's stored procedure parameters and result columns. &lt;P&gt;Only descriptions matching the schema, procedure and parameter name criteria are returned.  They are ordered by PROCEDURE_SCHEM and PROCEDURE_NAME. Within this, the return value, if any, is first. Next are the parameter descriptions in call order. The column descriptions follow in column number order. &lt;P&gt;Each row in the ResultSet is a parameter description or column description with the following fields: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String =&amp;gt; procedure catalog (may be null) &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String =&amp;gt; procedure schema (may be null) &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String =&amp;gt; procedure name &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column/parameter name &lt;LI&gt;&lt;B&gt;COLUMN_TYPE&lt;/B&gt; Short =&amp;gt; kind of column/parameter: &lt;UL&gt; &lt;LI&gt; procedureColumnUnknown - nobody knows &lt;LI&gt; procedureColumnIn - IN parameter &lt;LI&gt; procedureColumnInOut - INOUT parameter &lt;LI&gt; procedureColumnOut - OUT parameter &lt;LI&gt; procedureColumnReturn - procedure return value &lt;LI&gt; procedureColumnResult - result column in ResultSet &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&amp;gt; SQL type from java.sql.Types &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; SQL type name &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int =&amp;gt; precision &lt;LI&gt;&lt;B&gt;LENGTH&lt;/B&gt; int =&amp;gt; length in bytes of data &lt;LI&gt;&lt;B&gt;SCALE&lt;/B&gt; short =&amp;gt; scale &lt;LI&gt;&lt;B&gt;RADIX&lt;/B&gt; short =&amp;gt; radix &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short =&amp;gt; can it contain NULL? &lt;UL&gt; &lt;LI&gt; procedureNoNulls - does not allow NULL values &lt;LI&gt; procedureNullable - allows NULL values &lt;LI&gt; procedureNullableUnknown - nullability unknown &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&amp;gt; comment describing parameter/column &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String &lt;/OL&gt; &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return the column descriptions for a procedure. Additional columns beyond SPECIFIC_NAME can be defined by the database.
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param procedureNamePattern a procedure name pattern
 * @param columnNamePattern a column name pattern
 * @return ResultSet - each row is a stored procedure parameter orcolumn description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProcedureColumnsForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of a catalog's stored procedure parameters and result columns.  Same as getProcedureColumns() above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFunctionColumns</MethodName>
            <MethodComment>/** 
 * Implements DatabaseMetaData.getFunctionColumns() for an embedded database. Queries the database to get information about function parameters. Executes the 'getFunctionColumns' query from metadata.properties to obtain the ResultSet.&lt;p&gt; Compatibility: This is a new method in the API which is only available with with Derby versions &amp;gt; 10.1 and JDK versions &amp;gt;= 1.6 &lt;p&gt;Upgrade: Since this is a new query it does not have an SPS, and will be available as soon as any database, new or old, is booted with the new version of Derby, (in &lt;b&gt;soft and hard&lt;/b&gt; upgrade).
 * @param catalog limit the search to functions in this catalog(not used)
 * @param schemaPattern limit the search to functions in schemasmatching this pattern
 * @param functionNamePattern limit the search to functionsmatching this pattern
 * @param parameterNamePattern limit the search parametersmatching this pattern
 * @return a ResultSet with metadata information
 * @throws SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>functionNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetProcCols</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getProcedureColumns metadata calls. See getProcedureColumns() method above for parameter descriptions.
 * @param queryName Name of the query to execute; is usedto determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procedureNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery(queryName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(procedureNamePattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(columnNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTables</MethodName>
            <MethodComment>/** 
 * Get a description of tables available in a catalog. &lt;P&gt;Only table descriptions matching the catalog, schema, table name and type criteria are returned.  They are ordered by TABLE_TYPE, TABLE_SCHEM and TABLE_NAME. &lt;P&gt;Each table description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String =&amp;gt; table type.  Typical types are "TABLE", "VIEW",	"SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM". &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&amp;gt; explanatory comment on the table &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String =&amp;gt; the types catalog (may be &lt;code&gt;null&lt;/code&gt;) &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String =&amp;gt; the types schema (may be &lt;code&gt;null&lt;/code&gt;) &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; type name (may be &lt;code&gt;null&lt;/code&gt;) &lt;LI&gt;&lt;B&gt;SELF_REFERENCING_COL_NAME&lt;/B&gt; String =&amp;gt; name of the designated "identifier" column of a typed table (may be &lt;code&gt;null&lt;/code&gt;) &lt;LI&gt;&lt;B&gt;REF_GENERATION&lt;/B&gt; String =&amp;gt; specifies how values in SELF_REFERENCING_COL_NAME are created. Values are "SYSTEM", "USER", "DERIVED". (may be &lt;code&gt;null&lt;/code&gt;) &lt;/OL&gt; &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return information for all tables.
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param tableNamePattern a table name pattern
 * @param types a list of table types to include; null returns all types
 * @return ResultSet - each row is a table description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>types</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getTables")]</InnerVar>
                <InnerVar>int [numberOfTableTypesInDerby=4]</InnerVar>
                <InnerVar>String[] [typeParams=new String[numberOfTableTypesInDerby]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(tableNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemas</MethodName>
            <MethodComment>/** 
 * Get the schema names available in this database.  The results are ordered by schema name. &lt;P&gt;The schema columns are: &lt;OL&gt; &lt;li&gt;&lt;strong&gt;TABLE_SCHEM&lt;/strong&gt; String =&amp;gt; schema name&lt;/li&gt; &lt;li&gt;&lt;strong&gt;TABLE_CATALOG&lt;/strong&gt; String =&amp;gt; catalog name (may be &lt;code&gt;null&lt;/code&gt;)&lt;/li&gt; &lt;/OL&gt;
 * @return ResultSet - each row is a schema description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogs</MethodName>
            <MethodComment>/** 
 * Get the catalog names available in this database.  The results are ordered by catalog name. &lt;P&gt;The catalog column is: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; catalog name &lt;/OL&gt;
 * @return ResultSet - each row has a single String column that is acatalog name
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableTypes</MethodName>
            <MethodComment>/** 
 * Get the table types available in this database.  The results are ordered by table type. &lt;P&gt;The table type is: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String =&amp;gt; table type.  Typical types are "TABLE", "VIEW",	"SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM". &lt;/OL&gt;
 * @return ResultSet - each row has a single String column that is atable type
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumns</MethodName>
            <MethodComment>/** 
 * Get a description of table columns available in a catalog. &lt;P&gt;Only column descriptions matching the catalog, schema, table and column name criteria are returned.  They are ordered by TABLE_SCHEM, TABLE_NAME and ORDINAL_POSITION. &lt;P&gt;Each column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&amp;gt; SQL type from java.sql.Types &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; Data source dependent type name &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&amp;gt; column size.  For char or date types this is the maximum number of characters, for numeric or decimal types this is precision. &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; is not used. &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; int =&amp;gt; the number of fractional digits &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int =&amp;gt; Radix (typically either 10 or 2) &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; int =&amp;gt; is NULL allowed? &lt;UL&gt; &lt;LI&gt; columnNoNulls - might not allow NULL values &lt;LI&gt; columnNullable - definitely allows NULL values &lt;LI&gt; columnNullableUnknown - nullability unknown &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&amp;gt; comment describing column (may be null) &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String =&amp;gt; default value (may be null) &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int =&amp;gt; unused &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int =&amp;gt; unused &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int =&amp;gt; for char types the maximum number of bytes in the column &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int	=&amp;gt; index of column in table (starting at 1) &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String =&amp;gt; "NO" means column definitely does not allow NULL values; "YES" means the column might allow NULL values.  An empty string means nobody knows. &lt;LI&gt;&lt;B&gt;SCOPE_CATALOG&lt;/B&gt; String =&amp;gt; catalog of table that is the scope of a reference attribute (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't REF) &lt;LI&gt;&lt;B&gt;SCOPE_SCHEMA&lt;/B&gt; String =&amp;gt; schema of table that is the scope of a reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF) &lt;LI&gt;&lt;B&gt;SCOPE_TABLE&lt;/B&gt; String =&amp;gt; table name that this the scope of a reference attribure (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF) &lt;LI&gt;&lt;B&gt;SOURCE_DATA_TYPE&lt;/B&gt; short =&amp;gt; source type of a distinct type or user-generated Ref type, SQL type from java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't DISTINCT or user-generated REF) &lt;LI&gt;&lt;B&gt;IS_AUTOINCREMENT&lt;/B&gt; String =&amp;gt; Indicates whether this column is auto incremented &lt;UL&gt; &lt;LI&gt; YES --- if the column is auto incremented &lt;LI&gt; NO --- if the column is not auto incremented &lt;LI&gt; empty string --- if it cannot be determined whether the column is auto incremented parameter is unknown &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;SCOPE_CATLOG&lt;/B&gt; A redundant copy of SCOPE_CATALOG. The name of this column is deliberately mis-spelled in order to support a typo in the javadoc for DatabaseMetaData.getColumns() which was corrected by JDBC 4.1. &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param tableNamePattern a table name pattern
 * @param columnNamePattern a column name pattern
 * @return ResultSet - each row is a column description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnsForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of table columns available in a catalog. Same as getColumns() above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetCols</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getColumns metadata calls. See getColumns() method above for parameter descriptions.
 * @param queryName Name of the query to execute; is usedto determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery(queryName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(tableNamePattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(columnNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPrivileges</MethodName>
            <MethodComment>/** 
 * Get a description of the access rights for a table's columns. &lt;P&gt;Only privileges matching the column name criteria are returned.  They are ordered by COLUMN_NAME and PRIVILEGE. &lt;P&gt;Each privilige description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; =&amp;gt; grantor of access (may be null) &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String =&amp;gt; grantee of access &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String =&amp;gt; name of access (SELECT, INSERT, UPDATE, REFRENCES, ...) &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String =&amp;gt; "YES" if grantee is permitted to grant to others; "NO" if not; null if unknown &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name; "" retrieves those without a schema
 * @param table a table name
 * @param columnNamePattern a column name pattern
 * @return ResultSet - each row is a column privilege description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getColumnPrivileges")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(columnNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTablePrivileges</MethodName>
            <MethodComment>/** 
 * Get a description of the access rights for each table available in a catalog. Note that a table privilege applies to one or more columns in the table. It would be wrong to assume that this priviledge applies to all columns (this may be true for some systems but is not true for all.) &lt;P&gt;Only privileges matching the schema and table name criteria are returned.  They are ordered by TABLE_SCHEM, TABLE_NAME, and PRIVILEGE. &lt;P&gt;Each privilige description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; =&amp;gt; grantor of access (may be null) &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String =&amp;gt; grantee of access &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String =&amp;gt; name of access (SELECT, INSERT, UPDATE, REFRENCES, ...) &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String =&amp;gt; "YES" if grantee is permitted to grant to others; "NO" if not; null if unknown &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param tableNamePattern a table name pattern
 * @return ResultSet - each row is a table privilege description
 * @see #getSearchStringEscape
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getTablePrivileges")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(tableNamePattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBestRowIdentifier</MethodName>
            <MethodComment>/** 
 * Get a description of a table's optimal set of columns that uniquely identifies a row. They are ordered by SCOPE. &lt;P&gt;Each column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short =&amp;gt; actual scope of result &lt;UL&gt; &lt;LI&gt; bestRowTemporary - very temporary, while using row &lt;LI&gt; bestRowTransaction - valid for remainder of current transaction &lt;LI&gt; bestRowSession - valid for remainder of current session &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&amp;gt; SQL data type from java.sql.Types &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; Data source dependent type name &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&amp;gt; precision &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int =&amp;gt; not used &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short	 =&amp;gt; scale &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short =&amp;gt; is this a pseudo column like an Oracle ROWID &lt;UL&gt; &lt;LI&gt; bestRowUnknown - may or may not be pseudo column &lt;LI&gt; bestRowNotPseudo - is NOT a pseudo column &lt;LI&gt; bestRowPseudo - is a pseudo column &lt;/UL&gt; &lt;/OL&gt;
 * @param catalogPattern a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name; "" retrieves those without a schema
 * @param table a table name
 * @param scope the scope of interest; use same values as SCOPE
 * @param nullable include columns that are nullable?
 * @return ResultSet - each row is a column description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scope</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBestRowIdentifierForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of a table's optimal set of columns that uniquely identifies a row. They are ordered by SCOPE. Same as getBestRowIdentifier() above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scope</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetBestRowId</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getBestRowIdentifier metadata calls.  See getBestRowIdentifier() method above for parameter descriptions.
 * @param queryPrefix Prefix to be appended to the names ofthe queries used in this method.  This is used to determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scope</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryPrefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [nullableInIntForm=0]</InnerVar>
                <InnerVar>PreparedStatement [ps]</InnerVar>
                <InnerVar>boolean [done]</InnerVar>
                <InnerVar>ResultSet [rs=ps.executeQuery()]</InnerVar>
                <InnerVar>String [constraintId=""]</InnerVar>
                <InnerVar>long [indexNum=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setString;[1, catalogPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[2, schemaPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[1, catalogPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[2, schemaPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[1, catalogPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[2, schemaPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[1, catalogPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[2, schemaPattern]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setInt;[4, scope]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setInt;[5, nullableInIntForm]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVersionColumns</MethodName>
            <MethodComment>/** 
 * Get a description of a table's columns that are automatically updated when any value in a row is updated.  They are unordered. &lt;P&gt;Each column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short =&amp;gt; is not used &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&amp;gt; SQL data type from java.sql.Types &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; Data source dependent type name &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&amp;gt; precision &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int =&amp;gt; length of column value in bytes &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short	 =&amp;gt; scale &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short =&amp;gt; is this a pseudo column like an Oracle ROWID &lt;UL&gt; &lt;LI&gt; versionColumnUnknown - may or may not be pseudo column &lt;LI&gt; versionColumnNotPseudo - is NOT a pseudo column &lt;LI&gt; versionColumnPseudo - is a pseudo column &lt;/UL&gt; &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name; "" retrieves those without a schema
 * @param table a table name
 * @return ResultSet - each row is a column description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVersionColumnsForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of a table's columns that are automatically updated when any value in a row is updated.  They are unordered.  Same as getVersionColumns() above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetVersionCols</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getVersionColumns metadata calls.  See getVersionColumns() method above for parameter descriptions.
 * @param queryName Name of the query to execute; is usedto determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery(queryName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notInSoftUpgradeMode</MethodName>
            <MethodComment>/** 
 * check if the dictionary is at the same version as the engine. If not,  then that means stored versions of the JDBC database metadata queries may not be compatible with this version of the software. This can happen if we are in soft upgrade mode. Since in soft upgrade  mode, we can't change these stored metadata queries in a backward  incompatible way, engine needs to read the metadata sql from  metadata.properties or metadata_net.properties file rather than rely on system tables.
 * @return true if we are not in soft upgrade mode
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [notInSoftUpgradeMode]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrimaryKeys</MethodName>
            <MethodComment>/** 
 * Get a description of a table's primary key columns.  They are ordered by COLUMN_NAME. &lt;P&gt;Each primary key column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&amp;gt; sequence number within primary key &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&amp;gt; primary key name (may be null) &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name pattern; "" retrieves thosewithout a schema
 * @param table a table name
 * @return ResultSet - each row is a primary key column description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getPrimaryKeys")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getImportedKeys</MethodName>
            <MethodComment>/** 
 * Get a description of the primary key columns that are referenced by a table's foreign key columns (the primary keys imported by a table).  They are ordered by PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ. &lt;P&gt;Each primary key column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&amp;gt; primary key table catalog being imported (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; primary key table schema being imported (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&amp;gt; primary key table name being imported &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; primary key column name being imported &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&amp;gt; foreign key table catalog (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; foreign key table schema (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&amp;gt; foreign key table name &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; foreign key column name &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&amp;gt; sequence number within foreign key &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&amp;gt; What happens to foreign key when primary is updated: &lt;UL&gt; &lt;LI&gt; importedNoAction - do not allow update of primary key if it has been imported &lt;LI&gt; importedKeyCascade - change imported key to agree with primary key update &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been updated &lt;LI&gt; importedKeySetDefault - change imported key to default values if its primary key has been updated &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&amp;gt; What happens to the foreign key when primary is deleted. &lt;UL&gt; &lt;LI&gt; importedKeyNoAction - do not allow delete of primary key if it has been imported &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been deleted &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;LI&gt; importedKeySetDefault - change imported key to default if its primary key has been deleted &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&amp;gt; foreign key name (may be null) &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&amp;gt; primary key name (may be null) &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&amp;gt; can the evaluation of foreign key constraints be deferred until commit &lt;UL&gt; &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition &lt;/UL&gt; &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name pattern; "" retrieves thosewithout a schema
 * @param table a table name
 * @return ResultSet - each row is a primary key column description
 * @see #getExportedKeys
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getImportedKeys")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExportedKeys</MethodName>
            <MethodComment>/** 
 * Get a description of the foreign key columns that reference a table's primary key columns (the foreign keys exported by a table).  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and KEY_SEQ. &lt;P&gt;Each foreign key column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&amp;gt; primary key table catalog (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; primary key table schema (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&amp;gt; primary key table name &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; primary key column name &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&amp;gt; foreign key table catalog (may be null) being exported (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; foreign key table schema (may be null) being exported (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&amp;gt; foreign key table name being exported &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; foreign key column name being exported &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&amp;gt; sequence number within foreign key &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&amp;gt; What happens to foreign key when primary is updated: &lt;UL&gt; &lt;LI&gt; importedNoAction - do not allow update of primary key if it has been imported &lt;LI&gt; importedKeyCascade - change imported key to agree with primary key update &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been updated &lt;LI&gt; importedKeySetDefault - change imported key to default values if its primary key has been updated &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&amp;gt; What happens to the foreign key when primary is deleted. &lt;UL&gt; &lt;LI&gt; importedKeyNoAction - do not allow delete of primary key if it has been imported &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been deleted &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;LI&gt; importedKeySetDefault - change imported key to default if its primary key has been deleted &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&amp;gt; foreign key name (may be null) &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&amp;gt; primary key name (may be null) &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&amp;gt; can the evaluation of foreign key constraints be deferred until commit &lt;UL&gt; &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition &lt;/UL&gt; &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name pattern; "" retrieves thosewithout a schema
 * @param table a table name
 * @return ResultSet - each row is a foreign key column description
 * @see #getImportedKeys
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getCrossReference")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(null)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[5, swapNull(null)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[6, swapNull(null)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCrossReference</MethodName>
            <MethodComment>/** 
 * Get a description of the foreign key columns in the foreign key table that reference the primary key columns of the primary key table (describe how one table imports another's key.) This should normally return a single foreign key/primary key pair (most tables only import a foreign key from a table once.)  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and KEY_SEQ. &lt;P&gt;Each foreign key column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&amp;gt; primary key table catalog (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; primary key table schema (may be null) &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&amp;gt; primary key table name &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; primary key column name &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&amp;gt; foreign key table catalog (may be null) being exported (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&amp;gt; foreign key table schema (may be null) being exported (may be null) &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&amp;gt; foreign key table name being exported &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&amp;gt; foreign key column name being exported &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&amp;gt; sequence number within foreign key &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&amp;gt; What happens to foreign key when primary is updated: &lt;UL&gt; &lt;LI&gt; importedNoAction - do not allow update of primary key if it has been imported &lt;LI&gt; importedKeyCascade - change imported key to agree with primary key update &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been updated &lt;LI&gt; importedKeySetDefault - change imported key to default values if its primary key has been updated &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&amp;gt; What happens to the foreign key when primary is deleted. &lt;UL&gt; &lt;LI&gt; importedKeyNoAction - do not allow delete of primary key if it has been imported &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key &lt;LI&gt; importedKeySetNull - change imported key to NULL if its primary key has been deleted &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction (for ODBC 2.x compatibility) &lt;LI&gt; importedKeySetDefault - change imported key to default if its primary key has been deleted &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&amp;gt; foreign key name (may be null) &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&amp;gt; primary key name (may be null) &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&amp;gt; can the evaluation of foreign key constraints be deferred until commit &lt;UL&gt; &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition &lt;/UL&gt; &lt;/OL&gt;
 * @param primaryCatalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param primarySchema a schema name pattern; "" retrieves thosewithout a schema
 * @param primaryTable the table name that exports the key
 * @param foreignCatalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param foreignSchema a schema name pattern; "" retrieves thosewithout a schema
 * @param foreignTable the table name that imports the key
 * @return ResultSet - each row is a foreign key column description
 * @see #getImportedKeys
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>primaryCatalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primarySchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primaryTable</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignCatalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignSchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignTable</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getCrossReference")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(primaryCatalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(primarySchema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, primaryTable]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(foreignCatalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[5, swapNull(foreignSchema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[6, foreignTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCrossReferenceForODBC</MethodName>
            <MethodComment>/** 
 * In contrast to the JDBC version of getCrossReference, this method allows null values for table names.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>primaryCatalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primarySchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primaryTable</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignCatalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignSchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>foreignTable</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("odbc_getCrossReference")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(primaryCatalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(primarySchema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(primaryTable)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(foreignCatalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[5, swapNull(foreignSchema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[6, swapNull(foreignTable)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeInfo</MethodName>
            <MethodComment>/** 
 * Get a description of all the standard SQL types supported by this database. They are ordered by DATA_TYPE and then by how closely the data type maps to the corresponding JDBC SQL type. &lt;P&gt;Each type description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; Type name &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&amp;gt; SQL data type from java.sql.Types &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int =&amp;gt; maximum precision &lt;LI&gt;&lt;B&gt;LITERAL_PREFIX&lt;/B&gt; String =&amp;gt; prefix used to quote a literal (may be null) &lt;LI&gt;&lt;B&gt;LITERAL_SUFFIX&lt;/B&gt; String =&amp;gt; suffix used to quote a literal (may be null) &lt;LI&gt;&lt;B&gt;CREATE_PARAMS&lt;/B&gt; String =&amp;gt; parameters used in creating the type (may be null) &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short =&amp;gt; can you use NULL for this type? &lt;UL&gt; &lt;LI&gt; typeNoNulls - does not allow NULL values &lt;LI&gt; typeNullable - allows NULL values &lt;LI&gt; typeNullableUnknown - nullability unknown &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;CASE_SENSITIVE&lt;/B&gt; boolean=&amp;gt; is it case sensitive? &lt;LI&gt;&lt;B&gt;SEARCHABLE&lt;/B&gt; short =&amp;gt; can you use "WHERE" based on this type: &lt;UL&gt; &lt;LI&gt; typePredNone - No support &lt;LI&gt; typePredChar - Only supported with WHERE .. LIKE &lt;LI&gt; typePredBasic - Supported except for WHERE .. LIKE &lt;LI&gt; typeSearchable - Supported for all WHERE .. &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;UNSIGNED_ATTRIBUTE&lt;/B&gt; boolean =&amp;gt; is it unsigned? &lt;LI&gt;&lt;B&gt;FIXED_PREC_SCALE&lt;/B&gt; boolean =&amp;gt; can it be a money value? &lt;LI&gt;&lt;B&gt;AUTO_INCREMENT&lt;/B&gt; boolean =&amp;gt; can it be used for an auto-increment value? &lt;LI&gt;&lt;B&gt;LOCAL_TYPE_NAME&lt;/B&gt; String =&amp;gt; localized version of type name (may be null) &lt;LI&gt;&lt;B&gt;MINIMUM_SCALE&lt;/B&gt; short =&amp;gt; minimum scale supported &lt;LI&gt;&lt;B&gt;MAXIMUM_SCALE&lt;/B&gt; short =&amp;gt; maximum scale supported &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int =&amp;gt; unused &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int =&amp;gt; unused &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int =&amp;gt; usually 2 or 10 &lt;/OL&gt;
 * @return ResultSet - each row is a SQL type description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeInfoForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of all the standard SQL types supported by this database. They are ordered by DATA_TYPE and then by how closely the data type maps to the corresponding JDBC SQL type. Same as getTypeInfo above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeInfoMinion</MethodName>
            <MethodComment>/** 
 * Get a description of the standard SQL types supported by this database.
 * @param queryName the name of the query that fetches the information
 * @return a result set with SQL type description
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexInfo</MethodName>
            <MethodComment>/** 
 * Get a description of a table's indices and statistics. They are ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION. &lt;P&gt;Each index column description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&amp;gt; table catalog (may be null) &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&amp;gt; table schema (may be null) &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&amp;gt; table name &lt;LI&gt;&lt;B&gt;NON_UNIQUE&lt;/B&gt; boolean =&amp;gt; Can index values be non-unique? false when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;INDEX_QUALIFIER&lt;/B&gt; String =&amp;gt; index catalog (may be null); null when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;INDEX_NAME&lt;/B&gt; String =&amp;gt; index name; null when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;TYPE&lt;/B&gt; short =&amp;gt; index type: &lt;UL&gt; &lt;LI&gt; tableIndexStatistic - this identifies table statistics that are returned in conjuction with a table's index descriptions &lt;LI&gt; tableIndexClustered - this is a clustered index &lt;LI&gt; tableIndexHashed - this is a hashed index &lt;LI&gt; tableIndexOther - this is some other style of index &lt;/UL&gt; &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; short =&amp;gt; column sequence number within index; zero when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&amp;gt; column name; null when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;ASC_OR_DESC&lt;/B&gt; String =&amp;gt; column sort sequence, "A" =&amp;gt; ascending, "D" =&amp;gt; descending, may be null if sort sequence is not supported; null when TYPE is tableIndexStatistic &lt;LI&gt;&lt;B&gt;CARDINALITY&lt;/B&gt; int =&amp;gt; When TYPE is tableIndexStatistic, then this is the number of rows in the table; otherwise, it is the number of unique values in the index. &lt;LI&gt;&lt;B&gt;PAGES&lt;/B&gt; int =&amp;gt; When TYPE is  tableIndexStatisic then this is the number of pages used for the table, otherwise it is the number of pages used for the current index. &lt;LI&gt;&lt;B&gt;FILTER_CONDITION&lt;/B&gt; String =&amp;gt; Filter condition, if any. (may be null) &lt;/OL&gt;
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schema a schema name pattern; "" retrieves those without a schema
 * @param table a table name
 * @param unique when true, return only indices for unique values;when false, return indices regardless of whether unique or not
 * @param approximate when true, result is allowed to reflect approximateor out of data values; when false, results are requested to be accurate
 * @return ResultSet - each row is an index column description
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unique</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>approximate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexInfoForODBC</MethodName>
            <MethodComment>/** 
 * Get a description of a table's indices and statistics. They are ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION. Same as getIndexInfo above, except that the result set will conform to ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unique</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>approximate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doGetIndexInfo</MethodName>
            <MethodComment>/** 
 * Does the actual work for the getIndexInfo metadata calls.  See getIndexInfo() method above for parameter descriptions.
 * @param queryName Name of the query to execute; is usedto determine whether the result set should conform to JDBC or ODBC specifications.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>table</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unique</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>approximate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [approximateInInt=0]</InnerVar>
                <InnerVar>PreparedStatement [s=getPreparedQuery(queryName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schema)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, table]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setBoolean;[4, unique]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setInt;[5, approximateInInt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsResultSetType</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Does the database support the given result set type?
 * @param type defined in java.sql.ResultSet
 * @return true if so 
 * @see Connection
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsResultSetConcurrency</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Does the database support the concurrency type in combination with the given result set type?
 * @param type defined in java.sql.ResultSet
 * @param concurrency type defined in java.sql.ResultSet
 * @return true if so 
 * @see Connection
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>concurrency</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ownUpdatesAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether a result set's updates are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if updates are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ownDeletesAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether a result set's deletes are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if deletes are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ownInsertsAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether a result set's inserts are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if inserts are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>othersUpdatesAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether updates made by others are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if updates are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>othersDeletesAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether deletes made by others are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if deletes are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>othersInsertsAreVisible</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether inserts made by others are visible.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if inserts are visible for the result set type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatesAreDetected</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether or not a visible row update can be detected by  calling ResultSet.rowUpdated().
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if updates are detected by the resultset type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deletesAreDetected</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether or not a visible row delete can be detected by calling ResultSet.rowDeleted().  If deletesAreDetected() returns false, then deleted rows are removed from the result set.
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if deletes are detected by the resultset type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertsAreDetected</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine whether or not a visible row insert can be detected by calling ResultSet.rowInserted().
 * @param type result set type, i.e. ResultSet.TYPE_XXX
 * @return true if inserts are detected by the resultset type
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsBatchUpdates</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Return true if the driver supports batch updates, else return false.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUDTs</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Get a description of the user-defined types defined in a particular schema.  Schema specific UDTs may have type JAVA_OBJECT, STRUCT,  or DISTINCT. &lt;P&gt;Only types matching the catalog, schema, type name and type   criteria are returned.  They are ordered by DATA_TYPE, TYPE_SCHEM  and TYPE_NAME.  The type name parameter may be a fully qualified  name.  In this case, the catalog and schemaPattern parameters are ignored. &lt;P&gt;Each type description has the following columns: &lt;OL&gt; &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String =&amp;gt; the type's catalog (may be null) &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String =&amp;gt; type's schema (may be null) &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&amp;gt; type name &lt;LI&gt;&lt;B&gt;CLASS_NAME&lt;/B&gt; String =&amp;gt; Java class name &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; String =&amp;gt; type value defined in java.sql.Types.   One of JAVA_OBJECT, STRUCT, or DISTINCT &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&amp;gt; explanatory comment on the type &lt;LI&gt;&lt;B&gt;BASE_TYPE&lt;/B&gt; short =&amp;gt; type code of the source type of a DISTINCT type or the type that implements the user-generated reference type of the SELF_REFERENCING_COLUMN of a structured type as defined in java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE is not DISTINCT or not STRUCT with REFERENCE_GENERATION = USER_DEFINED) &lt;/OL&gt; &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support UDTs then an empty result set is returned.
 * @param catalog a catalog name; "" retrieves those without acatalog; null means drop catalog name from the selection criteria
 * @param schemaPattern a schema name pattern; "" retrieves thosewithout a schema
 * @param typeNamePattern a type name pattern; may be a fully qualifiedname
 * @param types a list of user-named types to include (JAVA_OBJECT, STRUCT, or DISTINCT); null returns all types 
 * @return ResultSet - each row is a type description
 * @exception SQLException if a database-access error occurs.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>types</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [getClassTypes=ILLEGAL_UDT_TYPE]</InnerVar>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getUDTs")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setInt;[1, java.sql.Types.JAVA_OBJECT]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[3, swapNull(schemaPattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[4, swapNull(typeNamePattern)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setInt;[5, getClassTypes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConnection</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Return the connection that produced this metadata object.
 */
</MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsStatementPooling</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether this database supports statement pooling.
 * @return true if statement pooling is supported; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsSavepoints</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether this database supports savepoints.
 * @return true if savepoints are supported; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsNamedParameters</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether this database supports named parameters to callable statements.
 * @return true if named parameters are supported; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMultipleOpenResults</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether it is possible to have multiple ResultSet objects returned from a CallableStatement object simultaneously.
 * @return true if a CallableStatement object can return multiple ResultSet objectssimultaneously; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsGetGeneratedKeys</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether auto-generated keys can be retrieved after a statement has been executed.
 * @return true if auto-generated keys can be retrieved after a statement hasexecuted; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsResultSetHoldability</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves whether this database supports the given result set holdability.
 * @param holdability - one of the following constants:ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT
 * @return true if so; false otherwiseexecuted; false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>holdability</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetHoldability</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the default holdability of this ResultSet object.
 * @return the default holdability which is ResultSet.HOLD_CURSORS_OVER_COMMIT
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseMajorVersion</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the major version number of the underlying database.
 * @return the underlying database's major version
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ProductVersionHolder [pvh=EmbedConnection.getMonitor().getEngineVersion()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseMinorVersion</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the minor version number of the underlying database.
 * @return the underlying database's minor version
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ProductVersionHolder [pvh=EmbedConnection.getMonitor().getEngineVersion()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJDBCMajorVersion</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the major JDBC version number for this driver.
 * @return JDBC version major number
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJDBCMinorVersion</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the minor JDBC version number for this driver.
 * @return JDBC version minor number
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLStateType</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Indicates whether the SQLSTATEs returned by SQLException.getSQLState is X/Open (now known as Open Group) SQL CLI or SQL99.
 * @return the type of SQLSTATEs, one of: sqlStateXOpen or sqlStateSQL99
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>locatorsUpdateCopy</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Indicates whether updates made to a LOB are made on a copy or directly to the LOB. &lt;p&gt; For the embedded driver, all updates will be made to a copy. Hence, this call will always return &lt;code&gt;true&lt;/code&gt;
 * @return true if updates are made to a copy of the LOB; false ifupdates are made directly to the LOB
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSuperTypes</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves a description of the user-defined type (UDT) hierarchies defined in a particular schema in this database. Only the immediate super type/ sub type relationship is modeled.
 * @param catalog - a catalog name; "" retrieves those without a catalog;null means drop catalog name from the selection criteria
 * @param schemaPattern - a schema name pattern; "" retrieves those without a schema
 * @param typeNamePattern - a UDT name pattern; may be a fully-qualified name
 * @return a ResultSet object in which a row gives information about the designated UDT
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSuperTables</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves a description of the table hierarchies defined in a particular schema in this database.
 * @param catalog - a catalog name; "" retrieves those without a catalog;null means drop catalog name from the selection criteria
 * @param schemaPattern - a schema name pattern; "" retrieves those without a schema
 * @param typeNamePattern - a UDT name pattern; may be a fully-qualified name
 * @return a ResultSet object in which each row is a type description
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAttributes</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves a description of the given attribute of the given type for a user-defined type (UDT) that is available in the given schema and catalog.
 * @param catalog - a catalog name; must match the catalog name as it isstored in the database; "" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
 * @param schemaPattern - a schema name pattern; "" retrieves those without a schema;null means that the schema name should not be used to narrow the search
 * @param typeNamePattern - a type name pattern; must match the type name as it isstored in the database
 * @param attributeNamePattern - an attribute name pattern; must match the attributename as it is declared in the database
 * @return a ResultSet object in which each row is a type description
 * @exception SQLException if a database access error occurs.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>attributeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClientInfoProperties</MethodName>
            <MethodComment>/** 
 * JDBC 4.0 &lt;p&gt;Returns a list of the client info properties supported by the driver. The result set contains the following columns: &lt;p&gt; &lt;ol&gt; &lt;li&gt;NAME String=&amp;gt; The name of the client info property.&lt;/li&gt; &lt;li&gt;MAX_LEN int=&amp;gt; The maximum length of the value for the property.&lt;/li&gt; &lt;li&gt;DEFAULT_VALUE String=&amp;gt; The default value of the property.&lt;/li&gt; &lt;li&gt;DESCRIPTION String=&amp;gt; A description of the property.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;The &lt;code&gt;ResultSet&lt;/code&gt; is sorted by the NAME column.
 * @return A &lt;code&gt;ResultSet&lt;/code&gt; object; each row is asupported client info property
 * @exception SQLException if an error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemas</MethodName>
            <MethodComment>/** 
 * JDBC 4.0 &lt;p&gt;Get the schema names available in this database. The results are ordered by schema name. &lt;p&gt;The schema columns are: &lt;ol&gt; &lt;li&gt;&lt;strong&gt;TABLE_SCHEM&lt;/strong&gt; String =&amp;gt; schema name&lt;/li&gt; &lt;li&gt;&lt;strong&gt;TABLE_CATALOG&lt;/strong&gt; String =&amp;gt; catalog name (may be &lt;code&gt;null&lt;/code&gt;)&lt;/li&gt; &lt;/ol&gt;
 * @param catalog catalog name used to narrow down the search; ""means no catalog, &lt;code&gt;null&lt;/code&gt; means any catalog
 * @param schemaPattern schema name used to narrow down thesearch, &lt;code&gt;null&lt;/code&gt; means schema name should not be used to narrow down search
 * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is aschema description
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s=getPreparedQuery("getSchemas")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;setString;[1, swapNull(catalog)]</InnerMethodInvoke>
                <InnerMethodInvoke>s;setString;[2, swapNull(schemaPattern)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowIdLifetime</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RowIdLifetime</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsStoredFunctionsUsingCallSyntax</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>autoCommitFailureClosesAllResultSets</MethodName>
            <MethodComment>/** 
 * Returns whether or not all open  {@code ResultSet}s on a  {@code Connection} are closed if an error occurs when auto-commit in enabled.
 * @return {@code true}, since the embedded driver will close the open {@code ResultSet}s
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isWrapperFor</MethodName>
            <MethodComment>/** 
 * Returns whether or not this instance implements the specified interface.
 * @param iface the interface to check for
 * @return true if this implements the interface
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>iface</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unwrap</MethodName>
            <MethodComment>/** 
 * Returns  {@code this} if this class implements the interface.
 * @param iface the interface
 * @return an object that implements the interface
 * @throws SQLException if no object is found that implements theinterface
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>iface</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generatedKeyAlwaysReturned</MethodName>
            <MethodComment>/** 
 * See DatabaseMetaData javadoc 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPseudoColumns</MethodName>
            <MethodComment>/** 
 * See DatabaseMetaData javadoc. Empty ResultSet because Derby does not support pseudo columns.
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalog</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClientCachedMetaData</MethodName>
            <MethodComment>/** 
 * Get metadata that the client driver will cache. The metadata is fetched using SYSIBM.METADATA (found in metadata_net.properties).
 * @return the result set returned by SYSIBM.METADATA
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSimpleQuery</MethodName>
            <MethodComment>/** 
 * Execute a query in metadata.properties (or SPS in the SYS schema) or metadata_net.properties (or SPS in the SYSIBM schema).
 * @param nameKey the name of the query
 * @param net if &lt;code&gt;true&lt;/code&gt;, execute a query inmetadata_net.properties; otherwise, execute a query in metadata.properties
 * @return a &lt;code&gt;ResultSet&lt;/code&gt; value
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nameKey</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=getPreparedQuery(nameKey,net)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSimpleQuery</MethodName>
            <MethodComment>/** 
 * Execute a query in metadata.properties, or an SPS in the SYS schema.
 * @param nameKey the name of the query
 * @return a &lt;code&gt;ResultSet&lt;/code&gt; value
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nameKey</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedQueryUsingSystemTables</MethodName>
            <MethodComment>/** 
 * Get a stored prepared statement from the system tables.
 * @param nameKey the name of the query
 * @param net if &lt;code&gt;true&lt;/code&gt;, find query in SYSIBM schema;otherwise, find query in SYS schema
 * @return a &lt;code&gt;PreparedStatement&lt;/code&gt; value
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nameKey</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedQuery</MethodName>
            <MethodComment>/** 
 * Either get the prepared query for the metadata call from the system tables, or from the metadata.properties or metadata_net.properties file. In soft upgrade mode, the queries stored in the system tables might not be upto date with the Derby engine release because system tables can't be modified in backward incompatible way in soft upgrade mode. Because of this, if the database is in  soft upgrade mode, get the queries from metadata.properties file rather than from the system tables. Getting queries from metadata(_net).properties might cause problems if system catalogs have been changed between versions either by addition of columns or have new catalogs. To continue to support soft upgrade from older versions of database, find query that most closely matches database dictionary version.
 * @param queryName Name of the metadata query for which we needa prepared statement
 * @param net if &lt;code&gt;true&lt;/code&gt;, use metadata_net.propertiesinstead of metadata.properties
 * @return PreparedStatement
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [s]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedQuery</MethodName>
            <MethodComment>/** 
 * Get a prepared query from system tables or metadata.properties.
 * @param queryName name of the query
 * @return a &lt;code&gt;PreparedStatement&lt;/code&gt; value
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQueryFromDescription</MethodName>
            <MethodComment>/** 
 * Given a queryName, find closest match in queryDescriptions. This method should be called in soft-upgrade mode only, where current software version doesn't match dictionary version. For these cases, there may be multiple entries in queryDescriptions for given queryName. Find a version of the query that closely matches dictionary version. This method is currently coded to handle two specific queries, getColumnPrivileges and getTablePrivileges. Derby databases that are 10.1 or earlier will not have new system tables added for 10.2 for privileges. It should be possible to automate finding closest match by generating all Major_Minor versions between software version and dictionary version and try each one from Dictionary version to current version. Since only needed for two queries, overhead may not be worth it yet.
 * @param queryName name of the query
 * @param net if &lt;code&gt;true&lt;/code&gt;, get the query frommetadata_net.properties instead of metadata.properties
 * @return the query text
 * @exception StandardException if an error occurs
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>queryName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getLanguageConnectionContext().getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareSPS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>spsName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spsText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>net</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>DataDictionary [dd=getLanguageConnectionContext().getDataDictionary()]</InnerVar>
                <InnerVar>SPSDescriptor [spsd=dd.getSPSDescriptor(spsName,net ? dd.getSysIBMSchemaDescriptor() : dd.getSystemSchemaDescriptor())]</InnerVar>
                <InnerVar>String [queryText="EXECUTE STATEMENT " + (net ? "SYSIBM" : "SYS") + ".\""+ spsName+ "\""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;beginNestedTransaction;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>lcc;commitNestedTransaction;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>swapNull</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageConnectionContext</MethodName>
            <MethodComment>/** 
 * Gets the LanguageConnectionContext for this connection.
 * @return	the lcc for this connection
 */
</MethodComment>
            <ReturnType>LanguageConnectionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LanguageConnectionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadQueryDescriptions</MethodName>
            <MethodComment>/** 
 * Loads the query descriptions from metadata.properties and metadata_net.properties into &lt;code&gt;queryDescriptions&lt;/code&gt; and &lt;code&gt;queryDescriptions_net&lt;/code&gt;.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>java.security.AccessController;doPrivileged;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment>/** 
 * Performs a privileged action. Reads the query descriptions.
 * @return &lt;code&gt;null&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;PBloadQueryDescriptions;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>