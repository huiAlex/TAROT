<Class>
    <Id>98</Id>
    <Package>org.apache.derby.iapi.jdbc</Package>
    <ClassName>EngineConnection</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Connection</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EngineConnection  /** 
 * Additional methods the embedded engine exposes on its Connection object implementations. An internal api only, mainly for the network server. Allows consistent interaction between EmbedConnections and BrokeredConnections.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>setDrdaID</MethodName>
            <MethodComment>/** 
 * Set the DRDA identifier for this connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInGlobalTransaction</MethodName>
            <MethodComment>/** 
 * Is this a global transaction
 * @return true if this is a global XA transaction
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPrepareIsolation</MethodName>
            <MethodComment>/** 
 * Set the transaction isolation level that will be used for the  next prepare.  Used by network server to implement DB2 style  isolation levels. Note the passed in level using the Derby constants from ExecutionContext and not the JDBC constants from java.sql.Connection.
 * @param level Isolation level to change to.  level is the DB2 levelspecified in the package names which happen to correspond to our internal levels. If  level == ExecutionContext.UNSPECIFIED_ISOLATION, the statement won't be prepared with an isolation level.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrepareIsolation</MethodName>
            <MethodComment>/** 
 * Return prepare isolation 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWarning</MethodName>
            <MethodComment>/** 
 * Add a SQLWarning to this Connection object.
 * @param newWarning Warning to be added, will be chained to anyexisting warnings.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newWarning</ParamName>
                    <ParamType>SQLWarning</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLOBMapping</MethodName>
            <MethodComment>/** 
 * Get the LOB reference corresponding to the locator.
 * @param key the integer that represents the LOB locator value.
 * @return the LOB Object corresponding to this locator.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSchemaName</MethodName>
            <MethodComment>/** 
 * Obtain the name of the current schema, so that the NetworkServer can use it for piggy-backing
 * @return the current schema name
 * @throws java.sql.SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetFromPool</MethodName>
            <MethodComment>/** 
 * Resets the connection before it is returned from a PooledConnection to a new application request (wrapped by a BrokeredConnection). &lt;p&gt; Note that resetting the transaction isolation level is not performed as part of this method. Temporary tables, IDENTITY_VAL_LOCAL and current schema are reset.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchema</MethodName>
            <MethodComment>/** 
 * Get the name of the current schema.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSchema</MethodName>
            <MethodComment>/** 
 * Set the default schema for the Connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>abort</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>executor</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNetworkTimeout</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>executor</ParamName>
                    <ParamType>Executor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>millis</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNetworkTimeout</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>