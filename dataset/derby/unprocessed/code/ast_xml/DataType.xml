<Class>
    <Id>618</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>DataType</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DataValueDescriptor</SuperInterface>
        <SuperInterface>Comparable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataType  /** 
 * DataType is the superclass for all data types.  It provides common behavior for datavalue descriptors -- it throws exceptions for all of the get* and setvalue(*)  methods of DataValueDescriptor; the subtypes need only override the one for the type they represent and all types it can also be returned as, and the methods dealing with nulls. Since all types satisfy getString  DataType does not define that interfaces of DataValueDescriptor. DataType is a little glue for columns to hold values with.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>getBoolean</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a boolean. Throws an exception if the data value is not receivable as a boolean.
 * @return	The data value as a boolean.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getByte</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a byte. Throws an exception if the data value is not receivable as a byte.
 * @return	The data value as a byte.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getShort</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a short. Throws an exception if the data value is not receivable as a short.
 * @return	The data value as a short.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>short</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInt</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a int. Throws an exception if the data value is not receivable as a int.
 * @return	The data value as a int.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLong</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a long. Throws an exception if the data value is not receivable as a long.
 * @return	The data value as a long.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFloat</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a float. Throws an exception if the data value is not receivable as a float.
 * @return	The data value as a float.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>float</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDouble</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a double. Throws an exception if the data value is not receivable as a double.
 * @return	The data value as a double.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeToBigDecimal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytes</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a byte[]. Throws an exception if the data value is not receivable as a Binary or Varbinary.
 * @return	The Binary value as a byte[].
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDate</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a java.sql.Date. Throws an exception if the data value is not receivable as a Date.
 * @param cal calendar for object creation
 * @return	The data value as a java.sql.Date.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Date</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTime</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a java.sql.Time. Throws an exception if the data value is not receivable as a Time.
 * @param cal calendar for object creation
 * @return	The data value as a java.sql.Time.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Time</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimestamp</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a java.sql.Timestamp. Throws an exception if the data value is not receivable as a Timestamp.
 * @param cal calendar for object creation
 * @return	The data value as a java.sql.Timestamp.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStream</MethodName>
            <MethodComment>/** 
 * Gets the value in the data stream descriptor as an InputStream. Throws an exception if the data value is not receivable as a stream.
 * @return	The data value as an InputStream.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasStream</MethodName>
            <MethodComment>/** 
 * Tells that the value isn't represented as a stream, which is true for most Derby data types. &lt;p&gt; This method will be overridden by types able to use a stream as the source.
 * @return {@code false}
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTraceString</MethodName>
            <MethodComment>/** 
 * Gets the value in the data stream descriptor as a trace string. This default implementation simply forwards the call to &lt;code&gt;getString&lt;/code&gt;.
 * @return The data value in a representation suitable for tracing.
 * @throws StandardException if getting the data value fails.
 * @see DataValueDescriptor#getString
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recycle</MethodName>
            <MethodComment>/** 
 * Recycle this DataType object.
 * @return this object with value set to null
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;restoreToNull;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternalFromArray</MethodName>
            <MethodComment>/** 
 * Read the DataValueDescriptor from the stream. The default implementation calls  {@code readExternal()}, which accesses the  {@code ArrayInputStream}as a generic stream. If sub-classes can implement it more efficiently by accessing the array, they should override this method.
 * @see DataValueDescriptor#readExternalFromArray
 * @see java.io.Externalizable#readExternal
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ArrayInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;readExternal;[in]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNullOp</MethodName>
            <MethodComment>/** 
 * The is null operator as called from the language module, as opposed to the storage module.
 * @return	A SQL boolean value telling whether the operand is null
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNotNull</MethodName>
            <MethodComment>/** 
 * The is not null operator as called from the language module, as opposed to the storage module.
 * @return	A SQL boolean value telling whether the operand is not null
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Time value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Time</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setValue;[theValue, (Calendar)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Time value to set this DataValueDescriptor to
 * @param cal The time zone from the calendar is used to construct the database time value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Time</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.sql.Time"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Timestamp value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Timestamp</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setValue;[theValue, (Calendar)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Timestamp value to set this DataValueDescriptor to
 * @param cal The time zone from the calendar is used to construct the database timestamp value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Timestamp</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.sql.Timestamp"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Date value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Date</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setValue;[theValue, (Calendar)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Date value to set this DataValueDescriptor to
 * @param cal The time zone from the calendar is used to construct the database date value
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Date</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cal</ParamName>
                    <ParamType>Calendar</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.sql.Date"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Object value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.lang.Object"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.lang.String"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Blob value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Blob</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.sql.Blob"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The Clob value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Clob</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.sql.Clob"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given int value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["int"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given double value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["double"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given float value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["float"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given short value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["short"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given long value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["long"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor to the given byte value At DataType level just throws an error lower classes will override
 * @param theValue	The value to set this DataValueDescriptor to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["byte"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value. At DataType level just throws an error lower classes will override
 * @param theValue	Contains the boolean value to set this to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["boolean"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor. At DataType level just throws an error lower classes will override
 * @param theValue	The byte value to set this DataValueDescriptor to
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["byte[]"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBigDecimal</MethodName>
            <MethodComment>/** 
 * Only to be called when the application sets a value using BigDecimal
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bigDecimal</ParamName>
                    <ParamType>BigDecimal</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.math.BigDecimal"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dvd</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFrom</MethodName>
            <MethodComment>/** 
 * Set the value of this DataValueDescriptor based on the value of the specified DataValueDescriptor.
 * @param dvd	The DataValueDescriptor that holds the value towhich we want to set this DataValueDescriptor's value.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dvd</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setToNull</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#setToNull
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;restoreToNull;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setObjectForCast</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#setObjectForCast
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>instanceOfResultType</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultTypeClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setObject;[theValue]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setObject</MethodName>
            <MethodComment>/** 
 * Set the value from an non-null object. Usually overridden. This implementation throws an exception. The object will have been correctly typed from the call to setObjectForCast.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;genericSetObject;[theValue]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeName</MethodName>
            <MethodComment>/** 
 * Get the type name of this value, possibly overriding with the passed in class name (for user/java types).
 * @param className
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObject</MethodName>
            <MethodComment>/** 
 * Gets the value in the data value descriptor as a int. Throws an exception if the data value is not receivable as a int.
 * @return	The data value as a int.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genericSetObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;[theValue]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneHolder</MethodName>
            <MethodComment>/** 
 * Default implementation of shallow cloning, which forwards to the deep clone method. &lt;p&gt; For many of the data types, a shallow clone will be the same as a deep clone. The data types requiring special handling of shallow clones have to override this method (for instance types whose value can be represented as a stream).
 * @return A shallow clone.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwLangSetMismatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;[value.getClass().getName()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwLangSetMismatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>argTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInto</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ps</ParamName>
                    <ParamType>PreparedStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setObject;[position, getObject()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInto</MethodName>
            <MethodComment>/** 
 * Set this value into a ResultSet for a subsequent ResultSet.insertRow or ResultSet.updateRow. This method will only be called for non-null values.
 * @exception SQLException thrown by the ResultSet object
 * @exception StandardException thrown by me accessing my value.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;updateObject;[position, getObject()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalize</MethodName>
            <MethodComment>/** 
 * Default normalization method. No information needed from DataTypeDescriptor.
 * @param desiredType	The type to normalize the source column to
 * @param source		The value to normalize
 * @exception StandardException				Thrown normalization error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>desiredType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>((DataValueDescriptor)this);setValue;[source]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typePrecedence</MethodName>
            <MethodComment>/** 
 * Each built-in type in JSQL has a precedence.  This precedence determines how to do type promotion when using binary operators.  For example, float has a higher precedence than int, so when adding an int to a float, the result type is float. The precedence for some types is arbitrary.  For example, it doesn't matter what the precedence of the boolean type is, since it can't be mixed with other types.  But the precedence for the number types is critical.  The SQL standard requires that exact numeric types be promoted to approximate numeric when one operator uses both.  Also, the precedence is arranged so that one will not lose precision when promoting a type.
 * @return		The precedence of this type.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * The = operator as called from the language module, as opposed to the storage module. This default implementations uses compare().
 * @param left			The value on the left side of the =
 * @param right			The value on the right side of the =
 * @return	A SQL boolean value telling whether the two parameters are equal
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notEquals</MethodName>
            <MethodComment>/** 
 * The &amp;lt;&amp;gt; operator as called from the language module, as opposed to the storage module. This default implementations uses compare().
 * @param left			The value on the left side of the &amp;lt;&amp;gt;
 * @param right			The value on the right side of the &amp;lt;&amp;gt;
 * @return	A SQL boolean value telling whether the two parametersare not equal
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lessThan</MethodName>
            <MethodComment>/** 
 * The &amp;lt; operator as called from the language module, as opposed to the storage module.
 * @param left   The value on the left side of the &amp;lt;
 * @param right   The value on the right side of the &amp;lt;
 * @return A SQL boolean value telling whether the first operand is lessthan the second operand
 * @exception StandardException  Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterThan</MethodName>
            <MethodComment>/** 
 * The &amp;gt; operator as called from the language module, as opposed to the storage module. This default implementations uses compare().
 * @param left			The value on the left side of the &amp;gt;
 * @param right			The value on the right side of the &amp;gt;
 * @return	A SQL boolean value telling whether the first operand is greaterthan the second operand
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lessOrEquals</MethodName>
            <MethodComment>/** 
 * The &amp;lt;= operator as called from the language module, as opposed to the storage module. This default implementations uses compare().
 * @param left			The value on the left side of the &amp;lt;=
 * @param right			The value on the right side of the &amp;lt;=
 * @return	A SQL boolean value telling whether the first operand is lessthan or equal to the second operand
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterOrEquals</MethodName>
            <MethodComment>/** 
 * The &amp;gt;= operator as called from the language module, as opposed to the storage module. This default implementation uses compare().
 * @param left			The value on the left side of the &amp;gt;=
 * @param right			The value on the right side of the &amp;gt;=
 * @return	A SQL boolean value telling whether the first operand is greaterthan or equal to the second operand
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderedNulls</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unknownRV</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [result=compare(other)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * Compare this Orderable with another, with configurable null ordering. The caller gets to determine how nulls should be treated - they can either be ordered values or unknown values. The caller also gets to decide, if they are ordered, whether they should be lower than non-NULL values, or higher
 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.Orderable.ORDER_OP_LESSTHAN means compare this &amp;lt; other. Orderable.ORDER_OP_LESSOREQUALS means compare this &amp;lt;= other.
 * @param other	The DataValueDescriptor to compare this one to.
 * @param orderedNulls	True means to treat nulls as ordered values,that is, treat SQL null as equal to null, and either greater or less than all other values. False means to treat nulls as unknown values, that is, the result of any comparison with a null is the UNKNOWN truth value.
 * @param nullsOrderedLow       True means NULL less than non-NULL,false means NULL greater than non-NULL. Only relevant if orderedNulls is true.
 * @param unknownRV		The return value to use if the result of thecomparison is the UNKNOWN truth value.  In other words, if orderedNulls is false, and a null is involved in the comparison, return unknownRV. This parameter is not used orderedNulls is true.
 * @return	true if the comparison is true (duh!)
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>op</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderedNulls</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullsOrderedLow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unknownRV</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [result=compare(other,nullsOrderedLow)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * Compare this Orderable with another, with configurable null ordering. This method treats nulls as ordered values, but allows the caller to specify whether they should be lower than all non-NULL values, or higher than all non-NULL values.
 * @param other		The Orderable to compare this one to.% @param nullsOrderedLow True if null should be lower than non-NULL
 * @return  &amp;lt;0 - this Orderable is less than other.0 - this Orderable equals other. &amp;gt;0 - this Orderable is greater than other. The code should not explicitly look for -1, or 1.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullsOrderedLow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareTo</MethodName>
            <MethodComment>/** 
 * Wrapper method for the "compare(DataValueDescriptor)" method of this class.  Allows sorting of an array of DataValueDescriptors using the JVMs own sorting algorithm.  Currently used for execution-time sorting of IN-list values to allow proper handling (i.e. elimination) of duplicates.
 * @see java.lang.Comparable#compareTo
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherDVD</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [other=(DataValueDescriptor)otherDVD]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flip</MethodName>
            <MethodComment>/** 
 * Flip the operator used in a comparison (&amp;lt; -&amp;gt; &amp;gt;). This is useful when flipping a comparison due to type precedence.
 * @param operator	The operator to flip.
 * @return The flipped operator.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>coalesce</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#coalesce
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>argumentsList</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnValue</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [index]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>returnValue;setToNull;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>in</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#in
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inList</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderedList</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BooleanDataValue [retval=null]</InnerVar>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>int [finish=inList.length]</InnerVar>
                <InnerVar>int [leftPrecedence=left.typePrecedence()]</InnerVar>
                <InnerVar>DataValueDescriptor [comparator=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;throwLangSetMismatch;["java.io.InputStream"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkHostVariable</MethodName>
            <MethodComment>/** 
 * Check the value to seem if it conforms to the restrictions imposed by DB2/JCC on host variables for this type.
 * @exception StandardException Variable is too big.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declaredLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dataTypeConversion</MethodName>
            <MethodComment>/** 
 * Return an conversion exception from this type to another.
 */
</MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>outOfRange</MethodName>
            <MethodComment>/** 
 * Return an out of range exception for this type.
 */
</MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidFormat</MethodName>
            <MethodComment>/** 
 * Return an out of range exception for this type.
 */
</MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>