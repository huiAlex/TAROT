<Class>
    <Id>1382</Id>
    <Package>org.apache.derby.impl.store.raw.xact</Package>
    <ClassName>LockCount</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>CLOSED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>IDLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ACTIVE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>UPDATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PREPARED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>END_ABORTED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>END_PREPARED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>END_COMMITTED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RECOVERY_ROLLBACK_FIRST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INTERNAL_TRANSACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NESTED_TOP_TRANSACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMMIT_SYNC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMMIT_NO_SYNC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMMIT_PREPARE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>savedEndStatus</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>needSync</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>justCreated</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>xc</FieldName>
            <FieldType>XactContext</FieldType>
        </Field>
        <Field>
            <FieldName>xactFactory</FieldName>
            <FieldType>XactFactory</FieldType>
        </Field>
        <Field>
            <FieldName>dataFactory</FieldName>
            <FieldType>DataFactory</FieldType>
        </Field>
        <Field>
            <FieldName>logFactory</FieldName>
            <FieldType>LogFactory</FieldType>
        </Field>
        <Field>
            <FieldName>dataValueFactory</FieldName>
            <FieldType>DataValueFactory</FieldType>
        </Field>
        <Field>
            <FieldName>compatibilitySpace</FieldName>
            <FieldType>CompatibilitySpace</FieldType>
        </Field>
        <Field>
            <FieldName>defaultLocking</FieldName>
            <FieldType>LockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>myGlobalId</FieldName>
            <FieldType>GlobalTransactionId</FieldType>
        </Field>
        <Field>
            <FieldName>myId</FieldName>
            <FieldType>TransactionId</FieldType>
        </Field>
        <Field>
            <FieldName>parentTransactionId</FieldName>
            <FieldType>TransactionId</FieldType>
        </Field>
        <Field>
            <FieldName>logger</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
        <Field>
            <FieldName>state</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>inComplete</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
        <Field>
            <FieldName>seenUpdates</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inPostCommitProcessing</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>logStart</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>logLast</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>savePoints</FieldName>
            <FieldType>Stack</FieldType>
        </Field>
        <Field>
            <FieldName>savePoints</FieldName>
            <FieldType>SavePoint</FieldType>
        </Field>
        <Field>
            <FieldName>postCommitWorks</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>postCommitWorks</FieldName>
            <FieldType>Serviceable</FieldType>
        </Field>
        <Field>
            <FieldName>postAbortWorks</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>postAbortWorks</FieldName>
            <FieldType>Serviceable</FieldType>
        </Field>
        <Field>
            <FieldName>postTerminationWorks</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>postTerminationWorks</FieldName>
            <FieldType>Serviceable</FieldType>
        </Field>
        <Field>
            <FieldName>recoveryTransaction</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>logBuffer</FieldName>
            <FieldType>DynamicByteArrayOutputStream</FieldType>
        </Field>
        <Field>
            <FieldName>postCompleteMode</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>sanityCheck_xaclosed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>transName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>readOnly</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>flush_log_on_xact_end</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>backupBlocked</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dontWaitForLocks</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>count</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>Xact</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xactFactory</ParamName>
                    <ParamType>XactFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentTransaction</ParamName>
                    <ParamType>Xact</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>logFactory</ParamName>
                    <ParamType>LogFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataFactory</ParamName>
                    <ParamType>DataFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataValueFactory</ParamName>
                    <ParamType>DataValueFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>readOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compatibilitySpace</ParamName>
                    <ParamType>CompatibilitySpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flush_log_on_xact_end</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetDefaultLocking;[]</InnerMethodInvoke>
                <InnerMethodInvoke>xactFactory;setNewTransactionId;[(XactId)null, this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setIdleState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockFactory</MethodName>
            <MethodComment>/** 
 */
</MethodComment>
            <ReturnType>LockFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogFactory</MethodName>
            <MethodComment>/** 
 * JIRA-606. As a part of this fix, it was required that LogFactory.checkVersion method to be exposed for any possible Version  checks in the Transaction processing module.  
 */
</MethodComment>
            <ReturnType>LogFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>anyoneBlocked</MethodName>
            <MethodComment>/** 
 * Return true if any transaction is currently blocked, even if not by this transaction.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogBuffer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DynamicByteArrayOutputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logAndUndo</MethodName>
            <MethodComment>/** 
 * Log and apply a compensation operation. Only need to write out the compensation op itself, the optional data has already been written by the rollforward operation this is attempting to undo.
 * @see RawTransaction#logAndDo 
 * @exception StandardException  Standard Derby exception policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compensation</ParamName>
                    <ParamType>Compensation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undoInstant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>LimitObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogInstant [clrInstant=logger.logAndUndo(this,compensation,undoInstant,in)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setLastLogInstant;[clrInstant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUpdateTransaction</MethodName>
            <MethodComment>/** 
 * Add this to the xactFactory list of update transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>transactionStatus</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeUpdateTransaction</MethodName>
            <MethodComment>/** 
 * Remove this from the xactFactory list of update transaction. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareTransaction</MethodName>
            <MethodComment>/** 
 * Remove this from the xactFactory list of update transaction. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFirstLogInstant</MethodName>
            <MethodComment>/** 
 * Set the log instant for the first log record written by this transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstLogInstant</MethodName>
            <MethodComment>/** 
 * Get the log instant for the first log record written by this transaction.
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLastLogInstant</MethodName>
            <MethodComment>/** 
 * Set the log instant for the last log record written by this transaction. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastLogInstant</MethodName>
            <MethodComment>/** 
 * Get the log instant for the last log record written by this transaction. 
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTransactionId</MethodName>
            <MethodComment>/** 
 * Set my transaction identifier.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>extid</ParamName>
                    <ParamType>GlobalTransactionId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localid</ParamName>
                    <ParamType>TransactionId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTransactionId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beginXact</ParamName>
                    <ParamType>Loggable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localId</ParamName>
                    <ParamType>TransactionId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setup</MethodName>
            <MethodComment>/** 
 * The default value for LOCKS_ESCALATION_THRESHOLD
 * @exception StandardException  Standard Derby exception policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>set</ParamName>
                    <ParamType>PersistentSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [escalationThreshold=PropertyUtil.getServiceInt(set,Property.LOCKS_ESCALATION_THRESHOLD,Property.MIN_LOCKS_ESCALATION_THRESHOLD,Integer.MAX_VALUE,Property.DEFAULT_LOCKS_ESCALATION_THRESHOLD)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLockFactory();setLimit;[compatibilitySpace, this, escalationThreshold, this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGlobalId</MethodName>
            <MethodComment>/** 
 * get the Global (external to raw store) transaction id that is unique across all raw stores
 */
</MethodComment>
            <ReturnType>GlobalTransactionId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextManager</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompatibilitySpace</MethodName>
            <MethodComment>/** 
 * Get the compatibility space of the transaction. &lt;p&gt; Returns an object that can be used with the lock manager to provide the compatibility space of a transaction.  2 transactions with the same compatibility space will not conflict in locks.  The usual case is that each transaction has it's own unique compatibility space. &lt;p&gt;
 * @return The compatibility space of the transaction.
 */
</MethodComment>
            <ReturnType>CompatibilitySpace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noWait</MethodName>
            <MethodComment>/** 
 * Tells whether lock requests should time out immediately if they can't be granted without waiting. Only works if this object is the owner of the compatibility space used in the request.
 * @return whether waiting for locks should time out immediately
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNoLockWait</MethodName>
            <MethodComment>/** 
 * {@inheritDoc}&lt;p&gt; This only works if this transaction is the owner of the compatibility space used in the request. If this transaction has inherited the compatibility space from its parent, the call to this method has no effect (except in debug builds, where an error will be raised).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>noWait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getId</MethodName>
            <MethodComment>/** 
 * get the short (internal to raw store) transaction id that is unique only for this raw store
 */
</MethodComment>
            <ReturnType>TransactionId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdNoCheck</MethodName>
            <MethodComment>/** 
 * Get the transaction id without sanity check, this should only be called by a cloned TransactionTableEntry 
 */
</MethodComment>
            <ReturnType>TransactionId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextId</MethodName>
            <MethodComment>/** 
 * Get my transaction context Id
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>XactContext [tempxc=xc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultLockingPolicy</MethodName>
            <MethodComment>/** 
 * Get the current default locking policy for all operations within this transaction. The transaction is initially started with a default locking policy equivalent to &lt;PRE&gt; newLockingPolicy( LockingPolicy.MODE_RECORD, TransactionController.ISOLATION_SERIALIZABLE, true); &lt;/PRE&gt; This default can be changed by subsequent calls to  setDefaultLockingPolicy(LockingPolicy policy).
 * @see Transaction#getDefaultLockingPolicy
 * @return The current default locking policy in this transaction.
 */
</MethodComment>
            <ReturnType>LockingPolicy</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newLockingPolicy</MethodName>
            <MethodComment>/** 
 * @see Transaction#newLockingPolicy 
 */
</MethodComment>
            <ReturnType>LockingPolicy</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stricterOk</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultLockingPolicy</MethodName>
            <MethodComment>/** 
 * @see Transaction#setDefaultLockingPolicy 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commit</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commitNoSync</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareCommit</MethodName>
            <MethodComment>/** 
 * Do work of commit that is common to xa_prepare and commit. &lt;p&gt; Do all the work necessary as part of a commit up to and including writing the commit log record.  This routine is used by both prepare and commit.  The work post commit is done by completeCommit(). &lt;p&gt;
 * @param commitflag various flavors of commit.
 * @exception StandardException  Standard exception policy.
 * @see Transaction#commit
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogInstant [flushTo=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>completeCommit</MethodName>
            <MethodComment>/** 
 * Do work to complete a commit which is not just a prepare. &lt;p&gt; Releases locks, does post commit work, and moves the state of the transaction to IDLE. &lt;p&gt;
 * @param commitflag various flavors of commit.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;postComplete;[commitflag, COMMIT]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commit</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#commit
 */
</MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogInstant [flushTo=prepareCommit(commitflag)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;completeCommit;[commitflag]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>abort</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#abort
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;postComplete;[0, ABORT]</InnerMethodInvoke>
                <InnerMethodInvoke>null;postTermination;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reprepare</MethodName>
            <MethodComment>/** 
 * During recovery re-prepare a transaction. &lt;p&gt; After redo() and undo(), this routine is called on all outstanding  in-doubt (prepared) transactions.  This routine re-acquires all  logical write locks for operations in the xact, and then modifies the transaction table entry to make the transaction look as if it had just been prepared following startup after recovery. &lt;p&gt; This routine is only called during Recovery.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>destroy</MethodName>
            <MethodComment>/** 
 * If this transaction is not idle, abort it.  After this call close().
 * @exception StandardException Standard Derby error policyThrown if the transaction is not idle.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * @exception StandardException Thrown if the transaction is not idle, thetransaction remains open.
 * @see Transaction#close
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLockFactory();clearLimit;[compatibilitySpace, this]</InnerMethodInvoke>
                <InnerMethodInvoke>xc;popMe;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logAndDo</MethodName>
            <MethodComment>/** 
 * Log the operation and do it. If this transaction has not generated any log records prior to this, then log a beginXact log record. If the passed in operation is null, then do nothing (after logging the beginXact if needed).
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#logAndDo 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operation</ParamName>
                    <ParamType>Loggable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogInstant [instant=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPostCommitWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>postCommitWorks;add;[work]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPostAbortWork</MethodName>
            <MethodComment>/** 
 * Add to the list of post abort work that may be processed after this transaction aborts.  
 * @param work the post commit work that is added
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>postAbortWorks;add;[work]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPostTerminationWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>postTerminationWorks;add;[work]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#openContainer 
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#openContainer 
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openDroppedContainer</MethodName>
            <MethodComment>/** 
 * Open a container that may already have been dropped.
 * @exception StandardException  Standard Derby exception policy
 * @see RawTransaction#openDroppedContainer
 */
</MethodComment>
            <ReturnType>RawContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawContainerHandle [hdl=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addContainer</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#addContainer 
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addAndLoadStreamContainer</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#addAndLoadStreamContainer
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openStreamContainer</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#openStreamContainer
 */
</MethodComment>
            <ReturnType>StreamContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStreamContainer</MethodName>
            <MethodComment>/** 
 * @see Transaction#dropStreamContainer
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;dropStreamContainer;[this, segmentId, containerId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reCreateContainerForRedoRecovery</MethodName>
            <MethodComment>/** 
 * Recreate a container during redo recovery. Used only during redo recovery while processing log records which are trying to create a container, and no valid container is found in the database.
 * @exception StandardException  Standard Derby exception policy
 * @see RawTransaction#reCreateContainerForRedoRecovery
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerInfo</ParamName>
                    <ParamType>ByteArray</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;reCreateContainerForRedoRecovery;[this, segmentId, containerId, containerInfo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropContainer</MethodName>
            <MethodComment>/** 
 * @see Transaction#dropContainer
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setActiveState;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dataFactory;dropContainer;[this, containerId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSavePoint</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#setSavePoint
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>savePoints;push;[new SavePoint(name,kindOfSavepoint)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwExceptionIfSQLSavepointNotAllowed</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#setSavePoint
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [foundUserSavepoint=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseSavePoint</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#releaseSavePoint
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [position=getSavePointPosition(name,kindOfSavepoint,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;popSavePoints;[position, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rollbackToSavePoint</MethodName>
            <MethodComment>/** 
 * @exception StandardException  Standard Derby exception policy
 * @see Transaction#rollbackToSavePoint
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [position=getSavePointPosition(name,kindOfSavepoint,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;notifyObservers;[SAVEPOINT_ROLLBACK]</InnerMethodInvoke>
                <InnerMethodInvoke>null;popSavePoints;[position, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogger</MethodName>
            <MethodComment>/** 
 * Get the Logger object used to write log records to the transaction log.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assumeIdentity</MethodName>
            <MethodComment>/** 
 * Transform this identity to the one stored in transaction table entry. Used by recovery only!
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ent</ParamName>
                    <ParamType>TransactionTableEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assumeGlobalXactIdentity</MethodName>
            <MethodComment>/** 
 * Assume complete identity of the given Transaction Table Entry. &lt;p&gt; Used by the final phase of the recovery to create new real transactions to take on the identity of in-doubt prepared transactions found during redo.  Need to assume the globalId.
 * @param ent The original entry we are assuming the identity of.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ent</ParamName>
                    <ParamType>TransactionTableEntry</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ent;setXact;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUpdateState</MethodName>
            <MethodComment>/** 
 * Move the transaction into the update state.
 * @exception StandardException problem setting a transaction id
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setIdleState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setActiveState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPrepareState</MethodName>
            <MethodComment>/** 
 * Move the state of the transaction from UPDATE to PREPARE. &lt;p&gt; The state transition should only be from UPDATE to PREPARE.  Read-only transactions (IDLE and ACTIVE) will never be prepared, they will be commited when the prepare is requested.  Only Update transactions will be allowed to go to prepared state. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defaultLockingPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LockingPolicy</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseAllLocks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLockFactory();unlockGroup;[getCompatibilitySpace(), this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetDefaultLocking</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDefaultLockingPolicy;[newLockingPolicy(LockingPolicy.MODE_RECORD,TransactionController.ISOLATION_SERIALIZABLE,true)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preComplete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitOrAbort</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postComplete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitflag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>commitOrAbort</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setIdleState;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doComplete</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commitOrAbort</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkObserverException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doPostCommitWorkInTran</MethodName>
            <MethodComment>/** 
 * If this is a user transaction (not an internal or nested top transaction), and this is not already taking care of post commit work, and not an XA transaction, then take care of hi prioirty  work right now using this thread and this context manager.   Otherwise, leave it to the post commit daemon.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handlesPostTerminationWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recoveryTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xactFactory;remove;[myId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transferPostCommitorAbortWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work_list</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postTermination</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [count=(postTerminationWorks == null) ? 0 : postTerminationWorks.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;transferPostCommitorAbortWork;[postCommitWorks]</InnerMethodInvoke>
                <InnerMethodInvoke>null;transferPostCommitorAbortWork;[postAbortWorks]</InnerMethodInvoke>
                <InnerMethodInvoke>null;unblockBackup;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSavePointPosition</MethodName>
            <MethodComment>/** 
 * Does a save point exist in the stack with the given name. Returns the position of the savepoint in the array
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kindOfSavepoint</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forRollbackOrRelease</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>popSavePoints</MethodName>
            <MethodComment>/** 
 * Pop all savepoints upto the one with the given name and rollback all changes made since this savepoint was pushed. If release is true then this savepoint is popped as well, otherwise it is left in the stack (at the top).
 * @return true if any work is rolled back, false if no work is rolled back
 * @exception StandardException Thrown if a error of severity less than TransactionException#SEVERITYis encountered during the rollback of this savepoint.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>release</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LogInstant [rollbackTo=null]</InnerVar>
                <InnerVar>int [size=savePoints.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>savePoints;setSize;[position + 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startNestedTopTransaction</MethodName>
            <MethodComment>/** 
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>RawTransaction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUserTransaction</MethodName>
            <MethodComment>/** 
 * see if this transaction is a user transaction.
 * @return true if this transaction is a user transaction
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [context_id=getContextId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isActive</MethodName>
            <MethodComment>/** 
 * see if this transaction has ever done anything. MT - single thread through synchronizing this.  This method may be called by other thread to test the state of this transaction.  That's why we need to synchronize with all methods which enters or exits the Idle state. Local method which read the state need not be synchronized because  the other thread may look at the state but it may not change it.
 * @return true if this transaction is not in idle or closed state
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [localState=state]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPrepared</MethodName>
            <MethodComment>/** 
 * see if this transaction is in PREPARED state. MT - single thread through synchronizing this.  This method may be called by other thread to test the state of this transaction.
 * @return true if this transaction is in PREPARED state.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIdle</MethodName>
            <MethodComment>/** 
 * See if this transaction is in the idle state, called by other thread to test the state of this transaction.  That's why we need to synchronzied with all methods whcih enters or exits the idle state
 * @return true if it is idle, otherwise false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPristine</MethodName>
            <MethodComment>/** 
 * see if this transaction is in a pristine state. &lt;BR&gt;MT - called only by the same thread that owns the xact, no need to synchronize.
 * @return true if it hasn't done any updates, otherwise false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inAbort</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileHandler</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileResource</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statusForBeginXactLog</MethodName>
            <MethodComment>/** 
 * put this into the beginXact log record to help recovery if we needs to rolled back first, put that in
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statusForEndXactLog</MethodName>
            <MethodComment>/** 
 * put this into the endXact log record to help recovery,  nothing to add
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPostComplete</MethodName>
            <MethodComment>/** 
 * Set the transaction to issue pre complete work at postComplete time, instead of preComplete time. This means that latches and containers will be held open until after a commit or an abort.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>blockBackup</MethodName>
            <MethodComment>/** 
 * Make the transaction block the online backup.
 * @param wait if &lt;tt&gt;true&lt;/tt&gt;, waits until the transactioncan block the backup.
 * @return     &lt;tt&gt;true&lt;/tt&gt; if the transaction  blocked the  backup.  &lt;tt&gt;false&lt;/tt&gt; otherwise.
 * @exception StandardException if interrupted while waiting for the backup in progress to complete.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unblockBackup</MethodName>
            <MethodComment>/** 
 * Unblock the backup, if it was blocked by some operation in  this transaction. Unblocking is done at commit/abort of this  transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBlockingBackup</MethodName>
            <MethodComment>/** 
 * Check if the transaction is blocking the backup ?
 * @return &lt;tt&gt; true &lt;/tt&gt; if this transaction is blocking the backup, otherwise &lt;tt&gt; false &lt;/tt&gt;
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reached</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compatibilitySpace</ParamName>
                    <ParamType>CompatibilitySpace</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>group</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>limit</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockList</ParamName>
                    <ParamType>Enumeration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Dictionary&lt;ContainerKey,LockCount&gt; [containers=new java.util.Hashtable&lt;ContainerKey,LockCount&gt;()]</InnerVar>
                <InnerVar>int [threshold=limit / (containers.size() + 1)]</InnerVar>
                <InnerVar>boolean [didEscalate=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXATransactionFromLocalTransaction</MethodName>
            <MethodComment>/** 
 * Convert a local transaction to a global transaction. &lt;p&gt; Must only be called a previous local transaction was created and exists in the context.  Can only be called if the current transaction is in the idle state, and no current global id.   &lt;p&gt; Simply call setTransactionId() which takes care of error checking.
 * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
 * @param global_id the global transaction identifier part of XID - ie.Xid.getGlobalTransactionId().
 * @param branch_id The branch qualifier of the Xid - ie. Xid.getBranchQaulifier()
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>format_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>global_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>branch_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GlobalXactId [gid=new GlobalXactId(format_id,global_id,branch_id)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTransactionId;[gid, this.getId()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_commit</MethodName>
            <MethodComment>/** 
 * This method is called to commit the current XA global transaction. &lt;p&gt; RESOLVE - how do we map to the "right" XAExceptions. &lt;p&gt;
 * @param onePhase If true, the resource manager should use a one-phasecommit protocol to commit the work done on behalf of  current xid.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onePhase</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_prepare</MethodName>
            <MethodComment>/** 
 * This method is called to ask the resource manager to prepare for a transaction commit of the transaction specified in xid. &lt;p&gt;
 * @return         A value indicating the resource manager's vote on thethe outcome of the transaction.  The possible values are:  XA_RDONLY or XA_OK.  If the resource manager wants to roll back the transaction, it should do so by  throwing an appropriate XAException in the prepare method.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xa_rollback</MethodName>
            <MethodComment>/** 
 * rollback the current global transaction. &lt;p&gt; The given transaction is roll'ed back and it's history is not maintained in the transaction table or long term log. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;abort;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Return the xid as a string. &lt;p&gt; The virtual lock table depends on this routine returning just the local transaction id as a string, even if it is a global transaction. Joins between the lock table and the transaction table will not work if this routine returns anything other than myId.toString(). &lt;p&gt;
 * @return The xid as a string.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toInternalDetailString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActiveStateTxIdString</MethodName>
            <MethodComment>/** 
 * Get string id of the transaction that would be when the Transaction is IN active state. This transaction "name" will be the same id which is returned in the TransactionInfo information if Tx is already in Active State. If the Transaction is in IDLE state, Transaction ID is  incremented when getActiveStateTxIdString() on raw transaction is called, instead of the Tx ID being incremented when Transaction gets into active state. The reason for incrementing the Tx ID earlier than when Tx is actually goes into active state is some debug statement cases like  log statement text. SQL statements are written to log before they are actually executed; In such cases we would like to display the actual TX ID on which locks are acquired when the statement is executed.
 * @return The a string which identifies the transaction.  
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValueFactory</MethodName>
            <MethodComment>/** 
 * Get DataValueFactory. &lt;p&gt; Return a DataValueFactory that can be used to allocate objects.  Used to make calls to:  DataValueFactory.getInstanceUsingFormatIdAndCollationType()
 * @return a booted data value factory.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DataValueFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [localState]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTransName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inRollForwardRecovery</MethodName>
            <MethodComment>/** 
 * Is the transaction in rollforward recovery
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkpointInRollForwardRecovery</MethodName>
            <MethodComment>/** 
 * Perform a checkpoint during rollforward recovery.
 * @throws org.apache.derby.iapi.error.StandardException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cinstant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>redoLWM</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undoLWM</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>logFactory;checkpointInRFR;[cinstant, redoLWM, undoLWM, dataFactory]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNestedOwner</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nestsUnder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>LockOwner</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>