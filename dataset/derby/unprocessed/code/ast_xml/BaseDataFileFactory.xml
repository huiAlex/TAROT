<Class>
    <Id>1274</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>BaseDataFileFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DataFactory</SuperInterface>
        <SuperInterface>CacheableFactory</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
        <SuperInterface>ModuleSupportable</SuperInterface>
        <SuperInterface>PrivilegedExceptionAction</SuperInterface>
        <SuperInterface>Object</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BaseDataFileFactory  /** 
 * Provides the abstract class with most of the implementation of DataFactory and ModuleControl shared by all the different filesystem implementations. &lt;p&gt; RESOLVE (mikem - 2/19/98) - Currently only getContainerClass() is abstract, there are probably more  routines which should be abstract.  Also the other implementations should  probably inherit from the abstract class, rather than from the DataFileFactory class.  Also there probably should be a generic directory and the rest of the filesystem implementations parallel to it. I wanted to limit the changes going into the branch and then fix  inheritance stuff in main. &lt;p&gt; The code in this class was moved over from DataFileFactory.java and then that file was made to inherit from this one.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>storageFactory</FieldName>
            <FieldType>StorageFactory</FieldType>
        </Field>
        <Field>
            <FieldName>writableStorageFactory</FieldName>
            <FieldType>WritableStorageFactory</FieldType>
        </Field>
        <Field>
            <FieldName>nextContainerId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>databaseEncrypted</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>pageCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>containerCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>logFactory</FieldName>
            <FieldType>LogFactory</FieldType>
        </Field>
        <Field>
            <FieldName>jbmsVersion</FieldName>
            <FieldType>ProductVersionHolder</FieldType>
        </Field>
        <Field>
            <FieldName>jvmVersion</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>osInfo</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>jarCPath</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>rawStoreFactory</FieldName>
            <FieldType>RawStoreFactory</FieldType>
        </Field>
        <Field>
            <FieldName>dataDirectory</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>throwDBlckException</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>identifier</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>freezeSemaphore</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>isFrozen</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>writersInProgress</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>removeStubsOK</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isCorrupt</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>inCreateNoLog</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>fileLockOnDB</FieldName>
            <FieldType>StorageRandomAccessFile</FieldType>
        </Field>
        <Field>
            <FieldName>exFileLock</FieldName>
            <FieldType>StorageFile</FieldType>
        </Field>
        <Field>
            <FieldName>istream</FieldName>
            <FieldType>HeaderPrintWriter</FieldType>
        </Field>
        <Field>
            <FieldName>LINE</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>dataNotSyncedAtAllocation</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dataNotSyncedAtCheckpoint</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>loggablePageActions</FieldName>
            <FieldType>PageActions</FieldType>
        </Field>
        <Field>
            <FieldName>loggableAllocActions</FieldName>
            <FieldType>AllocationActions</FieldType>
        </Field>
        <Field>
            <FieldName>readOnly</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>supportsRandomAccess</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>fileHandler</FieldName>
            <FieldType>FileResource</FieldType>
        </Field>
        <Field>
            <FieldName>droppedTableStubInfo</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>droppedTableStubInfo</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>postRecoveryRemovedFiles</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>postRecoveryRemovedFiles</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>actionCode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REMOVE_TEMP_DIRECTORY_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_CONTAINER_PATH_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_ALTERNATE_CONTAINER_PATH_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FIND_MAX_CONTAINER_ID_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DELETE_IF_EXISTS_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_PATH_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>POST_RECOVERY_REMOVE_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REMOVE_STUBS_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BOOT_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_LOCK_ON_DB_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RELEASE_LOCK_ON_DB_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RESTORE_DATA_DIRECTORY_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>GET_CONTAINER_NAMES_ACTION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>containerId</FieldName>
            <FieldType>ContainerKey</FieldType>
        </Field>
        <Field>
            <FieldName>stub</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionFile</FieldName>
            <FieldType>StorageFile</FieldType>
        </Field>
        <Field>
            <FieldName>myUUID</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>uuidFactory</FieldName>
            <FieldType>UUIDFactory</FieldType>
        </Field>
        <Field>
            <FieldName>databaseDirectory</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>backupRoot</FieldName>
            <FieldType>File</FieldType>
        </Field>
        <Field>
            <FieldName>bfilelist</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>undo_handler</FieldName>
            <FieldType>UndoHandler</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BaseDataFileFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;checkDerbyInternalsPrivilege;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canSupport</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [serviceType=startParams.getProperty(PersistentService.TYPE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUIDFactory [uf=getMonitor().getUUIDFactory()]</InnerVar>
                <InnerVar>PersistentService [ps=getMonitor().getServiceType(this)]</InnerVar>
                <InnerVar>String [value=startParams.getProperty(Property.FORCE_DATABASE_LOCK,PropertyUtil.getSystemProperty(Property.FORCE_DATABASE_LOCK))]</InnerVar>
                <InnerVar>String [restoreFrom=null]</InnerVar>
                <InnerVar>String [messageID=(isReadOnly()) ? MessageId.STORE_BOOT_MSG_READ_ONLY : MessageId.STORE_BOOT_MSG]</InnerVar>
                <InnerVar>boolean [logBootTrace=Boolean.valueOf(startParams.getProperty(Property.LOG_BOOT_TRACE,PropertyUtil.getSystemProperty(Property.LOG_BOOT_TRACE))).booleanValue()]</InnerVar>
                <InnerVar>String [target=PropertyUtil.getSystemProperty(Property.ERRORLOG_STYLE_PROPERTY)]</InnerVar>
                <InnerVar>CacheFactory [cf=(CacheFactory)startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory)]</InnerVar>
                <InnerVar>int [pageCacheSize=getIntParameter(RawStoreFactory.PAGE_CACHE_SIZE_PARAMETER,null,RawStoreFactory.PAGE_CACHE_SIZE_DEFAULT,RawStoreFactory.PAGE_CACHE_SIZE_MINIMUM,RawStoreFactory.PAGE_CACHE_SIZE_MAXIMUM)]</InnerVar>
                <InnerVar>int [fileCacheSize=getIntParameter(RawStoreFactory.CONTAINER_CACHE_SIZE_PARAMETER,null,RawStoreFactory.CONTAINER_CACHE_SIZE_DEFAULT,RawStoreFactory.CONTAINER_CACHE_SIZE_MINIMUM,RawStoreFactory.CONTAINER_CACHE_SIZE_MAXIMUM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logMsg;[LINE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logMsg;[new Date() + MessageService.getTextMessage(messageID,jbmsVersion,identifier,dataDirectory,(Object)this.getClass().getClassLoader(),jarCPath)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logMsg;[jvmVersion]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logMsg;[osInfo]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logMsg;[Property.SYSTEM_HOME_PROPERTY + "=" + PropertyUtil.getSystemProperty(Property.SYSTEM_HOME_PROPERTY)]</InnerMethodInvoke>
                <InnerMethodInvoke>pageCache;registerMBean;[dataDirectory]</InnerMethodInvoke>
                <InnerMethodInvoke>containerCache;registerMBean;[dataDirectory]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [OK=false]</InnerVar>
                <InnerVar>boolean [logBootTrace=PropertyUtil.getSystemBoolean(Property.LOG_BOOT_TRACE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logMsg;[LINE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;logMsg;[new Date() + MessageService.getTextMessage(MessageId.STORE_SHUTDOWN_MSG,getIdentifier(),getRootDirectory(),(Object)this.getClass().getClassLoader())]</InnerMethodInvoke>
                <InnerMethodInvoke>null;removeTempDirectory;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;releaseJBMSLockOnDB;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newCacheable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>CacheManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createFinished</MethodName>
            <MethodComment>/** 
 * Database creation finished
 * @exception StandardException Standard Derby exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkpoint;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openDroppedContainer</MethodName>
            <MethodComment>/** 
 * @see DataFactory#openDroppedContainer
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RawContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openContainer</MethodName>
            <MethodComment>/** 
 * @see DataFactory#openContainer
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RawContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>droppedOK</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [waitForLock=((mode &amp; ContainerHandle.MODE_LOCK_NOWAIT) == 0)]</InnerVar>
                <InnerVar>BaseContainerHandle [c]</InnerVar>
                <InnerVar>FileContainer [container=(FileContainer)containerCache.find(identity)]</InnerVar>
                <InnerVar>PageActions [pageActions=null]</InnerVar>
                <InnerVar>AllocationActions [allocActions=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addContainer</MethodName>
            <MethodComment>/** 
 * Add a container with a specified page size to a segment.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_containerid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [containerId=((input_containerid != ContainerHandle.DEFAULT_ASSIGN_ID) ? input_containerid : getNextId())]</InnerVar>
                <InnerVar>ContainerKey [identity=new ContainerKey(segmentId,containerId)]</InnerVar>
                <InnerVar>boolean [tmpContainer=(segmentId == ContainerHandle.TEMPORARY_SEGMENT)]</InnerVar>
                <InnerVar>ContainerHandle [ch=null]</InnerVar>
                <InnerVar>LockingPolicy [cl=null]</InnerVar>
                <InnerVar>FileContainer [container=(FileContainer)containerCache.create(identity,tableProperties)]</InnerVar>
                <InnerVar>ContainerHandle [containerHdl=null]</InnerVar>
                <InnerVar>Page [firstPage=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addAndLoadStreamContainer</MethodName>
            <MethodComment>/** 
 * Add and load a stream container
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [containerId=getNextId()]</InnerVar>
                <InnerVar>ContainerKey [identity=new ContainerKey(segmentId,containerId)]</InnerVar>
                <InnerVar>StreamFileContainer [sContainer=new StreamFileContainer(identity,this,tableProperties)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sContainer;load;[rowSource]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openStreamContainer</MethodName>
            <MethodComment>/** 
 * open an exsisting streamContainer
 * @see DataFactory#openStreamContainer
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>StreamContainerHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerKey [identity=new ContainerKey(segmentId,containerId)]</InnerVar>
                <InnerVar>StreamFileContainerHandle [c]</InnerVar>
                <InnerVar>StreamFileContainer [container=new StreamFileContainer(identity,this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStreamContainer</MethodName>
            <MethodComment>/** 
 * Drop a stream container. &lt;P&gt;&lt;B&gt;Synchronisation&lt;/B&gt; &lt;P&gt; This call will remove the container.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [tmpContainer=(segmentId == ContainerHandle.TEMPORARY_SEGMENT)]</InnerVar>
                <InnerVar>StreamContainerHandle [containerHdl=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reCreateContainerForRedoRecovery</MethodName>
            <MethodComment>/** 
 * re-Create a container during redo recovery. called ONLY during recovery load tran.
 * @exception StandardException Standard Derby Error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containerInfo</ParamName>
                    <ParamType>ByteArray</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerKey [identity=new ContainerKey(segmentId,containerId)]</InnerVar>
                <InnerVar>FileContainer [container=(FileContainer)containerCache.create(identity,containerInfo)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerCache;release;[container]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropContainer</MethodName>
            <MethodComment>/** 
 * Drop a container. &lt;P&gt;&lt;B&gt;Synchronisation&lt;/B&gt; &lt;P&gt; This call will mark the container as dropped and then obtain an CX lock (table level exclusive lock) on the container. Once a container has  been marked as dropped it cannot be retrieved by an openContainer()  call unless explicitly with droppedOK. &lt;P&gt; Once the exclusive lock has been obtained the container is removed and all its pages deallocated. The container will be fully removed at the commit time of the transaction.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ckey</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [tmpContainer=(ckey.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT)]</InnerVar>
                <InnerVar>LockingPolicy [cl=null]</InnerVar>
                <InnerVar>RawContainerHandle [containerHdl=(RawContainerHandle)t.openContainer(ckey,cl,ContainerHandle.MODE_FORUPDATE)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>t;notifyObservers;[ckey]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkpoint</MethodName>
            <MethodComment>/** 
 * Implement checkpoint operation, write/sync all pages in cache. &lt;p&gt; The derby write ahead log algorithm uses checkpoint of the data cache to determine points of the log no longer required by restart recovery.   &lt;p&gt; This implementation uses the 2 cache interfaces to force all dirty pages to disk: WRITE DIRTY PAGES TO OS: In the first step all pages in the page cache are written, but not synced (pagecache.cleanAll).  The cachemanager cleanAll() interface guarantees that every dirty page that exists when this call is first made will have it's clean() method called. The data cache (CachedPage.clean()), will call writePage but not sync the page.   By using the java write then sync, the checkpoint is usually doing async I/O, allowing the OS to schedule multiple I/O's to the file as efficiently as it can. Note that it has been observed that checkpoints can flood the I/O system because these writes are not synced, see DERBY-799 - checkpoint should probably somehow restrict the rate it sends out those I/O's - it was observed a simple sleep every N writes fixed most of the problem.   FORCE THOSE DIRTY WRITES TO DISK: To force the I/O's to disk, the system calls each open dirty file and uses the java interface to sync any outstanding dirty pages to disk (containerCache.cleanAll()).  The open container cache does this work in RAFContainer.clean() by writing it's header out and syncing the file.  (Note if any change is made to checkpoint to sync the writes vs. syncing the file, one probably still needs to  write the container header out and sync it).
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pageCache;cleanAll;[]</InnerMethodInvoke>
                <InnerMethodInvoke>containerCache;cleanAll;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>idle</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pageCache;ageOut;[]</InnerMethodInvoke>
                <InnerMethodInvoke>containerCache;ageOut;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRawStoreFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsf</ParamName>
                    <ParamType>RawStoreFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;bootLogFactory;[create, startParams]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdentifier</MethodName>
            <MethodComment>/** 
 * Return my unique identifier
 * @see DataFactory#getIdentifier
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reclaimSpace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>work</ParamName>
                    <ParamType>Serviceable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>contextMgr</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Transaction [tran=rawStoreFactory.findUserTransaction(contextMgr,AccessFactoryGlobals.SYS_TRANS_NAME)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markCorrupt</MethodName>
            <MethodComment>/** 
 * Really this is just a convience routine for callers that might not have access to a log factory.
 */
</MethodComment>
            <ReturnType>StandardException</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>originalError</ParamName>
                    <ParamType>StandardException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [firsttime=!isCorrupt]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFileHandler</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>FileResource</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeStubsOK</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUndoInsertEventHandler</MethodName>
            <MethodComment>/** 
 * Register a handler class for insert undo events. &lt;p&gt; Register a class to be called when an undo of an insert is executed.   When an undo of an event is executed by the raw store  UndoHandler.insertUndoNotify() will be called, allowing upper level  callers to execute code as necessary.  The initial need is for the  access layer to be able to queue post commit reclaim space in the case  of inserts which are aborted (including the normal case of inserts  failed for duplicate key violations) (see DERBY-4057) &lt;p&gt;
 * @param input_undo_handle Class to use to notify callers of an undo of an insert.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input_undo_handle</ParamName>
                    <ParamType>UndoHandler</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertUndoNotify</MethodName>
            <MethodComment>/** 
 * Notify through set handler that an undo of an insert has happened. &lt;p&gt; When an undo of an event is executed by the raw store  UndoHandler.insertUndoNotify() will be called, allowing upper level  callers to execute code as necessary.  The initial need is for the  access layer to be able to queue post commit reclaim space in the case  of inserts which are aborted (including the normal case of inserts  failed for duplicate key violations) (see DERBY-4057) Longer descrption of routine. &lt;p&gt;
 * @param rxact     raw transaction of the aborted insert.
 * @param page_key  page key of the aborted insert.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rxact</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>page_key</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIntParameter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaultValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>minimumValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumValue</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [newValue]</InnerVar>
                <InnerVar>String [parameter=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CacheManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageCache</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>CacheManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flush</MethodName>
            <MethodComment>/** 
 * Ask the log factory to flush up to this log instant.
 * @exception StandardException cannot sync log file
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getLogFactory();flush;[instant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLogFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawStoreFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RawStoreFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRootDirectory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newContainerObject</MethodName>
            <MethodComment>/** 
 * Produces new container objects. &lt;p&gt; Concrete implementations of a DataFactory must implement this routine to indicate what kind of containers are produced. This class produces file-based containers - RAFContainer objects for files that support random access and InputStreamContainer object for others, such as data files in JARs. &lt;p&gt;
 * @return A new file container object.
 */
</MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRAFContainer</MethodName>
            <MethodComment>/** 
 * Creates a RAFContainer object. This method is overridden in BaseDataFileFactoryJ4 to produce RAFContainer4 objects instead of RAFContainer objects.
 */
</MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factory</ParamName>
                    <ParamType>BaseDataFileFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLoggablePageActions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PageActions</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLoggableAllocationActions</MethodName>
            <MethodComment>/** 
 * Get the loggable allocation action associated with this implementation
 * @return the PageActions
 */
</MethodComment>
            <ReturnType>AllocationActions</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeTempDirectory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerPath</MethodName>
            <MethodComment>/** 
 * Return the path to a container file. &lt;p&gt; Return the path to a container file that is relative to the root  directory. &lt;p&gt; The format of the name of an existing container file is: segNNN/cXXX.dat The format of the name of a stub describing a dropped container file is: segNNN/dXXX.dat NNN = segment number, currently 0 is where normal db files are found. XXX = The hex representation of the container number The store will always create containers with this format name, but  the store will also recognize the following two formats when attempting to open files - as some copy tools have uppercased our filesnames when moving across operating systems: The format of the name of an existing container file is: segNNN/CXXX.DAT The format of the name of a stub describing a dropped container file is: segNNN/DXXX.DAT &lt;p&gt;
 * @param containerId The container being opened/created
 * @param stub        True if the file name for the stub is requested, otherwise the file name for the data file
 * @return The StorageFile representing path to container relative to root.
 */
</MethodComment>
            <ReturnType>StorageFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerPath</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StorageFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>code</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAlternateContainerPath</MethodName>
            <MethodComment>/** 
 * Return an alternate path to container file relative to the root directory. The alternate path uses upper case 'C','D', and 'DAT' instead of  lower case - there have been cases of people copying the database and somehow upper casing all the file names. The intended use is as a bug fix for track 3444.
 * @param containerId The container being opened/created
 * @param stub True if the file name for the stub is requested, otherwise the file name for the data file
 */
</MethodComment>
            <ReturnType>StorageFile</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerId</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeStubs</MethodName>
            <MethodComment>/** 
 * Remove stubs in this database.  Stubs are committed deleted containers
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stubFileToRemoveAfterCheckPoint</MethodName>
            <MethodComment>/** 
 * keeps track of information about the stub files of the  committed deleted containers. We use the info to delete them at checkpoints. In addition to the file info , we also keep track of the identity of the container; which helps to remove entry in the cache and the log instant when the stub was created, which helps us to figure out whether we require the stub file for the crash recovery. We maintain the information in a hashtable: key(LOG INSTANT) Values: File handle , and ContainerIdentity.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>logInstant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeDroppedContainerFileStubs</MethodName>
            <MethodComment>/** 
 * Delete the stub files that are not required for recovery. A stub file is not required to be around if the recovery is not going to see any log record that belongs to that container. Since the stub files are created as a post commit operation, they are not necessary during undo operation of the recovery. To remove a stub file we have to be sure that it was created before the redoLWM in the check point record. We can be sure that the stub is not required if the log instant when it was created is less than the redoLWM.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>redoLWM</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMaxContainerId</MethodName>
            <MethodComment>/** 
 * Find the largest containerid is seg 0. &lt;p&gt; Do a file list of the files in seg0 and return the highest numbered file found. &lt;p&gt; Until I figure out some reliable place to store this information across a boot of the system, this is what is used following a boot to assign the next conglomerate id when a new conglomerate is created.  It is only called at most once, and then the value is cached by calling store code. &lt;p&gt;
 * @return The largest containerid in seg0.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootLogFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleServiceType</MethodName>
            <MethodComment>/** 
 * Does this factory support this service type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJBMSLockOnDB</MethodName>
            <MethodComment>/** 
 * check to see if we are the only JBMS opened against this database. &lt;BR&gt;This method does nothing if this database is read only or we cannot access files directly on the database directory. &lt;BR&gt;We first see if a file named db.lck exists on the top database directory (i.e., the directory where service.properties lives).  If it doesn't exist, we create it and write to it our identity which is generated per boot of the JBMS. &lt;BR&gt;If the db.lck file already exists when we boot this database, we try to delete it first, assuming that an opened RandomAccessFile can act as a file lock against delete.  If that succeeds, we may hold a file lock against subsequent JBMS that tries to attach to this database before we exit. &lt;BR&gt;We test to see if we think an opened file will prevent it from being deleted, if so, we will hold on to the open file descriptor and use it as a filelock.  If not, and we started out deleting an existing db.lck file, we issue a warning message to the info stream that we are about to attached to a database which may already have another JBMS attached to it. Then we overwrite that db.lck file with our identity. &lt;BR&gt;Upon shutdown, we delete the db.lck file.  If the system crash instead of shutdown cleanly, it will be cleaned up the next time the system boots
 * @exception StandardException another JBMS is already attached to thedatabase at this directory
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuidFactory</ParamName>
                    <ParamType>UUIDFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>databaseDirectory</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privGetJBMSLockOnDB</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [fileLockExisted=false]</InnerVar>
                <InnerVar>String [blownUUID=null]</InnerVar>
                <InnerVar>StorageFile [fileLock=storageFactory.newStorageFile(DB_LOCKFILE_NAME)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseJBMSLockOnDB</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privReleaseJBMSLockOnDB</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logMsg</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>istream;println;[msg]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>databaseEncrypted</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDatabaseEncrypted</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isEncrypted</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encrypt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cleartext</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ciphertext</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outputOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newEngine</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrypt</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ciphertext</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cleartext</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outputOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decryptAllContainers</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EncryptOrDecryptData [containerDecrypter=new EncryptOrDecryptData(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerDecrypter;decryptAllContainers;[t]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>encryptAllContainers</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EncryptOrDecryptData [containerEncrypter=new EncryptOrDecryptData(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerEncrypter;encryptAllContainers;[t]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeOldVersionOfContainers</MethodName>
            <MethodComment>/** 
 * {@inheritDoc} 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>EncryptOrDecryptData [containerCryptoOp=new EncryptOrDecryptData(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerCryptoOp;removeOldVersionOfContainers;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>jarClassPath</MethodName>
            <MethodComment>/** 
 * Return a jar file by asking the class's  class loader for the location where the class was loaded from.  If no value, it returns null
 * @param cls the Class to ask to print the class name of an object
 * @return the ClassPath of a jar file
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cls</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CodeSource [cs=null]</InnerVar>
                <InnerVar>URL [result=cs.getLocation()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildOSinfo</MethodName>
            <MethodComment>/** 
 * Return values of system properties that identify the OS. Will catch SecurityExceptions and note them for displaying information.
 * @return the Java system property value for the OS or a string capturing asecurity exception.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [osInfo=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildJvmVersion</MethodName>
            <MethodComment>/** 
 * Return values of system properties that identify the JVM.  Will catch SecurityExceptions and note them for displaying information.
 * @return the Java system property value from the JVM or a string capturing asecurity exception.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [jvmversion=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEncryptionBlockSize</MethodName>
            <MethodComment>/** 
 * Returns the encryption block size used by the algorithm at time of creation of an encrypted database
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVersionedName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generationId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxContainerId</MethodName>
            <MethodComment>/** 
 * Return an id which can be used to create a container. &lt;p&gt; Return an id number with is greater than any existing container in the current database.  Caller will use this to allocate future container numbers - most likely caching the value and then incrementing it as it is used. &lt;p&gt;
 * @return The an id which can be used to create a container.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>random</MethodName>
            <MethodComment>/** 
 * return a secure random number 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fileToRemove</MethodName>
            <MethodComment>/** 
 * Add a file to the list of files to be removed post recovery.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>StorageFile</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remove</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [path=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postRecovery</MethodName>
            <MethodComment>/** 
 * Called after recovery is performed.
 * @exception StandardException Standard Derby Error Policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DaemonService [daemon=rawStoreFactory.getDaemon()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupCacheCleaner</MethodName>
            <MethodComment>/** 
 * Set up the cache cleaner for the container cache and the page cache.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>daemon</ParamName>
                    <ParamType>DaemonService</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>containerCache;useDaemonService;[daemon]</InnerMethodInvoke>
                <InnerMethodInvoke>pageCache;useDaemonService;[daemon]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>freezePersistentStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unfreezePersistentStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeInProgress</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeFinished</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>backupDataFiles</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rt</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>File</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [files=getContainerNames()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerNames</MethodName>
            <MethodComment>/** 
 * get all the names of the files in seg 0. MT - This method needs to be synchronized to avoid conflicts  with other privileged actions execution in this class.
 * @return An array of all the file names in seg0.
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreDataDirectory</MethodName>
            <MethodComment>/** 
 * removes the data directory(seg*) from database home directory and restores it from backup location. This function gets called only when any of the folling attributes are specified on connection URL: Attribute.CREATE_FROM (Create database from backup if it does not exist) Attribute.RESTORE_FROM (Delete the whole database if it exists and  then restore * it from backup) Attribute.ROLL_FORWARD_RECOVERY_FROM:(Perform Rollforward Recovery; except for the log directory everthing else is replced  by the copy  from backup. log files in the backup are copied to the existing online log  directory. In all the cases, data directory(seg*) is replaced by the data directory directory from backup when this function is called.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupPath</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>File [backupRoot=new java.io.File(backupPath)]</InnerVar>
                <InnerVar>String[] [bfilelist=AccessController.doPrivileged(new PrivilegedAction&lt;String[]&gt;(){
  public String[] run(){
    return backupRoot.list();
  }
}
)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>privRestoreDataDirectory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StorageFile [csegdir]</InnerVar>
                <InnerVar>StorageFile [dataRoot=storageFactory.newStorageFile(null)]</InnerVar>
                <InnerVar>String[] [cfilelist=dataRoot.list()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnly</MethodName>
            <MethodComment>/** 
 * Is the store read-only.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>luceneLoaded</MethodName>
            <MethodComment>/** 
 * Return true if the Lucene plugin is loaded 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StorageFactory [storageFactory=getStorageFactory()]</InnerVar>
                <InnerVar>StorageFile [luceneDir=storageFactory.newStorageFile(Database.LUCENE_DIR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStorageFactory</MethodName>
            <MethodComment>/** 
 * @return The StorageFactory used by this dataFactory
 */
</MethodComment>
            <ReturnType>StorageFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Privileged Monitor lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startSystemModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>