<Class>
    <Id>1708</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>XML</ClassName>
    <SuperClass>DataType</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>XMLDataValue</SuperInterface>
        <SuperInterface>StreamStorable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>XML  /** 
 * This type implements the XMLDataValue interface and thus is the type on which all XML related operations are executed. The first and simplest XML store implementation is a UTF-8 based one--all XML data is stored on disk as a UTF-8 string, just like the other Derby string types.  In order to make it possible for smarter XML implementations to exist in the future, this class always writes an "XML implementation id" to disk before writing the rest of its data.  When reading the data, the impl id is read first and serves as an indicator of how the rest of the data should be read. So long as there's only one implementation (UTF-8) the impl id can be ignored; but when smarter implementations are written, the impl id will be the key to figuring out how an XML value should be read, written, and processed.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>UTF8_IMPL_ID</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>BASE_MEMORY_USAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_PASS_BY_REF</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_PASS_BY_VALUE</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_RETURN_SEQUENCE</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_RETURN_CONTENT</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_EMPTY_ON_EMPTY</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XQ_NULL_ON_EMPTY</FieldName>
            <FieldType>short</FieldType>
        </Field>
        <Field>
            <FieldName>XML_DOC_ANY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XML_SEQUENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>xType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>xmlStringValue</FieldName>
            <FieldType>SQLChar</FieldType>
        </Field>
        <Field>
            <FieldName>xmlReqCheck</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>containsTopLevelAttr</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>tmpUtil</FieldName>
            <FieldType>SqlXmlUtil</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>XML</MethodName>
            <MethodComment>/** 
 * Default constructor.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>XML</MethodName>
            <MethodComment>/** 
 * Private constructor used for the  {@code cloneValue} method.Returns a new instance of XML whose fields are clones of the values received.
 * @param val A SQLChar instance to clone and use forthis XML value.
 * @param xmlType Qualified XML type for "val"
 * @param seqWithAttr Whether or not "val" corresponds tosequence with one or more top-level attribute nodes.
 * @param materialize whether or not to force materialization of theunderlying source data
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>SQLChar</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>xmlType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>seqWithAttr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>materialize</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setXType;[xmlType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneValue</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#cloneValue
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>forceMaterialization</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewNull</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#getNewNull
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeName</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#getTypeName
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typePrecedence</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#typePrecedence
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getString</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#getString
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLength</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#getLength
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>estimateMemoryUsage</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#estimateMemoryUsage
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [sz=BASE_MEMORY_USAGE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternalFromArray</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#readExternalFromArray
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ArrayInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>in;readShort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>xmlStringValue;readExternalFromArray;[in]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setXType;[XML_DOC_ANY]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFrom</MethodName>
            <MethodComment>/** 
 * @see DataType#setFrom
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>theValue</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [strVal=theValue.getString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xmlStringValue;setValue;[strVal]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setValueFromResultSet</MethodName>
            <MethodComment>/** 
 * @see DataValueDescriptor#setValueFromResultSet 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [valAsStr=resultSet.getString(colNumber)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * Compare two XML DataValueDescriptors.  NOTE: This method should only be used by the database store for the purpose of index positioning--comparisons of XML type are not allowed from the language side of things.  That said, all store wants to do is order the NULLs, so we don't actually have to do a full comparison.  Just return an order value based on whether or not this XML value and the other XML value are null.  As mentioned in the "compare" method of DataValueDescriptor, nulls are considered equal to other nulls and less than all other values. An example of when this method might be used is if the user executed a query like: select i from x_table where x_col is not null
 * @see DataValueDescriptor#compare
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalize</MethodName>
            <MethodComment>/** 
 * Normalization method - this method will always be called when storing an XML value into an XML column, for example, when inserting/updating.  We always force normalization in this case because we need to make sure the qualified type of the value we're trying to store is XML_DOC_ANY--we don't allow anything else.
 * @param desiredType   The type to normalize the source column to
 * @param source        The value to normalize
 * @exception StandardException Thrown if source is notXML_DOC_ANY.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>desiredType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>((DataValueDescriptor)this);setValue;[source]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * @see TypedFormat#getTypeFormatId From the engine's perspective, all XML implementations share the same format id.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNull</MethodName>
            <MethodComment>/** 
 * @see Storable#isNull
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreToNull</MethodName>
            <MethodComment>/** 
 * @see Storable#restoreToNull
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment>/** 
 * Read an XML value from an input stream.
 * @param in The stream from which we're reading.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>in;readShort;[]</InnerMethodInvoke>
                <InnerMethodInvoke>xmlStringValue;readExternal;[in]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setXType;[XML_DOC_ANY]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment>/** 
 * Write an XML value. 
 * @param out The stream to which we're writing.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeShort;[UTF8_IMPL_ID]</InnerMethodInvoke>
                <InnerMethodInvoke>xmlStringValue;writeExternal;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnStream</MethodName>
            <MethodComment>/** 
 * @see StreamStorable#returnStream
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setStream</MethodName>
            <MethodComment>/** 
 * @see StreamStorable#setStream
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xmlStringValue;setStream;[newStream]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setXType;[XML_DOC_ANY]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadStream</MethodName>
            <MethodComment>/** 
 * @see StreamStorable#loadStream
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getString;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>XMLParse</MethodName>
            <MethodComment>/** 
 * Method to parse an XML string and, if it's valid, store the _serialized_ version locally and then return this XMLDataValue.
 * @param stringValue The string value to check.
 * @param preserveWS Whether or not to preserveignorable whitespace.
 * @param sqlxUtil Contains SQL/XML objects and utilmethods that facilitate execution of XML-related operations
 * @return If 'text' constitutes a valid XML document,it has been stored in this XML value and this XML value is returned; otherwise, an exception is thrown. 
 * @exception StandardException Thrown on error.
 */
</MethodComment>
            <ReturnType>XMLDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stringValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preserveWS</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlxUtil</ParamName>
                    <ParamType>SqlXmlUtil</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [text=stringValue.getString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setXType;[XML_DOC_ANY]</InnerMethodInvoke>
                <InnerMethodInvoke>xmlStringValue;setValue;[text]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>XMLSerialize</MethodName>
            <MethodComment>/** 
 * The SQL/XML XMLSerialize operator. Serializes this XML value into a string with a user-specified character type, and returns that string via the received StringDataValue (if the received StringDataValue is non-null and of the correct type; else, a new StringDataValue is returned).
 * @param result The result of a previous call to this method,null if not called yet.
 * @param targetType The string type to which we want to serialize.
 * @param targetWidth The width of the target type.
 * @return A serialized (to string) version of this XML object,in the form of a StringDataValue object.
 * @exception StandardException    Thrown on error
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetCollationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;setValue;[getString()]</InnerMethodInvoke>
                <InnerMethodInvoke>result;setWidth;[targetWidth, 0, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>XMLExists</MethodName>
            <MethodComment>/** 
 * The SQL/XML XMLExists operator. Checks to see if evaluation of the query expression contained within the received util object against this XML value returns at least one item. NOTE: For now, the query expression must be XPath only (XQuery not supported) because that's what Xalan supports.
 * @param sqlxUtil Contains SQL/XML objects and utilmethods that facilitate execution of XML-related operations
 * @return True if evaluation of the query expression storedin sqlxUtil returns at least one node for this XML value; unknown if the xml value is NULL; false otherwise.
 * @exception StandardException Thrown on error
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlxUtil</ParamName>
                    <ParamType>SqlXmlUtil</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>XMLQuery</MethodName>
            <MethodComment>/** 
 * Evaluate the XML query expression contained within the received util object against this XML value and store the results into the received XMLDataValue "result" param (assuming "result" is non-null; else create a new XMLDataValue).
 * @param sqlxUtil Contains SQL/XML objects and util methods thatfacilitate execution of XML-related operations
 * @param result The result of a previous call to this method; nullif not called yet.
 * @return An XMLDataValue whose content corresponds to the serializedversion of the results from evaluation of the query expression. Note: this XMLDataValue may not be storable into Derby XML columns.
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>XMLDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlxUtil</ParamName>
                    <ParamType>SqlXmlUtil</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>XMLDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setXType</MethodName>
            <MethodComment>/** 
 * Set this XML value's qualified type.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xtype</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXType</MethodName>
            <MethodComment>/** 
 * Retrieve this XML value's qualified type.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsHavingTopLevelAttr</MethodName>
            <MethodComment>/** 
 * Take note of the fact this XML value represents an XML sequence that has one or more top-level attribute nodes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasTopLevelAttr</MethodName>
            <MethodComment>/** 
 * Return whether or not this XML value represents a sequence that has one or more top-level attribute nodes.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkXMLRequirements</MethodName>
            <MethodComment>/** 
 * See if the required JAXP and Xalan classes are in the user's classpath.  Assumption is that we will always call this method before instantiating an instance of SqlXmlUtil, and thus we will never get a ClassNotFound exception caused by missing JAXP/Xalan classes.  Instead, if either is missing we should throw an informative error indicating what the problem is. NOTE: This method only does the checks necessary to allow successful instantiation of the SqlXmlUtil class.  Further checks (esp. the presence of a JAXP _implementation_ in addition to the JAXP _interfaces_) are performed in the SqlXmlUtil constructor.
 * @exception StandardException thrown if the requiredclasses cannot be located in the classpath.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkJAXPRequirement</MethodName>
            <MethodComment>/** 
 * Check if we have a JAXP implementation installed.
 * @return {@code true} if JAXP is installed, or {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkXPathRequirement</MethodName>
            <MethodComment>/** 
 * Check if XPath is supported on this platform.
 * @return {@code true} if XPath is supported, or {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>