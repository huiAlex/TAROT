<Class>
    <Id>731</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>FromList</ClassName>
    <SuperClass>QueryTreeNodeVector</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>OptimizableList</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FromList  /** 
 * A FromList represents the list of tables in a FROM clause in a DML statement.  It extends QueryTreeNodeVector.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>properties</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>fixedJoinOrder</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>useStatistics</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>referencesSessionSchema</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isTransparent</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>windows</FieldName>
            <FieldType>WindowList</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FromList</MethodName>
            <MethodComment>/** 
 * Does not change the default for join order optimization, i.e. {@code false}.
 * @param cm context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FromList</MethodName>
            <MethodComment>/** 
 * Constructor for a FromList
 * @param optimizeJoinOrder {@code true} if join order optimization is tobe performed
 * @param cm                context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizeJoinOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[optimizeJoinOrder]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FromList</MethodName>
            <MethodComment>/** 
 * Constructor for a FromList
 * @param optimizeJoinOrder {@code true} if join order optimization is tobe performed
 * @param fromTable         initialize list with this table
 * @param cm                context manager
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizeJoinOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[optimizeJoinOrder]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addFromTable;[fromTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constructorMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizeJoinOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizable</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizableList#getOptimizable
 */
</MethodComment>
            <ReturnType>Optimizable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOptimizable</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.sql.compile.OptimizableList#setOptimizable
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setElementAt;[(FromTable)optimizable, index]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyProperties</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#verifyProperties
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addFromTable</MethodName>
            <MethodComment>/** 
 * Add a table to the FROM list.
 * @param fromTable	A FromTable to add to the list
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [leftTable]</InnerVar>
                <InnerVar>TableName [rightTable]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addElement;[fromTable]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesTarget</MethodName>
            <MethodComment>/** 
 * Search to see if a query references the specifed table name.
 * @param name		Table name (String) to search for.
 * @param baseTable	Whether or not name is for a base table
 * @return	true if found, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>boolean [found=false]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>boolean [found=false]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromTableByName</MethodName>
            <MethodComment>/** 
 * Determine whether or not the specified name is an exposed name in the current query block.
 * @param name	The specified name to search for as an exposed name.
 * @param schemaName	Schema name, if non-null.
 * @param exactMatch	Whether or not we need an exact match on specified schema and tablenames or match on table id.
 * @return The FromTable, if any, with the exposed name.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exactMatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>FromTable [result=null]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isJoinColumnForRightOuterJoin</MethodName>
            <MethodComment>/** 
 * Go through the list of the tables and see if the passed ResultColumn is a join column for a right outer join with USING/NATURAL clause.
 * @see HalfOuterJoinNode#isJoinColumnForRightOuterJoin
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindTables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [wasSkippingTypePrivileges=getCompilerContext().skipTypePrivileges(true)]</InnerVar>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;pushCurrentPrivType;[Authorizer.MIN_SELECT_PRIV]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;popCurrentPrivType;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();skipTypePrivileges;[wasSkippingTypePrivileges]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressions</MethodName>
            <MethodComment>/** 
 * Bind the expressions in this FromList.  This means  binding the sub-expressions, as well as figuring out what the return  type is for each expression.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumns</MethodName>
            <MethodComment>/** 
 * Bind the result columns of the ResultSetNodes in this FromList when there is no base table to bind them to.  This is useful for SELECT statements, where the result columns get their types from the expressions that live under them.
 * @param fromListParam		FromList to use/append to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [origList=fromListParam.size()]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>expandAll</MethodName>
            <MethodComment>/** 
 * Expand a "*" into the appropriate ResultColumnList. If the "*" is unqualified it will expand into a list of all columns in all of the base tables in the from list at the current nesting level; otherwise it will expand into a list of all of the columns in the base table that matches the qualification. NOTE: Callers are responsible for ordering the FromList by nesting level, with tables at the deepest (current) nesting level first.   We will expand the "*" into a list of all columns from all tables having the same nesting level as the first FromTable in this list. The check for nesting level exists because it's possible that this FromList includes FromTables from an outer query, which can happen if there is a "transparent" FromList above this one in the query tree.  Ex: select j from onerow where exists (select 1 from somerow union select * from diffrow where onerow.j &amp;lt; diffrow.k) If "this" is the FromList for the right child of the UNION then it will contain both "diffrow" and "onerow", the latter of which was passed down via a transparent FromList (to allow binding of the WHERE clause). In that case the "*" should only expand the result columns of "diffrow"; it should not expand the result columns of "onerow" because that table is from an outer query.  We can achieve this selective expansion by looking at nesting levels.
 * @param allTableName		The qualification on the "*" as a String.
 * @return ResultColumnList representing expansion
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [resultColumnList=null]</InnerVar>
                <InnerVar>ResultColumnList [tempRCList]</InnerVar>
                <InnerVar>boolean [matchfound=false]</InnerVar>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [targetNestingLevel=((FromTable)elementAt(0)).getLevel()]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindColumnReference</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Bind a column reference to one of the tables in this FromList.  The column name must be unique within the tables in the FromList.  An exception is thrown if a column name is not unique. This method fills in various fields in the column reference. &lt;/p&gt; &lt;p&gt; NOTE: Callers are responsible for ordering the FromList by nesting level, with tables at the deepest (current) nesting level first.  We will try to  match against all FromTables at a given nesting level.  If no match is found at a nesting level, then we proceed to the next level.  We stop walking the list when the nesting level changes and we have found a match. &lt;/p&gt; &lt;p&gt; NOTE: If the ColumnReference is qualified, then we will stop the search at the first nesting level where there is a match on the exposed table name. For example, &lt;p&gt; &lt;pre&gt; s (a, b, c), t (d, e, f) select * from s where exists (select * from t s where s.c = a) &lt;/pre&gt; &lt;p&gt; will not find a match for s.c, which is the expected ANSI behavior. &lt;/p&gt; &lt;p&gt; bindTables() must have already been called on this FromList before calling this method. &lt;/p&gt;
 * @param columnReference	The ColumnReference describing the column to bind
 * @return ResultColumn     The matching ResultColumn, or {@code null} ifthere is no matching column
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnReference</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [columnNameMatch=false]</InnerVar>
                <InnerVar>boolean [tableNameMatch=false]</InnerVar>
                <InnerVar>FromTable [fromTable=null]</InnerVar>
                <InnerVar>FromTable [matchingTable=null]</InnerVar>
                <InnerVar>int [currentLevel]</InnerVar>
                <InnerVar>int [previousLevel=-1]</InnerVar>
                <InnerVar>ResultColumn [matchingRC=null]</InnerVar>
                <InnerVar>ResultColumn [resultColumn]</InnerVar>
                <InnerVar>String [crTableName=columnReference.getTableName()]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rejectParameters</MethodName>
            <MethodComment>/** 
 * Check for (and reject) all ? parameters directly under the ResultColumns. This is done for SELECT statements.
 * @exception StandardException		Thrown if a ? parameter founddirectly under a ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>FromTable [fromTable]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LOJ_reorderable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [anyChange=false]</InnerVar>
                <InnerVar>FromTable [ft=(FromTable)elementAt(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess the query tree - this currently means: o  Generating a referenced table map for each ResultSetNode. o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF). o  Converting the WHERE and HAVING clauses into PredicateLists and classifying them. o  Flatten those FromSubqueries which can be flattened. o  Ensuring that a ProjectRestrictNode is generated on top of every  FromBaseTable and generated in place of every FromSubquery which could not be flattened.   o  Pushing single table predicates down to the new ProjectRestrictNodes.
 * @param numTables			The number of tables in the DML Statement
 * @param gbl				The group by list, if any
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicateTree</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flattenFromTables</MethodName>
            <MethodComment>/** 
 * Flatten all the FromTables that are flattenable. RESOLVE - right now we just flatten FromSubqueries.  We should also flatten flattenable JoinNodes here.
 * @param rcl				The RCL from the outer query
 * @param predicateList		The PredicateList from the outer query
 * @param sql				The SubqueryList from the outer query
 * @param gbl				The group by list, if any
 * @param havingClause      The HAVING clause, if any
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>havingClause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [flattened=true]</InnerVar>
                <InnerVar>ArrayList&lt;Integer&gt; [flattenedTableNumbers=new ArrayList&lt;Integer&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushPredicates</MethodName>
            <MethodComment>/** 
 * Categorize and push the predicates that are pushable.
 * @param predicateList		The query's PredicateList
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>predicateList;categorize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLevel</MethodName>
            <MethodComment>/** 
 * Set the (query block) level (0-based) for the FromTables in this FromList.
 * @param level		The query block level for this table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromTableByResultColumn</MethodName>
            <MethodComment>/** 
 * Get the FromTable from this list which has the specified ResultColumn in its RCL.
 * @param rc	The ResultColumn match on.
 * @return FromTable	The matching FromTable.
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromTable [fromTable=null]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setProperties</MethodName>
            <MethodComment>/** 
 * Set the Properties list for this FromList.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>props</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Enumeration&lt;?&gt; [e=properties.keys()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reOrder</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#reOrder 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>joinOrder</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [posn]</InnerVar>
                <InnerVar>ResultSetNode[] [orderedFL=new FromTable[joinOrder.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>useStatistics</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#useStatistics 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeJoinOrder</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#optimizeJoinOrder 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>legalJoinOrder</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#legalJoinOrder 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTablesInQuery</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JBitSet [assignedTableMap=new JBitSet(numTablesInQuery)]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initAccessPaths</MethodName>
            <MethodComment>/** 
 * @see OptimizableList#initAccessPaths 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizer</ParamName>
                    <ParamType>Optimizer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUntypedNullsToResultColumns</MethodName>
            <MethodComment>/** 
 * Bind any untyped null nodes to the types in the given ResultColumnList.
 * @param bindingRCL	The ResultColumnList with the types to bind to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bindingRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementLevel</MethodName>
            <MethodComment>/** 
 * Decrement (query block) level (0-based) for all of the tables in this from list. This is useful when flattening a subquery.
 * @param decrement	The amount to decrement by.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>decrement</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnsAtMostSingleRow</MethodName>
            <MethodComment>/** 
 * This method is used for both subquery flattening and distinct elimination based on a uniqueness condition.  For subquery flattening we want to make sure that the query block will return at most 1 row.  For distinct elimination we want to make sure that the query block will not return any duplicates. This is true if every table in the from list is (a base table and the set of columns from the table that are in equality comparisons with expressions that do not include columns from the same table is a superset of any unique index on the table) or an EXISTS FBT.  In addition, at least 1 of the tables in the list has a set of columns in equality comparisons with expressions that do not include column references from the same query block is a superset of a unique index on that table.  (This ensures that the query block will onlyr return a single row.) This method is expected to be called after normalization and after the from list has been preprocessed. It can be called both before and after the predicates have been pulled from the where clause. The algorithm for this is as follows If any table in the query block is not a base table, give up. For each table in the query Ignore exists table since they can only produce one row create a matrix of tables and columns from the table (tableColMap) (this is used to keep track of the join columns and constants that can be used to figure out whether the rows from a join or in a select list are distinct based on unique indexes) create an array of columns from the table(eqOuterCol) (this is used to determine that only one row will be returned from a join) if the current table is the table for the result columns set the result columns in the eqOuterCol and tableColMap (if these columns are a superset of a unique index and all joining tables result in only one row, the results will be distinct) go through all the predicates and update tableColMap  and eqOuterCol with join columns and correlation variables, parameters and constants since setting constants, correlation variables and parameters, reduces the number of columns required for uniqueness in a multi-column index, they are set for all the tables (if the table is not the result table, in this case only the column of the result table is set) join columns are just updated for the column in the row of the joining table. check if the marked columns in tableColMap are a superset of a unique index (This means that the join will only produce 1 row when joined with 1 row of another table) check that there is a least one table for which the columns in eqOuterCol(i.e. constant values) are a superset of a unique index (This quarantees that there will be only one row selected from this table). Once all tables have been evaluated, check that all the tables can be joined by unique index or will have only one row
 * @param rcl				If non-null, the RCL from the query block.If non-null for subqueries, then entry can be considered as part of an = comparison.
 * @param whereClause		The WHERE clause to consider.
 * @param wherePredicates	The predicates that have already beenpulled from the WHERE clause.
 * @param dd				The DataDictionary to use.
 * @return	Whether or not query block will returnat most 1 row for a subquery, no duplicates for a distinct.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whereClause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wherePredicates</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [satisfiesOuter=false]</InnerVar>
                <InnerVar>int[] [tableNumbers]</InnerVar>
                <InnerVar>ColumnReference [additionalCR=null]</InnerVar>
                <InnerVar>PredicateList [predicatesTemp]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
                <InnerVar>JBitSet[][] [tableColMap=new JBitSet[size][size]]</InnerVar>
                <InnerVar>boolean[] [oneRow=new boolean[size]]</InnerVar>
                <InnerVar>boolean [oneRowResult]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableNumbers</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
                <InnerVar>int[] [tableNumbers=new int[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genExistsBaseTables</MethodName>
            <MethodComment>/** 
 * Mark all of the FromBaseTables in the list as EXISTS FBTs. Each EBT has the same dependency list - those tables that are referenced minus the tables in the from list.
 * @param referencedTableMap	The referenced table map.
 * @param outerFromList			FromList from outer query block
 * @param isNotExists			Whether or not for NOT EXISTS
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNotExists</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JBitSet [dependencyMap=(JBitSet)referencedTableMap.clone()]</InnerVar>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tableNumberIsNotExists</MethodName>
            <MethodComment>/** 
 * determine whether this table is NOT EXISTS. This routine searches for the indicated table number in the fromlist and returns TRUE if the table is present in the from list and is  marked NOT EXISTS, false otherwise. A table may be present in the from list for NOT EXISTS if it is used as a correlated NOT EXISTS subquery. In such a situation, when the subquery is flattened, it is important that we remember that this is a NOT EXISTS subquery, because the join semantics are different  (we're looking for rows that do NOT match, rather than rows that do). And since the join semantics are different, we cannot include this table into a transitive closure of equijoins (See DERBY-3033 for a situation where this occurs).
 * @param tableNumber	which table to check
 * @return true if this table is in the from list as NOT EXISTS
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateTargetLockMode</MethodName>
            <MethodComment>/** 
 * Get the lock mode for the target of an update statement (a delete or update).  The update mode will always be row for CurrentOfNodes.  It will be table if there is no where clause.
 * @return	The lock mode
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashJoinSpecified</MethodName>
            <MethodComment>/** 
 * Return whether or not the user specified a hash join for any of the  tables in this list.
 * @return	Whether or not the user specified a hash join for any of the tables in this list.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsTransparent</MethodName>
            <MethodComment>/** 
 * Indicate that this FromList is "transparent", which means that its FromTables should be bound to tables from an outer query. Generally this is not allowed, but there are exceptions.  See SetOperatorNode.setResultToBooleanTrueNode() for more.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setWindows</MethodName>
            <MethodComment>/** 
 * Set windows field to the supplied value.
 * @param windows list of window definitions associated with a SELECT.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>windows</ParamName>
                    <ParamType>WindowList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWindows</MethodName>
            <MethodComment>/** 
 * @return list of window definitions associated with a SELECT.
 */
</MethodComment>
            <ReturnType>WindowList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>