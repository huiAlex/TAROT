<Class>
    <Id>1109</Id>
    <Package>org.apache.derby.iapi.util</Package>
    <ClassName>IdUtil</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>IdUtil  /** 
 * Utility class for parsing and producing string representations of ids. This class supports both delimited and un-delimited ids. &lt;P&gt;The syntax for an id follows.  &lt;PRE&gt; id := delim-id | unDelim-id delim-id := "[""|[any char but quote]]+" undelim-id := (a-z|A-Z|anyunicodeletter)[a-z|A-Z|_|0-9|anyunicodeletter|anyunicodedigit] In the syntax braces show grouping. '*' means repeat 0 or more times. '|' means or. '+' means repeat 1 or more times.  &lt;/PRE&gt; &lt;P&gt;In addition this class provides support for qualified names. A qualified name is a dot (.) separated list of ids. &lt;P&gt;Limitations: &lt;OL&gt; &lt;LI&gt;Unicode escape sequences in ids are not supported. &lt;LI&gt;Escape sequences (\n...) are not supported. &lt;/OL&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>DBCP_SCHEMA_NAME</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DBCP_SQL_JAR_NAME</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>normalToDelimited</MethodName>
            <MethodComment>/** 
 * Produce a delimited form of a normal value.
 * @return the delimited identifier.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mkQualifiedName</MethodName>
            <MethodComment>/** 
 * Produce a delimited two part qualified name from two un-delimited identifiers.
 * @return the result.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>id2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mkQualifiedName</MethodName>
            <MethodComment>/** 
 * Make a string form of a qualified name from the array of ids provided.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ids</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseMultiPartSQLIdentifier</MethodName>
            <MethodComment>/** 
 * Parse a multi-part (dot separated) SQL identifier form the String provided. Raise an excepion if the string does not contain valid SQL indentifiers. The returned String array contains the normalized form of the identifiers.
 * @param s The string to be parsed
 * @return An array of strings made by breaking the input string at its dots, '.'.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringReader [r=new StringReader(s)]</InnerVar>
                <InnerVar>String[] [qName=parseMultiPartSQLIdentifier(r)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyEmpty;[r]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseMultiPartSQLIdentifier</MethodName>
            <MethodComment>/** 
 * @param r The multi-part identifier to be parsed
 * @return An array of strings made by breaking the input string at its dots, '.'.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>StringReader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
                <InnerVar>String[] [result=new String[v.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>v;copyInto;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSQLIdentifier</MethodName>
            <MethodComment>/** 
 * Parse a SQL identifier from the String provided. Raise an excepion if the string does not contain a valid SQL indentifier. The returned String  contains the normalized form of the identifier.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringReader [r=new StringReader(s)]</InnerVar>
                <InnerVar>String [id=parseId(r,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyEmpty;[r]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseId</MethodName>
            <MethodComment>/** 
 * Read an id from the StringReader provided.
 * @param normalize true means return ids in nomral form, false meansreturn them as they were entered. &lt;P&gt; Raise an exception if the first thing in the StringReader is not a valid id.
 * @exception StandardException Ooops.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>StringReader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>normalize</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLIdentifier2CanonicalPropertyUsername</MethodName>
            <MethodComment>/** 
 * Given a case normal form SQL authorization identifier, convert it to a form that may be compared with the username of Derby builtin authentication, which uses Java properties of the form {@code derby.user.}&amp;lt;username&amp;gt;. &lt;p&gt; The returned form is suitable for comparing against the property string, cf.   {@code systemPropertiesExistsBuiltinUser}. &lt;p&gt; E.g.: &lt;p&gt; &lt;pre&gt; Argument -&amp;gt; Return ------------------ EVE      -&amp;gt; eve       [will match Java property: derby.user.eve] eVe      -&amp;gt; "eVe"     [will match Java property: derby.user."eVe"] "eve"    -&amp;gt; """eve""" [will match Java property: derby.user."""eVe"""] \eve\    -&amp;gt; "\eve\"   [will match Java property: derby.user."\eve\"] The latter could look this if specified on a Unix shell command line: -Dderby.user.'"\eve\"'=&amp;lt;password&amp;gt; Note: The processing of properties specified on the command line do not interpret backslash as escape in the way done by the java.util.Properties#load method, so no extra backslash is needed above. &lt;/pre&gt; Since parseSQLIdentifier maps many-to-one, the backward mapping is non-unique, so the chosen lower case canonical form is arbitrary, e.g. we will not be able to correctly match the non-canonical: &lt;p&gt; &lt;pre&gt; [Java property: derby.user.eVe] &lt;/pre&gt; since this is internally EVE (but see DERBY-3150), and maps back as eve after the rules above.
 * @see org.apache.derby.iapi.services.property.PropertyUtil#propertiesContainsBuiltinUser
 * @see org.apache.derby.iapi.services.property.PropertyUtil#systemPropertiesExistsBuiltinUser
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>authid</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [needsQuote=false]</InnerVar>
                <InnerVar>String [result]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseUnQId</MethodName>
            <MethodComment>/** 
 * Parse a regular identifier (unquoted) returning returning either the value of the identifier or a delimited identifier. Ensures that all characters in the identifer are valid for a regular identifier.
 * @param r Regular identifier to parse.
 * @param normalize If true return the identifer converted to a single case, otherwise return the identifier as entered.
 * @return the value of the identifer or a delimited identifier
 * @throws IOException Error accessing value
 * @throws StandardException Error parsing identifier.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>StringReader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>normalize</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [b=new StringBuffer()]</InnerVar>
                <InnerVar>int [c]</InnerVar>
                <InnerVar>boolean [first]</InnerVar>
                <InnerVar>String [id=b.toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>idChar</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseQId</MethodName>
            <MethodComment>/** 
 * Parse a delimited (quoted) identifier returning either the value of the identifier or a delimited identifier.
 * @param r Quoted identifier to parse.
 * @param normalize If true return a delimited identifer, otherwise return the identifier's value.
 * @return the value of the identifer or a delimited identifier
 * @throws IOException Error accessing value
 * @throws StandardException Error parsing identifier.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>StringReader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>normalize</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [b=new StringBuffer()]</InnerVar>
                <InnerVar>int [c=r.read()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyEmpty</MethodName>
            <MethodComment>/** 
 * Verify the read is empty (no more characters in its stream).
 * @param r
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>java.io.Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDbClassPath</MethodName>
            <MethodComment>/** 
 * Scan a database classpath from the string provided. This returns an array with one qualified name per entry on the classpath. The constants above describe the content of the returned names. This  raises an an exception if the string does not contain a valid database  class path. &lt;PRE&gt; classpath := item[:item] item := id.id In the syntax braces ([]) show grouping. '*' means repeat 0 or more times. The syntax for id is defined in IdUtil. &lt;/PRE&gt; &lt;BR&gt; Classpath returned is a two part name.	  &lt;BR&gt; If the class path is empty then this returns an array of zero length.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String[][]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Vector&lt;String[]&gt; [v=new Vector&lt;String[]&gt;()]</InnerVar>
                <InnerVar>java.io.StringReader [r=new java.io.StringReader(input)]</InnerVar>
                <InnerVar>String[][] [result=new String[v.size()][]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>v;copyInto;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseIdList</MethodName>
            <MethodComment>/** 
 * Scan a list of comma separated SQL identifiers from the string provided. This returns an array with containing the normalized forms of the identifiers. This raises an an exception if the string does not contain a valid list of names.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringReader [r=new StringReader(p)]</InnerVar>
                <InnerVar>String[] [result=parseIdList(r,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyEmpty;[r]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseIdList</MethodName>
            <MethodComment>/** 
 * Parse a list of comma separated SQL identifiers returning them a as elements in an array.
 * @param normalize true means return ids in nomral form, false meansreturn them as they were entered.
 * @exception StandardException Oops
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>r</ParamName>
                    <ParamType>StringReader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>normalize</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
                <InnerVar>String[] [result=new String[v.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>v;copyInto;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>intersect</MethodName>
            <MethodComment>/** 
 * Return an IdList with all the ids that in l1 and l2 or null if not ids are on both lists.
 * @param l1 An array of ids in normal form
 * @param l2 An array of ids in nomral form
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>l1</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>l2</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashSet&lt;String&gt; [h=new HashSet&lt;String&gt;()]</InnerVar>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>vectorToIdList</MethodName>
            <MethodComment>/** 
 * Return an idList in external form with one id for every  element of v. If v has no elements, return null.
 * @param normal True means the ids in v are in normal formand false means they are in external form.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>normal</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [a=new String[v.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>v;copyInto;[a]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserAuthorizationId</MethodName>
            <MethodComment>/** 
 * Map userName to authorizationId in its normal form.
 * @exception StandardException on error or userName is null
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserNameFromURLProps</MethodName>
            <MethodComment>/** 
 * Get user name from URL properties (key user) without any transformation. If the user property does not exist or is set to the empty string then Property.DEFAULT_USER_NAME is returned.
 * @see Property#DEFAULT_USER_NAME
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [userName=params.getProperty(Attribute.USERNAME_ATTR,Property.DEFAULT_USER_NAME)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dups</MethodName>
            <MethodComment>/** 
 * Return an IdList with all the ids that are repeated in l.
 * @param l a list of ids in normal form.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>l</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashSet&lt;String&gt; [h=new HashSet&lt;String&gt;()]</InnerVar>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pruneDups</MethodName>
            <MethodComment>/** 
 * Return an IdList with all the duplicate ids removed
 * @param l a list of ids in external form.
 * @exception StandardException Oops.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>l</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [normal_a=parseIdList(l)]</InnerVar>
                <InnerVar>StringReader [r=new StringReader(l)]</InnerVar>
                <InnerVar>String[] [external_a=parseIdList(r,false)]</InnerVar>
                <InnerVar>HashSet&lt;String&gt; [h=new HashSet&lt;String&gt;()]</InnerVar>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mkIdList</MethodName>
            <MethodComment>/** 
 * Produce a string form of an idList from an array of normalized ids.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ids</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mkIdListAsEntered</MethodName>
            <MethodComment>/** 
 * Produce an id list from an array of ids in external form
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>externalIds</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>idOnList</MethodName>
            <MethodComment>/** 
 * Return true if the normalized value of an indentifier is on the list  of SQL identifiers provided.
 * @param id an id in normal form
 * @param list a list of ids in external form.
 * @exception StandardException oops.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [list_a=parseIdList(list)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteId</MethodName>
            <MethodComment>/** 
 * Delete an normal value from a list of SQL identifiers. The returned list maintains its remaining identifiers in the format they were upon entry to the call.
 * @param id an id in normal form (quotes removed, upshifted if regular)
 * @param list a comma separated list of ids in externalform (possibly delmited or not upshifted).
 * @return the list with the id deleted or null if theresulting list has no ids. If 'id' is not on 'list' this returns list unchanged. If list becomes empty after the removal null is returned.
 * @exception StandardException oops.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Vector&lt;String&gt; [v=new Vector&lt;String&gt;()]</InnerVar>
                <InnerVar>StringReader [r=new StringReader(list)]</InnerVar>
                <InnerVar>String[] [enteredList_a=parseIdList(r,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendNormalToList</MethodName>
            <MethodComment>/** 
 * Append an identifier to a comma separated list of identifiers. The passed in identifier is its normal form, the list contains a list of SQL identifiers, either regular or delimited. This routine takes the easy way out and always appends a delimited identifier.
 * @return the list with the id appended in its delimited form. 
 * @exception StandardException oops
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [delimitedId=normalToDelimited(id)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseRoleId</MethodName>
            <MethodComment>/** 
 * Parse role identifier to internal, case normal form. It should not be NONE nor exceed Limits.MAX_IDENTIFIER_LENGTH.
 * @param roleName role identifier to check (SQL form, has possible quoting)
 * @return the role name to use (internal, case normal form).
 * @exception StandardException normal error policy
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>roleName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkIdentifierLengthLimit;[roleName, Limits.MAX_IDENTIFIER_LENGTH]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIdentifierLengthLimit</MethodName>
            <MethodComment>/** 
 * Check that identifier is not too long
 * @param identifier identifier (in case normal form) to check
 * @param identifier_length_limit maximum legal length
 * @exception StandardException normal error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identifier</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>identifier_length_limit</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>