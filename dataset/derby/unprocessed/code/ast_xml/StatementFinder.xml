<Class>
    <Id>806</Id>
    <Package>org.apache.derby.impl.tools.ij</Package>
    <ClassName>StatementFinder</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StatementFinder  /** 
 * StatementGrabber looks through an input stream for the next JSQL statement.  A statement is considered to be any tokens up to the next semicolon or EOF. &lt;p&gt; Semicolons inside comments, strings, and delimited identifiers are not considered to be statement terminators but to be part of those tokens. &lt;p&gt; Comments currently recognized include the SQL comment, which begins with "--" and ends at the next EOL, and nested bracketed comments. &lt;p&gt; Strings and delimited identifiers are permitted to contain newlines; the actual IJ or JSQL parsers will report errors when those cases occur. &lt;p&gt; There are no escaped characters, i.e. "\n" is considered to be two characters, '\' and 'n'.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>source</FieldName>
            <FieldType>Reader</FieldType>
        </Field>
        <Field>
            <FieldName>statement</FieldName>
            <FieldType>StringBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>state</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>atEOF</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>peekEOF</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>peekChar</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>peeked</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>promptwriter</FieldName>
            <FieldType>LocalizedOutput</FieldType>
        </Field>
        <Field>
            <FieldName>doPrompt</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>continuedStatement</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>IN_STATEMENT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>IN_STRING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>IN_SQLCOMMENT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>END_OF_STATEMENT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>END_OF_INPUT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MINUS</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SINGLEQUOTE</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLEQUOTE</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SEMICOLON</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>NEWLINE</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>RETURN</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SPACE</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>TAB</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>FORMFEED</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SLASH</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>ASTERISK</FieldName>
            <FieldType>char</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>StatementFinder</MethodName>
            <MethodComment>/** 
 * The constructor does not assume the stream is data input or buffered, so it will wrap it appropriately. If the StatementFinder's input stream is connected to System.in, a LocalizedOutput stream may be given to print line continuation prompts when StatementFinder reads a newline.
 * @param s the input stream for reading statements from.
 * @param promptDest LocalizedOutput stream to write linecontinuation prompts ("&amp;gt; ") to. If null, no such prompts will be written.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>LocalizedInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>promptDest</ParamName>
                    <ParamType>LocalizedOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ReInit</MethodName>
            <MethodComment>/** 
 * Reinit is used to redirect the finder to another stream. The previous stream should not have been in a PEEK state. If an output stream was given when constructing this  StatementFinder and the input is standard input,  continuation prompting will be enabled.
 * @param s the input stream for reading statements from.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>LocalizedInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextStatement</MethodName>
            <MethodComment>/** 
 * get the next statement in the input stream. Returns it, dropping its closing semicolon if it has one. If there is no next statement, return a null.
 * @return the next statement in the input stream.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [haveSemi=false]</InnerVar>
                <InnerVar>char [nextChar]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>statement;setLength;[0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>whiteSpace</MethodName>
            <MethodComment>/** 
 * Determine if the given character is considered whitespace
 * @param c the character to consider
 * @return true if the character is whitespace
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readBracketedComment</MethodName>
            <MethodComment>/** 
 * Advance the source stream to the end of a comment if it is on one, assuming the first character of a potential bracketed comment has been found. If it is not a comment, do not advance the stream.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>char [nextChar=peekChar()]</InnerVar>
                <InnerVar>int [nestingLevel=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;readChar;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readSingleLineComment</MethodName>
            <MethodComment>/** 
 * Advance the source stream to the end of a comment if it is on one, assuming the first character of a potential single line comment has been found. If it is not a comment, do not advance the stream. &lt;p&gt; The form of a single line comment is, in regexp, XX.*$, where XX is two instances of commentChar.
 * @param commentChar the character whose duplication signifiesthe start of the comment.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>commentChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char [nextChar]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;readChar;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readString</MethodName>
            <MethodComment>/** 
 * Advance the stream to the end of the string. Assumes the opening delimiter of the string has been read. This handles the SQL ability to put the delimiter within the string by doubling it, by reading those as two strings sitting next to one another.  I.e, 'Mary''s lamb' is read by this class as two strings, 'Mary' and 's lamb'. &lt;p&gt; The delimiter of the string is expected to be repeated at its other end. If the other flavor of delimiter occurs within the string, it is just a normal character within it. &lt;p&gt; All characters except the delimiter are permitted within the string. If EOF is hit before the closing delimiter is found, the end of the string is assumed. Parsers using this parser will detect the error in that case and return appropriate messages.
 * @param stringDelimiter the starting and ending characterfor the string being read.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stringDelimiter</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>atEOF</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekEOF</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readChar</MethodName>
            <MethodComment>/** 
 * return the next character in the source stream and append it to the statement buffer.
 * @return the next character in the source stream.
 */
</MethodComment>
            <ReturnType>char</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>peekChar</MethodName>
            <MethodComment>/** 
 * return the next character in the source stream, without advancing.
 * @return the next character in the source stream.
 */
</MethodComment>
            <ReturnType>char</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>char [c='\00']</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>