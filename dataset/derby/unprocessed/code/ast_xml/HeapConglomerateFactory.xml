<Class>
    <Id>1930</Id>
    <Package>org.apache.derby.impl.store.access.heap</Package>
    <ClassName>HeapConglomerateFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ConglomerateFactory</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
        <SuperInterface>ModuleSupportable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>HeapConglomerateFactory  /** 
 * The heap conglomerate factory manages heap conglomerates implemented on the raw store.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>IMPLEMENTATIONID</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>FORMATUUIDSTRING</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>formatUUID</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>defaultProperties</MethodName>
            <MethodComment>/** 
 * Return the default properties for this kind of conglomerate.
 * @see MethodFactory#defaultProperties
 */
</MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsImplementation</MethodName>
            <MethodComment>/** 
 * Return whether this access method implements the implementation type given in the argument string. The heap only has one implementation type, "heap".
 * @see MethodFactory#supportsImplementation
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>implementationId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>primaryImplementationType</MethodName>
            <MethodComment>/** 
 * Return the primary implementation type for this access method. The heap only has one implementation type, "heap".
 * @see MethodFactory#primaryImplementationType
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsFormat</MethodName>
            <MethodComment>/** 
 * Return whether this access method supports the format supplied in the argument. The heap currently only supports one format, HEAPFORMAT1.
 * @see MethodFactory#supportsFormat
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>primaryFormat</MethodName>
            <MethodComment>/** 
 * Return the primary format that this access method supports. The heap currently only supports one format, HEAPFORMAT1.
 * @see MethodFactory#primaryFormat
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerateFactoryId</MethodName>
            <MethodComment>/** 
 * Return the conglomerate factory id. &lt;p&gt; Return a number in the range of 0-15 which identifies this factory. Code which names conglomerates depends on this range currently, but could be easily changed to handle larger ranges.   One hex digit seemed reasonable for the number of conglomerate types being currently  considered (heap, btree, gist, gist btree, gist rtree, hash, others? ). &lt;p&gt;
 * @see ConglomerateFactory#getConglomerateFactoryId
 * @return an unique identifier used to the factory into the conglomid.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConglomerate</MethodName>
            <MethodComment>/** 
 * Create the conglomerate and return a conglomerate object for it.
 * @exception StandardException Standard exception policy.
 * @see ConglomerateFactory#createConglomerate
 */
</MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_mgr</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_containerid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrder</ParamName>
                    <ParamType>ColumnOrdering[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>temporaryFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Heap [heap=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heap;create;[xact_mgr.getRawStoreXact(), segment, input_containerid, template, columnOrder, collationIds, properties, heap.getTypeFormatId(), temporaryFlag]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readConglomerate</MethodName>
            <MethodComment>/** 
 * Return Conglomerate object for conglomerate with container_key. &lt;p&gt; Return the Conglomerate Object.  This is implementation specific. Examples of what will be done is using the key to find the file where the conglomerate is located, and then executing implementation specific code to instantiate an object from reading a "special" row from a known location in the file.  In the btree case the btree conglomerate is stored as a column in the control row on the root page. &lt;p&gt; This operation is costly so it is likely an implementation using this will cache the conglomerate row in memory so that subsequent accesses need not perform this operation.
 * @param xact_mgr      transaction to perform the create in.
 * @param container_key The unique id of the existing conglomerate.
 * @return An instance of the conglomerate.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_mgr</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>container_key</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerHandle [container=null]</InnerVar>
                <InnerVar>Page [page=null]</InnerVar>
                <InnerVar>DataValueDescriptor[] [control_row=new DataValueDescriptor[1]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertUndoNotify</MethodName>
            <MethodComment>/** 
 * Interface to be called when an undo of an insert is processed. &lt;p&gt; Implementer of this class provides interface to be called by the raw store when an undo of an insert is processed.  Initial implementation will be by Access layer to queue space reclaiming events if necessary when a rows is logically "deleted" as part of undo of the original insert.  This undo can happen a lot for many applications if they generate expected and handled duplicate key errors. &lt;p&gt; Caller may decide to call or not based on deleted row count of the page, or if overflow rows/columns are present.
 * @param access_factory    current access_factory of the aborted insert.
 * @param xact              transaction that is being backed out.
 * @param page_key          page key of the aborted insert.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>access_factory</ParamName>
                    <ParamType>AccessFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>xact</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>page_key</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xact;addPostAbortWork;[new HeapPostCommit(access_factory,page_key)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canSupport</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [impl=startParams.getProperty("derby.access.Conglomerate.type")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UUIDFactory [uuidFactory=getMonitor().getUUIDFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>HeapConglomerateFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Privileged Monitor lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>