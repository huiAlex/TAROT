<Class>
    <Id>337</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>MethodCallNode</ClassName>
    <SuperClass>JavaValueNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MethodCallNode  /** 
 * A MethodCallNode represents a Java method call.  Method calls can be done through DML (as expressions) or through the CALL statement.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>methodName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>javaClassName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>routineInfo</FieldName>
            <FieldType>RoutineAliasInfo</FieldType>
        </Field>
        <Field>
            <FieldName>internalCall</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>procedurePrimitiveArrayType</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>signature</FieldName>
            <FieldType>JSQLType[]</FieldType>
        </Field>
        <Field>
            <FieldName>methodParms</FieldName>
            <FieldType>JavaValueNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>method</FieldName>
            <FieldType>Member</FieldType>
        </Field>
        <Field>
            <FieldName>actualMethodReturnType</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>methodParameterTypes</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MethodCallNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFullName</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the schema-qualified name of the the routine. Is non-null only for StaticMethodCallNodes. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJavaClassName</MethodName>
            <MethodComment>/** 
 * @return the name of the class that contains the method, null if not known. It may not be knownuntil this node has been bound.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResolvedMethod</MethodName>
            <MethodComment>/** 
 * @return get the Java method or constructor determined during the bind() phase.
 */
</MethodComment>
            <ReturnType>Member</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineInfo</MethodName>
            <MethodComment>/** 
 * Get the details on the invoked routines.
 */
</MethodComment>
            <ReturnType>RoutineAliasInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addParms</MethodName>
            <MethodComment>/** 
 * Add the parameter list
 * @param parameterList		A list of the parameters
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterList</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [plSize=parameterList.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodParameterClasses</MethodName>
            <MethodComment>/** 
 * Get the resolved Classes of our parameters
 * @return	the Classes of our parameters
 */
</MethodComment>
            <ReturnType>Class&lt;?&gt;[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ClassInspector [ci=getClassFactory().getClassInspector()]</InnerVar>
                <InnerVar>Class&lt;?&gt;[] [parmTypeClasses=new Class&lt;?&gt;[methodParms.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrelationTables</MethodName>
            <MethodComment>/** 
 * Build a JBitSet of all of the tables that we are correlated with.
 * @param correlationMap	The JBitSet of the tables that we are correlated with.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>correlationMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [getCRs=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;accept;[getCRs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindParameters</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This means binding the sub-expressions, as well as figuring out what the return type is for this expression.
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>areParametersQueryInvariant</MethodName>
            <MethodComment>/** 
 * Return whether or not all of the parameters to this node are QUERY_INVARIANT or CONSTANT.  This is useful for VTIs - a VTI is a candidate for materialization if all of its parameters are QUERY_INVARIANT or CONSTANT
 * @return Whether or not all of the parameters to this node are QUERY_INVARIANT or CONSTANT
 * @exception StandardException	thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwNoMethodFound</MethodName>
            <MethodComment>/** 
 * Build parameters for error message and throw the exception when there is no matching signature found.
 * @param receiverTypeName	Type name for receiver
 * @param parmTypeNames		Type names for parameters as object types
 * @param primParmTypeNames	Type names for parameters as primitive types
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>receiverTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parmTypeNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>primParmTypeNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [parmTypes=new StringBuilder()]</InnerVar>
                <InnerVar>int [paramCount=signature.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarargTypeName</MethodName>
            <MethodComment>/** 
 * Turn an array type name into the corresponding vararg type name 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>arrayTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess an expression tree.  We do a number of transformations here (including subqueries, IN lists, LIKE and BETWEEN) plus subquery flattening. NOTE: This is done before the outer ResultSetNode is preprocessed.
 * @param numTables			Number of tables in the DML Statement
 * @param outerFromList		FromList from outer query block
 * @param outerSubqueryList	SubqueryList from outer query block
 * @param outerPredicateList	PredicateList from outer query block
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerSubqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerPredicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [parm]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>categorize</MethodName>
            <MethodComment>/** 
 * Categorize this predicate.  Initially, this means building a bit map of the referenced tables for each predicate. If the source of this ColumnReference (at the next underlying level)  is not a ColumnReference or a VirtualColumnNode then this predicate will not be pushed down. For example, in: select * from (select 1 from s) a (x) where x = 1 we will not push down x = 1. NOTE: It would be easy to handle the case of a constant, but if the inner SELECT returns an arbitrary expression, then we would have to copy that tree into the pushed predicate, and that tree could contain subqueries and method calls. RESOLVE - revisit this issue once we have views.
 * @param referencedTabs	JBitSet with bit map of referenced FromTables
 * @param simplePredsOnly	Whether or not to consider methodcalls, field references and conditional nodes when building bit map
 * @return boolean		Whether or not source.expression is a ColumnReferenceor a VirtualColumnNode.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>referencedTabs</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>simplePredsOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushable=true]</InnerVar>
                <InnerVar>int [param]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapColumnReferencesToExpressions</MethodName>
            <MethodComment>/** 
 * Remap all ColumnReferences in this tree to be clones of the underlying expression.
 * @return JavaValueNode			The remapped expression tree.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>JavaValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [param]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasVarargs</MethodName>
            <MethodComment>/** 
 * Return true if the routine has varargs 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFirstVarargIdx</MethodName>
            <MethodComment>/** 
 * Get the index of the first vararg if this is a varargs method 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isVararg</MethodName>
            <MethodComment>/** 
 * Return true if the parameter is a vararg 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parameterNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateParameters</MethodName>
            <MethodComment>/** 
 * Generate the parameters to the given method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb the method  the expression will go into
 * @return	Count of arguments to the method.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [param]</InnerVar>
                <InnerVar>int [nonVarargCount=hasVarargs() ? routineInfo.getParameterCount() - 1 : methodParms.length]</InnerVar>
                <InnerVar>int [totalArgCount=hasVarargs() ? nonVarargCount + 1 : nonVarargCount]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateAndCastOneParameter</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Generate and cast one parameter, pushing the result onto the stack. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>param</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
                <InnerVar>String [argumentType=getParameterTypeName(methodParms[param])]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateOneParameter;[acb, mb, param]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateVarargs</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Generate the trailing routine arguments into a varargs array and push that array onto the stack. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstVarargIdx=getFirstVarargIdx()]</InnerVar>
                <InnerVar>String [arrayType=methodParameterTypes[firstVarargIdx]]</InnerVar>
                <InnerVar>String [cellType=stripOneArrayLevel(arrayType)]</InnerVar>
                <InnerVar>String [varargType=cellType]</InnerVar>
                <InnerVar>int [varargCount=methodParms.length - firstVarargIdx]</InnerVar>
                <InnerVar>LocalField [arrayField=acb.newFieldDeclaration(Modifier.PRIVATE,arrayType)]</InnerVar>
                <InnerVar>MethodBuilder [cb=acb.getConstructor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cb;pushNewArray;[cellType, varargCount]</InnerMethodInvoke>
                <InnerMethodInvoke>cb;setField;[arrayField]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;getField;[arrayField]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineArgIdx</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the offset into the routine arguments corresponding to the index of the invocation parameter. The two indexes may be different in the case of varargs methods. There may be more invocation args than declared routine args. For a varargs routine, all of the trailing invocation parameters correspond to the last argument declared by the CREATE FUNCTION/PROCEDURE statement. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>invocationArgIdx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineArgIdx</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rai</ParamName>
                    <ParamType>RoutineAliasInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>invocationArgIdx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstVarargIdx=rai.getParameterCount() - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypeName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>param</ParamName>
                    <ParamType>JavaValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [argumentType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateOneParameter</MethodName>
            <MethodComment>/** 
 * Generate one parameter to the given method call. This method is overriden by RepStaticMethodCallNode.
 * @param acb				The ExpressionClassBuilder for the class we're generating
 * @param mb the method the expression will go into
 * @param parameterNumber	Identifies which parameter to generate. 0 based.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodParms[parameterNumber];generateExpression;[acb, mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNullParameterInfo</MethodName>
            <MethodComment>/** 
 * Set the appropriate type information for a null passed as a parameter. This method is called after method resolution, when a signature was successfully matched.
 * @param parmTypeNames	String[] with the java type names for the parametersas declared by the method
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parmTypeNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveMethodCall</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>staticMethod</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=signature.length]</InnerVar>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
                <InnerVar>String[] [parmTypeNames]</InnerVar>
                <InnerVar>String[] [primParmTypeNames=null]</InnerVar>
                <InnerVar>boolean[] [isParam=getIsParam()]</InnerVar>
                <InnerVar>boolean [hasDynamicResultSets=hasVarargs() ? false : (routineInfo != null) &amp;&amp; (count != 0) &amp;&amp; (count != methodParms.length)]</InnerVar>
                <InnerVar>int [signatureOffset=methodName.indexOf('(')]</InnerVar>
                <InnerVar>String [typeName=classInspector.getType(method)]</InnerVar>
                <InnerVar>String [methodParameter=null]</InnerVar>
                <InnerVar>DataTypeDescriptor [dts=DataTypeDescriptor.getSQLDataTypeDescriptor(typeName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setJavaTypeName;[typeName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stripOneArrayLevel</MethodName>
            <MethodComment>/** 
 * Strip the trailing [] from a type name 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseValidateSignature</MethodName>
            <MethodComment>/** 
 * Parse the user supplied signature for a method and validate it, need to match the number of parameters passed in and match the valid types for the parameter.
 * @param offset Character offset of first paren
 * @param hasDynamicResultSets Can ResultSet[] parameters be specified.
 * @return The valid array of types for resolution.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>externalName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasDynamicResultSets</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [siglen=externalName.length()]</InnerVar>
                <InnerVar>StringTokenizer [st=new StringTokenizer(externalName.substring(offset + 1,siglen - 1),",",true)]</InnerVar>
                <InnerVar>String[] [signatureTypes=new String[signature.length]]</InnerVar>
                <InnerVar>int [count]</InnerVar>
                <InnerVar>boolean [seenClass=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>someParametersAreNull</MethodName>
            <MethodComment>/** 
 * Return true if some parameters are null, false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [count=signature.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectSignature</MethodName>
            <MethodComment>/** 
 * Build an array of names of the argument types. These types are biased toward Java objects. That is, if an argument is of SQLType, then we map it to the corresponding Java synonym class (e.g., SQLINT is mapped to 'java.lang.Integer').
 * @return	array of type names
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [count=signature.length]</InnerVar>
                <InnerVar>String [parmTypeNames[]=new String[count]]</InnerVar>
                <InnerVar>TypeCompilerFactory [tcf=(routineInfo == null) ? null : getCompilerContext().getTypeCompilerFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIsParam</MethodName>
            <MethodComment>/** 
 * Build an array of booleans denoting whether or not a given method parameter is a ?.
 * @return array of booleans denoting wheter or not a given methodparameter is a ?.
 */
</MethodComment>
            <ReturnType>boolean[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean[] [isParam=new boolean[methodParms.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectTypeName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jsqlType</ParamName>
                    <ParamType>JSQLType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tcf</ParamName>
                    <ParamType>TypeCompilerFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrimitiveSignature</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>castToPrimitiveAsNecessary</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=signature.length]</InnerVar>
                <InnerVar>String[] [primParmTypeNames=new String[count]]</InnerVar>
                <InnerVar>JSQLType [jsqlTyp]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. The variant type can be: VARIANT				- variant within a scan (non-static field access) SCAN_INVARIANT		- invariant within a scan (column references from outer tables) QUERY_INVARIANT		- invariant within the life of a query (constant expressions)
 * @return	The variant type for the underlying expression.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVariantTypeOfParams</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [variance=Qualifier.QUERY_INVARIANT]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataType</MethodName>
            <MethodComment>/** 
 * Override method in ancestor.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodParms</MethodName>
            <MethodComment>/** 
 * Get the method parameters.
 * @return	The method parameters
 */
</MethodComment>
            <ReturnType>JavaValueNode[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>