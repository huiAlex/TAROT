<Class>
    <Id>1393</Id>
    <Package>org.apache.derby.catalog</Package>
    <ClassName>SystemProcedures</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SystemProcedures  /** 
 * Some system built-in procedures, and help routines.  Now used for network server. These procedures are built-in to the SYSIBM schema which match the DB2 SYSIBM procedures. Currently information on those can be found at url:  ftp://ftp.software.ibm.com/ps/products/db2/info/vr8/pdf/letter/db2l2e80.pdf &lt;P&gt; Also used for builtin-routines, such as SYSFUN functions, when direct calls into Java libraries cannot be made.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>SQL_BEST_ROWID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SQL_ROWVER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DRIVER_TYPE_OPTION</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ODBC_DRIVER_OPTION</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SQLCAMESSAGE</MethodName>
            <MethodComment>/** 
 * Method used by Derby Network Server to get localized message (original call from jcc.
 * @param sqlcode	sqlcode, not used.
 * @param errmcLen	sqlerrmc length
 * @param sqlerrmc	sql error message tokens, variable part of error message (ie.,arguments) plus messageId, separated by separator.
 * @param sqlerrp	not used
 * @param errd0  	not used
 * @param errd1  	not used
 * @param errd2  	not used
 * @param errd3  	not used
 * @param errd4  	not used
 * @param errd5  	not used
 * @param warn		not used
 * @param sqlState	5-char sql state
 * @param file		not used
 * @param localeStr	client locale in string
 * @param msg		OUTPUT parameter, localized error message
 * @param rc			OUTPUT parameter, return code -- 0 for success
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlcode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errmcLen</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlerrmc</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlerrp</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd0</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd1</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd2</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd3</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd4</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errd5</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>warn</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlState</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>file</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localeStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>msg</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rc</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numMessages=1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultConn</MethodName>
            <MethodComment>/** 
 * Get the default or nested connection corresponding to the URL jdbc:default:connection. We do not use DriverManager here as it is not supported in JSR 169. IN addition we need to perform more checks for null drivers or the driver returing null from connect as that logic is in DriverManager.
 * @return The nested connection
 * @throws SQLException Not running in a SQL statement
 */
</MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>InternalDriver [id=InternalDriver.activeDriver()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDMD</MethodName>
            <MethodComment>/** 
 * Get the DatabaseMetaData for the current connection for use in mapping the jcc SYSIBM.* calls to the Derby DatabaseMetaData methods 
 * @return The DatabaseMetaData object of the current connection
 */
</MethodComment>
            <ReturnType>DatabaseMetaData</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLPROCEDURES</MethodName>
            <MethodComment>/** 
 * Map SQLProcedures to EmbedDatabaseMetaData.getProcedures
 * @param catalogName SYSIBM.SQLProcedures CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLProcedures SchemaName  varchar(128),
 * @param procName    SYSIBM.SQLProcedures ProcName    varchar(128),
 * @param options     SYSIBM.SQLProcedures Options     varchar(4000))
 * @param rs          output parameter, the resultset object containing the result of getProcedures If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLFUNCTIONS</MethodName>
            <MethodComment>/** 
 * Map SQLFunctions to EmbedDatabaseMetaData.getFunctions
 * @param catalogName SYSIBM.SQLFunctions CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLFunctions SchemaName  varchar(128),
 * @param funcName    SYSIBM.SQLFunctions ProcName    varchar(128),
 * @param options     SYSIBM.SQLFunctions Options     varchar(4000)) (not used)
 * @param rs          output parameter, the resultset object containing the result of getFunctions
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>funcName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLTABLES</MethodName>
            <MethodComment>/** 
 * Map SQLTables to EmbedDatabaseMetaData.getSchemas, getCatalogs, getTableTypes and getTables, and return the result of the DatabaseMetaData calls. &lt;p&gt;JCC and DNC overload this method: &lt;ul&gt; &lt;li&gt;If options contains the string 'GETSCHEMAS=1', call getSchemas()&lt;/li&gt; &lt;li&gt;If options contains the string 'GETSCHEMAS=2', call getSchemas(String, String)&lt;/li&gt; &lt;li&gt;If options contains the string 'GETCATALOGS=1', call getCatalogs()&lt;/li&gt; &lt;li&gt;If options contains the string 'GETTABLETYPES=1', call getTableTypes()&lt;/li&gt; &lt;li&gt;otherwise, call getTables()&lt;/li&gt; &lt;/ul&gt;
 * @param catalogName SYSIBM.SQLTables CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLTables SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLTables TableName   varchar(128),
 * @param tableType   SYSIBM.SQLTables TableType   varchar(4000))
 * @param options     SYSIBM.SQLTables Options     varchar(4000))
 * @param rs          output parameter, the resultset object 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [optionValue=getOption("GETCATALOGS",options)]</InnerVar>
                <InnerVar>String[] [typeArray=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLFOREIGNKEYS</MethodName>
            <MethodComment>/** 
 * Map SQLForeignKeys to EmbedDatabaseMetaData.getImportedKeys, getExportedKeys, and getCrossReference
 * @param pkCatalogName SYSIBM.SQLForeignKeys PKCatalogName varchar(128),
 * @param pkSchemaName  SYSIBM.SQLForeignKeys PKSchemaName  varchar(128),
 * @param pkTableName   SYSIBM.SQLForeignKeys PKTableName   varchar(128),
 * @param fkCatalogName SYSIBM.SQLForeignKeys FKCatalogName varchar(128),
 * @param fkSchemaName  SYSIBM.SQLForeignKeys FKSchemaName  varchar(128),
 * @param fkTableName   SYSIBM.SQLForeignKeys FKTableName   varchar(128),
 * @param options       SYSIBM.SQLForeignKeys Options       varchar(4000))
 * @param rs            output parameter, the resultset object containing the result of the DatabaseMetaData calls JCC overloads this method: If options contains the string 'EXPORTEDKEY=1', call getImportedKeys If options contains the string 'IMPORTEDKEY=1', call getExportedKeys otherwise, call getCrossReference
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkCatalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkSchemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkCatalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkSchemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [exportedKeyProp=getOption("EXPORTEDKEY",options)]</InnerVar>
                <InnerVar>String [importedKeyProp=getOption("IMPORTEDKEY",options)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOption</MethodName>
            <MethodComment>/** 
 * Helper for SQLForeignKeys and SQLTables 
 * @return option	String containing the value for a given option 
 * @param pattern 	String containing the option to search for
 * @param options 	String containing the options to search through
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [start=options.lastIndexOf(pattern)]</InnerVar>
                <InnerVar>int [valueStart=options.indexOf('=',start)]</InnerVar>
                <InnerVar>int [valueEnd=options.indexOf(';',valueStart)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLPROCEDURECOLS</MethodName>
            <MethodComment>/** 
 * Map SQLProcedureCols to EmbedDatabaseMetaData.getProcedureColumns
 * @param catalogName SYSIBM.SQLProcedureCols CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLProcedureCols SchemaName  varchar(128),
 * @param procName    SYSIBM.SQLProcedureCols ProcName    varchar(128),
 * @param paramName   SYSIBM.SQLProcedureCols ParamName   varchar(128),
 * @param options     SYSIBM.SQLProcedureCols Options     varchar(4000))
 * @param rs          output parameter, the resultset object containing the result of getProcedureColumns If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>procName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLFUNCTIONPARAMS</MethodName>
            <MethodComment>/** 
 * Map SQLFunctionParameters to EmbedDatabaseMetaData.getFunctionColumns()
 * @param catalogName SYSIBM.SQLFunctionParameters CatalogNamevarchar(128),
 * @param schemaName SYSIBM.SQLFunctionParameters SchemaNamevarchar(128),
 * @param funcName SYSIBM.SQLFunctionParameters FuncNamevarchar(128),
 * @param paramName SYSIBM.SQLFunctionParameters ParamNamevarchar(128),
 * @param options SYSIBM.SQLFunctionParameters Optionsvarchar(4000))
 * @param rs output parameter, the resultset object containing theresult of getFunctionColumns(). 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>funcName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>paramName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLCOLUMNS</MethodName>
            <MethodComment>/** 
 * Map SQLColumns to EmbedDatabaseMetaData.getColumns
 * @param catalogName SYSIBM.SQLColumns CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLColumns SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLColumns TableName   varchar(128),
 * @param columnName  SYSIBM.SQLColumns ColumnName  varchar(128),
 * @param options     SYSIBM.SQLColumns Options     varchar(4000))If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 * @param rs          output parameter, the resultset object containing the result of getProcedures
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLCOLPRIVILEGES</MethodName>
            <MethodComment>/** 
 * Map SQLColPrivileges to EmbedDatabaseMetaData.getColumnPrivileges
 * @param catalogName SYSIBM.SQLColPrivileges CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLColPrivileges SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLColPrivileges ProcName    varchar(128),
 * @param columnName  SYSIBM.SQLColPrivileges ColumnName  varchar(128),
 * @param options     SYSIBM.SQLColPrivileges Options     varchar(4000))
 * @param rs          output parameter, the resultset object containing the result of getColumnPrivileges
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLTABLEPRIVILEGES</MethodName>
            <MethodComment>/** 
 * Map SQLTablePrivileges to EmbedDatabaseMetaData.getTablePrivileges
 * @param catalogName SYSIBM.SQLTablePrivileges CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLTablePrivileges SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLTablePrivileges ProcName    varchar(128),
 * @param options     SYSIBM.SQLTablePrivileges Options     varchar(4000))
 * @param rs          output parameter, the resultset object containing the result of getTablePrivileges
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLPRIMARYKEYS</MethodName>
            <MethodComment>/** 
 * Map SQLPrimaryKeys to EmbedDatabaseMetaData.getPrimaryKeys
 * @param catalogName SYSIBM.SQLPrimaryKeys CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLPrimaryKeys SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLPrimaryKeys TableName   varchar(128),
 * @param options     SYSIBM.SQLPrimaryKeys Options     varchar(4000))If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 * @param rs          output parameter, the resultset object containing the result of getPrimaryKeys
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLGETTYPEINFO</MethodName>
            <MethodComment>/** 
 * Map SQLGetTypeInfo to EmbedDatabaseMetaData.getTypeInfo
 * @param dataType  SYSIBM.SQLGetTypeInfo DataType smallint,
 * @param options   SYSIBM.SQLGetTypeInfo Options  varchar(4000))If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 * @param rs        output parameter, the resultset object containing theresult of getTypeInfo
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataType</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLSTATISTICS</MethodName>
            <MethodComment>/** 
 * Map SQLStatistics to EmbedDatabaseMetaData.getIndexInfo
 * @param catalogName SYSIBM.SQLStatistics CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLStatistics SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLStatistics TableName   varchar(128),
 * @param unique      SYSIBM.SQLStatistics Unique      smallint; 0=SQL_INDEX_UNIQUE(0); 1=SQL_INDEX_ALL(1),
 * @param approximate SYSIBM.SQLStatistics Approximate smallint; 1=true; 0=false,
 * @param options     SYSIBM.SQLStatistics Options     varchar(4000))If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 * @param rs          output parameter, the resultset object containing the result of getIndexInfo
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unique</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>approximate</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [boolUnique=(unique == 0) ? true : false]</InnerVar>
                <InnerVar>boolean [boolApproximate=(approximate == 1) ? true : false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLSPECIALCOLUMNS</MethodName>
            <MethodComment>/** 
 * Map SQLSpecialColumns to EmbedDatabaseMetaData.getBestRowIdentifier and getVersionColumns
 * @param colType     SYSIBM.SQLSpecialColumns ColType     smallint,where 1 means getBestRowIdentifier and 2 getVersionColumns was called.
 * @param catalogName SYSIBM.SQLSpecialColumns CatalogName varchar(128),
 * @param schemaName  SYSIBM.SQLSpecialColumns SchemaName  varchar(128),
 * @param tableName   SYSIBM.SQLSpecialColumns TableName   varchar(128),
 * @param scope       SYSIBM.SQLSpecialColumns Scope       smallint,
 * @param nullable    SYSIBM.SQLSpecialColumns Nullable    smallint; 0=false, 1=true,
 * @param options     SYSIBM.SQLSpecialColumns Options     varchar(4000))If options contains the string 'DATATYPE='ODBC'', call the ODBC version of this procedure.
 * @param rs          output parameter, the resultset object containing the result of the DatabaseMetaData call
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colType</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scope</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullable</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [boolNullable=(nullable == 1) ? true : false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SQLUDTS</MethodName>
            <MethodComment>/** 
 * Map SQLUDTS to EmbedDatabaseMetaData.getUDTs
 * @param catalogName     SYSIBM.SQLUDTS CatalogName          varchar(128),
 * @param schemaPattern   SYSIBM.SQLUDTS Schema_Name_Pattern  varchar(128),
 * @param typeNamePattern SYSIBM.SQLUDTS Type_Name_Pattern    varchar(128),
 * @param udtTypes        SYSIBM.SQLUDTS UDTTypes             varchar(128),
 * @param options         SYSIBM.SQLUDTS Options              varchar(4000))
 * @param rs              output parameter, the resultset object containingthe result of getUDTs, which will be empty
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeNamePattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>udtTypes</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [types=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>METADATA</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isForODBC</MethodName>
            <MethodComment>/** 
 * Helper for ODBC metadata calls.
 * @param options	String containig the options to search through.
 * @return True if options contain ODBC indicator; false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>options</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [optionValue=getOption(DRIVER_TYPE_OPTION,options)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_DATABASE_PROPERTY</MethodName>
            <MethodComment>/** 
 * Set/delete the value of a property of the database in current connection. &lt;p&gt; Will be called as SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY.
 * @param key       The property key.
 * @param value     The new value, if null the property is deleted.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDatabaseProperty;[key, value, Securable.SET_DATABASE_PROPERTY]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDatabaseProperty</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationCheck</ParamName>
                    <ParamType>Securable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_DATABASE_PROPERTY</MethodName>
            <MethodComment>/** 
 * Get the value of a property of the database in current connection. &lt;p&gt; Will be called as SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY.
 * @param key       The property key.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProperty</MethodName>
            <MethodComment>/** 
 * This method exists so that we can get a property value without performing authorization checks.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>authorizationCheck</ParamName>
                    <ParamType>Securable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_UPDATE_STATISTICS</MethodName>
            <MethodComment>/** 
 * Update the statistics for 1)all the indexes or 2)a specific index on a table. &lt;p&gt; Calls either  "alter table tablename all update statistics " sql or "alter table tablename update statistics indexname" sql This routine will be called when an application calls: SYSCS_UTIL.SYSCS_UPDATE_STATISTICS &lt;p&gt;
 * @param schemaname    schema name of the table/index(es) whose statistics will be updated. null will mean use the current schema to resolve the table name. Empty string for schema name will raise an  exception.
 * @param tablename     table name of the index(es) whose statistics willbe updated. A null value or an empty string will throw table not found exception. Must be non-null.
 * @param indexname    If null, then update the statistics for all the indexes for the given table name. If not null and not empty string, then the user wants to update the statistics for only the give index name. Empty string for index name will raise an  exception.
 * @exception SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [query=new StringBuffer()]</InnerVar>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(query.toString())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>query;append;["alter table "]</InnerMethodInvoke>
                <InnerMethodInvoke>query;append;[basicSchemaTableValidation(schemaname,tablename)]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_DROP_STATISTICS</MethodName>
            <MethodComment>/** 
 * Drop the statistics for  1)all the indexes or 2)a specific index on a table.
 * @param schemaname    schema name of the table/index(es) whose statistics will be dropped. null will mean use the current schema to resolve the table name. Empty string for schema name will raise an  exception.
 * @param tablename     table name of the index(es) whose statistics willbe dropped. A null value or an empty string will throw table not found exception. Must be non-null.
 * @param indexname     If null, then drop the statistics for all the indexes for the given table name. If not null and not empty string, then the user wants to drop the statistics for only the give index name. Empty string for index name will raise an  exception.
 * @exception SQLException 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [query=new StringBuffer()]</InnerVar>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(query.toString())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>query;append;["alter table "]</InnerMethodInvoke>
                <InnerMethodInvoke>query;append;[basicSchemaTableValidation(schemaname,tablename)]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>basicSchemaTableValidation</MethodName>
            <MethodComment>/** 
 * Do following checks a)Schema name can't be empty string b)If schema name is null, then we use current schema c)Table name can't be null or empty string
 * @param schemaname    If schema name is null, then we will use the current schema to resolve the table name. Empty string for schema name will raise an exception.
 * @param tablename     If table name is null or an empty string, we willthrow table not found exception.
 * @return schemaname.tablename or tablename
 * @throws SQLException a)if schema name is empty string b)if table name is empty string c)if table name is null
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_COMPRESS_TABLE</MethodName>
            <MethodComment>/** 
 * Compress the table. &lt;p&gt; Calls the "alter table compress {sequential}" sql.  This syntax is not db2 compatible so it mapped by a system routine.  This routine will be called when an application calls: SYSCS_UTIL.SYSCS_COMPRESS_TABLE &lt;p&gt;
 * @param schemaname    schema name of the table to compress. null will mean use the current schema to resolve the table name. Empty string for schema name will raise an  exception.
 * @param tablename     table name of the table to compress. A null value or an empty string will throw table not found  exception. Must be non-null.
 * @param sequential    if non-zero then rebuild indexes sequentially,if 0 then rebuild all indexes in parallel.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequential</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [query=new StringBuffer()]</InnerVar>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(query.toString())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>query;append;["alter table "]</InnerMethodInvoke>
                <InnerMethodInvoke>query;append;[basicSchemaTableValidation(schemaname,tablename)]</InnerMethodInvoke>
                <InnerMethodInvoke>query;append;[" compress" + (sequential != 0 ? " sequential" : "")]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_FREEZE_DATABASE</MethodName>
            <MethodComment>/** 
 * Freeze the database. &lt;p&gt; Call internal routine to freeze the database so that a backup can be made.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();freeze;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_UNFREEZE_DATABASE</MethodName>
            <MethodComment>/** 
 * Unfreeze the database. &lt;p&gt; Call internal routine to unfreeze the database, which was "freezed" by calling SYSCS_FREEZE_DATABASE(). can be made.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();unfreeze;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_CHECKPOINT_DATABASE</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();checkpoint;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_BACKUP_DATABASE</MethodName>
            <MethodComment>/** 
 * Backup the database to a backup directory.  This procedure will throw error, if there are any unlogged  operation executed in the same transaction backup is started. If there any unlogged operations in progess in other transaction, it will wait until those transactions are completed before starting the backup. Examples of unlogged operations include: create index and bulk insert. Note that once the backup begins these operations will not block,  instead they are automatically converted into logged operations.
 * @param backupDir the name of the directory where the backup should bestored. This directory will be created if it  does not exist.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();backup;[backupDir, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_BACKUP_DATABASE_NOWAIT</MethodName>
            <MethodComment>/** 
 * Backup the database to a backup directory. This procedure will throw error, if there are any uncommitted unlogged  operation before stating the backup. It will not wait for the unlogged operations to complete. Examples of unlogged operations include: create index and bulk insert. Note that once the backup begins these operations will not block,  instead they are automatically converted into logged operations.
 * @param backupDir the name of the directory where the backup should bestored. This directory will be created if it  does not exist.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();backup;[backupDir, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE</MethodName>
            <MethodComment>/** 
 * Backup the database to a backup directory and enable the log archive mode that will keep the archived log files required for roll-forward from this version of the backup. This procedure will throw error if there are any unlogged  operation executed in the same transaction backup is started. If there any unlogged operations in progess in other transaction, it will wait until those transactions are completed before starting the backup. Examples of unlogged operations include: create index and bulk insert. Note that once the backup begins these operations will not block,  instead they are automatically converted into logged operations.
 * @param backupDir the name of the directory where the backup should bestored. This directory will be created if not it  does not exist.   
 * @param deleteOnlineArchivedLogFiles  If &lt;tt&gt;non-zero&lt;/tt&gt; deletes online archived log files that exist before this backup, delete  will occur  only after the backup is  complete.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deleteOnlineArchivedLogFiles</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();backupAndEnableLogArchiveMode;[backupDir, (deleteOnlineArchivedLogFiles != 0), true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT</MethodName>
            <MethodComment>/** 
 * Backup the database to a backup directory and enable the log archive mode that will keep the archived log files required for roll-forward from this version backup. This procedure will throw error, if there are any uncommitted unlogged  operation before stating the backup. It will not wait for the unlogged operations to complete. Examples of unlogged operations include: create index and bulk insert. Note that once the backup begins these operations will not block,  instead they are automatically converted into logged operations.
 * @param backupDir the name of the directory where the backup should bestored. This directory will be created if not it  does not exist.   
 * @param deleteOnlineArchivedLogFiles  If &lt;tt&gt;non-zero&lt;/tt&gt; deletes online archived log files that exist before this backup, delete      will occur  only after the backup is  complete.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deleteOnlineArchivedLogFiles</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();backupAndEnableLogArchiveMode;[backupDir, (deleteOnlineArchivedLogFiles != 0), false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_DISABLE_LOG_ARCHIVE_MODE</MethodName>
            <MethodComment>/** 
 * Disables the log archival process, i.e No old log files will be kept around for a roll-forward recovery.
 * @param deleteOnlineArchivedLogFiles  If &lt;tt&gt;non-zero&lt;/tt&gt; deletes all theonline archived log files that exist before this call immediately.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>deleteOnlineArchivedLogFiles</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Factory.getDatabaseOfConnection();disableLogArchiveMode;[(deleteOnlineArchivedLogFiles != 0)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_RUNTIMESTATISTICS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>enable</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConnectionUtil.getCurrentLCC();setRunTimeStatisticsMode;[enable != 0 ? true : false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_STATISTICS_TIMING</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>enable</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConnectionUtil.getCurrentLCC();setStatisticsTiming;[enable != 0 ? true : false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_CHECK_TABLE</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=org.apache.derby.iapi.db.ConsistencyChecker.checkTable(schema,tablename)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_INPLACE_COMPRESS_TABLE</MethodName>
            <MethodComment>/** 
 * Implementation of SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(). &lt;p&gt; Code which implements the following system procedure: void SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE( IN SCHEMANAME        VARCHAR(128), IN TABLENAME         VARCHAR(128), IN PURGE_ROWS        SMALLINT, IN DEFRAGMENT_ROWS   SMALLINT, IN TRUNCATE_END      SMALLINT) &lt;p&gt; Use the SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE system procedure to reclaim  unused, allocated space in a table and its indexes. Typically, unused allocated space exists when a large amount of data is deleted from a table, and there have not been subsequent inserts to use the space freed by the deletes.   By default, Derby does not return unused space to the operating system. For  example, once a page has been allocated to a table or index, it is not  automatically returned to the operating system until the table or index is  destroyed. SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE allows you to return unused  space to the operating system. &lt;p&gt; This system procedure can be used to force 3 levels of in place compression of a SQL table: PURGE_ROWS, DEFRAGMENT_ROWS, TRUNCATE_END.  Unlike  SYSCS_UTIL.SYSCS_COMPRESS_TABLE() all work is done in place in the existing table/index. &lt;p&gt; Syntax: SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE( IN SCHEMANAME        VARCHAR(128), IN TABLENAME         VARCHAR(128), IN PURGE_ROWS        SMALLINT, IN DEFRAGMENT_ROWS   SMALLINT, IN TRUNCATE_END      SMALLINT) &lt;p&gt; SCHEMANAME:  An input argument of type VARCHAR(128) that specifies the schema of the table. Passing a null will result in an error. &lt;p&gt; TABLENAME: An input argument of type VARCHAR(128) that specifies the table name of the  table. The string must exactly match the case of the table name, and the  argument of "Fred" will be passed to SQL as the delimited identifier 'Fred'.  Passing a null will result in an error. &lt;p&gt; PURGE_ROWS: If PURGE_ROWS is set to non-zero then a single pass is made through the table  which will purge committed deleted rows from the table.  This space is then available for future inserted rows, but remains allocated to the table. As this option scans every page of the table, it's performance is linearly  related to the size of the table. &lt;p&gt; DEFRAGMENT_ROWS: If DEFRAGMENT_ROWS is set to non-zero then a single defragment pass is made which will move existing rows from the end of the table towards the front of the table.  The goal of the defragment run is to empty a set of pages at the end of the table which can then be returned to the OS by the TRUNCATE_END option.  It is recommended to only run DEFRAGMENT_ROWS, if also specifying the TRUNCATE_END option.  This option scans the whole table and needs to update index entries for every base table row move, and thus execution time is linearly related to the size of the table. &lt;p&gt; TRUNCATE_END: If TRUNCATE_END is set to non-zero then all contiguous pages at the end of the table will be returned to the OS.  Running the PURGE_ROWS and/or  DEFRAGMENT_ROWS passes options may increase the number of pages affected.   This option itself does no scans of the table, so performs on the order of a  few system calls. &lt;p&gt; SQL example: To compress a table called CUSTOMER in a schema called US, using all  available compress options: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('US', 'CUSTOMER', 1, 1, 1); To quickly just return the empty free space at the end of the same table,  this option will run much quicker than running all phases but will likely return much less space: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('US', 'CUSTOMER', 0, 0, 1); Java example: To compress a table called CUSTOMER in a schema called US, using all  available compress options: CallableStatement cs = conn.prepareCall ("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?, ?, ?)"); cs.setString(1, "US"); cs.setString(2, "CUSTOMER"); cs.setShort(3, (short) 1); cs.setShort(4, (short) 1); cs.setShort(5, (short) 1); cs.execute(); To quickly just return the empty free space at the end of the same table,  this option will run much quicker than running all phases but will likely return much less space: CallableStatement cs = conn.prepareCall ("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?, ?, ?)"); cs.setString(1, "US"); cs.setString(2, "CUSTOMER"); cs.setShort(3, (short) 0); cs.setShort(4, (short) 0); cs.setShort(5, (short) 1); cs.execute(); &lt;p&gt; It is recommended that the SYSCS_UTIL.SYSCS_COMPRESS_TABLE procedure is  issued in auto-commit mode. Note: This procedure acquires an exclusive table lock on the table being compressed. All statement plans dependent on the table or its indexes are invalidated. For information on identifying unused space, see the Derby Server and Administration Guide. TODO LIST: o defragment requires table level lock in nested user transaction, which will conflict with user lock on same table in user transaction.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tablename</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>purgeRows</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defragmentRows</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>truncateEnd</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
                <InnerVar>TransactionController [tc=lcc.getTransactionExecute()]</InnerVar>
                <InnerVar>String [escapedSchema=IdUtil.normalToDelimited(schema)]</InnerVar>
                <InnerVar>String [escapedTableName=IdUtil.normalToDelimited(tablename)]</InnerVar>
                <InnerVar>String [query="alter table " + escapedSchema + "."+ escapedTableName+ " compress inplace"+ (purgeRows != 0 ? " purge" : "")+ (defragmentRows != 0 ? " defragment" : "")+ (truncateEnd != 0 ? " truncate_end" : "")]</InnerVar>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(query)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_RUNTIMESTATISTICS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Object [rts=ConnectionUtil.getCurrentLCC().getRunTimeStatisticsObject()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>INSTALL_JAR</MethodName>
            <MethodComment>/** 
 * Install a jar file in the database. SQLJ.INSTALL_JAR
 * @param url URL of the jar file to be installed in the database.
 * @param jar SQL name jar will be installed as.
 * @param deploy Ignored.
 * @exception SQLException Error installing jar file.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jar</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deploy</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>REPLACE_JAR</MethodName>
            <MethodComment>/** 
 * Replace a jar file in the database. SQLJ.REPLACE_JAR
 * @param url URL of the jar file to be installed in the database.
 * @param jar SQL name of jar to be replaced.
 * @exception SQLException Error replacing jar file.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>url</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jar</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>REMOVE_JAR</MethodName>
            <MethodComment>/** 
 * Remove a jar file from the database.
 * @param jar      SQL name of jar to be replaced.
 * @param undeploy Ignored.
 * @exception SQLException Error removing jar file.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jar</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undeploy</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkJarSQLName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_EXPORT_TABLE</MethodName>
            <MethodComment>/** 
 * Export data from a table to given file. &lt;p&gt; Will be called by system procedure: SYSCS_EXPORT_TABLE(IN SCHEMANAME  VARCHAR(128),  IN TABLENAME    VARCHAR(128),  IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128))
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Export;exportTable;[conn, schemaName, tableName, fileName, columnDelimiter, characterDelimiter, codeset]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE</MethodName>
            <MethodComment>/** 
 * Export data from a table to given files. Large objects  are exported to an external file and the reference to it is written  in the main export file.  &lt;p&gt; Will be called by system procedure: SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE(IN SCHEMANAME  VARCHAR(128),  IN TABLENAME    VARCHAR(128),  IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128), IN LOBSFILENAME VARCHAR(32672))
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lobsFileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Export;exportTable;[conn, schemaName, tableName, fileName, columnDelimiter, characterDelimiter, codeset, lobsFileName]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_EXPORT_QUERY</MethodName>
            <MethodComment>/** 
 * Export data from a  select statement to given file. &lt;p&gt; Will be called as  SYSCS_EXPORT_QUERY(IN SELECTSTATEMENT  VARCHAR(32672),  IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128))
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectStatement</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Export;exportQuery;[conn, selectStatement, fileName, columnDelimiter, characterDelimiter, codeset]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE</MethodName>
            <MethodComment>/** 
 * Export data from a  select statement to given file. Large objects  are exported to an external file and the reference to it is written  in the main export file.  &lt;p&gt; Will be called as  SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE(IN SELECTSTATEMENT  VARCHAR(32672), IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128), IN LOBSFILENAME VARCHAR(32672))
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectStatement</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lobsFileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Export;exportQuery;[conn, selectStatement, fileName, columnDelimiter, characterDelimiter, codeset, lobsFileName]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_TABLE</MethodName>
            <MethodComment>/** 
 * Import  data from a given file to a table. &lt;p&gt; Will be called by system procedure as SYSCS_IMPORT_TABLE(IN SCHEMANAME  VARCHAR(128),  IN TABLENAME    VARCHAR(128),  IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128), IN  REPLACE SMALLINT)
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_TABLE_BULK</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>skip</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rollBackAndThrowSQLException</MethodName>
            <MethodComment>/** 
 * issue a rollback when SQLException se occurs. If SQLException ouccurs when rollback, the new SQLException will be added into the chain of se. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>se</ParamName>
                    <ParamType>SQLException</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE</MethodName>
            <MethodComment>/** 
 * Import  data from a given file to a table. Data for large object  columns is in an external file, the reference to it is in the main  input file. Read the lob data from the external file using the  lob location info in the main import file.  &lt;p&gt; Will be called by system procedure as SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE(IN SCHEMANAME  VARCHAR(128),  IN TABLENAME    VARCHAR(128),  IN FILENAME VARCHAR(32672) ,  IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1) ,   IN CODESET VARCHAR(128), IN  REPLACE SMALLINT)
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_DATA</MethodName>
            <MethodComment>/** 
 * Import data from a given file into the specified table columns from the  specified columns in the file. &lt;p&gt; Will be called as  SYSCS_IMPORT_DATA (IN SCHEMANAME VARCHAR(128), IN TABLENAME VARCHAR(128), IN INSERTCOLUMNLIST VARCHAR(32672), IN COLUMNINDEXES VARCHAR(32672), IN FILENAME VARCHAR(32672), IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1), IN CODESET VARCHAR(128),  IN REPLACE SMALLINT)
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_DATA_BULK</MethodName>
            <MethodComment>/** 
 * Import data from a given file into the specified table columns skipping header lines from the  specified columns in the file. &lt;p&gt; Will be called as  SYSCS_IMPORT_DATA_BULK (IN SCHEMANAME VARCHAR(128), IN TABLENAME VARCHAR(128), IN INSERTCOLUMNLIST VARCHAR(32672), IN COLUMNINDEXES VARCHAR(32672), IN FILENAME VARCHAR(32672), IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1), IN CODESET VARCHAR(128),  IN REPLACE SMALLINT, IN SKIP SMALLINT)
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>skip</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE</MethodName>
            <MethodComment>/** 
 * Import data from a given file into the specified table columns  from the  specified columns in the file. Data for large object  columns is in an  external file, the reference to it is in the  main input file. Read the lob data from the external file using  the lob location info in the main import file.  &lt;p&gt; Will be called as  SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE(IN SCHEMANAME VARCHAR(128),  IN TABLENAME VARCHAR(128), IN INSERTCOLUMNLIST VARCHAR(32672),  IN COLUMNINDEXES VARCHAR(32672), IN FILENAME VARCHAR(32672), IN COLUMNDELIMITER CHAR(1),  IN CHARACTERDELIMITER CHAR(1), IN CODESET VARCHAR(128),  IN REPLACE SMALLINT)
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertColumnList</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fileName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>characterDelimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>codeset</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replace</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_BULK_INSERT</MethodName>
            <MethodComment>/** 
 * Perform bulk insert using the specificed vti . &lt;p&gt; Will be called as  SYSCS_BULK_INSERT (IN SCHEMANAME VARCHAR(128), IN TABLENAME VARCHAR(128),  IN VTINAME VARCHAR(32672), IN VTIARG VARCHAR(32672))
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiArg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>String [entityName=IdUtil.mkQualifiedName(schemaName,tableName)]</InnerVar>
                <InnerVar>String [binsertSql="insert into " + entityName + " --DERBY-PROPERTIES insertMode=bulkInsert \n"+ "select * from new "+ IdUtil.normalToDelimited(vtiName)+ "("+ StringUtil.quoteStringLiteral(schemaName)+ ", "+ StringUtil.quoteStringLiteral(tableName)+ ", "+ StringUtil.quoteStringLiteral(vtiArg)+ ")"+ " as t"]</InnerVar>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(binsertSql)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_RELOAD_SECURITY_POLICY</MethodName>
            <MethodComment>/** 
 * Reload the policy file. &lt;p&gt; System procedure called thusly: SYSCS_UTIL.SYSCS_RELOAD_SECURITY_POLICY()
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>Policy.getPolicy();refresh;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>PI</MethodName>
            <MethodComment>/** 
 * Method to return the constant PI. SYSFUN.PI().
 * @return PI
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>COT</MethodName>
            <MethodComment>/** 
 * Cotangent function. SYSFUN.COT
 * @see &lt;a href="http://mathworld.wolfram.com/HyperbolicFunctions.html"&gt;HyperbolicFunctions&lt;/a&gt;
 * @return 1 / tan(x)
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SIGN</MethodName>
            <MethodComment>/** 
 * Method to return the sign of the given value. SYSFUN.SIGN().
 * @return 0, 1 or -1
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>RAND</MethodName>
            <MethodComment>/** 
 * Pseudo-random number function.
 * @return a random number
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>seed</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_USER_ACCESS</MethodName>
            <MethodComment>/** 
 * Set the connection level authorization for a specific user - SYSCS_UTIL.SYSCS_SET_USER_ACCESS.
 * @param userName name of the user in its normal form (not a SQL identifier).
 * @param connectionPermission
 * @throws SQLException Error setting the permission
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>connectionPermission</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeFromAccessList</MethodName>
            <MethodComment>/** 
 * Utility method for SYSCS_SET_USER_ACCESS removes a user from one of the access lists, driven by the property name.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>listProperty</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [removeList=getProperty(listProperty,Securable.SET_USER_ACCESS)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_USER_ACCESS</MethodName>
            <MethodComment>/** 
 * Get the connection level authorization for a specific user - SYSCS_UTIL.SYSCS_GET_USER_ACCESS.
 * @param userName name of the user in its normal form (not a SQL identifier).
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_INVALIDATE_STORED_STATEMENTS</MethodName>
            <MethodComment>/** 
 * Invalidate all the stored statements so they will get recompiled when executed next time around.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
                <InnerVar>DataDictionary [dd=lcc.getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_EMPTY_STATEMENT_CACHE</MethodName>
            <MethodComment>/** 
 * Empty as much of the cache as possible. It is not guaranteed  that the cache is empty after this call, as statements may be kept by currently executing queries, activations that are about to be garbage collected.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
                <InnerVar>CacheManager [statementCache=lcc.getLanguageConnectionFactory().getStatementCache()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_XPLAIN_MODE</MethodName>
            <MethodComment>/** 
 * this procedure switches between the different xplain modes 
 * @param mode either 0 for explain only, or 1 for explain and execute (default)
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ConnectionUtil.getCurrentLCC();setXplainOnlyMode;[mode != 0 ? true : false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_XPLAIN_MODE</MethodName>
            <MethodComment>/** 
 * This procedure returns the current status of the xplain mode. If the XPLAIN mode is non-zero, meaning that it is ON, then statements are being XPLAIN'd only, not executed.
 * @return 0 if XPLAIN mode is off, non-zero if on.
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_SET_XPLAIN_SCHEMA</MethodName>
            <MethodComment>/** 
 * This procedure sets the current xplain schema. If the schema is not set, runtime statistics are captured as a textual stream printout. If it is set, statisitcs information is stored in that schema in user tables.
 * @param schemaName May be an empty string.
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
                <InnerVar>TransactionController [tc=lcc.getTransactionExecute()]</InnerVar>
                <InnerVar>boolean [statsSave=lcc.getRunTimeStatisticsMode()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;setRunTimeStatisticsMode;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainSchema;[schemaName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINStatementDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINStatementTimingsDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINResultSetDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINResultSetTimingsDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINScanPropsDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXplainTable;[lcc, schemaName, new XPLAINSortPropsDescriptor()]</InnerMethodInvoke>
                <InnerMethodInvoke>lcc;setRunTimeStatisticsMode;[statsSave]</InnerMethodInvoke>
                <InnerMethodInvoke>lcc;setXplainSchema;[schemaName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs=conn.getMetaData().getSchemas()]</InnerVar>
                <InnerVar>boolean [schemaFound=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs=conn.getMetaData().getTables((String)null,schemaName,tableName,new String[]{"TABLE"})]</InnerVar>
                <InnerVar>boolean [tableFound=rs.next()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXplainSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXplainTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>XPLAINTableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [ddl=t.getTableDDL(schemaName)]</InnerVar>
                <InnerVar>Connection [conn=getDefaultConn()]</InnerVar>
                <InnerVar>String [ins=t.getTableInsert()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn.prepareStatement(ins);close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>lcc;setXplainStatement;[t.getCatalogName(), ins]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_XPLAIN_SCHEMA</MethodName>
            <MethodComment>/** 
 * This procedure returns the current set XPLAIN_SCHEMA
 * @return schema name, may be blank if no schema currently set.
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [sd=ConnectionUtil.getCurrentLCC().getXplainSchema()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_CREATE_USER</MethodName>
            <MethodComment>/** 
 * Create a new user.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
                <InnerVar>TransactionController [tc=lcc.getTransactionExecute()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addUser;[userName, password, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUser</MethodName>
            <MethodComment>/** 
 * Create a new user (this entry is called when bootstrapping the credentials of the DBO at database creation time.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeUserDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>UserDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDescriptorGenerator [ddg=dd.getDataDescriptorGenerator()]</InnerVar>
                <InnerVar>PasswordHasher [hasher=dd.makePasswordHasher(tc.getProperties())]</InnerVar>
                <InnerVar>String [hashingScheme=hasher.encodeHashingScheme()]</InnerVar>
                <InnerVar>String [hashedPassword=hasher.hashPasswordIntoString(userName,password)]</InnerVar>
                <InnerVar>Timestamp [currentTimestamp=new Timestamp((new java.util.Date()).getTime())]</InnerVar>
                <InnerVar>UserDescriptor [userDescriptor=ddg.newUserDescriptor(userName,hashingScheme,hashedPassword.toCharArray(),currentTimestamp)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_RESET_PASSWORD</MethodName>
            <MethodComment>/** 
 * Reset a user's password.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetAuthorizationIDPassword;[normalizeUserName(userName), password]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetAuthorizationIDPassword</MethodName>
            <MethodComment>/** 
 * Reset the password for an already normalized authorization id.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_MODIFY_PASSWORD</MethodName>
            <MethodComment>/** 
 * Change a user's password.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>password</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [currentUser=ConnectionUtil.getCurrentLCC().getStatementContext().getSQLSessionContext().getCurrentUser()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;resetAuthorizationIDPassword;[currentUser, password]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_DROP_USER</MethodName>
            <MethodComment>/** 
 * Drop a user.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkLegalUser</MethodName>
            <MethodComment>/** 
 * Raise an exception if the user doesn't exist. See commentary on DERBY-5648.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalizeUserName</MethodName>
            <MethodComment>/** 
 * Normalize the user name so that there is only one set of credentials for a given authorization id.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_GET_DATABASE_NAME</MethodName>
            <MethodComment>/** 
 * Return the database name
 * @return database name
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=ConnectionUtil.getCurrentLCC()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_PEEK_AT_SEQUENCE</MethodName>
            <MethodComment>/** 
 * Peek at the current value of a sequence generator without advancing it.
 * @param schemaName    The name of the schema holding the sequence.
 * @param sequenceName    The name of the sequence in that schema.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequenceName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SYSCS_PEEK_AT_IDENTITY</MethodName>
            <MethodComment>/** 
 * Peek at the current value of an identity generator without advancing it.
 * @param schemaName    The name of the schema holding the table.
 * @param tableName    The name of the table in that schema.
 * @exception SQLException if a database error occurs
 */
</MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Helper routine which looks up the monitor.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>