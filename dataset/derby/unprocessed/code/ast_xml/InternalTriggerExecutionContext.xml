<Class>
    <Id>2094</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>InternalTriggerExecutionContext</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>TriggerExecutionContext</SuperInterface>
        <SuperInterface>ExecutionStmtValidator</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>InternalTriggerExecutionContext  /** 
 * There is one of these beasts per INSERT/DELETE/UPDATE  statement.  It fulfills the contract for the externally visible trigger execution context and it validates that a statement that is about to be executed doesn't violate the restrictions placed upon what can be executed from a trigger. &lt;p&gt; Note that it is crucial that cleanup() is called once the DML has completed, cleanup() makes sure that users can't do something invalid on a tec reference that they were holding from when the trigger fired.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>dmlType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>statementText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>cc</FieldName>
            <FieldType>ConnectionContext</FieldType>
        </Field>
        <Field>
            <FieldName>targetTableId</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>targetTableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>lcc</FieldName>
            <FieldType>LanguageConnectionContext</FieldType>
        </Field>
        <Field>
            <FieldName>beforeResultSet</FieldName>
            <FieldType>CursorResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>afterResultSet</FieldName>
            <FieldType>CursorResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>afterRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>cleanupCalled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>event</FieldName>
            <FieldType>TriggerEvent</FieldType>
        </Field>
        <Field>
            <FieldName>triggerd</FieldName>
            <FieldType>TriggerDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetVector</FieldName>
            <FieldType>Vector</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetVector</FieldName>
            <FieldType>ResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>aiCounters</FieldName>
            <FieldType>Vector</FieldType>
        </Field>
        <Field>
            <FieldName>aiCounters</FieldName>
            <FieldType>AutoincrementCounter</FieldType>
        </Field>
        <Field>
            <FieldName>aiHT</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>aiHT</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>InternalTriggerExecutionContext</MethodName>
            <MethodComment>/** 
 * Build a trigger execution context. &lt;p&gt; About the only thing of real interest to outside observers is that it pushes itself as the trigger execution context in the lcc.  Be sure to call &lt;i&gt;cleanup()&lt;/i&gt; when you are done, or you will be flogged like the reprobate that you are.
 * @param lcc	the lcc
 * @param statementText	the text of the statement that caused thetrigger to fire.  may be null if we are replicating
 * @param targetTableId	the UUID of the table upon which the triggerfired
 * @param targetTableName	the name of the table upon which the triggerfired
 * @param aiCounters		A vector of AutoincrementCounters to keep stateof the ai columns in this insert trigger.a
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cc</ParamName>
                    <ParamType>ConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statementText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dmlType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aiCounters</ParamName>
                    <ParamType>AutoincrementCounter</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;pushTriggerExecutionContext;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeforeResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>CursorResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAfterResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>CursorResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentTriggerEvent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>event</ParamName>
                    <ParamType>TriggerEvent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearCurrentTriggerEvent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTrigger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerd</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearTrigger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanup</MethodName>
            <MethodComment>/** 
 * Cleanup the trigger execution context.  &lt;B&gt;MUST&lt;/B&gt; be called when the caller is done with the trigger execution context. &lt;p&gt; We go to somewhat exaggerated lengths to free up all our resources here because a user may hold on to a TEC after it is valid, so we clean everything up to be on the safe side.
 * @exception StandardException on unexpected error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensureProperContext</MethodName>
            <MethodComment>/** 
 * Make sure that the user isn't trying to get a result set after we have cleaned up. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateStatement</MethodName>
            <MethodComment>/** 
 * Make sure that whatever statement is about to be executed is ok from the context of this trigger. &lt;p&gt; Note that we are sub classed in replication for checks for replication specific language.
 * @param constantAction the constant action of the actionthat we are to validate
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constantAction</ParamName>
                    <ParamType>ConstantAction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTargetTableName</MethodName>
            <MethodComment>/** 
 * Get the target table name upon which the  trigger event is declared.
 * @return the target table
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTargetTableId</MethodName>
            <MethodComment>/** 
 * Get the target table UUID upon which the  trigger event is declared.
 * @return the uuid of the target table
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEventType</MethodName>
            <MethodComment>/** 
 * Get the type for the event that caused the trigger to fire.
 * @return the event type (e.g. UPDATE_EVENT)
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEventStatementText</MethodName>
            <MethodComment>/** 
 * Get the text of the statement that caused the trigger to fire.
 * @return the statement text
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOldRowSet</MethodName>
            <MethodComment>/** 
 * Returns a result set row the old images of the changed rows. For a row trigger, the result set will have a single row.  For a statement trigger, this result set has every row that has changed or will change.  If a statement trigger does not affect  a row, then the result set will be empty (i.e. ResultSet.next() will return false).
 * @return the ResultSet containing before images of the rows changed by the triggering event.
 * @exception SQLException if called after the triggering event hascompleted
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureProperContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewRowSet</MethodName>
            <MethodComment>/** 
 * Returns a result set row the new images of the changed rows. For a row trigger, the result set will have a single row.  For a statement trigger, this result set has every row that has changed or will change.  If a statement trigger does not affect  a row, then the result set will be empty (i.e. ResultSet.next() will return false).
 * @return the ResultSet containing after images of the rows changed by the triggering event.
 * @exception SQLException if called after the triggering event hascompleted
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;ensureProperContext;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOldRow</MethodName>
            <MethodComment>/** 
 * Like getBeforeResultSet(), but returns a result set positioned on the first row of the before result set.  Used as a convenience to get a column for a row trigger.  Equivalent to getBeforeResultSet() followed by next().
 * @return the ResultSet positioned on the old row image.
 * @exception SQLException if called after the triggering event hascompleted
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>java.sql.ResultSet [rs=getOldRowSet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewRow</MethodName>
            <MethodComment>/** 
 * Like getAfterResultSet(), but returns a result set positioned on the first row of the before result set.  Used as a convenience to get a column for a row trigger.  Equivalent to getAfterResultSet() followed by next().
 * @return the ResultSet positioned on the new row image.
 * @exception SQLException if called after the triggering event hascompleted
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>java.sql.ResultSet [rs=getNewRowSet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAutoincrementValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyHashtableToAIHT</MethodName>
            <MethodComment>/** 
 * Copy a map of auto increment values into the trigger execution context hash table of auto increment values.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>from</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>aiHT;putAll;[from]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetAICounters</MethodName>
            <MethodComment>/** 
 * Reset Autoincrement counters to the beginning or the end.
 * @param begin		if True, reset the AutoincremnetCounter to thebeginning-- used to reset the counters for the next trigger. If false, reset it to the end-- this sets up the counter appropriately for a AFTER STATEMENT trigger.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>begin</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateAICounters</MethodName>
            <MethodComment>/** 
 * Update auto increment counters from the last row inserted.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>