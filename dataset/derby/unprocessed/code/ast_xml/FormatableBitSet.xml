<Class>
    <Id>384</Id>
    <Package>org.apache.derby.iapi.services.io</Package>
    <ClassName>FormatableBitSet</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Formatable</SuperInterface>
        <SuperInterface>Cloneable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FormatableBitSet  /** 
 * FormatableBitSet is implemented as a packed array of bytes.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>value</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>bitsInLastByte</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>lengthAsBits</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>checkPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>udiv8</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>umod8</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>umul8</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FormatableBitSet</MethodName>
            <MethodComment>/** 
 * Niladic Constructor
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FormatableBitSet</MethodName>
            <MethodComment>/** 
 * Constructs a Bit with the initial number of bits
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numBits</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initializeBits;[numBits]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeBits</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numBits</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numBytes=numBytesFromBits(numBits)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FormatableBitSet</MethodName>
            <MethodComment>/** 
 * Constructs a Bit from an array of bytes.  Assume bytes are all being used.
 * @param newValue	The array of bytes to make up the new Bit
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FormatableBitSet</MethodName>
            <MethodComment>/** 
 * Copy constructor
 * @param original the FormatableBitSet to make a copy from
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>original</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [lenInBytes=FormatableBitSet.numBytesFromBits(original.lengthAsBits)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clone</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invariantHolds</MethodName>
            <MethodComment>/** 
 * This method returns true if the following conditions hold: 1. The number of bits in the bitset will fit into the allocated byte array. 2. 'lengthAsBits' and 'bitsInLastByte' are consistent. 3. All unused bits in the byte array are unset. This represents an invariant for the class, so this method should always return true. The method is public, but is primarily intended for testing and ASSERTS.
 * @return true if invariant holds, false otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [arrayLengthAsBits=value.length * 8]</InnerVar>
                <InnerVar>int [partialByteIndex=(lengthAsBits - 1) / 8]</InnerVar>
                <InnerVar>byte [partialByte=value[partialByteIndex]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLengthInBytes</MethodName>
            <MethodComment>/** 
 * Get the length in bytes of a Bit value
 * @return	The length in bytes of this value
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLength</MethodName>
            <MethodComment>/** 
 * Get the length in bits
 * @return The length in bits for this valueNOTE: could possibly be changed to a long.  As is we are restricted to 2^(31-3) -&amp;gt; 256meg instead of 2^31 (Integer.MAX_VALUE) like other datatypes (or 2 gig).  If it is ever changed to a long be sure to change read/writeExternal which write out the length in bits.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>calculateLength</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>realByteLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment>/** 
 * Get the length in bits -- alias for getLength()
 * @return The length in bits for this value
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getByteArray</MethodName>
            <MethodComment>/** 
 * Get the value of the byte array
 * @return	The value of the byte array
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [realByteLength=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>grow</MethodName>
            <MethodComment>/** 
 * Grow (widen) a FormatableBitSet so that it contains at least N bits. If the bitset already has more than n bits, this is a noop. Negative values of n are not allowed. ASSUMPTIONS: that all extra bits in the last byte are zero.
 * @param n	The number of bits you want.  The bits arealways added as 0 and are appended to the least significant end of the bit array.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [newNumBytes=FormatableBitSet.numBytesFromBits(n)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shrink</MethodName>
            <MethodComment>/** 
 * Shrink (narrow) a FormatableBitSet to N bits. N may not be larger than the current bitset size, or negative.
 * @param n	The number of bits the caller wants.  Thebits are always removed from the least significant end of the bit array.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>n</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstUnusedByte=numBytesFromBits(n)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Bit equivalence.  Compare this with other. If the length is different, then cannot be equal so short circuit.  Otherwise, rely on compare().  Note that two zero length bits are considered equal.
 * @param other	the other bit to compare to
 * @return TRUE|FALSE
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment>/** 
 * Bit comparison.  Compare this with other. Will always do a byte by byte compare. Given 2 similar bits of unequal lengths (x and y), where x.getLength() &amp;lt; y.getLength() but where: x[0..x.getLength()] == y[0..x.getLength()] then x &amp;lt; y.
 * @param other the other bit to compare to
 * @return -1	- if other &amp;lt;  this0	- if other == this 1	- if other &amp;gt;  this
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [otherCount, thisCount]</InnerVar>
                <InnerVar>int [otherLen, thisLen]</InnerVar>
                <InnerVar>byte[] [otherb]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment>/** 
 * Produce a hash code by putting the value bytes into an int, exclusive OR'ing if there are more than 4 bytes.
 * @return the hash code
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [code=0]</InnerVar>
                <InnerVar>int [i]</InnerVar>
                <InnerVar>int [shift=0]</InnerVar>
                <InnerVar>int [byteLength=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSet</MethodName>
            <MethodComment>/** 
 * Bit isSet
 * @param position	the bit to check
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteIndex=udiv8(position)]</InnerVar>
                <InnerVar>byte [bitIndex=umod8(position)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkPosition;[position]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>get</MethodName>
            <MethodComment>/** 
 * Bit get -- alias for isSet()
 * @param position	the bit to check
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>set</MethodName>
            <MethodComment>/** 
 * Bit set
 * @param position	the bit to set
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteIndex=udiv8(position)]</InnerVar>
                <InnerVar>byte [bitIndex=umod8(position)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkPosition;[position]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Bit clear
 * @param position	the bit to clear
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>position</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteIndex=udiv8(position)]</InnerVar>
                <InnerVar>byte [bitIndex=umod8(position)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkPosition;[position]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment>/** 
 * Clear all the bits in this FormatableBitSet
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [byteLength=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numBytesFromBits</MethodName>
            <MethodComment>/** 
 * Figure out how many bytes are needed to store the input number of bits.
 * @param bits	bits
 * @return	the number of bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bits</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numBitsInLastByte</MethodName>
            <MethodComment>/** 
 * Figure out how many bits are in the last byte from the total number of bits.
 * @param bits	bits
 * @return	the number of bits
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bits</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [lastbits=umod8(bits)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Format the string into BitSet format: {0, 2, 4, 8} if bits 0, 2, 4, 8 are set.
 * @return A new String containing the formatted Bit value
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>maxBitsForSpace</MethodName>
            <MethodComment>/** 
 * Statically calculates how many bits can fit into the number of bytes if this Bit object is externalized.  Only valid for this implementation of Bit.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numBytes</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>firstSet</MethodName>
            <MethodComment>/** 
 * A utility method which treats the byte argument as an 8-bit bitset and finds the first set bit in that byte. Assumes that at least one bit in v is set (v!=0).
 * @param v a non-zero byte to check for set bits
 * @return the zero-based index of the first set bit in the argument byte
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>anySetBit</MethodName>
            <MethodComment>/** 
 * If any bit is set, return the zero-based bit index of the first bit that is set. If no bit is set, return -1. By using anySetBit() and anySetBit(beyondBit), one can quickly go thru the entire bit array to return all set bit.
 * @return the zero-based index of the first bit that is set, or-1 if no bit is set
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [numbytes=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>anySetBit</MethodName>
            <MethodComment>/** 
 * Like anySetBit(), but return any set bit whose number is bigger than beyondBit. If no bit is set after beyondBit, -1 is returned.  By using anySetBit() and anySetBit(beyondBit), one can quickly go thru the entire bit array to return all set bit.
 * @param beyondBit Only look at bit that is greater than this bit number.Supplying a value of -1 makes the call equivalent to anySetBit().
 * @return the bit number of a bit that is set, or -1 if no bit afterbeyondBit is set
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beyondBit</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=udiv8(beyondBit)]</InnerVar>
                <InnerVar>byte [v=(byte)(value[i] &lt;&lt; umod8(beyondBit))]</InnerVar>
                <InnerVar>int [numbytes=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>or</MethodName>
            <MethodComment>/** 
 * Bitwise OR this FormatableBitSet with another FormatableBitSet. The result is stored in this bitset. The operand is unaffected. A null operand is treated as an empty bitset (i.e. a noop). A bitset that is smaller than its operand is expanded to the same size.
 * @param otherBit bitset operand
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherBit</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [otherLength=otherBit.getLength()]</InnerVar>
                <InnerVar>int [obByteLen=otherBit.getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyFrom</MethodName>
            <MethodComment>/** 
 * Copy the bytes from another FormatableBitSet. Assumes that this bit set is at least as large as the argument's bit set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>that</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[that.getByteArray(), 0, value, 0, that.getLengthInBytes()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>and</MethodName>
            <MethodComment>/** 
 * Bitwise AND this FormatableBitSet with another FormatableBitSet. The result is stored in this bitset. The operand is unaffected. A null operand is treated as an empty bitset (i.e. clearing this bitset). A bitset that is smaller than its operand is expanded to the same size.
 * @param otherBit bitset operand
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherBit</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [otherLength=otherBit.getLength()]</InnerVar>
                <InnerVar>int [byteLength=otherBit.getLengthInBytes()]</InnerVar>
                <InnerVar>int [i=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xor</MethodName>
            <MethodComment>/** 
 * Bitwise XOR this FormatableBitSet with another FormatableBitSet. The result is stored in this bitset. The operand is unaffected. A null operand is treated as an empty bitset (i.e. a noop). A bitset that is smaller than its operand is expanded to the same size.
 * @param otherBit bitset operand
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherBit</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [otherLength=otherBit.getLength()]</InnerVar>
                <InnerVar>int [obByteLen=otherBit.getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumBitsSet</MethodName>
            <MethodComment>/** 
 * Get a count of the number of bits that are set.
 * @return The number of bits that are set.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [bitsSet=0]</InnerVar>
                <InnerVar>int [numbytes=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment>/** 
 * Format: &lt;UL&gt; &lt;LI&gt;int		length in bits  &lt;/LI&gt; &lt;LI&gt;byte[]					&lt;/LI&gt;&lt;/UL&gt;
 * @see java.io.Externalizable#writeExternal
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [byteLen=getLengthInBytes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeInt;[getLength()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment>/** 
 * Note: gracefully handles zero length bits -- will create a zero length array with no bits being used.  Fortunately in.read() is ok with a zero length array so no special code. &lt;p&gt; WARNING: this method cannot be changed w/o changing SQLBit because SQLBit calls this directly w/o calling read/writeObject(), so the format id is not stored in that case.
 * @see java.io.Externalizable#readExternal
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [lenInBits]</InnerVar>
                <InnerVar>int [lenInBytes]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>in;readFully;[value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Get the formatID which corresponds to this class.
 * @return	the formatID of this class
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>