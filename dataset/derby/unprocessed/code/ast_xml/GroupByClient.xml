<Class>
    <Id>550</Id>
    <Package>org.apache.derbyTesting.perf.clients</Package>
    <ClassName>GroupByClient</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Client</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>GroupByClient  /** 
 * Test client which performs iterated GROUP BY statements on the {@code ONEKTUP} tables generated by {@code WisconsinFiller}. Based on the parameters specified when run, we perform a particular GROUP BY statement, and fetch and check the number of rows returned, as part of a performance run controlled by perf.clients.Runner. For example, you could cause this benchmark's GROUP BY to be: - one which returns 10 groups, with 1000 rows in each group, or - one which returns 100 groups, with 100 rows in each group, or - one which returns 1000 groups, with 10 rows in each group, etc. With correspondingly larger numbers of groups as the scale factor grows. You can use more rows by passing '-load_opts numRows=100000', e.g. Note that this only has an effect when you run -init. Note that changing the number of rows in the table also changes the expected size of each group; we issue a select count(*) query at the start to figure out the expected group size, but this hack only works with table sizes that are multiples of 1000. If you use a substantially larger number of rows (say, 100000 or more), you should specify '-rt 300' or higher so that a valid number of executions can occur, as the benchmark starts to slow down dramatically with large numbers of rows. To prepare the database for this little benchmark: java org.apache.derbyTesting.perf.clients.Runner -init -load group_by -load_opts numRows=NNNNNN (if you want more than 10,000 rows in DB) (this will also run the default GROUP BY, which is GROUP BY TEN) On subsequent runs you can skip the '-init', and should instead specify a particular GROUP BY to run, which you do by specifying: - the number of GROUP_BY columns (-load_opts numGroupingCols=N), and - the number of groups for each column (-load_opts numGroupsK=NNNN) (NOTE: we count from 1, not from 0, with these parameters!) I've tried this benchmark up to 5 grouping columns, which seemed like plenty for the benchmarking I wanted to do. The code supports more, but I'm not sure if it works or not. For example, this runs a 2-column group by: -load group_by -load_opts numGroupingCols=2,numGroups1=10,numGroups2=100 The resulting SQL will be: SELECT TEN, ONEPERCENT, COUNT(*) FROM TENKTUP1 GROUP BY TEN,ONEPERCENT Note that due to the way that the data in the TEN and ONEPERCENT columns are loaded, they are not independent, so this actually produces 100 groups. If numGroupingCols == 1, and thus the code can predict the number of rows that ought to be in each group, and the total number of groups, then it checks those values in the result as well.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MAX_GROUPING_COLS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>conn</FieldName>
            <FieldType>Connection</FieldType>
        </Field>
        <Field>
            <FieldName>ps</FieldName>
            <FieldType>PreparedStatement</FieldType>
        </Field>
        <Field>
            <FieldName>numGroupingCols</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numGroups</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>groupingExpr</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>totalExpectedGroups</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>tableSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sql</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>GroupByClient</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>c</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getTableSize;[]</InnerMethodInvoke>
                <InnerMethodInvoke>System.out;println;["We'll run '" + sql + "'"]</InnerMethodInvoke>
                <InnerMethodInvoke>c;setAutoCommit;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGroupingExpr</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuffer [buf=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buf;append;["SELECT "]</InnerMethodInvoke>
                <InnerMethodInvoke>null;appendGroups;[buf]</InnerMethodInvoke>
                <InnerMethodInvoke>buf;append;[", COUNT(*) FROM TENKTUP1 GROUP BY "]</InnerMethodInvoke>
                <InnerMethodInvoke>null;appendGroups;[buf]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendGroups</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>buf</ParamName>
                    <ParamType>StringBuffer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dumpTables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultSet [rs=conn.getMetaData().getTables(null,null,"%",null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableSize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=conn.createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs=s.executeQuery("select count(*) from tenktup1")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>s;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultSet [rs=ps.executeQuery()]</InnerVar>
                <InnerVar>int [expectedCount=tableSize / totalExpectedGroups]</InnerVar>
                <InnerVar>int [numRows=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>conn;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printReport</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>PrintStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>