<Class>
    <Id>152</Id>
    <Package>org.apache.derby.iapi.sql.dictionary</Package>
    <ClassName>SPSDescriptor</ClassName>
    <SuperClass>UniqueSQLObjectDescriptor</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Dependent</SuperInterface>
        <SuperInterface>Provider</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>SPSDescriptor  /** 
 * A SPSDescriptor describes a Stored Prepared Statement. It correlates to a row in SYS.SYSSTATEMENTS. &lt;B&gt;SYNCHRONIZATION&lt;/B&gt;: Stored prepared statements may be cached.  Thus they may be shared by multiple threads.  It is very hard for two threads to try to muck with an sps simultaeously because all ddl (including sps recompilation) clears out the sps cache and invalidates whatever statement held a cached sps.  But it is possible for two statements to do a prepare execute statment &lt;x&gt; at the exact same time, so both try to do an sps.prepare() at the  same time during code generation, so we synchronize most everything except getters on immutable objects just to be on the safe side.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>SPS_TYPE_TRIGGER</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SPS_TYPE_REGULAR</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SPS_TYPE_EXPLAIN</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>RECOMPILE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INVALIDATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sd</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>name</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>compSchemaId</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>type</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>text</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>usingText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>uuid</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>valid</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>preparedStatement</FieldName>
            <FieldType>ExecPreparedStatement</FieldType>
        </Field>
        <Field>
            <FieldName>params</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>compileTime</FieldName>
            <FieldType>Timestamp</FieldType>
        </Field>
        <Field>
            <FieldName>paramDefaults</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>initiallyCompilable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>lookedUpParams</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>uuidFactory</FieldName>
            <FieldType>UUIDFactory</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>SPSDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for a SPS Descriptor
 * @param dataDictionary		The data dictionary that this descriptor lives in
 * @param name 	the SPS name
 * @param uuid	the UUID
 * @param suuid	the schema UUID
 * @param compSchemaUUID	the schema UUID at compilation time
 * @param type	type
 * @param valid	is the sps valid
 * @param text	the text for this statement
 * @param initiallyCompilable	is the statement initially compilable?
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>suuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compSchemaUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valid</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initiallyCompilable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>SPSDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for a SPS Descriptor.  Used when constructing an SPS descriptor from a row in SYSSTATEMENTS.
 * @param dataDictionary		The data dictionary that this descriptor lives in
 * @param name 	the SPS name
 * @param uuid	the UUID
 * @param suuid	the schema UUID
 * @param compSchemaUUID	the schema UUID at compilation time
 * @param type	type
 * @param valid	is the sps valid
 * @param text	the text for this statement
 * @param usingText	the text for the USING clause supplied toCREATE or ALTER STATEMENT
 * @param compileTime	the time this was compiled
 * @param preparedStatement	the PreparedStatement
 * @param initiallyCompilable	is the statement initially compilable?
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>suuid</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compSchemaUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valid</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>usingText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compileTime</ParamName>
                    <ParamType>Timestamp</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preparedStatement</ParamName>
                    <ParamType>ExecPreparedStatement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initiallyCompilable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareAndRelease</MethodName>
            <MethodComment>/** 
 * FOR TRIGGERS ONLY &lt;p&gt; Generate the class for this SPS and immediately release it.  This is useful for cases where we don't want to immediately execute the statement  corresponding to this sps (e.g. CREATE STATEMENT). &lt;p&gt; &lt;I&gt;SIDE EFFECTS&lt;/I&gt;: will update and SYSDEPENDS  with the prepared statement dependency info.
 * @param lcc the language connection context
 * @param triggerTable the table descriptor to bind against.  Hadbetter be null if this isn't a trigger sps.
 * @param tc the transaction controller
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;compileStatement;[lcc, triggerTable, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>preparedStatement;makeInvalid;[DependencyManager.PREPARED_STATEMENT_RELEASE, lcc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareAndRelease</MethodName>
            <MethodComment>/** 
 * FOR TRIGGERS ONLY &lt;p&gt; Generate the class for this SPS and immediately release it.  This is useful for cases where we don't want to immediately execute the statement  corresponding to this sps (e.g. CREATE STATEMENT). &lt;p&gt; &lt;I&gt;SIDE EFFECTS&lt;/I&gt;: will update and SYSDEPENDS  with the prepared statement dependency info.
 * @param lcc the language connection context
 * @param triggerTable the table descriptor to bind against.  Hadbetter be null if this isn't a trigger sps.
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;prepareAndRelease;[lcc, triggerTable, (TransactionController)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareAndRelease</MethodName>
            <MethodComment>/** 
 * Generate the class for this SPS and immediately release it.  This is useful for cases where we don't want to immediately execute the statement  corresponding to this sps (e.g. CREATE STATEMENT). &lt;p&gt; &lt;I&gt;SIDE EFFECTS&lt;/I&gt;: will update and SYSDEPENDS  with the prepared statement dependency info.
 * @param lcc the language connection context
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;prepareAndRelease;[lcc, (TableDescriptor)null, (TransactionController)null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compileStatement</MethodName>
            <MethodComment>/** 
 * Compiles this SPS. &lt;p&gt; &lt;em&gt;Note:&lt;/em&gt; This SPS may still be marked as invalid after this method has completed, because an invalidation request may have been received while compiling.
 * @param lcc connection
 * @param triggerTable subject table (may be {@code null})
 * @param tc transaction controller to use (may be {@code null})
 * @throws StandardException if something fails
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContextManager [cm=lcc.getContextManager()]</InnerVar>
                <InnerVar>LanguageConnectionFactory [lcf=lcc.getLanguageConnectionFactory()]</InnerVar>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>Statement [stmt=lcf.getStatement(dd.getSchemaDescriptor(compSchemaId,null),text,true)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCompileTime;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setParams;[preparedStatement.getParameterTypes()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment>/** 
 * Gets the name of the sps.
 * @return	A String containing the name of the statement.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQualifiedName</MethodName>
            <MethodComment>/** 
 * Gets the full, qualified name of the statement.
 * @return	A String containing the name of the statement.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Gets the SchemaDescriptor for this SPS Descriptor.
 * @return SchemaDescriptor	The SchemaDescriptor.
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment>/** 
 * Gets an identifier telling what type of table this is. Types match final ints in this interface.  Currently returns SPS_TYPE_REGULAR or SPS_TYPE_TRIGGER.
 * @return	An identifier telling what type of statementwe are.
 */
</MethodComment>
            <ReturnType>char</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeAsString</MethodName>
            <MethodComment>/** 
 * Simple little helper function to convert your type to a string, which is easier to use.
 * @return type as a string
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initiallyCompilable</MethodName>
            <MethodComment>/** 
 * Is the statement initially compilable?  
 * @return	false if statement was created with the NOCOMPILE flagtrue otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validType</MethodName>
            <MethodComment>/** 
 * Validate the type. &lt;B&gt;NOTE&lt;/B&gt;: Only SPS_TYPE_REGULAR and SPS_TYPE_TRIGGER are currently valid.
 * @param type the type
 * @return true/false	
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompileTime</MethodName>
            <MethodComment>/** 
 * The time this prepared statement was compiled
 * @return the time this class was last compiled
 */
</MethodComment>
            <ReturnType>Timestamp</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCompileTime</MethodName>
            <MethodComment>/** 
 * Set the compile time to now
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getText</MethodName>
            <MethodComment>/** 
 * Get the text used to create this statement. Returns original text in a cleartext string.
 * @return The text
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setText</MethodName>
            <MethodComment>/** 
 * It is possible that when a trigger is invalidated, the generated trigger action sql associated with it needs to be regenerated. One example of such a case would be when ALTER TABLE on the trigger table changes the length of a column. The need for this code was found as part of DERBY-4874 where the Alter table had changed the length  of a varchar column from varchar(30) to varchar(64) but the generated  trigger action plan continued to use varchar(30). To fix varchar(30) in in trigger action sql to varchar(64), we need to regenerate the  trigger action sql which is saved as stored prepared statement. This  new trigger action sql will then get updated into SYSSTATEMENTS table. DERBY-4874
 * @param newText
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUsingText</MethodName>
            <MethodComment>/** 
 * Get the text of the USING clause used on CREATE or ALTER statement.
 * @return The text
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUUID</MethodName>
            <MethodComment>/** 
 * Gets the UUID of the SPS.
 * @return The UUID.
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParams</MethodName>
            <MethodComment>/** 
 * Get the array of date type descriptors for this statement.  Currently, we do a lookup if we don't already have the parameters saved. When SPSes are cached, the parameters should be set up when the sps is constructed.
 * @return the array of data type descriptors
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setParams</MethodName>
            <MethodComment>/** 
 * Set the list of parameters for this statement
 * @param params	the parameter list
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>params</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterDefaults</MethodName>
            <MethodComment>/** 
 * Get the default parameter values for this  statement.  Default parameter values are supplied by a USING clause on either a CREATE or ALTER STATEMENT statement.
 * @return the default parameter values
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setParameterDefaults</MethodName>
            <MethodComment>/** 
 * Set the parameter defaults for this statement.
 * @param values	the parameter defaults
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>values</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedStatement</MethodName>
            <MethodComment>/** 
 * Get the preparedStatement for this statement. If stmt is invalid or hasn't been compiled yet, it will be recompiled.
 * @return the preparedStatement
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ExecPreparedStatement</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPreparedStatement</MethodName>
            <MethodComment>/** 
 * Get the preparedStatement for this statement. Expects the prepared statement to have already been added to SYS.SYSSTATEMENTS. &lt;p&gt; Side Effects: will update SYS.SYSSTATEMENTS with the new plan if it needs to be recompiled.
 * @param recompIfInvalid if false, never recompile evenif statement is invalid
 * @return the preparedStatement
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ExecPreparedStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recompIfInvalid</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompSchemaId</MethodName>
            <MethodComment>/** 
 * Get the compilation type schema id when this view was first bound.
 * @return the schema UUID
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Prints the contents of the TableDescriptor
 * @return The contents as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependableFinder</MethodName>
            <MethodComment>/** 
 * Return the stored form of this provider
 * @see Dependable#getDependableFinder
 */
</MethodComment>
            <ReturnType>DependableFinder</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectName</MethodName>
            <MethodComment>/** 
 * Return the name of this Provider.  (Useful for errors.)
 * @return String	The name of this provider.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getObjectID</MethodName>
            <MethodComment>/** 
 * Get the provider's UUID 
 * @return String	The provider's UUID
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassType</MethodName>
            <MethodComment>/** 
 * Get the provider's type.
 * @return String The provider's type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isValid</MethodName>
            <MethodComment>/** 
 * Check that all of the dependent's dependencies are valid.
 * @return true if the dependent is currently valid
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>prepareToInvalidate</MethodName>
            <MethodComment>/** 
 * Prepare to mark the dependent as invalid (due to at least one of its dependencies being invalid).
 * @param action	The action causing the invalidation
 * @param p		the provider
 * @exception StandardException thrown if unable to make it invalid
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeInvalid</MethodName>
            <MethodComment>/** 
 * Mark the dependent as invalid (due to at least one of its dependencies being invalid).
 * @param action	The action causing the invalidation
 * @exception StandardException thrown if unable to make it invalid
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DependencyManager [dm]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>revalidate</MethodName>
            <MethodComment>/** 
 * Invalidate and revalidate.  The functional equivalent of calling makeInvalid() and makeValid(), except it is optimized.
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;makeInvalid;[DependencyManager.USER_RECOMPILE_REQUEST, lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;prepareAndRelease;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;updateSYSSTATEMENTS;[lcc, RECOMPILE, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadGeneratedClass</MethodName>
            <MethodComment>/** 
 * Load the underlying generatd class.  This is not expected to be used outside of the datadictionary package.  It is used for optimizing class loading for sps cacheing.
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateSYSSTATEMENTS</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateSPS;[this, tc, (mode == RECOMPILE)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recreateUUID</MethodName>
            <MethodComment>/** 
 * Get the UUID for the given string
 * @param idString	the string
 * @return the UUID
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>idString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorType</MethodName>
            <MethodComment>/** 
 * @see TupleDescriptor#getDescriptorType 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDescriptorName</MethodName>
            <MethodComment>/** 
 * @see TupleDescriptor#getDescriptorName 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>