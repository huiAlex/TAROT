<Class>
    <Id>896</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>StatementNode</ClassName>
    <SuperClass>QueryTreeNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StatementNode  /** 
 * A StatementNode represents a single statement in the language.  It is the top node for any statement. &lt;p&gt; StatementNode controls the class generation for query tree nodes.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>EMPTY_TD_LIST</FieldName>
            <FieldType>TableDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>NEED_DDL_ACTIVATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEED_CURSOR_ACTIVATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEED_PARAM_ACTIVATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEED_ROW_ACTIVATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEED_NOTHING_ACTIVATION</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>StatementNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAtomic</MethodName>
            <MethodComment>/** 
 * By default, assume StatementNodes are atomic. The rare statements that aren't atomic (e.g. CALL method()) override this.
 * @return true if the statement is atomic
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsSavepoint</MethodName>
            <MethodComment>/** 
 * Returns whether or not this Statement requires a set/clear savepoint around its execution.  The following statement "types" do not require them: Cursor	- unnecessary and won't work in a read only environment Xact	- savepoint will get blown away underneath us during commit/rollback &lt;p&gt; ONLY CALLABLE AFTER GENERATION &lt;P&gt; This implementation returns true, sub-classes can override the method to not require a savepoint.
 * @return boolean	Whether or not this Statement requires a set/clear savepoint
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSPSName</MethodName>
            <MethodComment>/** 
 * Get the name of the SPS that is used to execute this statement. Only relevant for an ExecSPSNode -- otherwise, returns null.
 * @return the name of the underlying sps
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeStatementName</MethodName>
            <MethodComment>/** 
 * Returns the name of statement in EXECUTE STATEMENT command. Returns null for all other commands.
 * @return String null unless overridden for Execute Statement command
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeSchemaName</MethodName>
            <MethodComment>/** 
 * Returns name of schema in EXECUTE STATEMENT command. Returns null for all other commands.
 * @return String schema for EXECUTE STATEMENT null for all others
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeResultDescription</MethodName>
            <MethodComment>/** 
 * Only DML statements have result descriptions - for all others return null. This method is overridden in DMLStatementNode.
 * @return null
 */
</MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCursorInfo</MethodName>
            <MethodComment>/** 
 * Get an object with information about the cursor if there is one.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String. See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment>/** 
 * Perform the binding operation statement.  Binding consists of permissions checking, view resolution, datatype resolution, and creation of a dependency list (for determining whether a tree or plan is still up to date). This bindStatement() method does nothing.  Each StatementNode type that can appear at the top of a tree can override this method with its own bindStatement() method that does "something".
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeStatement</MethodName>
            <MethodComment>/** 
 * Generates an optimized statement from a bound StatementNode.  Actually, it annotates the tree in place rather than generating a new tree. For non-optimizable statements (for example, CREATE TABLE), return the bound tree without doing anything.  For optimizable statements, this method will be over-ridden in the statement's root node (DMLStatementNode in all cases we know about so far). Throws an exception if the tree is not bound, or if the binding is out of date.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>activationKind</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lockTableForCompilation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Do code generation for this statement.
 * @param byteCode	the generated byte code for this statement.if non-null, then the byte code is saved here.
 * @return		A GeneratedClass for this statement
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>GeneratedClass</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>byteCode</ParamName>
                    <ParamType>ByteArray</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [nodeChoice=activationKind()]</InnerVar>
                <InnerVar>String [superClass]</InnerVar>
                <InnerVar>ActivationClassBuilder [generatingClass=new ActivationClassBuilder(superClass,getCompilerContext())]</InnerVar>
                <InnerVar>MethodBuilder [mbWorker=generatingClass.getClassBuilder().newMethodBuilder(Modifier.PROTECTED,ClassName.ResultSet,"createResultSet")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mbWorker;addThrownException;[ClassName.StandardException]</InnerMethodInvoke>
                <InnerMethodInvoke>null;generate;[generatingClass, mbWorker]</InnerMethodInvoke>
                <InnerMethodInvoke>mbWorker;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mbWorker;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>generatingClass;finishExecuteMethod;[]</InnerMethodInvoke>
                <InnerMethodInvoke>generatingClass;finishConstructor;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateIndexStatisticsFor</MethodName>
            <MethodComment>/** 
 * Returns a list of base tables for which the index statistics of the associated indexes should be updated. &lt;p&gt; This default implementation always returns an empty list.
 * @return A list of table descriptors (potentially empty).
 * @throws StandardException if accessing the index descriptors of a basetable fails
 */
</MethodComment>
            <ReturnType>TableDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>