<Class>
    <Id>866</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>UpdateNode</ClassName>
    <SuperClass>DMLModGeneratedColumnsStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>UpdateNode  /** 
 * An UpdateNode represents an UPDATE statement.  It is the top node of the query tree for that statement. For positioned update, there may be no from table specified. The from table will be derived from the cursor specification of the named cursor.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>changedColumnIds</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>deferred</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>checkConstraints</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>targetTable</FieldName>
            <FieldType>FromTable</FieldType>
        </Field>
        <Field>
            <FieldName>readColsBitSet</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>positionedUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>COLUMNNAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>UpdateNode</MethodName>
            <MethodComment>/** 
 * Constructor for an UpdateNode.
 * @param targetTableName	The name of the table to update
 * @param resultSet         The ResultSet that we will generate
 * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
 * @param cm                The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>matchingClause</ParamName>
                    <ParamType>MatchingClauseNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment>/** 
 * Bind this UpdateNode.  This means looking up tables and columns and getting their types, and figuring out the result types of all expressions, as well as doing view resolution, permissions checking, etc. &lt;p&gt; Binding an update will also massage the tree so that the ResultSetNode has a set of columns to contain the old row value, followed by a set of columns to contain the new row value, followed by a column to contain the RowLocation of the row to be updated.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>FromList [fromList=new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerVar>
                <InnerVar>TableName [cursorTargetTableName=null]</InnerVar>
                <InnerVar>CurrentOfNode [currentOfNode=null]</InnerVar>
                <InnerVar>ResultColumnList [afterColumns=null]</InnerVar>
                <InnerVar>DataDictionary [dataDictionary=getDataDictionary()]</InnerVar>
                <InnerVar>ArrayList&lt;String&gt; [explicitlySetColumns=getExplicitlySetColumns()]</InnerVar>
                <InnerVar>List&lt;CastNode&gt; [allCastNodes=collectAllCastNodes()]</InnerVar>
                <InnerVar>TagFilter [tagFilter=new TagFilter(TagFilter.NEED_PRIVS_FOR_UPDATE_STMT)]</InnerVar>
                <InnerVar>SelectNode [sel]</InnerVar>
                <InnerVar>ColumnDescriptorList [addedGeneratedColumns=new ColumnDescriptorList()]</InnerVar>
                <InnerVar>ColumnDescriptorList [affectedGeneratedColumns=new ColumnDescriptorList()]</InnerVar>
                <InnerVar>boolean [allColumns=false]</InnerVar>
                <InnerVar>boolean [needBaseColumns=(targetVTI == null) || inMatchingClause()]</InnerVar>
                <InnerVar>ValueNode [rowLocationNode]</InnerVar>
                <InnerVar>ResultColumn [rowLocationColumn=new ResultColumn(COLUMNNAME,rowLocationNode,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();pushCurrentPrivType;[Authorizer.SELECT_PRIV]</InnerMethodInvoke>
                <InnerMethodInvoke>null;tagPrivilegedNodes;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[tagFilter]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindTables;[dataDictionary]</InnerMethodInvoke>
                <InnerMethodInvoke>null;verifyTargetTable;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addUpdatePriv;[explicitlySetColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addGeneratedColumns;[targetTableDescriptor, resultSet, affectedGeneratedColumns, addedGeneratedColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>resultSet.getResultColumns();markUpdated;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;normalizeCorrelatedColumns;[resultSet.getResultColumns(), targetTable]</InnerMethodInvoke>
                <InnerMethodInvoke>resultSet;bindResultColumns;[targetTableDescriptor, targetVTI, resultSet.getResultColumns(), this, fromList]</InnerMethodInvoke>
                <InnerMethodInvoke>null;forbidGenerationOverrides;[resultSet.getResultColumns(), addedGeneratedColumns]</InnerMethodInvoke>
                <InnerMethodInvoke>rowLocationColumn;markGenerated;[]</InnerMethodInvoke>
                <InnerMethodInvoke>resultColumnList;addResultColumn;[rowLocationColumn]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkTableNameAndScrubResultColumns;[resultColumnList]</InnerMethodInvoke>
                <InnerMethodInvoke>resultSet;setResultColumns;[resultColumnList]</InnerMethodInvoke>
                <InnerMethodInvoke>SelectNode;checkNoWindowFunctions;[resultSet, "&lt;update source&gt;"]</InnerMethodInvoke>
                <InnerMethodInvoke>resultSet.getResultColumns();bindUntypedNullsToResultColumns;[resultColumnList]</InnerMethodInvoke>
                <InnerMethodInvoke>rowLocationColumn;bindResultColumnToExpression;[]</InnerMethodInvoke>
                <InnerMethodInvoke>resultColumnList;checkStorableExpressions;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();popCurrentPrivType;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[tagFilter]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrivType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExplicitlySetColumns</MethodName>
            <MethodComment>/** 
 * Get the names of the explicitly set columns, that is, the columns on the left side of SET operators.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ArrayList&lt;String&gt; [result=new ArrayList&lt;String&gt;()]</InnerVar>
                <InnerVar>ResultColumnList [rcl=resultSet.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>associateAddedColumns</MethodName>
            <MethodComment>/** 
 * Associate all added columns with the TARGET table of the enclosing MERGE statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tagOriginalResultSetColumns</MethodName>
            <MethodComment>/** 
 * Tag the original columns mentioned in the result list.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAllResultSetColumns</MethodName>
            <MethodComment>/** 
 * Collect all of the result set columns.
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [crVisitor=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resultSet.getResultColumns();accept;[crVisitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAllCastNodes</MethodName>
            <MethodComment>/** 
 * Collect all of the CastNodes in the WHERE clause and on the right side of SET operators. Later on, we will need to add permissions for all UDTs mentioned by these nodes.
 */
</MethodComment>
            <ReturnType>CastNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;CastNode&gt; [getCasts=new CollectNodesVisitor&lt;CastNode&gt;(CastNode.class)]</InnerVar>
                <InnerVar>ValueNode [whereClause=((SelectNode)resultSet).whereClause]</InnerVar>
                <InnerVar>ResultColumnList [rcl=resultSet.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>tagPrivilegedNodes</MethodName>
            <MethodComment>/** 
 * Tag all of the nodes which may require privilege checks. These are various QueryTreeNodes in the WHERE clause and on the right side of SET operators.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ArrayList&lt;QueryTreeNode&gt; [result=new ArrayList&lt;QueryTreeNode&gt;()]</InnerVar>
                <InnerVar>SelectNode [selectNode=(SelectNode)resultSet]</InnerVar>
                <InnerVar>ValueNode [whereClause=selectNode.whereClause]</InnerVar>
                <InnerVar>ResultColumnList [rcl=resultSet.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>result;add;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectPrivilegedNodes</MethodName>
            <MethodComment>/** 
 * Add to an evolving list all of the nodes under an expression which may require privilege checks.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [getCRs=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
                <InnerVar>CollectNodesVisitor&lt;StaticMethodCallNode&gt; [getSMCNs=new CollectNodesVisitor&lt;StaticMethodCallNode&gt;(StaticMethodCallNode.class)]</InnerVar>
                <InnerVar>CollectNodesVisitor&lt;FromBaseTable&gt; [getFBTs=new CollectNodesVisitor&lt;FromBaseTable&gt;(FromBaseTable.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expr;accept;[getCRs]</InnerMethodInvoke>
                <InnerMethodInvoke>result;addAll;[getCRs.getList()]</InnerMethodInvoke>
                <InnerMethodInvoke>expr;accept;[getSMCNs]</InnerMethodInvoke>
                <InnerMethodInvoke>result;addAll;[getSMCNs.getList()]</InnerMethodInvoke>
                <InnerMethodInvoke>expr;accept;[getFBTs]</InnerMethodInvoke>
                <InnerMethodInvoke>result;addAll;[getFBTs.getList()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUpdatePriv</MethodName>
            <MethodComment>/** 
 * Add UPDATE_PRIV on all columns on the left side of SET operators.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>explicitlySetColumns</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;pushCurrentPrivType;[Authorizer.UPDATE_PRIV]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment>/** 
 * Compile constants that Execution will use
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [lckMode=inMatchingClause() ? TransactionController.MODE_RECORD : resultSet.updateTargetLockMode()]</InnerVar>
                <InnerVar>long [heapConglomId=targetTableDescriptor.getHeapConglomerateId()]</InnerVar>
                <InnerVar>TransactionController [tc=getLanguageConnectionContext().getTransactionCompile()]</InnerVar>
                <InnerVar>StaticCompiledOpenConglomInfo[] [indexSCOCIs=new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeferredForUpdateOfIndexColumn</MethodName>
            <MethodComment>/** 
 * Updates are deferred if they update a column in the index used to scan the table being updated.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Code generation for update. The generated code will contain: o  A static member for the (xxx)ResultSet with the RowLocations	and new update values o  The static member will be assigned the appropriate ResultSet within the nested calls to get the ResultSets.  (The appropriate cast to the (xxx)ResultSet will be generated.) o  The CurrentRowLocation() in SelectNode's select list will generate a new method for returning the RowLocation as well as a call to that method when generating the (xxx)ResultSet.
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb	The method for the execute() method to be built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateCodeForTemporaryTable;[acb]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;newFieldDeclaration;[Modifier.PRIVATE, ClassName.CursorResultSet, acb.newRowLocationScanResultSetName()]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementType</MethodName>
            <MethodComment>/** 
 * Return the type of statement, something from StatementType.
 * @return the type of statement
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReadMap</MethodName>
            <MethodComment>/** 
 * Gets the map of all columns which must be read out of the base table. These are the columns needed to&lt;UL&gt;: &lt;LI&gt;maintain indices&lt;/LI&gt; &lt;LI&gt;maintain foreign keys&lt;/LI&gt; &lt;LI&gt;maintain generated columns&lt;/LI&gt; &lt;LI&gt;support Replication's Delta Optimization&lt;/LI&gt;&lt;/UL&gt; &lt;p&gt; The returned map is a FormatableBitSet with 1 bit for each column in the table plus an extra, unsued 0-bit. If a 1-based column id must be read from the base table, then the corresponding 1-based bit is turned ON in the returned FormatableBitSet. &lt;p&gt;  &lt;B&gt;NOTE&lt;/B&gt;: this method is not expected to be called when all columns are being updated (i.e. updateColumnList is null).
 * @param dd				the data dictionary to look in
 * @param baseTable		the base table descriptor
 * @param updateColumnList the rcl for the update. CANNOT BE NULL
 * @param affectedGeneratedColumns columns whose generation clauses mention columns being updated
 * @return a FormatableBitSet of columns to be read out of the base table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumnList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affectedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean[] [needsDeferredProcessing=new boolean[1]]</InnerVar>
                <InnerVar>ArrayList&lt;ConglomerateDescriptor&gt; [conglomerates=new ArrayList&lt;ConglomerateDescriptor&gt;()]</InnerVar>
                <InnerVar>FormatableBitSet [columnMap=getUpdateReadMap(dd,baseTable,updateColumnList,conglomerates,relevantCdl,relevantTriggers,needsDeferredProcessing,affectedGeneratedColumns)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;markAffectedIndexes;[conglomerates]</InnerMethodInvoke>
                <InnerMethodInvoke>null;adjustDeferredFlag;[needsDeferredProcessing[0]]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChangedColumnIds</MethodName>
            <MethodComment>/** 
 * Construct the changedColumnIds array. Note we sort its entries by columnId.
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateReadMap</MethodName>
            <MethodComment>/** 
 * Builds a bitmap of all columns which should be read from the Store in order to satisfy an UPDATE statement. Is passed a list of updated columns. Does the following: 1)	finds all indices which overlap the updated columns 2)	adds the index columns to a bitmap of affected columns 3)	adds the index descriptors to a list of conglomerate descriptors. 4)	finds all constraints which overlap the updated columns and adds the constrained columns to the bitmap 5)	finds all triggers which overlap the updated columns. 6)	Go through all those triggers from step 5 and for each one of those triggers, follow the rules below to decide which columns should be read. Rule1)If trigger column information is null, then read all the columns from trigger table into memory irrespective of whether there is any trigger action column information. 2 egs of such triggers create trigger tr1 after update on t1 for each row values(1); create trigger tr1 after update on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2);  Rule2)If trigger column information is available but no trigger  action column information is found and no REFERENCES clause is used for the trigger, then read all the columns identified by  the trigger column. eg  create trigger tr1 after update of c1 on t1  for each row values(1); Rule3)If trigger column information and trigger action column information both are not null, then only those columns will be read into memory. This is possible only for triggers created in release 10.9 or higher(with the exception of 10.7.1.1 where we did collect that information but because of corruption caused by those changes, we do not use the information collected by 10.7). Starting 10.9, we are collecting trigger action column  informatoin so we can be smart about what columns get read  during trigger execution. eg create trigger tr1 after update of c1 on t1  referencing old as oldt for each row  insert into t2 values(2,oldt.j,-2); Rule4)If trigger column information is available but no trigger  action column information is found but REFERENCES clause is used for the trigger, then read all the columns from the trigger  table. This will cover soft-upgrade scenario for triggers created  pre-10.9.  eg trigger created prior to 10.9 create trigger tr1 after update of c1 on t1  referencing old as oldt for each row  insert into t2 values(2,oldt.j,-2); 7)	adds the triggers to an evolving list of triggers 8)	finds all generated columns whose generation clauses mention the updated columns and adds all of the mentioned columns
 * @param dd	Data Dictionary
 * @param baseTable	Table on which update is issued
 * @param updateColumnList	a list of updated columns
 * @param conglomerates       OUT: list of affected indices
 * @param relevantConstraints	IN/OUT. Empty list is passed in. We hang constraints on it as we go.
 * @param relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
 * @param needsDeferredProcessing	IN/OUT. true if the statement already needsdeferred processing. set while evaluating this routine if a trigger or constraint requires deferred processing
 * @param affectedGeneratedColumns columns whose generation clauses mention updated columns
 * @return a FormatableBitSet of columns to be read out of the base table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumnList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerates</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relevantConstraints</ParamName>
                    <ParamType>ConstraintDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>relevantTriggers</ParamName>
                    <ParamType>TriggerDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needsDeferredProcessing</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affectedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [columnCount=baseTable.getMaxColumnID()]</InnerVar>
                <InnerVar>FormatableBitSet [columnMap=new FormatableBitSet(columnCount + 1)]</InnerVar>
                <InnerVar>int[] [changedColumnIds=updateColumnList.sortMe()]</InnerVar>
                <InnerVar>int [rclSize=relevantConstraints.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>DMLModStatementNode;getXAffectedIndexes;[baseTable, updateColumnList, columnMap, conglomerates]</InnerMethodInvoke>
                <InnerMethodInvoke>baseTable;getAllRelevantConstraints;[StatementType.UPDATE, changedColumnIds, needsDeferredProcessing, relevantConstraints]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addGeneratedColumnPrecursors;[baseTable, affectedGeneratedColumns, columnMap]</InnerMethodInvoke>
                <InnerMethodInvoke>baseTable;getAllRelevantTriggers;[StatementType.UPDATE, changedColumnIds, relevantTriggers]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addGeneratedColumnPrecursors</MethodName>
            <MethodComment>/** 
 * Add all of the columns mentioned by the generation clauses of generated columns. The generated columns were added when we called addGeneratedColumns earlier on.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affectedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnMap</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [generatedColumnCount=affectedGeneratedColumns.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addGeneratedColumns</MethodName>
            <MethodComment>/** 
 * Add generated columns to the update list as necessary. We add any column whose generation clause mentions columns already in the update list. We fill in a list of all generated columns affected by this update. We also fill in a list of all generated columns which we added to the update list.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateSet</ParamName>
                    <ParamType>ResultSetNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>affectedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>addedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [updateColumnList=updateSet.getResultColumns()]</InnerVar>
                <InnerVar>ColumnDescriptorList [generatedColumns=baseTable.getGeneratedColumns()]</InnerVar>
                <InnerVar>HashSet&lt;String&gt; [updatedColumns=new HashSet&lt;String&gt;()]</InnerVar>
                <InnerVar>UUID [tableID=baseTable.getObjectID()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalizeCorrelatedColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [correlationName=fromTable.getCorrelationName()]</InnerVar>
                <InnerVar>TableName [tableNameNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkTableNameAndScrubResultColumns</MethodName>
            <MethodComment>/** 
 * Check table name and then clear it from the result set columns.
 * @exception StandardExcepion if invalid column/table is specified.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalizeSynonymColumns</MethodName>
            <MethodComment>/** 
 * Normalize synonym column references to have the name of the base table. 
 * @param rcl	    The result column list of the target table
 * @param fromTable The table name to set the column refs to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [tableNameNode]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidGenerationOverrides</MethodName>
            <MethodComment>/** 
 * Do not allow generation clauses to be overriden. Throws an exception if the user attempts to override the value of a generated column.  The only value allowed in a generated column is DEFAULT. We will use addedGeneratedColumns list to pass through the generated columns which have already been added to the update list.
 * @param targetRCL  the row in the table being UPDATEd
 * @param addedGeneratedColumns generated columns which the compiler addedearlier on
 * @throws StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>addedGeneratedColumns</ParamName>
                    <ParamType>ColumnDescriptorList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=targetRCL.size()]</InnerVar>
                <InnerVar>ResultColumnList [resultRCL=resultSet.getResultColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>