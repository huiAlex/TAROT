<Class>
    <Id>318</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>ConstraintConstantAction</ClassName>
    <SuperClass>DDLSingleTableConstantAction</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ConstraintConstantAction  /** 
 * This class  describes actions that are ALWAYS performed for a constraint creation at Execution time.
 * @version 0.1
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>constraintName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>constraintType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>tableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>schemaName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>schemaId</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>indexAction</FieldName>
            <FieldType>IndexConstantAction</FieldType>
        </Field>
        <Field>
            <FieldName>constraintId</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ConstraintConstantAction</MethodName>
            <MethodComment>/** 
 * Make one of these puppies.
 * @param constraintName	Constraint name.
 * @param constraintType	Constraint type.
 * @param tableName		Table name.
 * @param tableId			UUID of table.
 * @param schemaName		schema that table and constraint lives in.
 * @param indexAction		IndexConstantAction for constraint (if necessary)RESOLVE - the next parameter should go away once we use UUIDs (Generated constraint names will be based off of uuids)
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexAction</ParamName>
                    <ParamType>IndexConstantAction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintType</MethodName>
            <MethodComment>/** 
 * Get the constraint type.
 * @return The constraint type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintName</MethodName>
            <MethodComment>/** 
 * Get the constraint name
 * @return	the constraint name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConstraintId</MethodName>
            <MethodComment>/** 
 * Get the constraint id of the constraint
 * @return constraint id
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexAction</MethodName>
            <MethodComment>/** 
 * Get the associated index constant action.
 * @return	the constant action for the backing index
 */
</MethodComment>
            <ReturnType>IndexConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateFKConstraint</MethodName>
            <MethodComment>/** 
 * Make sure that the foreign key constraint is valid with the existing data in the target table.  Open the table, if there aren't any rows, ok.  If there are rows, open a scan on the referenced key with table locking at level 2.  Pass in the scans to the BulkRIChecker.  If any rows fail, barf.
 * @param tc		transaction controller
 * @param dd		data dictionary
 * @param fk		foreign key constraint
 * @param refcd	referenced key
 * @param indexTemplateRow	index template row
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fk</ParamName>
                    <ParamType>ForeignKeyConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refcd</ParamName>
                    <ParamType>ReferencedKeyConstraintDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexTemplateRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroupFetchScanController [refScan=null]</InnerVar>
                <InnerVar>GroupFetchScanController [fkScan=tc.openGroupFetchScan(fk.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),false,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_READ_COMMITTED,(FormatableBitSet)null,(DataValueDescriptor[])null,ScanController.GE,null,(DataValueDescriptor[])null,ScanController.GT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateConstraint</MethodName>
            <MethodComment>/** 
 * Evaluate a check constraint or not null column constraint.   Generate a query of the form SELECT COUNT(*) FROM t where NOT(&lt;check constraint&gt;) and run it by compiling and executing it.   Will work ok if the table is empty and query returns null.
 * @param constraintName	constraint name
 * @param constraintText	constraint text
 * @param constraintId      constraint id
 * @param td				referenced table
 * @param lcc				the language connection context
 * @param isCheckConstraint	the constraint is a check constraint
 * @param isInitiallyDeferred {@code true} if the constraint isinitially deferred
 * @return true if null constraint passes, false otherwise
 * @exception StandardException if check constraint fails
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>constraintName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isCheckConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInitiallyDeferred</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [checkStmt=new StringBuilder()]</InnerVar>
                <InnerVar>ResultSet [rs=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>checkStmt;append;["SELECT COUNT(*) FROM "]</InnerMethodInvoke>
                <InnerMethodInvoke>checkStmt;append;[td.getQualifiedName()]</InnerMethodInvoke>
                <InnerMethodInvoke>checkStmt;append;[" WHERE NOT("]</InnerMethodInvoke>
                <InnerMethodInvoke>checkStmt;append;[constraintText]</InnerMethodInvoke>
                <InnerMethodInvoke>checkStmt;append;[")"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>