<Class>
    <Id>1320</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>Like</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Like  /** 
 * Like matching algorithm. Not too speedy for %s. SQL92 says the escape character can only and must be followed by itself, %, or _.  So if you choose % or _ as the escape character, you can no longer do that sort of matching. Not the most recent Like -- missing the unit tests
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>anyChar</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>anyString</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>SUPER_STRING</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>Like</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>like</MethodName>
            <MethodComment>/** 
 * This method gets called for UCS_BASIC and territory based character string types to look for a pattern in a value string. It also deals with escape character if user has provided one.
 * @param val value to compare. if null, result is null.
 * @param valLength length of val
 * @param pat pattern to compare. if null, result is null.
 * @param patLength length of pat
 * @param escape escape character. Must be 1 char long.if null, no escape character is used.
 * @param escapeLength length of escape
 * @param collator null if we are dealing with UCS_BASIC character string types. If not null, then we use it to  get collation elements for characters in val and  non-metacharacters in pat to do the comparison.
 * @return null if val or pat null, otherwise true if matchand false if not.
 * @exception StandardException thrown if data invalid
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pat</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>patLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escapeLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collator</ParamName>
                    <ParamType>RuleBasedCollator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>like</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pat</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escapeLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collator</ParamName>
                    <ParamType>RuleBasedCollator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char [escChar=' ']</InnerVar>
                <InnerVar>boolean [haveEsc=true]</InnerVar>
                <InnerVar>Boolean [result]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkEquality</MethodName>
            <MethodComment>/** 
 * If the character in val matches the character in pat, then it does not matter if the database is UCS_BASIC or territory based, we simply return  TRUE from the method.  If the characters do not match and we are running with UCS_BASIC  collation, then we will return FALSE.  But if the database is territory based, then we want to use the Collator  for the territory to determine if the Collator treats the 2 characters  as equal (ie if their collation elements match, then the 2 characters  are equal even if they  are not the same character).
 * @param val value to compare.
 * @param vLoc character position in val.
 * @param pat pattern to look for in val.
 * @param pLoc character position in pat.
 * @param collator null if we are dealing with UCS_BASIC character stringtypes. If not null, then we use it to determine the equality of the 2 characters in pat and val if they are not same.
 * @return TRUE if the character in val and vLoc match based on straightequality or collation element based equality. Otherwise we will  return FALSE.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pat</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collator</ParamName>
                    <ParamType>RuleBasedCollator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [s1=new String(val,vLoc,1)]</InnerVar>
                <InnerVar>String [s2=new String(pat,pLoc,1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMinLen</MethodName>
            <MethodComment>/** 
 * Calculate the shortest length string that could match this pattern
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pStart</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>haveEsc</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [m=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkLengths</MethodName>
            <MethodComment>/** 
 * checkLengths   Returns null if we are not done. Returns true if we are at the end of our value and pattern Returns false if there is more pattern left but out of input value
 * @param vLoc current index into char[] val
 * @param vEnd end index or our value
 * @param pLoc current index into our char[] pattern
 * @param pat  pattern char []
 * @param pEnd end index of our pattern []
 */
</MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pLoc</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pat</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pEnd</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>like</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>valueLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>char[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>patternLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collator</ParamName>
                    <ParamType>RuleBasedCollator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOptimizable</MethodName>
            <MethodComment>/** 
 * Determine whether or not this LIKE can be transformed into optimizable clauses.  It can if the pattern is non-null and if the length == 0 or the first character is not a wild card.
 * @param pattern	The right side of the LIKE
 * @return	Whether or not the LIKE can be transformed
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char [firstChar=pattern.charAt(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterEqualStringFromParameter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterEqualStringFromParameterWithEsc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterEqualString</MethodName>
            <MethodComment>/** 
 * Return the substring from the pattern for the optimization &amp;gt;= clause.
 * @param pattern	The right side of the LIKE
 * @param escape	The escape clause
 * @param maxWidth	Maximum length of column, for null padding
 * @return	The String for the &amp;gt;= clause
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstAnyChar=pattern.indexOf(anyChar)]</InnerVar>
                <InnerVar>int [firstAnyString=pattern.indexOf(anyString)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>greaterEqualString</MethodName>
            <MethodComment>/** 
 * greaterEqualString -- for Escape clause only Walk the pattern character by character
 * @param pattern like pattern to build from
 * @param escChar the escape character in the pattern
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [patternLen=pattern.length()]</InnerVar>
                <InnerVar>char[] [patternChars=new char[patternLen]]</InnerVar>
                <InnerVar>char[] [result=new char[patternLen]]</InnerVar>
                <InnerVar>int [r=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pattern;getChars;[0, patternLen, patternChars, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stripEscapesNoPatternChars</MethodName>
            <MethodComment>/** 
 * stripEscapesNoPatternChars
 * @param pattern	pattern String to search
 * @param escChar	the escape character
 * @return a stripped of ESC char string if no pattern chars, null otherwise
 * @exception StandardException thrown if data invalid
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [patternLen=pattern.length()]</InnerVar>
                <InnerVar>char[] [patternChars=new char[patternLen]]</InnerVar>
                <InnerVar>char[] [result=new char[patternLen]]</InnerVar>
                <InnerVar>int [r=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pattern;getChars;[0, patternLen, patternChars, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lessThanStringFromParameter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lessThanStringFromParameterWithEsc</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lessThanString</MethodName>
            <MethodComment>/** 
 * Return the substring from the pattern for the &amp;lt; clause.
 * @param pattern	The right side of the LIKE
 * @param escape	The escape clause
 * @param maxWidth	Maximum length of column, for null padding
 * @return	The String for the &amp;lt; clause
 * @exception StandardException thrown if data invalid
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>escape</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [lastUsableChar]</InnerVar>
                <InnerVar>char [oldLastChar]</InnerVar>
                <InnerVar>char [newLastChar]</InnerVar>
                <InnerVar>int [escChar]</InnerVar>
                <InnerVar>StringBuffer [upperLimit=new StringBuffer(maxWidth)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>upperLimit;setCharAt;[lastUsableChar, newLastChar]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLikeComparisonNeeded</MethodName>
            <MethodComment>/** 
 * Return whether or not the like comparison is still needed after performing the like transformation on a constant string.  The comparison is not needed if the constant string is of the form: CONSTANT%  (constant followed by a trailing %)
 * @param pattern	The right side of the LIKE
 * @return Whether or not the like comparison is still needed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [firstAnyChar=pattern.indexOf(anyChar)]</InnerVar>
                <InnerVar>int [firstAnyString=pattern.indexOf(anyString)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padWithNulls</MethodName>
            <MethodComment>/** 
 * Pad a string with null characters, in order to make it &amp;gt; and &amp;lt; comparable with SQLChar.
 * @param string	The string to pad
 * @param len		Max number of characters to pad to
 * @return the string padded with 0s up to the given length
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buf=new StringBuffer(len).append(string)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buf;setLength;[len]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>