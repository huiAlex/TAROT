<Class>
    <Id>1778</Id>
    <Package>org.apache.derby.iapi.sql.execute</Package>
    <ClassName>ResultSetFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ResultSetFactory  /** 
 * ResultSetFactory provides a wrapper around all of the result sets needed in an execution implementation. &lt;p&gt; For the activations to avoid searching for this module in their execute methods, the base activation supertype should implement a method that does the lookup and salts away this factory for the activation to use as it needs it.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>MODULE</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getDDLResultSet</MethodName>
            <MethodComment>/** 
 * Generic DDL result set creation.
 * @param activation 		the activation for this result set
 * @return	ResultSet	A wrapper result set to run the Execution-timelogic.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMiscResultSet</MethodName>
            <MethodComment>/** 
 * Generic Misc result set creation.
 * @param activation 		the activation for this result set
 * @return	ResultSet	A wrapper result set to run the Execution-timelogic.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetTransactionResultSet</MethodName>
            <MethodComment>/** 
 * @param activation 		the activation for this result set
 * @return	ResultSet	A wrapper result set to run the Execution-timelogic.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInsertResultSet</MethodName>
            <MethodComment>/** 
 * An insert result set simply reports that it completed, and the number of rows inserted.  It does not return rows. The insert has been completed once the insert result set is available.
 * @param source the result set from which to take rows tobe inserted into the target table.
 * @param generationClauses	The code to compute column generation clauses if any
 * @param checkGM	The code to enforce the check constraints, if any
 * @param fullTemplate Saved item for a row template used by bulk insert,or -1 if this is not a bulk insert
 * @param schemaNameName schema name of table
 * @param tableName table name
 * @return the insert operation as a result set.
 * @exception StandardException thrown when unable to perform the insert
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generationClauses</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkGM</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaNameName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInsertVTIResultSet</MethodName>
            <MethodComment>/** 
 * An insert VTI result set simply reports that it completed, and the number of rows inserted.  It does not return rows. The insert has been completed once the insert result set is available.
 * @param source the result set from which to take rows tobe inserted into the target table.
 * @param vtiRS	The code to instantiate the VTI, if necessary
 * @return the insert VTI operation as a result set.
 * @exception StandardException thrown when unable to perform the insert
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiRS</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeleteVTIResultSet</MethodName>
            <MethodComment>/** 
 * A delete VTI result set simply reports that it completed, and the number of rows deleted.  It does not return rows. The delete has been completed once the delete result set is available.
 * @param source the result set from which to take rows tobe inserted into the target table.
 * @return the delete VTI operation as a result set.
 * @exception StandardException thrown when unable to perform the insert
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeleteResultSet</MethodName>
            <MethodComment>/** 
 * A delete result set simply reports that it completed, and the number of rows deleted.  It does not return rows. The delete has been completed once the delete result set is available.
 * @param source the result set from which to take rows tobe deleted from the target table. This result set must contain one column which provides RowLocations that are valid in the target table.
 * @return the delete operation as a result set.
 * @exception StandardException thrown when unable to perform the delete
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMergeResultSet</MethodName>
            <MethodComment>/** 
 * A MERGE result set simply reports that it completed, and the number of rows that it INSERTed/UPDATEd/DELETEdd.  It does not return rows. The delete has been completed once the MERGE result set is available.
 * @param drivingLeftJoin the result set from which to take rows tobe drive the INSERT/UPDATE/DELETE operations.
 * @return the MERGE operation as a result set.
 * @exception StandardException thrown when unable to perform the work
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drivingLeftJoin</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeleteCascadeResultSet</MethodName>
            <MethodComment>/** 
 * A delete Cascade result set simply reports that it completed, and the number of rows deleted.  It does not return rows. The delete has been completed once the delete result set is available.
 * @param source the result set from which to take rows tobe deleted from the target table.
 * @param constantActionItem a constant action saved object reference
 * @param dependentResultSets an array of DeleteCascade Resultsetsfor the current table referential action dependents tables.
 * @param resultSetId  an Id which is used to store the refenceto the temporary result set created of the materilized rows.Dependent table resultsets uses the same id to access their parent temporary result sets.
 * @return the delete operation as a delete cascade result set.
 * @exception StandardException thrown when unable to perform the delete
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constantActionItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependentResultSets</ParamName>
                    <ParamType>ResultSet[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateResultSet</MethodName>
            <MethodComment>/** 
 * An update result set simply reports that it completed, and the number of rows updated.  It does not return rows. The update has been completed once the update result set is available.
 * @param source the result set from which to take rows to be updated in the target table. This result set must contain  a column which provides RowLocations that are valid in the  target table, and new values to be placed in those rows.
 * @param generationClauses	The code to compute column generation clauses if any
 * @param checkGM	The code to enforce the check constraints, if any
 * @return the update operation as a result set.
 * @exception StandardException thrown when unable to perform the update
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generationClauses</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkGM</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateVTIResultSet</MethodName>
            <MethodComment>/** 
 * @param source the result set from which to take rows to be updated in the target table.
 * @return the update operation as a result set.
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeleteCascadeUpdateResultSet</MethodName>
            <MethodComment>/** 
 * An update result set simply reports that it completed, and the number of rows updated.  It does not return rows. The update has been completed once the update result set is available.
 * @param source the result set from which to take rows to be updated in the target table. This result set must contain  a column which provides RowLocations that are valid in the  target table, and new values to be placed in those rows.
 * @param generationClauses	The code to compute generated columns, if any
 * @param checkGM	The code to enforce the check constraints, if any
 * @param constantActionItem a constant action saved object reference
 * @param rsdItem   result Description, saved object id. 				
 * @return the update operation as a result set.
 * @exception StandardException thrown when unable to perform the update
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>generationClauses</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>checkGM</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constantActionItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rsdItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCallStatementResultSet</MethodName>
            <MethodComment>/** 
 * A call statement result set simply reports that it completed.   It does not return rows.
 * @param methodCall a reference to a method in the activationfor the method call
 * @param activation the activation for this result set
 * @return the call statement operation as a result set.
 * @exception StandardException thrown when unable to perform the call statement
 */
</MethodComment>
            <ReturnType>ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodCall</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getProjectRestrictResultSet</MethodName>
            <MethodComment>/** 
 * A project restrict result set iterates over its source, evaluating a restriction and when it is satisfied, constructing a row to return in its result set based on its projection. The rows can be constructed as they are requested from the result set.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param restriction a reference to a method in the activationthat is applied to the activation's "current row" field to determine whether the restriction is satisfied or not. The signature of this method is &lt;verbatim&gt; Boolean restriction() throws StandardException; &lt;/verbatim&gt;
 * @param projection a reference to a method in the activationthat is applied to the activation's "current row" field to project out the expected result row. The signature of this method is &lt;verbatim&gt; ExecRow projection() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param constantRestriction a reference to a method in the activationthat represents a constant expression (eg where 1 = 2). The signature of this method is &lt;verbatim&gt; Boolean restriction() throws StandardException; &lt;/verbatim&gt;
 * @param mapArrayItem	Item # for mapping of source to target columns
 * @param cloneMapItem Item # for columns that need cloning
 * @param reuseResult  Whether or not to reuse the result row.
 * @param doesProjection	Whether or not this PRN does a projection
 * @param validatingCheckConstraint {@code true if this PRN is used tofor validating a deferred check constraint}.
 * @param validatingBaseTableUUIDString The uuid for the table beingvalidated.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the project restrict operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restriction</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>projection</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constantRestriction</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mapArrayItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cloneMapItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuseResult</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>doesProjection</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validatingCheckConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validatingBaseTableUUIDString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHashTableResultSet</MethodName>
            <MethodComment>/** 
 * A hash table result set builds a hash table on its source, applying a list of predicates, if any, to the source, when building the hash table.  It then does a look up into the hash table on a probe. The rows can be constructed as they are requested from the result set.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param singleTableRestriction restriction, if any, applied toinput of hash table.
 * @param equijoinQualifiers Qualifier[] for look up into hash table
 * @param projection a reference to a method in the activationthat is applied to the activation's "current row" field to project out the expected result row. The signature of this method is &lt;verbatim&gt; ExecRow projection() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param mapRefItem	Item # for mapping of source to target columns
 * @param reuseResult	Whether or not to reuse the result row.
 * @param keyColItem	Item for hash key column array
 * @param removeDuplicates	Whether or not to remove duplicates when building the hash table
 * @param maxInMemoryRowCount			Max size of in-memory hash table
 * @param initialCapacity				initialCapacity for java.util.HashTable
 * @param loadFactor					loadFactor for java.util.HashTable
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the project restrict operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singleTableRestriction</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>equijoinQualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>projection</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mapRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuseResult</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>keyColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>removeDuplicates</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxInMemoryRowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadFactor</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSortResultSet</MethodName>
            <MethodComment>/** 
 * A sort result set sorts its source and if requested removes duplicates.  It will generate the entire result when open, and then return it a row at a time. &lt;p&gt; If passed aggregates it will do scalar or vector aggregate processing.  A list of aggregator information is passed off of the PreparedStatement's savedObjects.  Aggregation and SELECT DISTINCT cannot be processed in the same sort.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param distinct true if distinct SELECT list
 * @param isInSortedOrder	true if the source result set is in sorted order
 * @param orderItem entry in preparedStatement's savedObjects for order
 * @param rowAllocator a reference to a saved objectthat generates rows of the right size and shape for the source
 * @param rowSize the size of the row that is allocated by rowAllocator.size should be the maximum size of the sum of all the datatypes. user type are necessarily approximated
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the distinct operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distinct</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScalarAggregateResultSet</MethodName>
            <MethodComment>/** 
 * A ScalarAggregateResultSet computes non-distinct scalar aggregates. It will compute the aggregates when open.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param isInSortedOrder	true if the source result set is in sorted order
 * @param aggregateItem entry in preparedStatement's savedObjects for aggregates
 * @param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
 * @param rowAllocator     a reference to a saved objectthat generates rows of the right size and shape for the source
 * @param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param singleInputRow	Whether we know we have a single input row or not
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the scalar aggregation operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderingItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singleInputRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDistinctScalarAggregateResultSet</MethodName>
            <MethodComment>/** 
 * A DistinctScalarAggregateResultSet computes scalar aggregates when  at least one of them is a distinct aggregate. It will compute the aggregates when open.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param isInSortedOrder	true if the source result set is in sorted order
 * @param aggregateItem entry in preparedStatement's savedObjects for aggregates
 * @param orderingItem entry in preparedStatement's savedObjects for order
 * @param rowAllocator a reference to a saved objectthat generates rows of the right size and shape for the source
 * @param rowSize the size of the row that is allocated by rowAllocator.size should be the maximum size of the sum of all the datatypes. user type are necessarily approximated
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param singleInputRow	Whether we know we have a single input row or not
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the scalar aggregation operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderingItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singleInputRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGroupedAggregateResultSet</MethodName>
            <MethodComment>/** 
 * A GroupedAggregateResultSet computes non-distinct grouped aggregates. It will compute the aggregates when open.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param isInSortedOrder	true if the source result set is in sorted order
 * @param aggregateItem entry in preparedStatement's savedObjects for aggregates
 * @param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
 * @param rowAllocator     a reference to a saved objectthat generates rows of the right size and shape for the source
 * @param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param isRollup true if this is a GROUP BY ROLLUP()
 * @return the scalar aggregation operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderingItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRollup</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDistinctGroupedAggregateResultSet</MethodName>
            <MethodComment>/** 
 * A DistinctGroupedAggregateResultSet computes scalar aggregates when  at least one of them is a distinct aggregate. It will compute the aggregates when open.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param isInSortedOrder	true if the source result set is in sorted order
 * @param aggregateItem entry in preparedStatement's savedObjects for aggregates
 * @param orderingItem entry in preparedStatement's savedObjects for order
 * @param rowAllocator a reference to a saved objectthat generates rows of the right size and shape for the source
 * @param rowSize the size of the row that is allocated by rowAllocator.size should be the maximum size of the sum of all the datatypes. user type are necessarily approximated
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param isRollup true if this is a GROUP BY ROLLUP()
 * @return the scalar aggregation operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderingItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRollup</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAnyResultSet</MethodName>
            <MethodComment>/** 
 * An any result set iterates over its source, returning a row with all columns set to nulls if the source returns no rows.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param emptyRowFun a reference to a method in the activationthat is called if the source returns no rows
 * @param resultSetNumber		The resultSetNumber for the ResultSet
 * @param subqueryNumber		The subquery number for this subquery.
 * @param pointOfAttachment	The point of attachment for this subquery.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the any operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>emptyRowFun</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pointOfAttachment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOnceResultSet</MethodName>
            <MethodComment>/** 
 * A once result set iterates over its source, raising an error if the source returns &amp;gt; 1 row and returning a row with all columns set to nulls if the source returns no rows.
 * @param source the result set from which to take rows to be filtered by this operation.
 * @param emptyRowFun a reference to a method in the activationthat is called if the source returns no rows
 * @param cardinalityCheck The type of cardinality check, if any thatis required
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param subqueryNumber		The subquery number for this subquery.
 * @param pointOfAttachment	The point of attachment for this subquery.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the once operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>emptyRowFun</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cardinalityCheck</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pointOfAttachment</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowResultSet</MethodName>
            <MethodComment>/** 
 * A row result set forms a result set on a single, known row value. It is used to turn constant rows into result sets for use in the result set paradigm. The row can be constructed when it is requested from the result set.
 * @param activation the activation for this result set,against which the row operation is performed to create the result set.
 * @param row a reference to a method in the activationthat creates the expected row. &lt;verbatim&gt; ExecRow row() throws StandardException; &lt;/verbatim&gt;
 * @param canCacheRow	True if execution can cache the input rowafter it has gotten it.  If the input row is constructed soley of constants or parameters, it is ok to cache this row rather than recreating it each time it is requested.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the row as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>canCacheRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVTIResultSet</MethodName>
            <MethodComment>/** 
 * A VTI result set wraps a user supplied result set.
 * @param activation the activation for this result set,against which the row operation is performed to create the result set.
 * @param row a reference to a saved objectthat creates the expected row.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param constructor		The GeneratedMethod for the user's constructor
 * @param javaClassName	The java class name for the VTI
 * @param erdNumber		int for referenced column BitSet (so it can be turned back into an object)
 * @param version2			Whether or not VTI is a version 2 VTI.
 * @param isTarget			Whether or not VTI is a target VTI.
 * @param optimizerEstimatedRowCount	Estimated total # of rows by optimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param isDerbyStyleTableFunction    True if this is a Derby-style table function
 * @param returnTypeNumber	Which saved object contains the return type (a multi-set) serialized as a byte array
 * @param vtiProjectionNumber	Which saved object contains the projection for a RestrictedVTI
 * @param vtiRestrictionNumber	Which saved object contains the restriction for a RestrictedVTI
 * @param vtiSchema   Name of the schema holding the table function.
 * @param vtiName      Name of the table function.
 * @return the row as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constructor</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>javaClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pushedQualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>erdNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>version2</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuseablePs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ctcNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isTarget</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanIsolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isDerbyStyleTableFunction</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnTypeNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiProjectionNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiRestrictionNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiSchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vtiName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHashScanResultSet</MethodName>
            <MethodComment>/** 
 * A hash result set forms a result set on a hash table built on a scan of a table. The rows are put into the hash table on the 1st open. &lt;p&gt;
 * @param activation the activation for this result set,which provides the context for the row allocation operation.
 * @param conglomId the conglomerate of the table to be scanned.
 * @param scociItem The saved item for the static conglomerate info.
 * @param resultRowTemplate The saved item for result row template.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param startKeyGetter a reference to a method in the activationthat gets the start key indexable row for the scan.  Null means there is no start key. &lt;verbatim&gt; ExecIndexRow startKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param startSearchOperator The start search operator for openingthe scan
 * @param stopKeyGetter	a reference to a method in the activationthat gets the stop key indexable row for the scan.  Null means there is no stop key. &lt;verbatim&gt; ExecIndexRow stopKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param stopSearchOperator	The stop search operator for openingthe scan
 * @param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter(Exact match search.)
 * @param scanQualifiers the array of Qualifiers for the scan.Null or an array length of zero means there are no qualifiers.
 * @param nextQualifiers the array of Qualifiers for the look up into the hash table.
 * @param initialCapacity	The initialCapacity for the HashTable.
 * @param loadFactor		The loadFactor for the HashTable.
 * @param maxCapacity		The maximum size for the HashTable.
 * @param hashKeyColumn	The 0-based column # for the hash key.
 * @param tableName		The full name of the table 
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName		The name of the index, if one used to access table.
 * @param isConstraint		If index, if used, is a backing index for a constraint.
 * @param forUpdate		True means open for update
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the table scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanQualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nextQualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>initialCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>loadFactor</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxCapacity</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hashKeyColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDistinctScanResultSet</MethodName>
            <MethodComment>/** 
 * A distinct scan result set pushes duplicate elimination into the scan. &lt;p&gt;
 * @param activation the activation for this result set,which provides the context for the row allocation operation.
 * @param conglomId the conglomerate of the table to be scanned.
 * @param scociItem The saved item for the static conglomerate info.
 * @param resultRowTemplate The saved item for result row template.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param hashKeyColumn	The 0-based column # for the hash key.
 * @param tableName		The full name of the table
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName		The name of the index, if one used to access table.
 * @param isConstraint		If index, if used, is a backing index for a constraint.
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the table scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hashKeyColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValidateCheckConstraintResultSet</MethodName>
            <MethodComment>/** 
 * A table scan result set forms a result set on a scan of a table. The rows can be constructed as they are requested from the result set. &lt;p&gt; This form of the table scan operation is simple, and is to be used when there are no predicates to be passed down to the scan to limit its scope on the target table.
 * @param conglomId the conglomerate of the table to be scanned.
 * @param scociItem The saved item for the static conglomerate info.
 * @param activation the activation for this result set,which provides the context for the row allocation operation.
 * @param resultRowTemplate The saved item for result row template.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param startKeyGetter a reference to a method in the activationthat gets the start key indexable row for the scan.  Null means there is no start key. &lt;verbatim&gt; ExecIndexRow startKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param startSearchOperator The start search operator for openingthe scan
 * @param stopKeyGetter	a reference to a method in the activationthat gets the stop key indexable row for the scan.  Null means there is no stop key. &lt;verbatim&gt; ExecIndexRow stopKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param stopSearchOperator	The stop search operator for openingthe scan
 * @param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter(Exact match search.)
 * @param qualifiers the array of Qualifiers for the scan.Null or an array length of zero means there are no qualifiers.
 * @param tableName		The full name of the table
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName		The name of the index, if one used to access table.
 * @param isConstraint		If index, if used, is a backing index for a constraint.
 * @param forUpdate		True means open for update
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param oneRowScan		Whether or not this is a 1 row scan.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the table scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableScanResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBulkTableScanResultSet</MethodName>
            <MethodComment>/** 
 * A table scan result set forms a result set on a scan of a table. The rows can be constructed as they are requested from the result set. &lt;p&gt; This form of the table scan operation is simple, and is to be used when there are no predicates to be passed down to the scan to limit its scope on the target table.
 * @param conglomId the conglomerate of the table to be scanned.
 * @param scociItem The saved item for the static conglomerate info.
 * @param activation the activation for this result set,which provides the context for the row allocation operation.
 * @param resultRowTemplate The saved item for result row template.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param startKeyGetter a reference to a method in the activationthat gets the start key indexable row for the scan.  Null means there is no start key. &lt;verbatim&gt; ExecIndexRow startKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param startSearchOperator The start search operator for openingthe scan
 * @param stopKeyGetter	a reference to a method in the activationthat gets the stop key indexable row for the scan.  Null means there is no stop key. &lt;verbatim&gt; ExecIndexRow stopKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param stopSearchOperator	The stop search operator for openingthe scan
 * @param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter(Exact match search.)
 * @param qualifiers the array of Qualifiers for the scan.Null or an array length of zero means there are no qualifiers.
 * @param tableName		The full name of the table
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName		The name of the index, if one used to access table.
 * @param isConstraint		If index, if used, is a backing index for a constraint.
 * @param forUpdate		True means open for update
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param rowsPerRead		The number of rows to read per fetch.
 * @param disableForHoldable Whether or not bulk fetch should be disabledat runtime if the cursor is holdable.
 * @param oneRowScan		Whether or not this is a 1 row scan.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the table scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowsPerRead</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>disableForHoldable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMultiProbeTableScanResultSet</MethodName>
            <MethodComment>/** 
 * A multi-probe result set, used for probing an index with one or more target values (probeValues) and returning the matching rows.  This type of result set is useful for IN lists as it allows us to avoid scannning an entire, potentially very large, index for a mere handful of rows (DERBY-47). All arguments are the same as for TableScanResultSet, plus the following:
 * @param probeVals List of values with which to probe the underlyingtable. Should not be null.
 * @param sortRequired Which type of sort we need for the values(ascending, descending, or none).
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>probeVals</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sortRequired</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIndexRowToBaseRowResultSet</MethodName>
            <MethodComment>/** 
 * An index row to base row result set gets an index row from its source and uses the RowLocation in its last column to get the row from the base conglomerate. &lt;p&gt;
 * @param conglomId	Conglomerate # for the heap.
 * @param scoci The saved item for the static conglomerate info.
 * @param source	the source result set, which is expected to providerows from an index conglomerate
 * @param resultRowAllocator a reference to a method in the activationthat creates a holder for the rows from the scan. &lt;verbatim&gt; ExecRow rowAllocator() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param indexName		The name of the index.
 * @param heapColRefItem	A saved item for a bitImpl of columns thatare referenced in the underlying heap.  -1 if no item.
 * @param allColRefItem A saved item for a bitImpl of columnsthat are referenced in the underlying index and heap.  -1 if no item.
 * @param heapOnlyColRefItem A saved item for a bitImpl ofcolumns that are referenced in the underlying heap only.  -1 if no item.
 * @param indexColMapItem	A saved item for a ReferencedColumnsDescriptorImplwhich tell  which columms are coming from the index.
 * @param restriction		The restriction, if any, to be applied to the base row
 * @param forUpdate		True means to open for update
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param baseColumnCount		Number of columns in the base table
 * @return the index row to base row operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scoci</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapColRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allColRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>heapOnlyColRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColMapItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restriction</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseColumnCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWindowResultSet</MethodName>
            <MethodComment>/** 
 * A OLAP window on top of a regular result set. It is used to realize window functions. &lt;p&gt;
 * @param activation   Activation
 * @param source       The result set input to this result set.
 * @param rowAllocator A reference to a saved objectthat generates rows of the right size and shape for the source.
 * @param resultSetNumber The resultSetNumber for the ResultSet
 * @param erdNumber    Int for ResultDescription(so it can be turned back into an object)
 * @param restriction  The restriction, if any, to be applied to thebase row
 * @param optimizerEstimatedRowCount Estimated total # of rows by optimizer
 * @param optimizerEstimatedCost Estimated total cost by optimizer
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowAllocator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>erdNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>restriction</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNestedLoopJoinResultSet</MethodName>
            <MethodComment>/** 
 * A nested loop left outer join result set forms a result set on top of 2 other result sets. The rows can be constructed as they are requested from the result set. &lt;p&gt; This form of the nested loop join operation is simple, and is to be used when there are no join predicates to be passed down to the join to limit its scope on the right ResultSet.
 * @param leftResultSet	Outer ResultSet for join.
 * @param leftNumCols		Number of columns in the leftResultSet
 * @param rightResultSet	Inner ResultSet for join.
 * @param rightNumCols		Number of columns in the rightResultSet
 * @param joinClause a reference to a method in the activationthat is applied to the activation's "current row" field to determine whether the joinClause is satisfied or not. The signature of this method is &lt;verbatim&gt; Boolean joinClause() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param oneRowRightSide	boolean, whether or not the right side returnsa single row.  (No need to do 2nd next() if it does.)
 * @param notExistsRightSide	boolean, whether or not the right side resides aNOT EXISTS base table
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @return the nested loop join operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinClause</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>notExistsRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHashJoinResultSet</MethodName>
            <MethodComment>/** 
 * A hash join.
 * @param leftResultSet	Outer ResultSet for join.
 * @param leftNumCols		Number of columns in the leftResultSet
 * @param rightResultSet	Inner ResultSet for join.
 * @param rightNumCols		Number of columns in the rightResultSet
 * @param joinClause a reference to a method in the activationthat is applied to the activation's "current row" field to determine whether the joinClause is satisfied or not. The signature of this method is &lt;verbatim&gt; Boolean joinClause() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param oneRowRightSide	boolean, whether or not the right side returnsa single row.  (No need to do 2nd next() if it does.)
 * @param notExistsRightSide	boolean, whether or not the right side resides aNOT EXISTS base table
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @return the nested loop join operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinClause</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>notExistsRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNestedLoopLeftOuterJoinResultSet</MethodName>
            <MethodComment>/** 
 * A nested loop join result set forms a result set on top of 2 other result sets. The rows can be constructed as they are requested from the result set. &lt;p&gt; This form of the nested loop join operation is simple, and is to be used when there are no join predicates to be passed down to the join to limit its scope on the right ResultSet.
 * @param leftResultSet	Outer ResultSet for join.
 * @param leftNumCols		Number of columns in the leftResultSet
 * @param rightResultSet	Inner ResultSet for join.
 * @param rightNumCols		Number of columns in the rightResultSet
 * @param joinClause a reference to a method in the activationthat is applied to the activation's "current row" field to determine whether the joinClause is satisfied or not. The signature of this method is &lt;verbatim&gt; Boolean joinClause() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param emptyRowFun a reference to a method in the activationthat is called if the right child returns no rows
 * @param wasRightOuterJoin	Whether or not this was originally a right outer join
 * @param oneRowRightSide	boolean, whether or not the right side returnsa single row.  (No need to do 2nd next() if it does.)
 * @param notExistsRightSide	boolean, whether or not the right side resides aNOT EXISTS base table
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @return the nested loop join operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinClause</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>emptyRowFun</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wasRightOuterJoin</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>notExistsRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHashLeftOuterJoinResultSet</MethodName>
            <MethodComment>/** 
 * A left outer join using a hash join.
 * @param leftResultSet	Outer ResultSet for join.
 * @param leftNumCols		Number of columns in the leftResultSet
 * @param rightResultSet	Inner ResultSet for join.
 * @param rightNumCols		Number of columns in the rightResultSet
 * @param joinClause a reference to a method in the activationthat is applied to the activation's "current row" field to determine whether the joinClause is satisfied or not. The signature of this method is &lt;verbatim&gt; Boolean joinClause() throws StandardException; &lt;/verbatim&gt;
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param emptyRowFun a reference to a method in the activationthat is called if the right child returns no rows
 * @param wasRightOuterJoin	Whether or not this was originally a right outer join
 * @param oneRowRightSide	boolean, whether or not the right side returnsa single row.  (No need to do 2nd next() if it does.)
 * @param notExistsRightSide	boolean, whether or not the right side resides aNOT EXISTS base table
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @return the nested loop join operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leftNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightResultSet</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightNumCols</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>joinClause</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>emptyRowFun</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wasRightOuterJoin</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>notExistsRightSide</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaterializedResultSet</MethodName>
            <MethodComment>/** 
 * A ResultSet which materializes the underlying ResultSet tree into a  temp table on the 1st open.  All subsequent "scans" of this ResultSet will return results from the temp table.
 * @param source the result set input to this result set.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the materialization operation as a result set.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScrollInsensitiveResultSet</MethodName>
            <MethodComment>/** 
 * A ResultSet which provides the insensitive scrolling functionality for the underlying result set by materializing the underlying ResultSet  tree into a hash table while scrolling forward.
 * @param source the result set input to this result set.
 * @param activation the activation for this result set,which provides the context for normalization.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param sourceRowWidth	The # of columns in the source row.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the materialization operation as a result set.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceRowWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scrollable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNormalizeResultSet</MethodName>
            <MethodComment>/** 
 * REMIND: needs more description...
 * @param source the result set input to this result set.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param erdNumber	int for ResultDescription (so it can be turned back into an object)
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the normalization operation as a result set.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>erdNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentOfResultSet</MethodName>
            <MethodComment>/** 
 * A current of result set forms a result set on the current row of an open cursor. It is used to perform positioned operations such as positioned update and delete, using the result set paradigm.
 * @param cursorName the name of the cursor providing the row.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cursorName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnionResultSet</MethodName>
            <MethodComment>/** 
 * The Union interface is used to evaluate the union (all) of two ResultSets. (Any duplicate elimination is performed above this ResultSet.) Forms a ResultSet returning the union of the rows in two source ResultSets.  The column types in source1 and source2 are assumed to be the same.
 * @param source1	The first ResultSet whose rows go into the union
 * @param source2	The second ResultSet whose rows go into theunion
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return	A ResultSet from which the caller can get the unionof the two source ResultSets.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source1</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>source2</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSetOpResultSet</MethodName>
            <MethodComment>/** 
 * The SetOpResultSet is used to implement an INTERSECT or EXCEPT operation. It selects rows from two ordered input result sets.
 * @param leftSource The result set that implements the left input
 * @param rightSource The result set that implements the right input
 * @param activation the activation for this result set
 * @param resultSetNumber
 * @param optimizerEstimatedRowCount
 * @param optimizerEstimatedCost
 * @param opType IntersectOrExceptNode.INTERSECT_OP or EXCEPT_OP
 * @param all true if the operation is an INTERSECT ALL or an EXCEPT ALL,false if the operation is an INTERSECT DISCTINCT or an EXCEPT DISCTINCT
 * @param intermediateOrderByColumnsSavedObject The saved object index for the array of order by columns for theordering of the left and right sources. That is, both the left and right sources have an order by clause of the form ORDER BY intermediateOrderByColumns[0],intermediateOrderByColumns[1],...
 * @param intermediateOrderByDirectionSavedObject The saved object index for the array of sourceorder by directions. That is, the ordering of the i'th order by column in the input is ascending if intermediateOrderByDirection[i] is 1, descending if intermediateOrderByDirection[i] is -1.
 * @return	A ResultSet from which the caller can get the INTERSECT or EXCEPT
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftSource</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightSource</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>opType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>all</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>intermediateOrderByColumnsSavedObject</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>intermediateOrderByDirectionSavedObject</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>intermediateOrderByNullsLowSavedObject</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastIndexKeyResultSet</MethodName>
            <MethodComment>/** 
 * A last index key result set returns the last row from the index in question.  It is used as an ajunct to max().
 * @param activation 		the activation for this result set,which provides the context for the row allocation operation.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param resultRowTemplate The saved item for result row template
 * @param conglomId 		the conglomerate of the table to be scanned.
 * @param tableName			The full name of the table
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName			The name of the index, if one used to access table.
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @return the scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRaDependentTableScanResultSet</MethodName>
            <MethodComment>/** 
 * A Dependent table scan result set forms a result set on a scan of a dependent table for the rows that got materialized on the scan of its parent table and if the row being deleted on parent table has a reference in the dependent table.
 * @param activation the activation for this result set,which provides the context for the row allocation operation.
 * @param conglomId the conglomerate of the table to be scanned.
 * @param scociItem The saved item for the static conglomerate info.
 * @param resultRowTemplate The saved item for result row template.
 * @param resultSetNumber	The resultSetNumber for the ResultSet
 * @param startKeyGetter a reference to a method in the activationthat gets the start key indexable row for the scan.  Null means there is no start key. &lt;verbatim&gt; ExecIndexRow startKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param startSearchOperator The start search operator for openingthe scan
 * @param stopKeyGetter	a reference to a method in the activationthat gets the stop key indexable row for the scan.  Null means there is no stop key. &lt;verbatim&gt; ExecIndexRow stopKeyGetter() throws StandardException; &lt;/verbatim&gt;
 * @param stopSearchOperator	The stop search operator for openingthe scan
 * @param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter(Exact match search.)
 * @param qualifiers the array of Qualifiers for the scan.Null or an array length of zero means there are no qualifiers.
 * @param tableName		The full name of the table
 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
 * @param indexName		The name of the index, if one used to access table.
 * @param isConstraint		If index, if used, is a backing index for a constraint.
 * @param forUpdate		True means open for update
 * @param colRefItem		An saved item for a bitSet of columns thatare referenced in the underlying table.  -1 if no item.
 * @param lockMode			The lock granularity to use (seeTransactionController in access)
 * @param tableLocked		Whether or not the table is marked as using table locking(in sys.systables)
 * @param isolationLevel	Isolation level (specified or not) to use on scans
 * @param oneRowScan		Whether or not this is a 1 row scan.
 * @param optimizerEstimatedRowCount	Estimated total # of rows byoptimizer
 * @param optimizerEstimatedCost		Estimated total cost by optimizer
 * @param parentResultSetId  Id to access the materialized temporary resultset from the reference stored in the activation.
 * @param fkIndexConglomId foreign key index conglomerate id.
 * @param fkColArrayItem  saved column array object  that matches the foreign key indexcolumns  and the resultset from the parent table.
 * @param rltItem row location template
 * @return the table scan operation as a result set.
 * @exception StandardException thrown when unable to create theresult set
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scociItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexColItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentResultSetId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkIndexConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkColArrayItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rltItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowCountResultSet</MethodName>
            <MethodComment>/** 
 * This result sets implements the filtering needed by &lt;result offset clause&gt; and &lt;fetch first clause&gt;. It is only ever generated if at least one of the two clauses is present.
 * @param source          The source result set being filtered
 * @param activation      The activation for this result set,which provides the context for the row allocation operation
 * @param resultSetNumber The resultSetNumber for the ResultSet
 * @param offsetMethod   The OFFSET parameter was specified
 * @param fetchFirstMethod The FETCH FIRST/NEXT parameter was specified
 * @param hasJDBClimitClause True if the offset/fetchFirst clauses were added by JDBC LIMIT escape syntax
 * @param optimizerEstimatedRowCount Estimated total # of rows by optimizer
 * @param optimizerEstimatedCost Estimated total cost by optimizer
 * @exception StandardException Standard error policy
 */
</MethodComment>
            <ReturnType>NoPutResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offsetMethod</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchFirstMethod</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasJDBClimitClause</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>