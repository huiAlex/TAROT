<Class>
    <Id>1150</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>MergeNode</ClassName>
    <SuperClass>DMLModStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MergeNode  /** 
 * &lt;p&gt; A MergeNode represents a MERGE statement. The statement looks like this... &lt;/p&gt; &lt;pre&gt; MERGE INTO targetTable USING sourceTable ON searchCondition matchingClause1 ... matchingClauseN &lt;/pre&gt; &lt;p&gt; ...where each matching clause looks like this... &lt;/p&gt; &lt;pre&gt; WHEN MATCHED [ AND matchingRefinement ] THEN DELETE &lt;/pre&gt; &lt;p&gt; ...or &lt;/p&gt; &lt;pre&gt; WHEN MATCHED [ AND matchingRefinement ] THEN UPDATE SET col1 = expr1, ... colM = exprM &lt;/pre&gt; &lt;p&gt; ...or &lt;/p&gt; &lt;pre&gt; WHEN NOT MATCHED [ AND matchingRefinement ] THEN INSERT columnList VALUES valueList &lt;/pre&gt; &lt;p&gt; The Derby compiler essentially rewrites this statement into a driving left join followed by a series of DELETE/UPDATE/INSERT actions. The left join looks like this: &lt;/p&gt; &lt;pre&gt; SELECT selectList FROM sourceTable LEFT OUTER JOIN targetTable ON searchCondition &lt;/pre&gt; &lt;p&gt; The selectList of the driving left join consists of the following: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;All of the columns mentioned in the searchCondition.&lt;/li&gt; &lt;li&gt;All of the columns mentioned in the matchingRefinement clauses.&lt;/li&gt; &lt;li&gt;All of the columns mentioned in the SET clauses and the INSERT columnLists and valueLists.&lt;/li&gt; &lt;li&gt;All additional columns needed for the triggers and foreign keys fired by the DeleteResultSets and UpdateResultSets constructed for the WHEN MATCHED clauses.&lt;/li&gt; &lt;li&gt;All additional columns needed to build index rows and evaluate generated columns needed by the UpdateResultSets constructed for the WHEN MATCHED...THEN UPDATE clauses.&lt;/li&gt; &lt;li&gt;A trailing targetTable.RowLocation column.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; The driving left join's selectList then looks like this... &lt;/p&gt; &lt;pre&gt; sc1, ..., scN, tc1, ..., tcM, targetTable.RowLocation &lt;/pre&gt; &lt;p&gt; Where sc1...scN are the columns we need from the source table (in alphabetical order) and tc1...tcM are the columns we need from the target table (in alphabetical order). &lt;/p&gt; &lt;p&gt; The matchingRefinement expressions are bound and generated against the FromList of the driving left join. Dummy DeleteNode, UpdateNode, and InsertNode statements are independently constructed in order to bind and generate the DELETE/UPDATE/INSERT actions. &lt;/p&gt; &lt;p&gt; At execution time, the targetTable.RowLocation column is used to determine whether a given driving row matches. The row matches iff targetTable.RowLocation is not null. The driving row is then assigned to the first DELETE/UPDATE/INSERT action to which it applies. The relevant columns from the driving row are extracted and buffered in a temporary table (the "then" rows) specific to that DELETE/UPDATE/INSERT action. After the driving left join has been processed, the DELETE/UPDATE/INSERT actions are run in order, each taking its corresponding temporary table as its source ResultSet. &lt;/p&gt; &lt;p&gt; Name resolution was a particularly thorny problem. This is because name resolution behaves differently for SELECTs and UPDATEs. In particular, while processing UPDATEs, the compiler throws away name resolution information; this happens as a consequence of work done on DERBY-1043. In the end, I had to invent more name resolution machinery in order to compensate for the differences in the handling of SELECTs and UPDATEs. If we are to allow subqueries in matching refinement clauses and in the values expressions of INSERT and UPDATE actions, then we probably need to remove this special name resolution machinery. And that, in turn, probably means revisiting DERBY-1043. &lt;/p&gt; &lt;p&gt; The special name resolution machinery involves marking source and target column references in order to make it clear which table they belong to. This is done in associateColumn(). The markers are consulted at code-generation time in order to resolve column references when we generate the expressions needed to populate the rows which go into the temporary tables. That resolution happens in MatchingClauseNode.getSelectListOffset(). &lt;/p&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>SOURCE_TABLE_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TARGET_TABLE_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TARGET_ROW_LOCATION_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_targetTable</FieldName>
            <FieldType>FromBaseTable</FieldType>
        </Field>
        <Field>
            <FieldName>_sourceTable</FieldName>
            <FieldType>FromTable</FieldType>
        </Field>
        <Field>
            <FieldName>_searchCondition</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>_matchingClauses</FieldName>
            <FieldType>QueryTreeNodeVector</FieldType>
        </Field>
        <Field>
            <FieldName>_matchingClauses</FieldName>
            <FieldType>MatchingClauseNode</FieldType>
        </Field>
        <Field>
            <FieldName>_selectList</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>_leftJoinFromList</FieldName>
            <FieldType>FromList</FieldType>
        </Field>
        <Field>
            <FieldName>_hojn</FieldName>
            <FieldType>HalfOuterJoinNode</FieldType>
        </Field>
        <Field>
            <FieldName>_constantAction</FieldName>
            <FieldType>ConstantAction</FieldType>
        </Field>
        <Field>
            <FieldName>_leftJoinCursor</FieldName>
            <FieldType>CursorNode</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MergeNode</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Constructor for a MergeNode. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sourceTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>searchCondition</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>matchingClauses</ParamName>
                    <ParamType>MatchingClauseNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTargetTable</MethodName>
            <MethodComment>/** 
 * Get the target table for the MERGE statement 
 */
</MethodComment>
            <ReturnType>FromBaseTable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>associateColumn</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Associate a column with the SOURCE or TARGET table. This is part of the special name resolution machinery which smooths over the differences between name resolution for SELECTs and UPDATEs. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Boilerplate for binding an expression against a FromList 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>int [previousReliability=cc.getReliability()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;setReliability;[previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;pushCurrentPrivType;[Authorizer.SELECT_PRIV]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnsInExpression</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add the columns in the matchingRefinement clause to the evolving map. This is called when we're building the SELECT list for the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ColumnReference&gt; [colRefs=getColumnReferences(expression)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getColumnsFromList;[map, colRefs, mergeTableID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnsFromList</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add a list of columns to the the evolving map. This is called when we're building the SELECT list for the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;ColumnReference&gt; [colRefs=getColumnReferences(rcl)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getColumnsFromList;[map, colRefs, mergeTableID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>IgnoreFilter [ignorePermissions=new IgnoreFilter()]</InnerVar>
                <InnerVar>FromList [dfl=new FromList(getContextManager())]</InnerVar>
                <InnerVar>FromTable [dflSource=cloneFromTable(_sourceTable)]</InnerVar>
                <InnerVar>FromBaseTable [dflTarget=(FromBaseTable)cloneFromTable(_targetTable)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forbidDerivedColumnLists;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;forbidSynonyms;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>dfl;addFromTable;[dflSource]</InnerMethodInvoke>
                <InnerMethodInvoke>dfl;addFromTable;[dflTarget]</InnerMethodInvoke>
                <InnerMethodInvoke>dfl;bindTables;[dd, new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bindLeftJoin;[dd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkNoAggregates</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clause</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HasNodeVisitor [visitor=new HasNodeVisitor(AggregateNode.class,SubqueryNode.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>clause;accept;[visitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExposedName</MethodName>
            <MethodComment>/** 
 * Get the exposed name of a FromTable 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ft</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidDerivedColumnLists</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Because of name resolution complexities, we do not allow derived column lists on source or target tables. These lists arise in queries like the following: &lt;/p&gt; &lt;pre&gt; merge into t1 r( x ) using t2 on r.x = t2.a when matched then delete; merge into t1 using t2 r( x ) on t1.a = r.x when matched then delete; &lt;/pre&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidSynonyms</MethodName>
            <MethodComment>/** 
 * Neither the source nor the target table may be a synonym 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;forbidSynonyms;[_targetTable.getTableNameField().cloneMe()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidSynonyms</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [synonym=resolveTableToSynonym(tableName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tableName;bind;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notBaseTable</MethodName>
            <MethodComment>/** 
 * Throw a "not base table" exception 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>targetIsBaseTable</MethodName>
            <MethodComment>/** 
 * Return true if the target table is a base table 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromBaseTable [fbt=targetTable]</InnerVar>
                <InnerVar>TableDescriptor [desc=fbt.getTableDescriptor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sourceIsBase_or_VTI</MethodName>
            <MethodComment>/** 
 * Return true if the source table is a base table, view, or table function 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>FromBaseTable [fbt=(FromBaseTable)_sourceTable]</InnerVar>
                <InnerVar>TableDescriptor [desc=fbt.getTableDescriptor()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindLeftJoin</MethodName>
            <MethodComment>/** 
 * Bind the driving left join select. Stuffs the left join SelectNode into the resultSet variable.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>int [previousReliability=cc.getReliability()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneFromList</MethodName>
            <MethodComment>/** 
 * Create a FromList for binding a WHEN [ NOT ] MATCHED clause 
 */
</MethodComment>
            <ReturnType>FromList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetTable</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FromList [dummyFromList=new FromList(getContextManager())]</InnerVar>
                <InnerVar>FromBaseTable [dummyTargetTable=new FromBaseTable(targetTable.getTableNameField(),targetTable.correlationName,null,null,getContextManager())]</InnerVar>
                <InnerVar>FromTable [dummySourceTable=cloneFromTable(_sourceTable)]</InnerVar>
                <InnerVar>IgnoreFilter [ignorePermissions=new IgnoreFilter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dummyTargetTable;setMergeTableID;[ColumnReference.MERGE_TARGET]</InnerMethodInvoke>
                <InnerMethodInvoke>dummySourceTable;setMergeTableID;[ColumnReference.MERGE_SOURCE]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyFromList;addFromTable;[dummySourceTable]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyFromList;addFromTable;[dummyTargetTable]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>dummyFromList;bindTables;[dd, new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager())]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneFromTable</MethodName>
            <MethodComment>/** 
 * Clone a FromTable to avoid binding the original 
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOnClausePrivileges</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add the privileges required by the ON clause. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addColumnPrivilege</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add SELECT privilege on the indicated column. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>ResultColumn [rc=cr.getSource()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addRoutinePrivilege</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add EXECUTE privilege on the indicated routine. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>routine</ParamName>
                    <ParamType>StaticMethodCallNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;pushCurrentPrivType;[Authorizer.EXECUTE_PRIV]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;addRequiredRoutinePriv;[routine.ad]</InnerMethodInvoke>
                <InnerMethodInvoke>cc;popCurrentPrivType;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCastNodes</MethodName>
            <MethodComment>/** 
 * Get a list of CastNodes in an expression 
 */
</MethodComment>
            <ReturnType>CastNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;CastNode&gt; [getCNs=new CollectNodesVisitor&lt;CastNode&gt;(CastNode.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expression;accept;[getCNs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRoutineReferences</MethodName>
            <MethodComment>/** 
 * Get a list of routines in an expression 
 */
</MethodComment>
            <ReturnType>StaticMethodCallNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;StaticMethodCallNode&gt; [getSMCNs=new CollectNodesVisitor&lt;StaticMethodCallNode&gt;(StaticMethodCallNode.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expression;accept;[getSMCNs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildSelectList</MethodName>
            <MethodComment>/** 
 * Build the select list for the left join 
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>HashMap&lt;String,ColumnReference&gt; [drivingColumnMap=new HashMap&lt;String,ColumnReference&gt;()]</InnerVar>
                <InnerVar>ResultColumnList [selectList=new ResultColumnList(getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;getColumnsInExpression;[drivingColumnMap, _searchCondition, ColumnReference.MERGE_UNKNOWN]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addColumns;[(FromTable)_leftJoinFromList.elementAt(SOURCE_TABLE_INDEX), drivingColumnMap, selectList, ColumnReference.MERGE_SOURCE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addColumns;[(FromTable)_leftJoinFromList.elementAt(TARGET_TABLE_INDEX), drivingColumnMap, selectList, ColumnReference.MERGE_TARGET]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addTargetRowLocation;[selectList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTargetRowLocation</MethodName>
            <MethodComment>/** 
 * Add the target table's row location to the left join's select list 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [fromTableName=_targetTable.getTableName()]</InnerVar>
                <InnerVar>ColumnReference [cr=new ColumnReference(TARGET_ROW_LOCATION_NAME,fromTableName,getContextManager())]</InnerVar>
                <InnerVar>ResultColumn [rowLocationColumn=new ResultColumn((String)null,cr,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>_targetTable;setRowLocationColumnName;[TARGET_ROW_LOCATION_NAME]</InnerMethodInvoke>
                <InnerMethodInvoke>cr;setMergeTableID;[ColumnReference.MERGE_TARGET]</InnerMethodInvoke>
                <InnerMethodInvoke>rowLocationColumn;markGenerated;[]</InnerMethodInvoke>
                <InnerMethodInvoke>selectList;addResultColumn;[rowLocationColumn]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addColumns</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add to an evolving select list the columns from the indicated table. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromTable</ParamName>
                    <ParamType>FromTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>drivingColumnMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>selectList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [columnNames=getColumns(mergeTableID,drivingColumnMap)]</InnerVar>
                <InnerVar>TableName [tableName=fromTable.getTableName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumns</MethodName>
            <MethodComment>/** 
 * Get the column names from the table with the given table number, in sorted order 
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HashSet&lt;String&gt; [set=new HashSet&lt;String&gt;()]</InnerVar>
                <InnerVar>String[] [retval=new String[set.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>set;toArray;[retval]</InnerMethodInvoke>
                <InnerMethodInvoke>Arrays;sort;[retval]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnReferences</MethodName>
            <MethodComment>/** 
 * Get a list of column references in an expression 
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [getCRs=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>expression;accept;[getCRs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnsFromList</MethodName>
            <MethodComment>/** 
 * Add a list of columns to the the evolving map 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefs</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addColumn</MethodName>
            <MethodComment>/** 
 * Add a column to the evolving map of referenced columns 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>map</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mergeTableID</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [key=makeDCMKey(cr.getTableName(),cr.getColumnName())]</InnerVar>
                <InnerVar>ColumnReference [mapCR=map.get(key)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;associateColumn;[_leftJoinFromList, cr, mergeTableID]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeDCMKey</MethodName>
            <MethodComment>/** 
 * Make a HashMap key for a column in the driving column map of the LEFT JOIN 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizeStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>IgnoreFilter [ignorePermissions=new IgnoreFilter()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();addPrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
                <InnerMethodInvoke>_leftJoinCursor;optimizeStatement;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getCompilerContext();removePrivilegeFilter;[ignorePermissions]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [clauseCount=_matchingClauses.size()]</InnerVar>
                <InnerVar>ScrollInsensitiveResultSetNode [sirs=(ScrollInsensitiveResultSetNode)_leftJoinCursor.resultSet]</InnerVar>
                <InnerVar>ResultSetNode [generatedScan=sirs.getChildResult()]</InnerVar>
                <InnerVar>ConstantAction[] [clauseActions=new ConstantAction[clauseCount]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;generateParameterValueSet;[acb]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>_leftJoinCursor;generate;[acb, mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, "getMergeResultSet", ClassName.ResultSet, 1]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>