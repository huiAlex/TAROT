<Class>
    <Id>1485</Id>
    <Package>org.apache.derby.impl.tools.planexporter</Package>
    <ClassName>AccessDatabase</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AccessDatabase  /** 
 * This class will perform the database connection establishment, querying the database, shut downing the database. Created under DERBY-4587-PlanExporter tool
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>conn</FieldName>
            <FieldType>Connection</FieldType>
        </Field>
        <Field>
            <FieldName>schema</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>query</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>schemaExists</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>data</FieldName>
            <FieldType>TreeNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>depth</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>xmlDetails</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>P_ID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NODE_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NO_OF_OPENS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INPUT_ROWS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RETURNED_ROWS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VISITED_PAGES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_QUALIFIERS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NEXT_QUALIFIERS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCANNED_OBJECT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SORT_TYPE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NO_OF_OUTPUT_ROWS_BY_SORTER</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getQuery</MethodName>
            <MethodComment>/** 
 * @return the stmt_id
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDepth</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AccessDatabase</MethodName>
            <MethodComment>/** 
 * @param dburl
 * @param aSchema
 * @param aQuery
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dburl</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aSchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aQuery</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InstantiationException</ExceptionType>
                <ExceptionType>IllegalAccessException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>NoSuchMethodException</ExceptionType>
                <ExceptionType>InvocationTargetException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AccessDatabase</MethodName>
            <MethodComment>/** 
 * @param aConn
 * @param aSchema
 * @param aQuery
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>aConn</ParamName>
                    <ParamType>Connection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aSchema</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aQuery</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createConnection</MethodName>
            <MethodComment>/** 
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws ClassNotFoundException
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>Connection</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbURL</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class&lt;?&gt; [clazz=(dbURL.indexOf("://") != -1) ? Class.forName("org.apache.derby.jdbc.ClientDriver") : Class.forName("org.apache.derby.jdbc.EmbeddedDriver")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>clazz.getConstructor();newInstance;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InstantiationException</ExceptionType>
                <ExceptionType>IllegalAccessException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>NoSuchMethodException</ExceptionType>
                <ExceptionType>InvocationTargetException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSchema</MethodName>
            <MethodComment>/** 
 * Set the schema of the current connection to the XPLAIN schema in which the statistics can be found.
 * @throws SQLException if an error happens while accessing the database
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PreparedStatement [setSchema=conn.prepareStatement("SET SCHEMA ?")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>setSchema;setString;[1, schema]</InnerMethodInvoke>
                <InnerMethodInvoke>setSchema;execute;[]</InnerMethodInvoke>
                <InnerMethodInvoke>setSchema;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>schemaExists</MethodName>
            <MethodComment>/** 
 * Check if there is a schema in the database that matches the schema name that was passed in to this instance.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultSet [result=conn.getMetaData().getSchemas()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifySchemaExistance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXMLFragment</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; This method creates the queries such that after execution of the query it will return XML data fragments. &lt;/P&gt;
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;createXMLData;["select 'id=\"' ||RS_ID|| '\"' " + "from SYSXPLAIN_RESULTSETS " + "where STMT_ID = ?", ID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select PARENT_RS_ID " + "from SYSXPLAIN_RESULTSETS " + "where STMT_ID = ?", P_ID]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'name=\"' ||OP_IDENTIFIER|| '\"' " + "from SYSXPLAIN_RESULTSETS " + "where STMT_ID = ?", NODE_TYPE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'no_opens=\"' " + "|| TRIM(CHAR(NO_OPENS))|| '\"' " + "from SYSXPLAIN_RESULTSETS "+ "where STMT_ID = ?", NO_OF_OPENS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'input_rows=\"' " + "|| TRIM(CHAR(INPUT_ROWS))|| '\"' " + "from SYSXPLAIN_RESULTSETS "+ "where STMT_ID = ?", INPUT_ROWS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'returned_rows=\"' " + "|| TRIM(CHAR(RETURNED_ROWS))|| '\"' " + "from SYSXPLAIN_RESULTSETS "+ "where STMT_ID = ?", RETURNED_ROWS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'visited_pages=\"'" + "|| TRIM(CHAR(NO_VISITED_PAGES))|| '\"' " + "from (SYSXPLAIN_SCAN_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", VISITED_PAGES]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'scan_qualifiers=\"'" + "||SCAN_QUALIFIERS|| '\"' " + "from (SYSXPLAIN_SCAN_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", SCAN_QUALIFIERS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'next_qualifiers=\"'" + "||NEXT_QUALIFIERS|| '\"' " + "from (SYSXPLAIN_SCAN_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", NEXT_QUALIFIERS]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'scanned_object=\"'" + "||SCAN_OBJECT_NAME|| '\"' " + "from (SYSXPLAIN_SCAN_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", SCANNED_OBJECT]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'scan_type=\"'" + "||TRIM(SCAN_TYPE)|| '\"' " + "from (SYSXPLAIN_SCAN_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", SCAN_TYPE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'sort_type=\"'" + "||TRIM(SORT_TYPE)|| '\"' " + "from (SYSXPLAIN_SORT_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", SORT_TYPE]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createXMLData;["select 'sorter_output=\"'" + "||TRIM(CHAR(NO_OUTPUT_ROWS))|| '\"' " + "from (SYSXPLAIN_SORT_PROPS "+ "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) "+ "where STMT_ID = ?", NO_OF_OUTPUT_ROWS_BY_SORTER]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXmlString</MethodName>
            <MethodComment>/** 
 * Generating the XML tree
 * @return all xml elements as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getChildren</MethodName>
            <MethodComment>/** 
 * @param currentLevel level of the XML tree (0 based) of current node
 * @param id current node's stmt_id
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>currentLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>indent</MethodName>
            <MethodComment>/** 
 * @param j indent needed
 * @return indent as a string
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>j</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [str=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markTheDepth</MethodName>
            <MethodComment>/** 
 * marking the depth of each element
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [i=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>data[i];setDepth;[depth]</InnerMethodInvoke>
                <InnerMethodInvoke>null;findChildren;[i, depth]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findChildren</MethodName>
            <MethodComment>/** 
 * @param idx current element's index
 * @param dep current examining depth
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>idx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dep</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeDataArray</MethodName>
            <MethodComment>/** 
 * @return whether the initialization is successful or not
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createXMLData</MethodName>
            <MethodComment>/** 
 * Create XML data based on the query that's passed in. The query should have exactly one parameter, which will be initialized to the statement id before the query is executed.
 * @param qry query to be executed
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>qry</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>x</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement(qry)]</InnerVar>
                <InnerVar>ResultSet [results=ps.executeQuery()]</InnerVar>
                <InnerVar>int [i=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setString;[1, getQuery()]</InnerMethodInvoke>
                <InnerMethodInvoke>results;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noOfNodes</MethodName>
            <MethodComment>/** 
 * @return total # of nodes
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement("select count(*) from SYSXPLAIN_RESULTSETS where STMT_ID = ?")]</InnerVar>
                <InnerVar>ResultSet [results=ps.executeQuery()]</InnerVar>
                <InnerVar>int [no=results.getInt(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setString;[1, getQuery()]</InnerMethodInvoke>
                <InnerMethodInvoke>results;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>results;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statement</MethodName>
            <MethodComment>/** 
 * @return the &amp;lt;statement&amp;gt; element
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement("select STMT_TEXT from SYSXPLAIN_STATEMENTS where STMT_ID = ?")]</InnerVar>
                <InnerVar>ResultSet [results=ps.executeQuery()]</InnerVar>
                <InnerVar>String [statement=results.getString(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setString;[1, getQuery()]</InnerMethodInvoke>
                <InnerMethodInvoke>results;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>results;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>escapeForXML</MethodName>
            <MethodComment>/** 
 * Escape characters that have a special meaning in XML.
 * @param text the text to escape
 * @return the text with special characters escaped
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [sb=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>escapeInAttribute</MethodName>
            <MethodComment>/** 
 * This method is needed since in the case of XML attributes we have to filter the quotation (&amp;quot;) marks that is compulsory. eg: scanned_object="A &amp;quot;quoted&amp;quot;  table name";
 * @param text attribute string to be checked
 * @return modified string
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [correctXMLString=escapeForXML(text.substring(text.indexOf('"') + 1,text.length() - 1))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>time</MethodName>
            <MethodComment>/** 
 * @return XPLAIN_TIME of SYSXPLAIN_STATEMENTS
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=conn.prepareStatement("select '&lt;time&gt;'||TRIM(CHAR(XPLAIN_TIME))||" + "'&lt;/time&gt;' from SYSXPLAIN_STATEMENTS " + "where STMT_ID = ?")]</InnerVar>
                <InnerVar>ResultSet [results=ps.executeQuery()]</InnerVar>
                <InnerVar>String [time=results.getString(1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ps;setString;[1, getQuery()]</InnerMethodInvoke>
                <InnerMethodInvoke>results;next;[]</InnerMethodInvoke>
                <InnerMethodInvoke>results;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stmtID</MethodName>
            <MethodComment>/** 
 * @return stmt_id as a XML element
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeConnection</MethodName>
            <MethodComment>/** 
 * closing the connection to the database
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getData</MethodName>
            <MethodComment>/** 
 * @return data array of TreeNode Objects
 */
</MethodComment>
            <ReturnType>TreeNode[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>