<Class>
    <Id>741</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>AllocPage</ClassName>
    <SuperClass>StoredPage</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AllocPage  /** 
 * An allocation page of the file container. &lt;P&gt; This class extends a normal Stored page, with the exception that a hunk of space may be 'borrowed' by the file container to store the file header. &lt;P&gt; The borrowed space is not visible to the alloc page even though it is present in the page data array.  It is accessed directly by the FileContainer.  Any change made to the borrowed space is not managed or seen by the allocation page. &lt;P&gt; The reason for having this borrowed space is so that the container header does not need to have a page of its own. &lt;P&gt;&lt;B&gt;Page Format&lt;/B&gt;&lt;BR&gt; An allocation page extends a stored page, the on disk format is different from a stored page in that N bytes are 'borrowed' by the container and the page header of an allocation page will be slightly bigger than a normal stored page.  This N bytes are stored between the page header and the  record space. &lt;P&gt; The reason why this N bytes can't simply be a row is because it needs to be statically accessible by the container object to avoid a chicken and egg problem of the container object needing to instantiate an alloc page object before it can be objectified, and an alloc page object needing to instantiate a container object before it can be objectified.  So this N bytes must be stored outside of the normal record interface yet it must be settable because only the first alloc page has this borrowed space.  Other (non-first) alloc page have N == 0. &lt;PRE&gt; [ borrowed ] +----------+-------------+---+---------+-------------------+-------------+--------+ | FormatId | page header | N | N bytes | alloc extend rows | slot offset |checksum| +----------+-------------+---+---------+-------------------+-------------+--------+ &lt;/PRE&gt; N is a byte that indicates the size of the borrowed space.  Once an alloc page is initialized, the value of N cannot change. &lt;P&gt; The maximum space that can be borrowed by the container is 256 bytes. &lt;P&gt; The allocation page are of the same page size as any other pages in the container. The first allocation page of the FileContainer starts at the first physical byte of the container.  Subsequent allocation pages are chained via the nextAllocPageOffset.  Each allocation page is expected to manage at least 1000 user pages (for 1K page size) so this chaining may not be a severe performance hit.  The logical -&amp;gt; physical mapping of an allocation page is stored in the previous allocation page.  The container object will need to maintain this mapping. &lt;P&gt; The following fields are stored in the page header &lt;PRE&gt;
 * @derby.formatId	RAW_STORE_ALLOC_PAGE
 * @derby.purpose	manage page allocation
 * @derby.upgrade
 * @derby.diskLayout FormatId(int) StoredPageHeader	see StoredPage nextAllocPageNubmer(long)	the next allocation page's number nextAllocPageOffset(long)	the file offset of the next allocation page reserved1(long)				reserved for future usage reserved2(long)				reserved for future usage reserved3(long)				reserved for future usage reserved4(long)				reserved for future usage N(byte)						the size of the borrowed container info containerInfo(byte[N])		the content of the borrowed container info AllocExtent					the one and only extent on this alloc page
 * @derby.endFormat &lt;/PRE&gt; &lt;P&gt; The allocation page contains allocation extent rows.  In this first cut implementation, there is only 1 allocation extent row per allocation page. &lt;P&gt; The allocation extent row is an externalizable object and is directly written on to the page by the alloc page.  In other words, it will not be converted in to a storeableRow.  This is to cut down overhead, enhance performance and gives more control of the size and layout of the allocation extent row to the alloc page. &lt;P&gt; &lt;HR WIDTH="100%"&gt; &lt;BR&gt; DETAIL implmentation notes &lt;BR&gt; &lt;HR WIDTH="100%"&gt; &lt;P&gt; Create Container - an embryonic allocation page is formatted on disk by a spcial static function to avoid instantiating a full AllocPage object. This embryonic allocation has enough information that it can find the file header and not much else.  Then the allocation page is perperly initiated by creating the first extent. &lt;P&gt; Open Container - A static AllocPage method will be used to read off the container information directly from disk.  Even if the first alloc page (page 0) is already in the page cache, it will not be used because cleaning the alloc page will introduce a deadlock if the container is not in the container cache.  Long term, the first alloc page should probably live in the container cache rather than in the page cache. &lt;P&gt; Get Page - The first alloc page (page 0) will be read into the page cache. Continue to follow the alloc page chain until the alloc page that manages the specified page is found.  From the alloc page, the physical offset of the specified page is located. &lt;P&gt; Cleaning alloc page - the alloc page is written out the same way any page is written out.  The container object will provide a call back to the alloc page to write the current version of the container object back into the borrowed space before the alloc page itself is written out. &lt;P&gt; Cleaning the container object - get the the first alloc page, dirty it and clean it (which will cause it to call the container object to write itself out into the borrowed space).  The versioning of the container is independent of the versioning of the alloc page.  The container version is stored inside the borrowed space and is opaque to the alloc page. &lt;P&gt; For the fields in an allocation extent row
 * @see AllocExtent
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>FORMAT_NUMBER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>nextAllocPageNumber</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>nextAllocPageOffset</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>reserved1</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>reserved2</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>reserved3</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>reserved4</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>extent</FieldName>
            <FieldType>AllocExtent</FieldType>
        </Field>
        <Field>
            <FieldName>borrowedSpace</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALLOC_PAGE_HEADER_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALLOC_PAGE_HEADER_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BORROWED_SPACE_OFFSET</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BORROWED_SPACE_LEN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_BORROWED_SPACE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TEST_MULTIPLE_ALLOC_PAGE</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Return my format identifier.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AllocPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxFreeSpace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createPage</MethodName>
            <MethodComment>/** 
 * Create a new alloc page.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>args</ParamName>
                    <ParamType>PageCreationArgs</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AllocExtent</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pagesAlloced</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>availspace</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxPages=AllocExtent.MAX_RANGE(availspace)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initFromData</MethodName>
            <MethodComment>/** 
 * Initialize in memory structure using the buffer in pageData
 * @exception StandardException If the page cannot be read correctly, or is inconsistent.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myContainer</ParamName>
                    <ParamType>FileContainer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newIdentity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>byte [n=pageData[BORROWED_SPACE_OFFSET]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writePage</MethodName>
            <MethodComment>/** 
 * Write the page out
 * @exception StandardException If the page cannot be written
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>identity</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readAllocPageHeader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrdi;setPosition;[ALLOC_PAGE_HEADER_OFFSET]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateAllocPageHeader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[ALLOC_PAGE_HEADER_OFFSET]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[nextAllocPageNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[nextAllocPageOffset]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
                <InnerMethodInvoke>logicalDataOut;writeLong;[0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AllocExtent</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayInputStream [lrdi=rawDataIn]</InnerVar>
                <InnerVar>AllocExtent [newExtent=new AllocExtent()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataIn;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>newExtent;readExternal;[lrdi]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExtent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawDataOut;setPosition;[offset]</InnerMethodInvoke>
                <InnerMethodInvoke>extent;writeExternal;[logicalDataOut]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>WriteContainerInfo</MethodName>
            <MethodComment>/** 
 * Write the container information into the container information area.
 * @param containerInfo the container information
 * @param epage the allocation page data which may not be fully formed,but is guarenteed to be big enough to cover the area inhibited by the container info
 * @param create if create, write out the length of the container infoalso. Else check to make sure epage's original container info is of the same length
 * @exception StandardException standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerInfo</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>epage</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [N=(containerInfo == null) ? 0 : containerInfo.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ReadContainerInfo</MethodName>
            <MethodComment>/** 
 * Extract the container information from epage.
 * @param containerInfo where to put the extracted information
 * @param epage the allocation page which has the container information.Epage may not be fully formed, but is guarenteed to be big enough to cover the area inhibited by the container info
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerInfo</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>epage</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [N=(int)epage[BORROWED_SPACE_OFFSET]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextFreePageNumber</MethodName>
            <MethodComment>/** 
 * Return the next free page number after given page number 
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pnum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPage</MethodName>
            <MethodComment>/** 
 * Add a page which is managed by this alloc page. Return the page number of the newly added page. &lt;BR&gt; MT - thread aware (latched)
 * @param mycontainer (future) allows the alloc page to call back to thecontainer to grow the container by creating and syncing multiple pages at once
 * @param ntt the nested top action that is the allocation transaction.NTT will comit before the user transaction
 * @param userHandle the container handle that is opened by the usertransaction.  Use the userHandle to latch the new page so that it may remain latched after NTT is committed so the user transaction can guarentee to have an empty page
 * @exception StandardException If the page cannot be added
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mycontainer</ParamName>
                    <ParamType>FileContainer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getAllocationActionSet();actionAllocatePage;[ntt, this, newPageNumber, AllocExtent.ALLOCATED_PAGE, AllocExtent.FREE_PAGE]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deallocatePage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getAllocationActionSet();actionAllocatePage;[userHandle.getTransaction(), this, pageNumber, AllocExtent.DEALLOCATED_PAGE, AllocExtent.ALLOCATED_PAGE]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateUnfilledPageInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inputExtent</ParamName>
                    <ParamType>AllocExtent</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>extent;updateUnfilledPageInfo;[inputExtent]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canAddFreePage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lastAllocatedPage</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextAllocPageOffset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chainNewAllocPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allocHandle</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAllocPageNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAllocPageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getAllocationActionSet();actionChainAllocPage;[allocHandle.getTransaction(), this, newAllocPageNum, newAllocPageOffset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextAllocPageNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLast</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastPagenum</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxPagenum</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastPreallocPagenum</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageStatus</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPageStatus</MethodName>
            <MethodComment>/** 
 * Do the actual page allocation/deallocation/ree underneath a log operation. Change the page status to new status
 * @exception StandardException If the page cannot be allocated
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newStatus</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chainNextAllocPage</MethodName>
            <MethodComment>/** 
 * Chain the next page number and offset underneath a log record
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAllocPageNum</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newAllocPageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressSpace</MethodName>
            <MethodComment>/** 
 * Compress free pages. &lt;p&gt; Compress the free pages at the end of the range maintained by this allocation page.  All pages being compressed should be FREE. Only pages in the last allocation page can be compressed. &lt;p&gt;
 * @param instant               log address for this operation.
 * @param new_highest_page      The new highest page on this allocation page.  The number is the offset of the page in the array of pages maintained by this  allocation page, for instance a value of 0  indicates all page except the first one are to be truncated.  If all pages are  truncated then the offset is set to -1.
 * @param num_pages_truncated   The number of allocated pages in this allocation page prior to the truncate.   Note that all pages from NewHighestPage+1  through newHighestPage+num_pages_truncated  should be FREE.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_highest_page</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_pages_truncated</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>extent;compressPages;[new_highest_page, num_pages_truncated]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>undoCompressSpace</MethodName>
            <MethodComment>/** 
 * Handle undo of compress space operation.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_highest_page</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_pages_truncated</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;logAction;[instant]</InnerMethodInvoke>
                <InnerMethodInvoke>extent;undoCompressPages;[new_highest_page, num_pages_truncated]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllocExtent</MethodName>
            <MethodComment>/** 
 * Return a copy of the allocExtent to be cached by the container. the container must take care to maintain its coherency by invalidating the cache before any update.
 */
</MethodComment>
            <ReturnType>AllocExtent</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preAllocatePage</MethodName>
            <MethodComment>/** 
 * Preallocate user page if needed.
 * @param myContainer the container object
 * @param preAllocThreshold start preallocating after this threshold
 * @param preAllocSize preallocate this number of pages 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>myContainer</ParamName>
                    <ParamType>FileContainer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preAllocThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preAllocSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [lastPreallocatedPagenum=extent.getLastPreallocPagenum()]</InnerVar>
                <InnerVar>int [n=myContainer.preAllocate(lastPreallocatedPagenum,preAllocSize)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compress</MethodName>
            <MethodComment>/** 
 * compress out empty pages at end of container. &lt;p&gt; Call the extent to update the data structure make the bit map look like contiguous free pages at the end of the extent no longer exist. Similar to preallocate do the operation unlogged, need to force the change to the extent before actually removing the space from the file. &lt;p&gt; The sequence is: 1) update extent data structure 2) force extent changes to disk 3) truncate pages If the system crashes between 1 and 2 then no changes are on disk. If the system crashes between 2 and 3 then there are extra pages in the file that extent does not know about, this is the same case as preallocation which the code already handes.  It will handle any set of pages from 0 to all of the intended pages being  truncated.  The next allocate looks at actual size of file as does the right thing. &lt;p&gt; MT - expect Container level X lock
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ntt</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>myContainer</ParamName>
                    <ParamType>FileContainer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [all_pages_compressed=false]</InnerVar>
                <InnerVar>int [last_valid_page_bit=extent.compress(owner,ntt,this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>