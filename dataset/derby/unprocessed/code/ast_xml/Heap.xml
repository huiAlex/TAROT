<Class>
    <Id>1246</Id>
    <Package>org.apache.derby.impl.store.access.heap</Package>
    <ClassName>Heap</ClassName>
    <SuperClass>GenericConglomerate</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Conglomerate</SuperInterface>
        <SuperInterface>StaticCompiledOpenConglomInfo</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Heap  /** 
 * A heap object corresponds to an instance of a heap conglomerate.  It caches information which makes it fast to open heap controllers from it.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>conglom_format_id</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>id</FieldName>
            <FieldType>ContainerKey</FieldType>
        </Field>
        <Field>
            <FieldName>format_ids</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>collation_ids</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>hasCollatedTypes</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>BASE_MEMORY_USAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CONTAINER_KEY_MEMORY_USAGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>estimateMemoryUsage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [sz=BASE_MEMORY_USAGE]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>Heap</MethodName>
            <MethodComment>/** 
 * Zero arg constructor for Monitor to create empty object.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>create</MethodName>
            <MethodComment>/** 
 * Create a heap conglomerate. &lt;p&gt; Create a heap conglomerate.  This method is called from the heap factory to create a new instance of a heap. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>segmentId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_containerid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnOrder</ParamName>
                    <ParamType>ColumnOrdering[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationIds</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglom_format_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tmpFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [containerid=rawtran.addContainer(segmentId,input_containerid,ContainerHandle.MODE_DEFAULT,properties,tmpFlag)]</InnerVar>
                <InnerVar>ContainerHandle [container=null]</InnerVar>
                <InnerVar>Page [page=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot_create</MethodName>
            <MethodComment>/** 
 * Create a heap conglomerate during the boot process. &lt;p&gt; Manufacture a Heap Conglomerate out of "thin" air, to boot strap the system.  Create an in-memory Heap Conglomerate with the input parameters, The caller will use this to open the conglomerate conglomerate and read the "real" values from disk.  Conglom-conglom is always on segment 0.
 * @param containerid The container id of the conglomerate.
 * @param template    Object array describing the columns of the heap.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>containerid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addColumn</MethodName>
            <MethodComment>/** 
 * Add a column to the heap conglomerate. &lt;p&gt; This routine update's the in-memory object version of the Heap Conglomerate to have one more column of the type described by the input template column.  
 * @param column_id        The column number to add this column at.
 * @param template_column  An instance of the column to be added to table.
 * @param collation_id     Collation id of the column added.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>template_column</ParamName>
                    <ParamType>Storable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collation_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerHandle [container=null]</InnerVar>
                <InnerVar>Page [page=null]</InnerVar>
                <InnerVar>Transaction [rawtran=xact_manager.getRawStoreXact()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>drop</MethodName>
            <MethodComment>/** 
 * Drop this heap.
 * @see Conglomerate#drop
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xact_manager.getRawStoreXact();dropContainer;[id]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchMaxOnBTree</MethodName>
            <MethodComment>/** 
 * Retrieve the maximum value row in an ordered conglomerate. &lt;p&gt; Returns true and fetches the rightmost row of an ordered conglomerate  into "fetchRow" if there is at least one row in the conglomerate.  If there are no rows in the conglomerate it returns false. &lt;p&gt; Non-ordered conglomerates will not implement this interface, calls will generate a StandardException. &lt;p&gt; RESOLVE - this interface is temporary, long term equivalent (and more)  functionality will be provided by the openBackwardScan() interface.  
 * @param conglomId       The identifier of the conglomerateto open the scan for.
 * @param open_mode       Specifiy flags to control opening of table.  OPENMODE_FORUPDATE - if set open the table for update otherwise open table shared.
 * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
 * @param isolation_level The isolation level to lock the conglomerate at.One of (ISOLATION_READ_COMMITTED or  ISOLATION_SERIALIZABLE).
 * @param scanColumnList  A description of which columns to return from every fetch in the scan.  template,  and scanColumnList work together to describe the row to be returned by the scan -  see RowUtil for description of how these three  parameters work together to describe a "row".
 * @param fetchRow        The row to retrieve the maximum value into.
 * @return boolean indicating if a row was found and retrieved or not.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchRow</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getId</MethodName>
            <MethodComment>/** 
 * Get the id of the container of the conglomerate. &lt;p&gt; Will have to change when a conglomerate could have more than one  container.  The ContainerKey is a combination of the container id and segment id.
 * @return The ContainerKey.
 */
</MethodComment>
            <ReturnType>ContainerKey</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDynamicCompiledConglomInfo</MethodName>
            <MethodComment>/** 
 * Return dynamic information about the conglomerate to be dynamically  reused in repeated execution of a statement. &lt;p&gt; The dynamic info is a set of variables to be used in a given  ScanController or ConglomerateController.  It can only be used in one  controller at a time.  It is up to the caller to insure the correct  thread access to this info.  The type of info in this is a scratch  template for btree traversal, other scratch variables for qualifier  evaluation, ... &lt;p&gt;
 * @return The dynamic information.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>DynamicCompiledOpenConglomInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStaticCompiledConglomInfo</MethodName>
            <MethodComment>/** 
 * Return static information about the conglomerate to be included in a a compiled plan. &lt;p&gt; The static info would be valid until any ddl was executed on the  conglomid, and would be up to the caller to throw away when that  happened.  This ties in with what language already does for other  invalidation of static info.  The type of info in this would be  containerid and array of format id's from which templates can be created. The info in this object is read only and can be shared among as many  threads as necessary. &lt;p&gt;
 * @return The static compiled information.
 * @param conglomId The identifier of the conglomerate to open.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>StaticCompiledOpenConglomInfo</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTemporary</MethodName>
            <MethodComment>/** 
 * Is this conglomerate temporary? &lt;p&gt;
 * @return whether conglomerate is temporary or not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>load</MethodName>
            <MethodComment>/** 
 * Bulk load into the conglomerate. &lt;p&gt;
 * @see Conglomerate#load
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>createConglom</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowSource</ParamName>
                    <ParamType>RowLocationRetRowSource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [num_rows_loaded=0]</InnerVar>
                <InnerVar>HeapController [heapcontroller=new HeapController()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>open</MethodName>
            <MethodComment>/** 
 * Open a heap controller. &lt;p&gt;
 * @see Conglomerate#open
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenConglomerate [open_conglom=new OpenHeap()]</InnerVar>
                <InnerVar>HeapController [heapcontroller=new HeapController()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heapcontroller;init;[open_conglom]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openByContainerKey</MethodName>
            <MethodComment>/** 
 * Open a heap controller given ContainerKey. &lt;p&gt; Static routine to open a container given input of the ContainerKey. Routine will lock the container first, and then get the Heap from the conglomerate cache.  This insures that interaction with the conglomerate cache is safe with respect to concurrent alter table's  which may or may not commit.   Currently only package accessible and only used by HeapPostCommit. Longer term would be better to change all of the open interfaces to get lock before accessing conglomerate cache rather than have a  specific interface for HeapPostCommit.
 * @see Conglomerate#open
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>container_key</ParamName>
                    <ParamType>ContainerKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ContainerHandle [open_container=rawtran.openContainer(container_key,locking_policy,open_mode)]</InnerVar>
                <InnerVar>Heap [heap=(Heap)xact_manager.findExistingConglomerateFromKey(container_key)]</InnerVar>
                <InnerVar>OpenConglomerate [open_conglom=new OpenHeap()]</InnerVar>
                <InnerVar>HeapController [heapcontroller=new HeapController()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heapcontroller;init;[open_conglom]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openScan</MethodName>
            <MethodComment>/** 
 * Open a heap scan controller. &lt;p&gt;
 * @see Conglomerate#openScan
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ScanManager</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenConglomerate [open_conglom=new OpenHeap()]</InnerVar>
                <InnerVar>HeapScan [heapscan=new HeapScan()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heapscan;init;[open_conglom, scanColumnList, startKeyValue, startSearchOperator, qualifier, stopKeyValue, stopSearchOperator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenConglomerate [open_for_ddl_lock=null]</InnerVar>
                <InnerVar>HeapController [heapcontroller=null]</InnerVar>
                <InnerVar>TransactionManager [nested_xact=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenConglomerate [open_conglom=null]</InnerVar>
                <InnerVar>HeapController [heapcontroller=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defragmentConglomerate</MethodName>
            <MethodComment>/** 
 * Open a heap compress scan. &lt;p&gt;
 * @see Conglomerate#defragmentConglomerate
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ScanManager</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>locking_policy</ParamName>
                    <ParamType>LockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolation_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenConglomerate [open_conglom=new OpenHeap()]</InnerVar>
                <InnerVar>HeapCompressScan [heap_compress_scan=new HeapCompressScan()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heap_compress_scan;init;[open_conglom, null, null, 0, null, null, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openStoreCost</MethodName>
            <MethodComment>/** 
 * Return an open StoreCostController for the conglomerate. &lt;p&gt; Return an open StoreCostController which can be used to ask about  the estimated row counts and costs of ScanController and  ConglomerateController operations, on the given conglomerate. &lt;p&gt;
 * @param xact_manager The TransactionController under which this operation takes place.
 * @param rawtran  raw transaction context in which scan is managed.
 * @return The open StoreCostController.
 * @exception StandardException  Standard exception policy.
 * @see StoreCostController
 */
</MethodComment>
            <ReturnType>StoreCostController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OpenHeap [open_conglom=new OpenHeap()]</InnerVar>
                <InnerVar>HeapCostController [heapcost=new HeapCostController()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>heapcost;init;[open_conglom]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Print this heap.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglom</MethodName>
            <MethodComment>/** 
 * return the "Conglomerate". &lt;p&gt; For heap just return "this", which both implements Conglomerate and StaticCompiledOpenConglomInfo. &lt;p&gt;
 * @return this
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Return my format identifier.
 * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNull</MethodName>
            <MethodComment>/** 
 * Return whether the value is null or not.
 * @see org.apache.derby.iapi.services.io.Storable#isNull
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreToNull</MethodName>
            <MethodComment>/** 
 * Restore the in-memory representation to the null value.
 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal_v10_2</MethodName>
            <MethodComment>/** 
 * Store the 10.2 format stored representation of column value in stream. &lt;p&gt; This routine stores the 10.2 version the Heap, ie. the ACCESS_HEAP_V2_ID format.  It is used by any database which has been created in  10.2 or a previous release and has not been hard upgraded to a  version subsequent to 10.2. &lt;p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>FormatIdUtil;writeFormatIdInteger;[out, conglom_format_id]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[(int)id.getSegmentId()]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeLong;[id.getContainerId()]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[format_ids.length]</InnerMethodInvoke>
                <InnerMethodInvoke>ConglomerateUtil;writeFormatIdArray;[format_ids, out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment>/** 
 * Store the stored representation of column value in stream. &lt;p&gt; This routine uses the current database version to either store the the 10.2 format (ACCESS_HEAP_V2_ID) or the current format  (ACCESS_HEAP_V3_ID).   &lt;p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;writeExternal_v10_2;[out]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment>/** 
 * Restore the in-memory representation from the stream. &lt;p&gt;
 * @exception ClassNotFoundException Thrown if the stored representation is serialized and a class named in  the stream could not be found.
 * @see java.io.Externalizable#readExternal
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [segmentid=in.readInt()]</InnerVar>
                <InnerVar>long [containerid=in.readLong()]</InnerVar>
                <InnerVar>int [num_columns=in.readInt()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>