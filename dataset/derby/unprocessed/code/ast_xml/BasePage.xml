<Class>
    <Id>1183</Id>
    <Package>org.apache.derby.impl.store.raw.data</Package>
    <ClassName>BasePage</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Page</SuperInterface>
        <SuperInterface>DerbyObserver</SuperInterface>
        <SuperInterface>TypedFormat</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BasePage  /** 
 * This class implements all the the generic locking behaviour for a Page. It leaves method used to log and store the records up to sub-classes. It is intended that the object can represent multiple pages from different containers during its lifetime. &lt;P&gt; A page contains a set of records, which can be accessed by "slot", which defines the order of the records on the page, or by "id" which defines the identity of the records on the page.  Clients access records by both slot and id, depending on their needs. &lt;P&gt; BasePage implements Observer to watch the ContainerHandle which notifies its Observers when it is closing. &lt;BR&gt; MT - mutable
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>auxObj</FieldName>
            <FieldType>AuxObject</FieldType>
        </Field>
        <Field>
            <FieldName>identity</FieldName>
            <FieldType>PageKey</FieldType>
        </Field>
        <Field>
            <FieldName>headers</FieldName>
            <FieldType>StoredRecordHeader[]</FieldType>
        </Field>
        <Field>
            <FieldName>recordCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>owner</FieldName>
            <FieldType>BaseContainerHandle</FieldType>
        </Field>
        <Field>
            <FieldName>nestedLatch</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>inClean</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>preLatch</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>lastLog</FieldName>
            <FieldType>LogInstant</FieldType>
        </Field>
        <Field>
            <FieldName>repositionNeededAfterVersion</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>pageVersion</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>pageStatus</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>VALID_PAGE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>INVALID_PAGE</FieldName>
            <FieldType>byte</FieldType>
        </Field>
        <Field>
            <FieldName>INIT_PAGE_REUSE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INIT_PAGE_OVERFLOW</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INIT_PAGE_REUSE_RECORDID</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_RECORD_DEFAULT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_RECORD_FOR_UPDATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LOG_RECORD_FOR_PURGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>InvalidRecordHandle</FieldName>
            <FieldType>RecordHandle</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BasePage</MethodName>
            <MethodComment>/** 
 * Create a new, empty page.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * Initialized the BasePage. &lt;p&gt; Initialize the object, ie. perform work normally perfomed in  constructor.  Called by setIdentity() and createIdentity().
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setAuxObject;[null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;clearLastLogInstant;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeHeaders</MethodName>
            <MethodComment>/** 
 * Must be called by a sub-class before calling setHeaderAtSlot.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numRecords</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fillInIdentity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearIdentity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;cleanPageForReuse;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanPageForReuse</MethodName>
            <MethodComment>/** 
 * Initialized this page for reuse or first use
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setAuxObject;[null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIdentity</MethodName>
            <MethodComment>/** 
 * OK to hand object outside to cache.. 
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInvalidRecordHandle</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>MakeRecordHandle</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkey</ParamName>
                    <ParamType>PageKey</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHandleConstant</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeRecordHandle</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordHandleConstant</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageNumber</MethodName>
            <MethodComment>/** 
 * @see Page#getPageNumber 
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageKey</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PageKey</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordHandle</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(recordId,FIRST_SLOT_NUMBER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordHandleAtSlot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordExists</MethodName>
            <MethodComment>/** 
 * @see Page#recordExists
 * @exception StandardException recordHandle is not a valid record handle
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreDelete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(handle.getId(),handle.getSlotNumberHint())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchFromSlot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rh</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchDesc</ParamName>
                    <ParamType>FetchDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ignoreDelete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StoredRecordHeader [recordHeader=getHeaderAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkSlotOnPage;[slot]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchFieldFromSlot</MethodName>
            <MethodComment>/** 
 * @exception StandardException	Standard Derby error policy
 * @see Page#fetchFieldFromSlot
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [row=new Object[fieldId + 1]]</InnerVar>
                <InnerVar>FetchDescriptor [fetchDesc=new FetchDescriptor(fieldId + 1,fieldId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSlotNumber</MethodName>
            <MethodComment>/** 
 * @exception StandardException Record does not exist on this page.
 * @see Page#getSlotNumber
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(handle.getId(),handle.getSlotNumberHint())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextSlotNumber</MethodName>
            <MethodComment>/** 
 * @exception StandardException Record does not exist on this page.
 * @see Page#getNextSlotNumber
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findNextRecordById(handle.getId())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#insertAtSlot
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertNoOverflow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>int [recordId]</InnerVar>
                <InnerVar>RecordHandle [handle]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionInsert;[t, this, slot, recordId, row, validColumns, undo, insertFlag, 0, false, -1, (DynamicByteArrayOutputStream)null, -1, overflowThreshold]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insert</MethodName>
            <MethodComment>/** 
 * @see Page#insert
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertAllowOverflow</MethodName>
            <MethodComment>/** 
 * Insert a row allowing overflow. If handle is supplied then the record at that hanlde will be updated to indicate it is a partial row and it has an overflow portion.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nextPortionHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [curPage=this]</InnerVar>
                <InnerVar>RecordHandle [headHandle=null]</InnerVar>
                <InnerVar>RecordHandle [handleToUpdate=null]</InnerVar>
                <InnerVar>RawTransaction [t=curPage.owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertLongColumn</MethodName>
            <MethodComment>/** 
 * Routine to insert a long column. &lt;p&gt; This code inserts a long column as a linked list of rows on overflow pages.  This list is pointed to by a small pointer in the main page row column.  The operation does the following: allocate new overflow page insert single row filling overflow page while (more of column exists) allocate new overflow page insert single row with next piece of row update previous piece to point to this new piece of row Same code is called both from an initial insert of a long column and from a subsequent update that results in a long column.
 * @return The recordHandle of the first piece of the long column chain.
 * @param mainChainPage The parent page with row piece containing columnthat will eventually point to this long column chain.
 * @param lce           The LongColumnException thrown when we recognizedthat the column being inserted was "long", this  structure is used to cache the info that we have read so far about column.  In the case of an insert of the stream it will have a copy of just the first page of the stream that has already been read once.
 * @param insertFlag    flags for insert operation.    
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mainChainPage</ParamName>
                    <ParamType>BasePage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lce</ParamName>
                    <ParamType>LongColumnException</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [row=new Object[1]]</InnerVar>
                <InnerVar>RecordHandle [firstHandle=null]</InnerVar>
                <InnerVar>RecordHandle [handle=null]</InnerVar>
                <InnerVar>RecordHandle [prevHandle=null]</InnerVar>
                <InnerVar>BasePage [curPage=mainChainPage]</InnerVar>
                <InnerVar>BasePage [prevPage=null]</InnerVar>
                <InnerVar>boolean [isFirstPage=true]</InnerVar>
                <InnerVar>byte [after_first_page_insertFlag=(byte)(insertFlag | Page.INSERT_UNDO_WITH_PURGE)]</InnerVar>
                <InnerVar>int [startColumn=0]</InnerVar>
                <InnerVar>RawTransaction [t=curPage.owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preDirty</MethodName>
            <MethodComment>/** 
 * The page or its header is about to be modified. Loggable actions use this to make sure the page gets cleaned if a checkpoint is taken after any log record is sent to the log stream but before the page is actually dirtied.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateOverflowDetails</MethodName>
            <MethodComment>/** 
 * Update the overflow pointer for a long row &lt;BR&gt; MT - latched - page latch must be held
 * @param handle			handle of the record for long row
 * @param overflowHandle	the overflow (continuation) pointer for the long row
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateFieldOverflowDetails</MethodName>
            <MethodComment>/** 
 * Update the overflow pointer for a long column &lt;BR&gt; MT - latched - page latch must be held
 * @param handle			handle of the record for long row
 * @param overflowHandle	the overflow (continuation) pointer for the long row
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendOverflowFieldHeader</MethodName>
            <MethodComment>/** 
 * Append an overflow pointer to a partly logged row, to point to a long column that just been logged. &lt;BR&gt; MT - latched - page latch must be held
 * @param logBuffer		The buffer that contains the partially logged row.
 * @param overflowHandle	the overflow (continuation) pointerto the beginning of the long column
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logBuffer</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOverflowPageForInsert</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewOverflowPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BasePage</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#updateAtSlot
 * @exception StandardException	Standard Derby error policy
 * @exception StandardException	StandardException.newException(SQLState.UPDATE_DELETED_RECORDif the record is already deleted
 * @exception StandardException	StandardException.newException(SQLState.CONTAINER_READ_ONLYif the container is read only
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RecordHandle [handle=getRecordHandleAtSlot(slot)]</InnerVar>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;doUpdateAtSlot;[t, slot, handle.getId(), row, validColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doUpdateAtSlot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateFieldAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#updateFieldAtSlot
 * @exception StandardException	Standard Derby error policy
 * @exception StandardException	StandardException.newException(SQLState.UPDATE_DELETED_RECORDif the record is already deleted
 * @exception StandardException	StandardException.newException(SQLState.CONTAINER_READ_ONLYif the container is read only
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>RecordHandle [handle=getRecordHandleAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionUpdateField;[t, this, slot, handle.getId(), fieldId, newValue, undo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNumFields</MethodName>
            <MethodComment>/** 
 * @see Page#fetchNumFields
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNumFieldsAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#fetchNumFieldsAtSlot
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#deleteAtSlot
 * @param slot		the slot number
 * @param delete	true if this record is to be deleted, false if thisdeleted record is to be marked undeleted
 * @param undo		logical undo logic if necessary
 * @exception StandardException Standard exception policy. 
 * @exception StandardException	StandardException.newException(SQLState.UPDATE_DELETED_RECORDif an attempt to delete a record that is already deleted
 * @exception StandardException	StandardException.newException(SQLState.UNDELETE_RECORDif an attempt to undelete a record that is not deleted
 */
</MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>RecordHandle [handle=getRecordHandleAtSlot(slot)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionDelete;[t, this, slot, handle.getId(), delete, undo]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeAtSlot</MethodName>
            <MethodComment>/** 
 * Purge one or more rows on a non-overflow page.
 * @see Page#purgeAtSlot
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numpurges</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needDataLogged</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>int[] [recordIds=new int[numpurges]]</InnerVar>
                <InnerVar>PageKey [pageId=getPageId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionPurge;[t, this, slot, numpurges, recordIds, needDataLogged]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeRowPieces</MethodName>
            <MethodComment>/** 
 * Purge all the overflow columns and overflow rows of the record at slot.
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>needDataLogged</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyAndPurge</MethodName>
            <MethodComment>/** 
 * @see Page#copyAndPurge
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>destPage</ParamName>
                    <ParamType>Page</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>src_slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dest_slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BasePage [dpage=(BasePage)destPage]</InnerVar>
                <InnerVar>PageKey [pageId=getPageId()]</InnerVar>
                <InnerVar>int[] [recordIds=new int[num_rows]]</InnerVar>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dpage;copyInto;[this, src_slot, num_rows, dest_slot]</InnerMethodInvoke>
                <InnerMethodInvoke>owner.getActionSet();actionPurge;[t, this, src_slot, num_rows, recordIds, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unlatch</MethodName>
            <MethodComment>/** 
 * Unlatch the page.
 * @see Page#unlatch
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;releaseExclusive;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLatched</MethodName>
            <MethodComment>/** 
 * Check whether the page is latched.
 * @return &lt;code&gt;true&lt;/code&gt; if the page is latched, &lt;code&gt;false&lt;/code&gt;otherwise
 * @see Page#isLatched
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordCount</MethodName>
            <MethodComment>/** 
 * @see Page#recordCount 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalDeletedRecordCount</MethodName>
            <MethodComment>/** 
 * get record count without checking for latch
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>internalNonDeletedRecordCount</MethodName>
            <MethodComment>/** 
 * get record count without checking for latch
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [deletedCount=internalDeletedRecordCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nonDeletedRecordCount</MethodName>
            <MethodComment>/** 
 * @see Page#nonDeletedRecordCount 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shouldReclaimSpace</MethodName>
            <MethodComment>/** 
 * Is this page/deleted row a candidate for immediate reclaim space. &lt;p&gt; Used by access methods after executing a delete on "slot_just_deleted" to ask whether a post commit should be queued to try to reclaim space after the delete commits.   &lt;p&gt; Also used by access methods after undo of an insert. &lt;p&gt; Will return true if the number of non-deleted rows on the page is &amp;lt;= "num_non_deleted_rows".  For instance 0 means schedule reclaim only if all rows are deleted, 1 if all rows but one are deleted.   &lt;p&gt; Will return true if the row just deleted is either a long row or long column.  In this case doing a reclaim space on the single row may reclaim multiple pages of free space, so better to do it now rather than wait for all rows on page to be deleted.  This case is to address the worst case scenario of all rows with long columns, but very short rows otherwise.  In this case there could be 1000's of rows on the  main page with many gigabytes of data on overflow pages in deleted space that would not be reclaimed until all rows on the page were deleted.
 * @return true if a reclaim space should be scheduled post commit on thispage, false otherwise.
 * @param num_non_deleted_rows threshold number of non-deleted rows toschedule reclaim space.
 * @param slot_just_deleted    row on page to check for long row/long column
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>num_non_deleted_rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot_just_deleted</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDeletedOnPage</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDeletedAtSlot</MethodName>
            <MethodComment>/** 
 * @see Page#isDeletedAtSlot
 * @exception StandardException Standard exception policy. 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkSlotOnPage;[slot]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAuxObject</MethodName>
            <MethodComment>/** 
 * Set the aux object. &lt;BR&gt; MT - single thread required. Calls via the Page interface will have the page latched, thus providing single threadedness. Otherwise calls via this class are only made when the class has no-identity, thus only a single thread can see the object. 
 * @see Page#setAuxObject
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>AuxObject</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAuxObject</MethodName>
            <MethodComment>/** 
 * Get the aux object. &lt;BR&gt; MT - latched - It is required the caller throws away the returned reference when the page is unlatched.
 * @see Page#getAuxObject
 */
</MethodComment>
            <ReturnType>AuxObject</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRepositionNeeded</MethodName>
            <MethodComment>/** 
 * Set a hint in this page to make B-tree scans positioned on it reposition before they continue. This method is typically called when rows are removed from a B-tree leaf page (for instance in a page split).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRepositionNeeded</MethodName>
            <MethodComment>/** 
 * Check if a B-tree scan positioned on this page needs to reposition.
 * @param version the last version on which the B-tree scan had a validposition on this page
 * @return {@code true} if a repositioning is needed because the rowon the current position may have been removed from this page after the specified version;  {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>version</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>update</MethodName>
            <MethodComment>/** 
 * This object is set to observe the BaseContainerHandle it was obtained by, that handle will notify its observers when it is being closed. In that case we will release the latch on the page held by that container. &lt;BR&gt; MT - latched
 * @see DerbyObserver#update
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>DerbyObservable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>arg</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;releaseExclusive;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageId</MethodName>
            <MethodComment>/** 
 * Get the Page identifer &lt;BR&gt; MT - RESOLVE
 */
</MethodComment>
            <ReturnType>PageKey</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setExclusive</MethodName>
            <MethodComment>/** 
 * Get an exclusive latch on the page. &lt;BR&gt; MT - thread safe
 * @exception StandardException Standard Derby policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requester</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=requester.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setExclusiveNoWait</MethodName>
            <MethodComment>/** 
 * Get an exclusive latch on the page, but only if I don't have to wait. &lt;BR&gt; MT - thread safe
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requester</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=requester.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>releaseExclusive</MethodName>
            <MethodComment>/** 
 * Release the exclusive latch on the page. &lt;BR&gt; MT - latched
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner;deleteObserver;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;notifyAll;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preLatch</MethodName>
            <MethodComment>/** 
 * Move page state from UNLATCHED to PRELATCH. setExclusive*() routines do the work of completing the latch - using the preLatch status.
 * @param requester handle to the container requesting ownership
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requester</ParamName>
                    <ParamType>BaseContainerHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>requester;addObserver;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHeaderAtSlot</MethodName>
            <MethodComment>/** 
 * Must be called by any non-abstract sub-class to initialise the slot table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rh</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bumpRecordCount</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>number</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeaderAtSlot</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entireRecordOnPage</MethodName>
            <MethodComment>/** 
 * Returns true if the entire record of that slot fits inside of this page.  Returns false if part of the record on this slot overflows to other pages, either due to long row or long column.  &lt;BR&gt; MT - latched
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recordHeaderOnDemand</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkSlotOnPage</MethodName>
            <MethodComment>/** 
 * Is the given slot number on the page? &lt;BR&gt; MT - latched
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeleteStatus</MethodName>
            <MethodComment>/** 
 * Mark the record at the passed in slot as deleted. return code comes from StoredRecordHeader class: return	1, if delete status from not deleted to deleted return -1, if delete status from deleted to not deleted return  0, if status unchanged. &lt;BR&gt; &lt;B&gt;Any sub-class must call this method when deleting a record.&lt;/B&gt; &lt;BR&gt; MT - latched
 * @exception StandardException Standard Derby error policy
 * @exception IOException IO error accessing page
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deallocatePage</MethodName>
            <MethodComment>/** 
 * Mark this page as being deallocated
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionInvalidatePage;[t, this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initPage</MethodName>
            <MethodComment>/** 
 * Mark this page as being allocated and initialize it to a pristine page
 * @exception StandardException Derby Standard error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>initFlag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pageOffset</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionInitPage;[t, this, initFlag, getTypeFormatId(), pageOffset]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findRecordById</MethodName>
            <MethodComment>/** 
 * Find the slot for the record with the passed in identifier. &lt;BR&gt; This method returns the record regardless of its deleted status. &lt;BR&gt; The "slotHint" argument is a hint about what slot the record id might be in.  Callers may save the last slot where the record was across latch/unlatches to the page, and then pass that slot back as a hint -  if the page has not shuffled slots since the last reference then the hint will succeed and a linear search is saved.  If the caller has no idea where it may be, then FIRST_SLOT_NUMBER is passed in and a linear search is performed. &lt;BR&gt; MT - latched
 * @param recordId  record id of the record to search for.
 * @param slotHint "hint" about which slot the record might be in.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slotHint</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxSlot=recordCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findNextRecordById</MethodName>
            <MethodComment>/** 
 * Find the slot for the first record on the page with an id greater than  the passed in identifier. &lt;BR&gt; Returns the slot of the first record on the page with an id greater  than the one passed in.  Usefulness of this functionality depends on the clients use of the raw store interfaces.  If all "new" records are always inserted at the end of the page, and the raw store continues to guarantee that all record id's will be allocated in increasing order on a given page, then a page is always sorted in record id order.  For instance current heap tables function this way.  If the client ever inserts at a particular slot number, rather than at the "end" then the record id's will not be sorted. &lt;BR&gt; In the case where all record id's are always sorted on a page, then this routine can be used by scan's which "lose" their position because the row they have as a position was purged.  They can reposition their scan at the "next" row after the row that is now missing from the table. &lt;BR&gt; This method returns the record regardless of its deleted status. &lt;BR&gt; MT - latched
 * @param recordId  record id of the first record on the page with a record id higher than the one passed in.  If no  such record exists, -1 is returned.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [maxSlot=recordCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyInto</MethodName>
            <MethodComment>/** 
 * Copy num_rows from srcPage, src_slot into this page starting at dest_slot. This is destination page of the the copy half of copy and Purge.
 * @see Page#copyAndPurge
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>srcPage</ParamName>
                    <ParamType>BasePage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>src_slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>num_rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dest_slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RawTransaction [t=owner.getTransaction()]</InnerVar>
                <InnerVar>int[] [recordIds=new int[num_rows]]</InnerVar>
                <InnerVar>PageKey [pageId=getPageId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>owner.getActionSet();actionCopyRows;[t, this, srcPage, dest_slot, num_rows, src_slot, recordIds]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeAndShiftDown</MethodName>
            <MethodComment>/** 
 * Remove record at slot. &lt;p&gt; Remove the slot at the in-memory slot table, i.e., slots from 0 to deleteSlot-1 is untouched, deleteSlot is removed from in memory slot table, deleteSlot+1 .. recordCount()-1 move to down one slot. &lt;BR&gt; MT - latched
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[headers, slot + 1, headers, slot, headers.length - (slot + 1)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>shiftUp</MethodName>
            <MethodComment>/** 
 * Shift all records in the in-memory slot table up one slot, starting at and including the record in slot 'low' A new slot is added to accomdate the move. &lt;BR&gt; MT - latched
 */
</MethodComment>
            <ReturnType>StoredRecordHeader</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>low</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compactRecord</MethodName>
            <MethodComment>/** 
 * Try to compact this record.  Deleted record are treated the same way as nondeleted record.  This page must not be an overflow page.  The record may already have been purged from the page. &lt;P&gt; &lt;B&gt;Locking Policy&lt;/B&gt; &lt;P&gt; No locks are obtained. &lt;BR&gt; MT - latched &lt;P&gt; &lt;B&gt;NOTE : CAVEAT &lt;/B&gt;&lt;BR&gt; This operation will physically get rid of any reserved space this record may have, or it may compact the record by merging strung out row pieces together.  Since the freed reserved space is immediately usable by other transactions which latched the page, it is only safe to use this operation if the caller knows that it has exclusive access to the page for the duration of the transaction, i.e., effectively holding a page lock on the page, AND that the record has no uncommitted updates.
 * @param handle Handle to deleted or non-deleted record
 * @see ContainerHandle#compactRecord
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>handle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [slot=findRecordById(handle.getId(),handle.getSlotNumberHint())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLastLogInstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogInstant</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearLastLogInstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateLastLogInstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageVersion</MethodName>
            <MethodComment>/** 
 * Return the current page version.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bumpPageVersion</MethodName>
            <MethodComment>/** 
 * increment the version by one and return the new version.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPageVersion</MethodName>
            <MethodComment>/** 
 * set it when the page is read from disk. &lt;BR&gt; MT - single thread required - Only called while the page has no identity which requires that only a single caller can be accessing it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPageStatus</MethodName>
            <MethodComment>/** 
 * Set page status based on passed in status flag.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>status</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageStatus</MethodName>
            <MethodComment>/** 
 * Get the page status, one of the values in the above page status flag
 */
</MethodComment>
            <ReturnType>byte</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreRecordFromSlot</MethodName>
            <MethodComment>/** 
 * Read the record at the given slot into the given row. &lt;P&gt; This reads and initializes the columns in the row array from the raw  bytes stored in the page associated with the given slot.  If validColumns is non-null then it will only read those columns indicated by the bit set, otherwise it will try to read into every column in row[].   &lt;P&gt; If there are more columns than entries in row[] then it just stops after every entry in row[] is full. &lt;P&gt; If there are more entries in row[] than exist on disk, the requested  excess columns will be set to null by calling the column's object's restoreToNull() routine  (ie.  ((Object) column).restoreToNull() ). &lt;P&gt; If a qualifier list is provided then the row will only be read from disk if all of the qualifiers evaluate true.  Some of the columns may have been read into row[] in the process of evaluating the qualifier. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @param slot              the slot number
 * @param row (out)         filled in sparse row
 * @param fetchDesc         A set of information about the fetch: whatcolumns to fetch, any qualifiers, ...
 * @param rh                the record handle for the row at top level,and is used in OverflowInputStream to lock the  row for Blobs/Clobs.
 * @param isHeadRow         Is the head row portion of the row, false ifa long row and the 2-N'th portion of the long row.
 * @return  false if a qualifier_list is provided and the row does not qualifier (no row read in that case), else true.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchDesc</ParamName>
                    <ParamType>FetchDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rh</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordHeader</ParamName>
                    <ParamType>StoredRecordHeader</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isHeadRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restorePortionLongColumn</MethodName>
            <MethodComment>/** 
 * Read portion of a log record at the given slot into the given byteHolder. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fetchStream</ParamName>
                    <ParamType>OverflowInputStream</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordId</MethodName>
            <MethodComment>/** 
 * Create a new record identifier. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordIdAndBump</MethodName>
            <MethodComment>/** 
 * Create a new record identifier, and bump to next recordid. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRecordId</MethodName>
            <MethodComment>/** 
 * Create a new record identifier, the passed in one is the last one created. Use this method to collect and reserve multiple recordIds in one stroke.  Given the same input recordId, the subclass MUST return the same recordId every time. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>spaceForCopy</MethodName>
            <MethodComment>/** 
 * Is there space for copying this many rows which takes this many bytes on the page &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException Standard Derby policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>num_rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceNeeded</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTotalSpace</MethodName>
            <MethodComment>/** 
 * Return the total number of bytes used, reserved, or wasted by the record at this slot. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception StandardException Standard Derby policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReservedCount</MethodName>
            <MethodComment>/** 
 * Return the total number of bytes reserved by the record at this slot. &lt;BR&gt; MT - latched, page is latched when this methods is called.
 * @exception IOException Thrown by InputStream methods potential I/O errors
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRecordLength</MethodName>
            <MethodComment>/** 
 * Get the stored length of a record. This must match the amount of data written by logColumn and logField. &lt;BR&gt; MT - latched - page latch must be held
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>restoreRecordFromStream</MethodName>
            <MethodComment>/** 
 * Restore a storable row from a InputStream that was used to store the row after a logRecord call. &lt;BR&gt; MT - latched - page latch must be held
 * @exception StandardException	Standard Derby error policy
 * @exception IOException object exceeds the available data in the stream.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>LimitObjectInput</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logRecord</MethodName>
            <MethodComment>/** 
 * Log a currently stored record to the output stream. The logged version of the record must be readable by storeRecord. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot		Slot number the record is stored in.
 * @param flag		LOG_RECORD_*, the reason for logging the record.
 * @param recordId Record identifier of the record.
 * @param validColumns which columns needs to be logged
 * @param out		Where to write the logged form.
 * @param headRowHandle	the recordHandle of the head row piece, usedfor post commit cleanup for update. 
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flag</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>headRowHandle</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logRow</MethodName>
            <MethodComment>/** 
 * Log the row that will be stored at the given slot to the given OutputStream. The logged form of the Row must be readable by storeRecord. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot				Slot number the record will be stored in.
 * @param forInsert		True if the row is being logged for an insert,false for an update.
 * @param recordId			Record identifier of the record.
 * @param row				The row version of the record.
 * @param validColumns		FormatableBitSet of which columns in row are valid,null indicates all are valid
 * @param out				Where to write the logged form.
 * @param startColumn		The first column that is being logged in this row.This is used when logging portion of long rows.
 * @param insertFlag		To indicate whether the insert would allow overflow.
 * @param realStartColumn	This is used when a long column is detected.Portion of the row may already be logged and stored in the 'out' buffer.  After we log the long column, the saved buffer was passed here, and we need to continue to log the row.  realStartColumn is the starting column for the continuation of the logRow operation. Pass in (-1) if realStartColumn is not significant.
 * @param realSpaceOnPage	Being used in conjunction with realStartColumn,to indicate the real free space left on the page.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forInsert</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>Object[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>insertFlag</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>realStartColumn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>realSpaceOnPage</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logField</MethodName>
            <MethodComment>/** 
 * Log a currently stored field. The logged version of the field must be readable by storeField. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot		Slot number the record is stored in.
 * @param fieldNumber Number of the field (starts at 0).
 * @param out		Where to write the logged form.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>OutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logColumn</MethodName>
            <MethodComment>/** 
 * Log a to be stored column. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot		slot of the current record
 * @param fieldId	field number of the column being updated
 * @param column column version of the field.
 * @param out		Where to write the logged form.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflowThreshold</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>logLongColumn</MethodName>
            <MethodComment>/** 
 * Log a to be stored long column.  return -1 when done. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot			slot of the current record
 * @param recordId		the id of the long column record
 * @param column		column version of the field.
 * @param out			Where to write the logged form.
 * @exception StandardException	Standard Derby error policy
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>column</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>DynamicByteArrayOutputStream</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeRecord</MethodName>
            <MethodComment>/** 
 * Read a previously stored record written by logRecord or logRow and store it on the data page at the given slot with the given record identifier. Any previously stored record must be replaced. &lt;BR&gt; MT - latched - page latch must be held
 * @exception StandardException Standard Derby error policy
 * @exception IOException Thrown by InputStream methods potential I/O errorswhile writing the page
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forInsert</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeField</MethodName>
            <MethodComment>/** 
 * Read a previously stored field written by logField or logColumn and store it on the data page at thge given slot with the given record identifier and field number. Any previously stored field is replaced. &lt;BR&gt; MT - latched - page latch must be held
 * @exception StandardException Standard Derby error policy
 * @exception IOException Thrown by InputStream methods and potential I/O errorswhile writing the page.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reserveSpaceForSlot</MethodName>
            <MethodComment>/** 
 * Reserve the required number of bytes for the record in the specified slot. &lt;BR&gt; MT - latched - page latch must be held
 * @exception StandardException Standard Derby error policy
 * @exception IOException Thrown by InputStream methods and potential I/O errorswhile writing the page.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spaceToReserve</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipField</MethodName>
            <MethodComment>/** 
 * Skip a previously stored field written by logField or logColumn. &lt;BR&gt; MT - latched - page latch must be held
 * @exception StandardException Standard Derby error policy
 * @exception IOException Thrown by InputStream methods
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipRecord</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDeleteStatus</MethodName>
            <MethodComment>/** 
 * Set the delete status of a record from the page. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot the slot to delete or undelete
 * @param delete set delete status to this value 
 * @exception StandardException Standard Derby error policy
 * @exception IOException IO error accessing page
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delete</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeRecord</MethodName>
            <MethodComment>/** 
 * Purge a record from the page. &lt;BR&gt; MT - latched - page latch must be held
 * @param slot the slot to purge
 * @param recordId the id of the record that is to be purged
 * @exception StandardException Standard Derby error policy
 * @exception IOException Thrown by potential I/O errorswhile writing the page.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compactRecord</MethodName>
            <MethodComment>/** 
 * Subclass implementation of compactRecord.
 * @see BasePage#compactRecord
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>RawTransaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPageStatus</MethodName>
            <MethodComment>/** 
 * Set the page status underneath a log record &lt;BR&gt; MT - latched - page latch must be held
 * @param instant the log instant of the log record
 * @param status the page status
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>status</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initPage</MethodName>
            <MethodComment>/** 
 * initialize a page for the first time or for reuse All subtypes are expected to overwrite this method if it has something to clean up
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>status</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>recordId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>overflow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuse</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReservedSpace</MethodName>
            <MethodComment>/** 
 * Set the reserved space for this row to value.
 * @exception StandardException Standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>instant</ParamName>
                    <ParamType>LogInstant</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>slot</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOverflowPage</MethodName>
            <MethodComment>/** 
 * Return true if the page is an overflow page, false if not. For implementation that don't have overflow pages, return false.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>allowInsert</MethodName>
            <MethodComment>/** 
 * Returns false if an insert is not to be allowed in the page.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unfilled</MethodName>
            <MethodComment>/** 
 * Returns true if an insert is allowed in the page and the page is relatively unfilled - let specific implementation decide what relatively unfilled means
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setContainerRowCount</MethodName>
            <MethodComment>/** 
 * Set the number of rows in the container - the page uses this to decide whether it needs to aggressive set the container's row count when it changes. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPageArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>slotTableToString</MethodName>
            <MethodComment>/** 
 * Debugging, print slot table information 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [str=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>