<Class>
    <Id>1901</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>DataValueFactory</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataValueFactory  /** 
 * This interface is how we get data values of different types. For any method that takes a 'previous' argument it is required that the caller pass in an object of the same class that would be returned by the call if null was passed for previous.
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL int with the given value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL int with a char value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL smallint with the given value.  A null argument means get a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL TINYINT with the given value.  A null argument means get a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL bigint with the given value.  A null argument means get a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL real with the given value.  A null argument means get a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL double precision with the given value.  A null argument means a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL boolean with the given value.  A null argument means get a SQL null value.  The second arg  uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BooleanDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLongVarbitDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL Long Bit Varying with the given value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBlobDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL Blob with the given value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBlobDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL Blob with the given value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Blob</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL varchar with the given value.  A null argument means get a SQL null value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQLVarhar object to represent a SQL VARCHAR  (UCS_BASIC) with the given value. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new SQLVarchar will be created and set to the value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a StringDataValue to represent a SQL VARCHAR with the passed in collationType. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new StringDataValue will be created and set to the value. If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC then the call is the equivalent of the overload without collationType.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLongvarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL long varchar with the given value.  A null argument means get a SQL null value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLongvarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQLLongvarchar object to represent a SQL LONG VARCHAR  (UCS_BASIC) with the given value. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new SQLLongvarchar will be created and set to the value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLongvarcharDataValue</MethodName>
            <MethodComment>/** 
 * Get a StringDataValue to represent a SQL LONG VARCHAR with the passed in collationType. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new StringDataValue will be created and set to the value. If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC then the call is the equivalent of the overload without collationType.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClobDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC) with the given value. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new SQLLongvarchar will be created and set to the value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClobDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC) with the given value. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new SQLLongvarchar will be created and set to the value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Clob</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClobDataValue</MethodName>
            <MethodComment>/** 
 * Get a StringDataValue to represent a SQL LONG VARCHAR with the passed in collationType. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new StringDataValue will be created and set to the value. If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC then the call is the equivalent of the overload without collationType.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClobDataValue</MethodName>
            <MethodComment>/** 
 * Get a StringDataValue to represent a SQL CLOB with the passed in collationType. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new StringDataValue will be created and set to the value. If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC then the call is the equivalent of the overload without collationType.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Clob</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a User-defined data value with the given value and type name. A null argument means get a SQL null value.  The second arg uses the previous value (if non-null) hold the return value.
 */
</MethodComment>
            <ReturnType>UserDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>UserDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a RefDataValue with the given value.  A null argument means get a SQL null value.  Uses the previous value (if non-null) to hold the return value.
 */
</MethodComment>
            <ReturnType>RefDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>RefDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL int with the given value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL bigint with the given value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL real with the given value.  Uses the previous value, if non-null, as the data holder to return.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>float</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL double precision with the given value.  Uses the previous value, if non-null, as the data holder to return.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL SMALLINT with the given value.  Uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>short</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL TINYINT with the given value. Uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDecimalDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL DECIMAL with the given value. Uses the previous value, if non-null, as the data holder to return.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Number</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL boolean with the given value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BooleanDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBitDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL bit with the given value.  The second form re-uses the previous value, if non-null, as the data holder to return.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBitDataValue</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVarbitDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL bit with the given value.  Uses the previous value, if non-null, as the data holder to return.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCharDataValue</MethodName>
            <MethodComment>/** 
 * Get a new SQLChar object to represent a SQL CHAR (UCS_BASIC) with the given value. A null argument means get a SQL NULL value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCharDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQLChar object to represent a SQL CHAR  (UCS_BASIC with the given value. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new SQLChar will be created and set to the value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCharDataValue</MethodName>
            <MethodComment>/** 
 * Get a StringDataValue to represent a SQL CHAR with the passed in collationType. A null argument means get a SQL NULL value. If previous is not null (Java reference) then it will be set to the value passed in and returned, otherwise a new StringDataValue will be created and set to the value. If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC then the call is the equivalent of the overload without collationType.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL date with the given value.  A null argument means get a SQL null value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Date</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL time with the given value.  A null argument means get a SQL null value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Time</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataValue</MethodName>
            <MethodComment>/** 
 * Get a SQL timestamp with the given value.  A null argument means get a SQL null value.  The second arg re-uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Timestamp</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimestamp</MethodName>
            <MethodComment>/** 
 * Implement the timestamp SQL function: construct a SQL timestamp from a string, or timestamp.
 * @param operand Must be a timestamp or a string convertible to a timestamp.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimestamp</MethodName>
            <MethodComment>/** 
 * Construct a SQL timestamp from a date and time.
 * @param date Must be convertible to a date.
 * @param time Must be convertible to a time.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>date</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>time</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDate</MethodName>
            <MethodComment>/** 
 * Implements the SQL date function
 * @param operand A date, timestamp, string or integer.
 * @return the corresponding date value
 * @exception StandardException if the syntax is invalid or the date is out of range.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDateValue</MethodName>
            <MethodComment>/** 
 * @param dateStr A date in one of the DB2 standard date formats or the local format.
 * @param isJdbcEscape If true then the timestamp must be in the JDBC timestamp escape format, otherwise it mustbe in the DB2 timestamp format.
 * @return A DateTimeDataValue
 * @exception StandardException if the syntax is invalid or the date is out of range.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dateStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isJdbcEscape</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeValue</MethodName>
            <MethodComment>/** 
 * @param timeStr A date in one of the DB2 standard time formats or the local format.
 * @param isJdbcEscape If true then the timestamp must be in the JDBC time escape format, otherwise it mustbe in the DB2 time format.
 * @return A DateTimeDataValue
 * @exception StandardException if the syntax is invalid or the time is out of range.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timeStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isJdbcEscape</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimestampValue</MethodName>
            <MethodComment>/** 
 * @param timestampStr A time in string format.
 * @param isJdbcEscape If true then the time must be in the JDBC time escape format, otherwise it mustbe in the DB2 time format.
 * @return An internal timestamp
 * @exception StandardException if the syntax is invalid or the timestamp is out of range.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>timestampStr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isJdbcEscape</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXMLDataValue</MethodName>
            <MethodComment>/** 
 * Get a null XML value. Uses the previous value, if non-null, as the data holder to return.
 */
</MethodComment>
            <ReturnType>XMLDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>previous</ParamName>
                    <ParamType>XMLDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullInteger</MethodName>
            <MethodComment>/** 
 * Get a SQL int with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullShort</MethodName>
            <MethodComment>/** 
 * Get a SQL smallint with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullByte</MethodName>
            <MethodComment>/** 
 * Get a SQL tinyint with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullLong</MethodName>
            <MethodComment>/** 
 * Get a SQL bigint with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullFloat</MethodName>
            <MethodComment>/** 
 * Get a SQL float with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullDouble</MethodName>
            <MethodComment>/** 
 * Get a SQL double with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullDecimal</MethodName>
            <MethodComment>/** 
 * Get a SQL Decimal/Numeric with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>NumberDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>NumberDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullBoolean</MethodName>
            <MethodComment>/** 
 * Get a SQL boolean with  a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>BooleanDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>BooleanDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullBit</MethodName>
            <MethodComment>/** 
 * Get a SQL Bit with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullVarbit</MethodName>
            <MethodComment>/** 
 * Get a SQL Bit Varying with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullLongVarbit</MethodName>
            <MethodComment>/** 
 * Get a SQL Long Bit Varying with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullBlob</MethodName>
            <MethodComment>/** 
 * Get a SQL Blob with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>BitDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>BitDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullChar</MethodName>
            <MethodComment>/** 
 * Get a SQL CHAR (UCS_BASIC) with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullChar</MethodName>
            <MethodComment>/** 
 * Get a SQL CHAR set to NULL with collation set to collationType. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullVarchar</MethodName>
            <MethodComment>/** 
 * Get a SQL VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullVarchar</MethodName>
            <MethodComment>/** 
 * Get a SQL VARCHAR set to NULL with collation set to collationType. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullLongvarchar</MethodName>
            <MethodComment>/** 
 * Get a SQL LONG VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullLongvarchar</MethodName>
            <MethodComment>/** 
 * Get a SQL LONG VARCHAR set to NULL with collation set to collationType. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullClob</MethodName>
            <MethodComment>/** 
 * Get a SQL CLOB (UCS_BASIC) with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullClob</MethodName>
            <MethodComment>/** 
 * Get a SQL CLOB set to NULL with collation set to collationType. If the supplied value is null then get a new value, otherwise set it to null and return that value.
 */
</MethodComment>
            <ReturnType>StringDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>StringDataValue</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullObject</MethodName>
            <MethodComment>/** 
 * Get a User-defined data value with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>UserDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>UserDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullRef</MethodName>
            <MethodComment>/** 
 * Get a RefDataValue with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>RefDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>RefDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullDate</MethodName>
            <MethodComment>/** 
 * Get a SQL date with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullTime</MethodName>
            <MethodComment>/** 
 * Get a SQL time with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullTimestamp</MethodName>
            <MethodComment>/** 
 * Get a SQL timestamp with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>DateTimeDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>DateTimeDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullXML</MethodName>
            <MethodComment>/** 
 * Get an XML with a SQL null value. If the supplied value is null then get a new value, otherwise set it to null and return  that value.
 */
</MethodComment>
            <ReturnType>XMLDataValue</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataValue</ParamName>
                    <ParamType>XMLDataValue</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCharacterCollator</MethodName>
            <MethodComment>/** 
 * Return the RuleBasedCollator depending on the collation type.  If the collation type is UCS_BASIC, then this method will return  null. If the collation type is TERRITORY_BASED then the return value will be the Collator derived from the database's locale. If this is the first time Collator is being requested for a database with collation type of TERRITORY_BASED, then we will check  to make sure that JVM supports the Collator for the database's  locale. If not, we will throw an exception  This method will be used when Store code is trying to create a DVD template row using the format ids and the collation types. First a DVD will be constructed just using format id. Then if the DVD is of type StringDataValue, then it will call this method to get the Collator object. If the Collator object returned from this method is null then we will continue to use the default DVDs for the character types, ie the DVDs which just use the JVM's default collation. (This is why, we want this method to return null if we are dealing with UCS_BASIC.) If the Collator object returned is not null, then we will construct collation sensitive DVD for the character types. So, the return value of this method determines if we are going to create a character DVD with default collation or with custom collation. 
 * @param collationType This will be UCS_BASIC or TERRITORY_BASED
 * @return Collator null if the collation type is UCS_BASIC.Collator based on territory if the collation type is TERRITORY_BASED
 */
</MethodComment>
            <ReturnType>RuleBasedCollator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNull</MethodName>
            <MethodComment>/** 
 * Return an object based on the format id and collation type. For format ids which do not correspond to character types, a format id is sufficient to get the right DVD. But for character types, Derby uses same format id for collation sensitive character types and for character types that use the default JVM collation. To get the correct DVD for character types, we need to know the collation type. Using collation type, we will determine if we need to construct collation sensitive DVD and associate the correct RuleBasedCollator with such DVDs.
 * @param formatId Format id for the DVD
 * @param collationType this is meaningful only for character types.
 * @return DataValueDescriptor which will be constructed using the passed parameters 
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>