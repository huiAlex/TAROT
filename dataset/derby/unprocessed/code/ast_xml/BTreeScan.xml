<Class>
    <Id>614</Id>
    <Package>org.apache.derby.impl.store.access.btree</Package>
    <ClassName>BTreeScan</ClassName>
    <SuperClass>OpenBTree</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ScanManager</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BTreeScan  /** 
 * A b-tree scan controller corresponds to an instance of an open b-tree scan. &lt;P&gt; &lt;B&gt;Concurrency Notes&lt;/B&gt; &lt;P&gt; The concurrency rules are derived from OpenBTree. &lt;P&gt;
 * @see OpenBTree
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>init_rawtran</FieldName>
            <FieldType>Transaction</FieldType>
        </Field>
        <Field>
            <FieldName>init_forUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>init_scanColumnList</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>init_template</FieldName>
            <FieldType>DataValueDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>init_startKeyValue</FieldName>
            <FieldType>DataValueDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>init_startSearchOperator</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_qualifier</FieldName>
            <FieldType>Qualifier</FieldType>
        </Field>
        <Field>
            <FieldName>init_stopKeyValue</FieldName>
            <FieldType>DataValueDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>init_stopSearchOperator</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_hold</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>init_fetchDesc</FieldName>
            <FieldType>FetchDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>init_lock_fetch_desc</FieldName>
            <FieldType>FetchDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>scan_position</FieldName>
            <FieldType>BTreeRowPosition</FieldType>
        </Field>
        <Field>
            <FieldName>init_useUpdateLocks</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_INIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_INPROGRESS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_DONE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_HOLD_INIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SCAN_HOLD_INPROGRESS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>scan_state</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stat_numpages_visited</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stat_numrows_visited</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stat_numrows_qualified</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stat_numdeleted_rows_visited</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>lock_operation</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>fetchNext_one_slot_array</FieldName>
            <FieldType>DataValueDescriptor[][]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BTreeScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchRows</MethodName>
            <MethodComment>/** 
 * Fetch the next N rows from the table. &lt;p&gt; Utility routine used by both fetchSet() and fetchNextGroup().
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>row_array</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hash_table</ParamName>
                    <ParamType>BackingStoreHashtable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key_column_numbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initScanParams</MethodName>
            <MethodComment>/** 
 * Shared initialization code between init() and reopenScan(). &lt;p&gt; Basically save away input parameters describing qualifications for the scan, and do some error checking.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scan_position;init;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtStartForForwardScan</MethodName>
            <MethodComment>/** 
 * Position scan at "start" position for a forward scan. &lt;p&gt;  Positions the scan to the slot just before the first record to be  returned from the scan.  Returns the start page latched, and  sets "current_slot" to the slot number. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [exact]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtNextPage</MethodName>
            <MethodComment>/** 
 * Position scan to 0 slot on next page. &lt;p&gt; Position to next page, keeping latch on previous page until we have  latch on next page.  This routine releases the latch on current_page once it has successfully gotten the latch on the next page.
 * @param pos           current row position of the scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pos.current_leaf;release;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtPreviousPage</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Position the scan after the last row on the previous page. Hold the latch on the current page until the previous page has been latched. If the immediate left sibling is empty, move further until a non-empty page is found or there are no more leaves to be found. The latch on the current page will be held until a non-empty left sibling page is found. &lt;/p&gt; &lt;p&gt; This method never waits for a latch, as waiting for latches while holding another latch is only allowed when moving forward in the B-tree. Waiting while moving backward may result in deadlocks with scanners going forward. A  {@code WaitError} is thrown if the previous page cannotbe latched without waiting.  {@code scan_position.current_leaf} willpoint to the same page as before the method was called in the case where a  {@code WaitError} is thrown, and the page will still be latched.&lt;/p&gt;
 * @throws StandardException standard exception policy
 * @throws WaitError if the previous page cannot be latched immediately
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BTreeRowPosition [pos=scan_position]</InnerVar>
                <InnerVar>LeafControlRow [leaf=(LeafControlRow)pos.current_leaf.getLeftSibling(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pos.current_leaf;release;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>WaitError</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * Check if a B-tree page is empty. The control row, which is always present, is not counted.
 * @param page the B-tree page to check
 * @return true if the page is empty, false otherwise
 * @throws StandardException standard exception policy
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>page</ParamName>
                    <ParamType>Page</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtStartPosition</MethodName>
            <MethodComment>/** 
 * Position scan at "start" position. &lt;p&gt; Positions the scan to the slot just before the first record to be returned from the scan.  Returns the start page latched, and sets "current_slot" to the slot number.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtDoneScanFromClose</MethodName>
            <MethodComment>/** 
 * Do any necessary work to complete the scan.
 * @param pos           current row position of the scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtDoneScan</MethodName>
            <MethodComment>/** 
 * Do work necessary to close a scan. &lt;p&gt; This routine can only be called "inline" from other btree routines, as it counts on the state of the pos to be correct. &lt;p&gt; Closing a scan from close() must handle long jumps from exceptions where the state of pos may not be correct.  The easiest case is a lock timeout which has caused us not to have a latch on a page, but pos still thinks there is a latch.  This is the easiest but other exceptions can also caused the same state at close() time.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>process_qualifier</MethodName>
            <MethodComment>/** 
 * process_qualifier - Determine if a row meets all qualifier conditions. &lt;p&gt; Check all qualifiers in the qualifier array against row.  Return true if all compares specified by the qualifier array return true, else return false. &lt;p&gt; It is up to caller to make sure qualifier list is non-null.
 * @param row      The row with the same partial column list as therow returned by the current scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [row_qualifies=true]</InnerVar>
                <InnerVar>Qualifier [q]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reposition</MethodName>
            <MethodComment>/** 
 * Reposition the scan leaving and reentering the access layer. &lt;p&gt; When a scan leaves access it saves the RecordHandle of the record on the page.  There are 2 cases to consider when trying to reposition the scan when re-entering access: o ROW has not moved off the page. If the row has not moved then the RecordHandle we have saved away is valid, and we just call RawStore to reposition on that RecordHandle (RawStore takes care of the row moving within the page). o ROW has moved off the page. This can only happen in the case of a btree split.  In that case the splitter will have caused all scans positioned on  this page within the same transaction to save a copy of the row that the scan was positioned on.  Then to reposition the scan it is necessary to research the tree from the top using the copy of the row. There are a few cases where it is possible that the key no longer exists in the table.  In the case of a scan held  open across commit it is easy to imagine that the row the scan was  positioned on could be deleted and subsequently purged from the table  all before the scan resumes.  Also in the case of read uncommitted  the scan holds no lock on the current row, so it could be purged - in the following scenario for instance:  read uncommitted transaction 1 opens scan and positions on row (1,2), transaction 2 deletes (1,2) and commits, transaction 1 inserts (1,3) which goes to same page as (1,2) and is going to cause a split, transaction 1 saves scan position as key, and then purges row (1, 2), when transaction 1 resumes scan (1, 2) no longer exists.  missing_row_for_key_ok  parameter is added as a sanity check to make sure it ok that  repositioning does not go to same row that we were repositioned on.
 * @param pos                     position to set the scan to.
 * @param missing_row_for_key_ok  if true and exact key is not found thenscan is just set to key just left of the key (thus a next will move to the key just after "pos")
 * @return  returns true if scan has been repositioned successfully, elsereturns false if the position key could not be found and missing_row_for_key_ok was false indicating that scan could only be positioned on the exact key match.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>missing_row_for_key_ok</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SearchParameters [sp=new SearchParameters(pos.current_positionKey,SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,init_template,this,false)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * Initialize the scan for use. &lt;p&gt; Any changes to this method may have to be reflected in close as well. &lt;p&gt; The btree init opens the container (super.init), and stores away the state of the qualifiers.  The actual searching for the first position is delayed until the first next() call.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>btree_locking_policy</ParamName>
                    <ParamType>BTreeLockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scanColumnList</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerate</ParamName>
                    <ParamType>BTree</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>static_info</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initScanParams;[startKeyValue, startSearchOperator, qualifier, stopKeyValue, stopSearchOperator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the scan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;positionAtDoneScanFromClose;[scan_position]</InnerMethodInvoke>
                <InnerMethodInvoke>this.getXactMgr();closeMe;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delete</MethodName>
            <MethodComment>/** 
 * Delete the row at the current position of the scan.
 * @see ScanController#delete
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [ret_val=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>didNotQualify</MethodName>
            <MethodComment>/** 
 * A call to allow client to indicate that current row does not qualify. &lt;p&gt; Indicates to the ScanController that the current row does not qualify for the scan.  If the isolation level of the scan allows,  this may result in the scan releasing the lock on this row. &lt;p&gt; Note that some scan implimentations may not support releasing locks on  non-qualifying rows, or may delay releasing the lock until sometime later in the scan (ie. it may be necessary to keep the lock until  either the scan is repositioned on the next row or page). &lt;p&gt; This call should only be made while the scan is positioned on a current valid row.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>doesCurrentPositionQualify</MethodName>
            <MethodComment>/** 
 * Returns true if the current position of the scan still qualifies under the set of qualifiers passed to the openScan().  When called this routine will reapply all qualifiers against the row currently positioned and return true if the row still qualifies.  If the row has been deleted or no longer passes the qualifiers then this routine will return false. &lt;p&gt; This case can come about if the current scan or another scan on the same table in the same transaction deleted the row or changed columns referenced by the qualifier after the next() call which positioned the scan at this row. &lt;p&gt; Note that for comglomerates which don't support update, like btree's, there is no need to recheck the qualifiers. &lt;p&gt; The results of a fetch() performed on a scan positioned on a deleted row are undefined. &lt;p&gt;
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetch</MethodName>
            <MethodComment>/** 
 * Fetch the row at the current position of the Scan.
 * @param row The row into which the value of the current position in the scan is to be stored.
 * @param qualify indicates whether the qualifiers should be applied.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualify</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isHeldAfterCommit</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.store.access.ScanController#isHeldAfterCommit
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetch</MethodName>
            <MethodComment>/** 
 * Fetch the row at the current position of the Scan.
 * @see ScanController#fetch
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;fetch;[row, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchWithoutQualify</MethodName>
            <MethodComment>/** 
 * Fetch the row at the current position of the Scan without applying the  qualifiers.
 * @see ScanController#fetchWithoutQualify
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;fetch;[row, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanInfo</MethodName>
            <MethodComment>/** 
 * Return ScanInfo object which describes performance of scan. &lt;p&gt; Return ScanInfo object which contains information about the current scan. &lt;p&gt;
 * @see ScanInfo
 * @return The ScanInfo object which contains info about current scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ScanInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCurrentPositionDeleted</MethodName>
            <MethodComment>/** 
 * Returns true if the current position of the scan is at a deleted row.  This case can come about if the current scan or another scan on the same table in the same transaction deleted the row after the next() call which positioned the scan at this row. The results of a fetch() performed on a scan positioned on a deleted row are undefined.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [ret_val]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isKeyed</MethodName>
            <MethodComment>/** 
 * Return whether this is a keyed conglomerate. &lt;p&gt;
 * @return whether this is a keyed conglomerate.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtRowLocation</MethodName>
            <MethodComment>/** 
 * @see ScanController#positionAtRowLocation Not implemented for this class
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rLoc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment>/** 
 * Move to the next position in the scan.
 * @see ScanController#next
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [ret_val=fetchRows(scan_position,fetchNext_one_slot_array,(RowLocation[])null,(BackingStoreHashtable)null,1,(int[])null) == 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNext</MethodName>
            <MethodComment>/** 
 * Fetch the row at the next position of the Scan. If there is a valid next position in the scan then the value in the template storable row is replaced with the value of the row at the current scan position.  The columns of the template row must be of the same type as the actual columns in the underlying conglomerate. The resulting contents of templateRow after a fetchNext()  which returns false is undefined. The result of calling fetchNext(row) is exactly logically equivalent to making a next() call followed by a fetch(row) call.  This interface allows implementations to optimize  the 2 calls if possible.
 * @param row The template row into which the valueof the next position in the scan is to be stored.
 * @return True if there is a next position in the scan,false if there isn't.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNextGroup</MethodName>
            <MethodComment>/** 
 * Fetch the next N rows from the table. &lt;p&gt; The client allocates an array of N rows and passes it into the fetchNextSet() call.  This routine does the equivalent of N  fetchNext() calls, filling in each of the rows in the array. Locking is performed exactly as if the N fetchNext() calls had been made. &lt;p&gt; It is up to Access how many rows to return.  fetchNextSet() will return how many rows were filled in.  If fetchNextSet() returns 0 then the scan is complete, (ie. the scan is in the same state as if fetchNext() had returned false).  If the scan is not complete then fetchNext() will return (1 &amp;lt;= row_count &amp;lt;= N). &lt;p&gt; The current position of the scan is undefined if fetchNextSet() is used (ie. mixing fetch()/fetchNext() and fetchNextSet() calls in a single scan does not work).  This is because a fetchNextSet() request for 5 rows from a heap where the first 2 rows qualify, but no other rows qualify will result in the scan being positioned at the end of the table, while if 5 rows did qualify the scan will be positioned on the 5th row. &lt;p&gt; Qualifiers, start and stop positioning of the openscan are applied just as in a normal scan.  &lt;p&gt; The columns of the row will be the standard columns returned as part of a scan, as described by the validColumns - see openScan for description. &lt;p&gt; Expected usage: // allocate an array of 5 empty row templates DataValueDescriptor[][] row_array = allocate_row_array(5); int row_cnt = 0; scan = openScan(); while ((row_cnt = scan.fetchNextSet(row_array) != 0) { // I got "row_cnt" rows from the scan.  These rows will be // found in row_array[0] through row_array[row_cnt - 1] } &lt;p&gt; RESOLVE - This interface is being provided so that we can prototype the performance results it can achieve.  If it looks like this interface is useful, it is very likely we will look into a better way to tie together the now 4 different fetch interfaces: fetch, fetchNext(), fetchNextGroup(), and fetchSet().
 * @return The number of qualifying rows found and copied into the provided array of rows.  If 0 then the scan is complete,  otherwise the return value will be:  1 &amp;lt;= row_count &amp;lt;= row_array.length
 * @param row_array         The array of rows to copy rows into.  row_array[].length must &amp;gt;= 1.  This routine assumes that all entries in the array  contain complete template rows.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row_array</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNextGroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row_array</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old_rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchSet</MethodName>
            <MethodComment>/** 
 * Insert all rows that qualify for the current scan into the input Hash table.   &lt;p&gt; This routine scans executes the entire scan as described in the  openScan call.  For every qualifying unique row value an entry is placed into the HashTable. For unique row values the entry in the BackingStoreHashtable has a key value of the object stored in  row[key_column_number], and the value of the data is row.  For row  values with duplicates, the key value is also row[key_column_number],  but the value of the data is a Vector of rows.  The caller will have to call "instanceof" on the data value object if duplicates are expected, to determine if the data value of the Hashtable entry is a row or is a Vector of rows. &lt;p&gt; Note, that for this routine to work efficiently the caller must  ensure that the object in row[key_column_number] implements  the hashCode and equals method as appropriate for it's datatype. &lt;p&gt; It is expected that this call will be the first and only call made in an openscan.  Qualifiers and stop position of the openscan are applied just as in a normal scan.  This call is logically equivalent to the  caller performing the following: import java.util.Hashtable; hash_table = new Hashtable(); while (next()) { row = create_new_row(); fetch(row); if ((duplicate_value =  hash_table.put(row[key_column_number], row)) != null) { Vector row_vec; // inserted a duplicate if ((duplicate_value instanceof vector)) { row_vec = (Vector) duplicate_value; } else { // allocate vector to hold duplicates row_vec = new Vector(2); // insert original row into vector row_vec.addElement(duplicate_value); // put the vector as the data rather than the row hash_table.put(row[key_column_number], row_vec); } // insert new row into vector row_vec.addElement(row); } } &lt;p&gt; The columns of the row will be the standard columns returned as part of a scan, as described by the validColumns - see openScan for description. RESOLVE - is this ok?  or should I hard code somehow the row to be the first column and the row location? &lt;p&gt; Currently it is only possible to hash on the first column in the conglomerate, in the future we may change the interface to allow hashing either on a different column or maybe on a combination of columns. &lt;p&gt; No overflow to external storage is provided, so calling this routine on a 1 gigabyte conglomerate will incur at least 1 gigabyte of memory (probably failing with a java out of memory condition).  If this routine gets an out of memory condition, or if "max_rowcnt" is  exceeded then then the routine will give up, empty the Hashtable,  and return "false." &lt;p&gt; On exit from this routine, whether the fetchSet() succeeded or not the scan is complete, it is positioned just the same as if the scan had been drained by calling "next()" until it returns false (ie.  fetchNext() and next() calls will return false).   reopenScan() can be called to restart the scan. &lt;p&gt; RESOLVE - until we get row counts what should we do for sizing the the size, capasity, and load factor of the hash table. For now it is up to the caller to create the Hashtable, Access does not reset any parameters. &lt;p&gt; RESOLVE - I am not sure if access should be in charge of allocating the new row objects.  I know that I can do this in the case of btree's, but I don't think I can do this in heaps. Maybe this is solved by work to be done on the sort  interface.
 * @param max_rowcnt        The maximum number of rows to insert into the Hash table.  Pass in -1 if there is no maximum.
 * @param key_column_numbers The column numbers of the columns in thescan result row to be the key to the Hashtable. "0" is the first column in the scan result row (which may be different than the first column in the row in the table of the scan).
 * @param hash_table        The java HashTable to load into.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>max_rowcnt</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key_column_numbers</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hash_table</ParamName>
                    <ParamType>BackingStoreHashtable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;fetchRows;[scan_position, (DataValueDescriptor[][])null, (RowLocation[])null, (BackingStoreHashtable)hash_table, max_rowcnt, key_column_numbers]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenScan</MethodName>
            <MethodComment>/** 
 * Reposition the current scan.  This call is semantically the same as if the current scan had been closed and a openScan() had been called instead. The scan is reopened with against the same conglomerate, and the scan is reopened with the same "hold" and "forUpdate" parameters passed in the original openScan.  The previous template row continues to be used.
 * @param startKeyValue  An indexable row which holds a(partial) key value which, in combination with the startSearchOperator, defines the starting position of the scan.  If null, the starting position of the scan is the first row of the conglomerate.
 * @param startSearchOperator an operator which defineshow the startKeyValue is to be searched for.  If startSearchOperation is ScanController.GE, the scan starts on the first row which is greater than or equal to the startKeyValue.  If startSearchOperation is ScanController.GT, the scan starts on the first row whose key is greater than startKeyValue.  The startSearchOperation parameter is ignored if the startKeyValue parameter is null.
 * @param qualifier An array of qualifiers which, appliedto each key, restrict the rows returned by the scan.  Rows for which any one of the qualifiers returns false are not returned by the scan. If null, all rows are returned.
 * @param stopKeyValue  An indexable row which holds a(partial) key value which, in combination with the stopSearchOperator, defines the ending position of the scan.  If null, the ending position of the scan is the last row of the conglomerate.
 * @param stopSearchOperator an operator which defineshow the stopKeyValue is used to determine the scan stopping position. If stopSearchOperation is ScanController.GE, the scan stops just before the first row which is greater than or equal to the stopKeyValue.  If stopSearchOperation is ScanController.GT, the scan stops just before the first row whose key is greater than startKeyValue.  The stopSearchOperation parameter is ignored if the stopKeyValue parameter is null.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyValue</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initScanParams;[startKeyValue, startSearchOperator, qualifier, stopKeyValue, stopSearchOperator]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenScanByRowLocation</MethodName>
            <MethodComment>/** 
 * Reposition the current scan.  This call is semantically the same as if the current scan had been closed and a openScan() had been called instead. The scan is reopened against the same conglomerate, and the scan is reopened with the same "scan column list", "hold" and "forUpdate" parameters passed in the original openScan.   &lt;p&gt; The statistics gathered by the scan are not reset to 0 by a reopenScan(), rather they continue to accumulate. &lt;p&gt; Note that this operation is currently only supported on Heap conglomerates. Also note that order of rows within are heap are not guaranteed, so for instance positioning at a RowLocation in the "middle" of a heap, then inserting more data, then continuing the scan is not guaranteed to see the new rows - they may be put in the "beginning" of the heap.
 * @param startRowLocation  An existing RowLocation within the conglomerate,at which to position the start of the scan.  The scan will begin at this location and continue forward until the end of the conglomerate.   Positioning at a non-existent RowLocation (ie. an invalid one or one that had been deleted), will result in an exception being thrown when the  first next operation is attempted.
 * @param qualifier An array of qualifiers which, appliedto each key, restrict the rows returned by the scan.  Rows for which any one of the qualifiers returns false are not returned by the scan. If null, all rows are returned.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startRowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchLocation</MethodName>
            <MethodComment>/** 
 * Fetch the location of the current position in the scan.
 * @see ScanController#fetchLocation
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templateLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newRowLocationTemplate</MethodName>
            <MethodComment>/** 
 * Return a row location object of the correct type to be used in calls to fetchLocation.
 * @see org.apache.derby.iapi.store.access.GenericScanController#newRowLocationTemplate
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * Replace the entire row at the current position of the scan. Unimplemented interface by btree, will throw an exception.
 * @see ScanController#replace
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>validColumns</ParamName>
                    <ParamType>FormatableBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeForEndTransaction</MethodName>
            <MethodComment>/** 
 * Close the scan, a commit or abort is about to happen.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closeHeldScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>savePositionAndReleasePage</MethodName>
            <MethodComment>/** 
 * Save the current scan position by key and release the latch on the leaf that's being scanned. This method should be called if the latch on a leaf needs to be released in the middle of the scan. The scan can later reposition to the saved position by calling  {@code reposition()}.
 * @param partialKey known parts of the key that should be saved, or{@code null} if the entire key is unknown and will have to be fetchedfrom the page
 * @param vcols an array which tells which columns of the partial key arevalid (key columns that have 0 in this array are not valid, and their values must be fetched from the page), or  {@code null} if all thecolumns are valid
 * @throws StandardException if an error occurs while saving the position
 * @see #reposition(BTreeRowPosition,boolean)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>partialKey</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>vcols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Page [page=scan_position.current_leaf.getPage()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>savePositionAndReleasePage</MethodName>
            <MethodComment>/** 
 * Shortcut for for savePositionAndReleasePage(null,null). 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;savePositionAndReleasePage;[null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRecordHandleForDebugging</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RecordHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>