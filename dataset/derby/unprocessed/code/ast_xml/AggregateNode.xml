<Class>
    <Id>2176</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>AggregateNode</ClassName>
    <SuperClass>UnaryOperatorNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AggregateNode  /** 
 * An Aggregate Node is a node that represents a set function/aggregate. It used for all system aggregates as well as user defined aggregates.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>aggName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>aggClassName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>argType</FieldName>
            <FieldType>TypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>returnType</FieldName>
            <FieldType>TypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>BUILTIN_MODERN_AGGS</FieldName>
            <FieldType>BuiltinAggDescriptor[]</FieldType>
        </Field>
        <Field>
            <FieldName>distinct</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>uad</FieldName>
            <FieldType>AggregateDefinition</FieldType>
        </Field>
        <Field>
            <FieldName>userAggregateName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>aggregatorClassName</FieldName>
            <FieldType>StringBuffer</FieldType>
        </Field>
        <Field>
            <FieldName>aggregateDefinitionClassName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>aggregateDefinitionClass</FieldName>
            <FieldType>Class</FieldType>
        </Field>
        <Field>
            <FieldName>aggregateDefinitionClass</FieldName>
            <FieldType>?</FieldType>
        </Field>
        <Field>
            <FieldName>classInspector</FieldName>
            <FieldType>ClassInspector</FieldType>
        </Field>
        <Field>
            <FieldName>aggregateName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>generatedRC</FieldName>
            <FieldType>ResultColumn</FieldType>
        </Field>
        <Field>
            <FieldName>generatedRef</FieldName>
            <FieldType>ColumnReference</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BuiltinAggDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>aggName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>argType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>returnType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AggregateNode</MethodName>
            <MethodComment>/** 
 * Constructed when binding a StaticMethodNode that we realize is an aggregate.
 * @param operand the value expression for the aggregate
 * @param uadClass the class of the user aggregate definition
 * @param alias the name by which the aggregate was called
 * @param distinct boolean indicating whether this is distinctor not.
 * @param aggregateName the name of the aggregate from the user'sperspective, e.g. MAX
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uadClass</ParamName>
                    <ParamType>UserAggregateDefinition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>alias</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distinct</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setUserDefinedAggregate;[uadClass]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AggregateNode</MethodName>
            <MethodComment>/** 
 * @param operand the value expression for the aggregate
 * @param uadClass the class name for user aggregate definitionfor the aggregate
 * @param distinct boolean indicating whether this is distinctor not.
 * @param aggregateName the name of the aggregate from the user'sperspective, e.g. MAX
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uadClass</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distinct</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AggregateNode</MethodName>
            <MethodComment>/** 
 * @param operand the value expression for the aggregate
 * @param uadClass Class for the internal aggregate type
 * @param distinct boolean indicating whether this is distinctor not.
 * @param aggregateName the name of the aggregate from the user'sperspective, e.g. MAX
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operand</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>uadClass</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>distinct</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUserDefinedAggregate</MethodName>
            <MethodComment>/** 
 * initialize fields for user defined aggregate 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>userAgg</ParamName>
                    <ParamType>UserAggregateDefinition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceAggregatesWithColumnReferences</MethodName>
            <MethodComment>/** 
 * Replace aggregates in the expression tree with a ColumnReference to that aggregate, append the aggregate to the supplied RCL (assumed to be from the child ResultSetNode) and return the ColumnReference. This is useful for pushing aggregates in the Having clause down to the user's select at parse time.  It is also used for moving around  Aggregates in the select list when creating the Group By node.  In  that case it is called &lt;B&gt; after &lt;/B&gt; bind time, so we need to create the column differently.
 * @param rcl	The RCL to append to.
 * @param tableNumber	The tableNumber for the new ColumnReference
 * @return ValueNode	The (potentially) modified tree.
 * @exception StandardException			Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAggregateDefinition</MethodName>
            <MethodComment>/** 
 * Get the AggregateDefinition.
 * @return The AggregateDefinition
 */
</MethodComment>
            <ReturnType>AggregateDefinition</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedRC</MethodName>
            <MethodComment>/** 
 * Get the generated ResultColumn where this aggregate now resides after a call to  replaceAggregatesWithColumnReference().
 * @return the result column
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedRef</MethodName>
            <MethodComment>/** 
 * Get the generated ColumnReference to this aggregate after the parent called replaceAggregatesWithColumnReference().
 * @return the column reference
 */
</MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this operator.  Determine the type of the subexpression, and pass that into the UserAggregate.
 * @param fromList			The query's FROM list
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>DataTypeDescriptor [dts=null]</InnerVar>
                <InnerVar>ClassFactory [cf]</InnerVar>
                <InnerVar>boolean [noSchema=true]</InnerVar>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>DataTypeDescriptor [resultType=uad.getAggregator(dts,aggregatorClassName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;instantiateAggDef;[]</InnerMethodInvoke>
                <InnerMethodInvoke>aggregates;add;[this]</InnerMethodInvoke>
                <InnerMethodInvoke>null;checkAggregatorClassName;[aggregatorClassName.toString()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[resultType]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveAggregate</MethodName>
            <MethodComment>/** 
 * Resolve a user-defined aggregate.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>noSchema</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AliasDescriptor [ad=resolveBuiltinAggregate(dd,rawName,noSchema)]</InnerVar>
                <InnerVar>java.util.List&lt;AliasDescriptor&gt; [list=dd.getRoutineList(sd.getUUID().toString(),rawName,AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveBuiltinAggregate</MethodName>
            <MethodComment>/** 
 * Construct an AliasDescriptor for a modern builtin aggregate.
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>noSchema</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BuiltinAggDescriptor [bad=null]</InnerVar>
                <InnerVar>AliasInfo [aliasInfo=new AggregateAliasInfo(bad.argType,bad.returnType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkAggregatorClassName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;verifyClassExist;[className]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>instantiateAggDef</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setOperator;[aggregateName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setMethodName;[aggregateDefinitionClassName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDistinct</MethodName>
            <MethodComment>/** 
 * Indicate whether this aggregate is distinct or not.
 * @return 	true/false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAggregatorClassName</MethodName>
            <MethodComment>/** 
 * Get the class that implements that aggregator for this node.
 * @return the class name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAggregateName</MethodName>
            <MethodComment>/** 
 * Get the class that implements that aggregator for this node.
 * @return the class name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewAggregatorResultColumn</MethodName>
            <MethodComment>/** 
 * Get the result column that has a new aggregator. This aggregator will be fed into the sorter.
 * @param dd	the data dictionary
 * @return the result column.  WARNING: it still needs to be bound
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [className=aggregatorClassName.toString()]</InnerVar>
                <InnerVar>DataTypeDescriptor [compType=DataTypeDescriptor.getSQLDataTypeDescriptor(className)]</InnerVar>
                <InnerVar>ConstantNode [nullNode=getNullNode(compType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>nullNode;bindExpression;[null, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewExpressionResultColumn</MethodName>
            <MethodComment>/** 
 * Get the aggregate expression in a new result column.
 * @param dd the data dictionary
 * @return the result column.  WARNING: it still needs to be bound
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [node]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewNullResultExpression</MethodName>
            <MethodComment>/** 
 * Get the null aggregate result expression column.
 * @return the value node
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Do code generation for this unary operator.  Should never be called for an aggregate -- it should be converted into something else by code generation time.
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the code to place the code
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Print a string ref of this node.
 * @return a string representation of this node 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstant</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constantExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>where</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLName</MethodName>
            <MethodComment>/** 
 * Get the SQL name of the aggregate 
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUserDefinedAggregate</MethodName>
            <MethodComment>/** 
 * Return true if this is a user-defined aggregate 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>