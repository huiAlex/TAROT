<Class>
    <Id>82</Id>
    <Package>org.apache.derby.impl.store.access.heap</Package>
    <ClassName>HeapScan</ClassName>
    <SuperClass>GenericScanController</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ScanManager</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>fetchNext_one_slot_array</FieldName>
            <FieldType>DataValueDescriptor[][]</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>HeapScan</MethodName>
            <MethodComment>/** 
 * The only constructor for a heap scan returns a scan in the closed state, the caller must call open.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>queueDeletePostCommitWork</MethodName>
            <MethodComment>/** 
 * Protected concrete impl of abstract methods of  GenericController class:
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TransactionManager [xact_mgr=open_conglom.getXactMgr()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>xact_mgr;addPostCommitWork;[new HeapPostCommit(xact_mgr.getAccessManager(),pos.current_page.getPageKey())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRowLocationArray</MethodName>
            <MethodComment>/** 
 * Private/Protected methods of This class:
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>RowPosition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRowLocationArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rh</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenScanByRecordHandleAndSetLocks</MethodName>
            <MethodComment>/** 
 * Reposition the current scan and sets the necessary locks.
 * @param rh An existing RecordHandle within the conglomerate,at which to position the start of the scan.  The scan will begin at this location and continue forward until the end of the conglomerate.   Positioning at a non-existent RowLocation (ie. an invalid one or one that had been deleted), will result in an exception being thrown when the  first next operation is attempted.
 * @return true if the scan was successfully repositioned
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rh</ParamName>
                    <ParamType>RecordHandle</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [rowLocationDisappeared=open_conglom.latchPageAndRepositionScan(scan_position)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>scan_position;unlatch;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNext</MethodName>
            <MethodComment>/** 
 * Fetch the row at the next position of the Scan. If there is a valid next position in the scan then the value in the template storable row is replaced with the value of the row at the current scan position.  The columns of the template row must be of the same type as the actual columns in the underlying conglomerate. The resulting contents of templateRow after a fetchNext()  which returns false is undefined. The result of calling fetchNext(row) is exactly logically equivalent to making a next() call followed by a fetch(row) call.  This interface allows implementations to optimize  the 2 calls if possible.
 * @param fetch_row The template row into which the valueof the next position in the scan is to be stored.
 * @return True if there is a next position in the scan,false if there isn't.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fetch_row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [ret_val=fetchRows(fetchNext_one_slot_array,(RowLocation[])null,(BackingStoreHashtable)null,1,(int[])null) == 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.store.access.ScanController#next
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [ret_val=fetchRows(fetchNext_one_slot_array,(RowLocation[])null,(BackingStoreHashtable)null,1,(int[])null) == 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionAtRowLocation</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.store.access.ScanController#positionAtRowLocation
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchLocation</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.store.access.ScanController#fetchLocation
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>templateLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>HeapRowLocation [hrl=(HeapRowLocation)templateLocation]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>hrl;setFrom;[scan_position.current_rh]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNextGroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row_array</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchNextGroup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row_array</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old_rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_rowloc_array</ParamName>
                    <ParamType>RowLocation[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanInfo</MethodName>
            <MethodComment>/** 
 * Return ScanInfo object which describes performance of scan. &lt;p&gt; Return ScanInfo object which contains information about the current scan. &lt;p&gt;
 * @see ScanInfo
 * @return The ScanInfo object which contains info about current scan.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ScanInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenScanByRowLocation</MethodName>
            <MethodComment>/** 
 * Reposition the current scan.  This call is semantically the same as if the current scan had been closed and a openScan() had been called instead. The scan is reopened against the same conglomerate, and the scan is reopened with the same "scan column list", "hold" and "forUpdate" parameters passed in the original openScan.   &lt;p&gt; The statistics gathered by the scan are not reset to 0 by a reopenScan(), rather they continue to accumulate. &lt;p&gt; Note that this operation is currently only supported on Heap conglomerates. Also note that order of rows within are heap are not guaranteed, so for instance positioning at a RowLocation in the "middle" of a heap, then inserting more data, then continuing the scan is not guaranteed to see the new rows - they may be put in the "beginning" of the heap.
 * @param startRowLocation  An existing RowLocation within the conglomerate,at which to position the start of the scan.  The scan will begin at this location and continue forward until the end of the conglomerate.   Positioning at a non-existent RowLocation (ie. an invalid one or one that had been deleted), will result in an exception being thrown when the  first next operation is attempted.
 * @param qualifier An array of qualifiers which, appliedto each key, restrict the rows returned by the scan.  Rows for which any one of the qualifiers returns false are not returned by the scan. If null, all rows are returned.
 * @exception StandardException Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startRowLocation</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifier</ParamName>
                    <ParamType>Qualifier</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;reopenScanByRecordHandle;[((HeapRowLocation)startRowLocation).getRecordHandle(open_conglom.getContainer()), qualifier]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>