<Class>
    <Id>90</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>MergeResultSet</ClassName>
    <SuperClass>NoRowsResultSetImpl</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>MergeResultSet  /** 
 * INSERT/UPDATE/DELETE a target table based on how it outer joins with a driving table. For a description of how Derby processes the MERGE statement, see the header comment on MergeNode.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>_drivingLeftJoin</FieldName>
            <FieldType>NoPutResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>_constants</FieldName>
            <FieldType>MergeConstantAction</FieldType>
        </Field>
        <Field>
            <FieldName>_row</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>_rowCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>_thenRows</FieldName>
            <FieldType>TemporaryRowHolderImpl[]</FieldType>
        </Field>
        <Field>
            <FieldName>_subjectRowIDs</FieldName>
            <FieldType>BackingStoreHashtable</FieldType>
        </Field>
        <Field>
            <FieldName>_numOpens</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>MergeResultSet</MethodName>
            <MethodComment>/** 
 * Construct from a driving left join and an Activation.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drivingLeftJoin</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifiedRowCount</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>open</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [rowsFound=collectAffectedRows()]</InnerVar>
                <InnerVar>int [clauseCount=_constants.matchingClauseCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setup;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanUp;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [clauseCount=_constants.matchingClauseCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Clean up resources and call close on data members.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;close;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUp</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [clauseCount=_constants.matchingClauseCount()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectAffectedRows</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Loop through the rows in the driving left join. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [rlColumn]</InnerVar>
                <InnerVar>boolean [rowsFound=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addSubjectRow</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Add another subject row id to the evolving hashtable of affected target rows. The concept of a subject row is defined by the 2011 SQL Standard, part 2, section 14.12 (merge statement), general rule 6. A row in the target table is a subject row if it joins to the source table on the main search condition and if the joined row satisfies the matching refinement condition for some WHEN MATCHED clause. A row in the target table may only be a subject row once. That is, a given target row may only qualify for UPDATE or DELETE processing once. If it qualifies for more than one UPDATE or DELETE action, then the Standard requires us to raise a cardinality violation. &lt;/p&gt;
 * @param subjectRowID    The location of the subject row.
 * @exception StandardException A cardinality exception is thrown if we've already added this subject row.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>subjectRowID</ParamName>
                    <ParamType>SQLRef</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createSubjectRowIDhashtable</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Create a BackingStoreHashtable to hold the ids of subject rows. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int[] [keyCols=new int[]{0}]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>