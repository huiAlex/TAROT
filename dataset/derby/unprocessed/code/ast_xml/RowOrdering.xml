<Class>
    <Id>194</Id>
    <Package>org.apache.derby.iapi.sql.compile</Package>
    <ClassName>RowOrdering</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>RowOrdering  /** 
 * This interface provides a representation of the ordering of rows in a ResultSet.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>ASCENDING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DESCENDING</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DONTCARE</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>orderedOnColumn</MethodName>
            <MethodComment>/** 
 * Tell whether this ordering is ordered on the given column in the given position
 * @param direction		One of ASCENDING, DESCENDING, or DONTCAREdepending on the requirements of the caller. An ORDER BY clause cares about direction, while DISTINCT and GROUP BY do not.
 * @param orderPosition	The position in the ordering list.  For example,for ORDER BY A, B, position 0 has column A, and position 1 has column B.  Note that for an ordering, more than one column can be in a single ordering position: for example, in the query SELECT * FROM S, T WHERE S.A = T.B ORDER BY T.B columns S.A and T.B will be in the same ordering positions because they are equal.  Also, constant values are considered ordered in all positions (consider SELECT A FROM T WHERE A = 1 ORDER BY A).
 * @param tableNumber	The table number of the Optimizable containingthe column in question
 * @param columnNumber	The column number in the table (one-based).
 * @return	true means this ordering is ordered on the given columnin the given position.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>direction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orderedOnColumn</MethodName>
            <MethodComment>/** 
 * Tell whether this ordering is ordered on the given column. This is similar to the method above, but it checks whether the column is ordered in any position, rather than a specified position. This is useful for operations like DISTINCT and GROUP BY.
 * @param direction		One of ASCENDING, DESCENDING, or DONTCAREdepending on the requirements of the caller. An ORDER BY clause cares about direction, while DISTINCT and GROUP BY do not.
 * @param tableNumber	The table number of the Optimizable containingthe column in question
 * @param columnNumber	The column number in the table (one-based).
 * @return	true means this ordering is ordered on the given columnin the given position.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>direction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOrderedColumn</MethodName>
            <MethodComment>/** 
 * Add a column to this RowOrdering in the current order position. This is a no-op if there are any unordered optimizables in the join order (see below).
 * @param direction		One of ASCENDING, DESCENDING, or DONTCARE.DONTCARE can be used for things like columns with constant value, and for one-row tables.
 * @param tableNumber	The table the column is in.
 * @param columnNumber	The column number in the table (one-based)
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>direction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nextOrderPosition</MethodName>
            <MethodComment>/** 
 * Move to the next order position for adding ordered columns. This is a no-op if there are any unordered optimizables in the join order (see below).
 * @param direction		One of ASCENDING, DESCENDING, or DONTCARE.DONTCARE can be used for things like columns with constant value, and for one-row tables.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>direction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizableAlwaysOrdered</MethodName>
            <MethodComment>/** 
 * Tell this RowOrdering that it is always ordered on the given optimizable This is useful when considering a unique index where there is an equality match on the entire key - in this case, all the columns are ordered, regardless of the direction or position, or even whether the columns are in the index.
 * @param optimizable	The table in question
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnAlwaysOrdered</MethodName>
            <MethodComment>/** 
 * Tell this RowOrdering that it is always ordered on the given column of the given optimizable.  This is useful when a column in the optimizable has an equals comparison with a constant expression or it is involved in a equijoin with an optimizable which is always  ordered on the column on which the equijoin is happening. This is  reset when the optimizable is removed from this RowOrdering.
 * @param optimizable	The table in question
 * @param columnNumber	The number of the column in question.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isColumnAlwaysOrdered</MethodName>
            <MethodComment>/** 
 * Return true if the column is always ordered. That will be true if the column has a constant comparison predicate on it or it is involved in a equijoin with an optimizable which is always ordered on the column on which the equijoin is happening.
 * @param tableNumber	The table in question
 * @param columnNumber	The number of the column in question.
 * @return	true means this column is always ordered
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>alwaysOrdered</MethodName>
            <MethodComment>/** 
 * Ask whether the given table is always ordered.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeOptimizable</MethodName>
            <MethodComment>/** 
 * Tell this row ordering that it is no longer ordered on the given table.  Also, adjust the current order position, if necessary. This only works to remove ordered columns from the end of the ordering.
 * @param tableNumber	The number of the table to remove from this RowOrdering.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUnorderedOptimizable</MethodName>
            <MethodComment>/** 
 * Add an unordered optimizable to this RowOrdering.  This is to solve the following problem: Suppose we have the query: select * from r, s, t order by r.a, t.b Also suppose there are indexes on r.a and t.b.  When the optimizer considers the join order (r, s, t) using the index on r.a, the heap on s, and the index on t.b, the rows from the join order will *NOT* be ordered on t.b, because there is an unordered result set between r and t.  So, when s is added to the partial join order, and we then add table t to the join order, we want to ensure that we don't add column t.b to the RowOrdering.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizable</ParamName>
                    <ParamType>Optimizable</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copy</MethodName>
            <MethodComment>/** 
 * Copy the contents of this RowOrdering to the given RowOrdering.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>copyTo</ParamName>
                    <ParamType>RowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>