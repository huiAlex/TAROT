<Class>
    <Id>1620</Id>
    <Package>org.apache.derby.impl.jdbc</Package>
    <ClassName>EmbedStatement</ClassName>
    <SuperClass>ConnectionChild</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>EngineStatement</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EmbedStatement  /** 
 * EmbedStatement is a local JDBC statement. It supports JDBC 4.1.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>applicationConnection</FieldName>
            <FieldType>java.sql.Connection</FieldType>
        </Field>
        <Field>
            <FieldName>applicationStatement</FieldName>
            <FieldType>EngineStatement</FieldType>
        </Field>
        <Field>
            <FieldName>updateCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>results</FieldName>
            <FieldType>EmbedResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>autoGeneratedKeysResultSet</FieldName>
            <FieldType>java.sql.ResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>cursorName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>forMetaData</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetConcurrency</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetHoldability</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>lcc</FieldName>
            <FieldType>LanguageConnectionContext</FieldType>
        </Field>
        <Field>
            <FieldName>warnings</FieldName>
            <FieldType>SQLWarning</FieldType>
        </Field>
        <Field>
            <FieldName>SQLText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>fetchSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>fetchDirection</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MaxFieldSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>timeoutMillis</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>active</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>batchStatements</FieldName>
            <FieldType>Vector</FieldType>
        </Field>
        <Field>
            <FieldName>batchStatements</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>maxRows</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>pvs</FieldName>
            <FieldType>ParameterValueSet</FieldType>
        </Field>
        <Field>
            <FieldName>isPoolable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>closeOnCompletion</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>closingResultSets</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dynamicResults</FieldName>
            <FieldType>EmbedResultSet[]</FieldType>
        </Field>
        <Field>
            <FieldName>currentDynamicResultSet</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>EmbedStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>connection</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forMetaData</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetConcurrency</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetHoldability</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeQuery</MethodName>
            <MethodComment>/** 
 * Execute a SQL statement that returns a single ResultSet.
 * @param sql					typically this is a static SQL SELECT statement
 * @return a ResultSet that contains the data produced by thequery; never null
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, true, false, Statement.NO_GENERATED_KEYS, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * Execute a SQL INSERT, UPDATE or DELETE statement. In addition, SQL statements that return nothing such as SQL DDL statements can be executed.
 * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQLstatement that returns nothing
 * @return either the row count for INSERT, UPDATE or DELETE; or 0for SQL statements that return nothing
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeLargeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 Execute a SQL INSERT, UPDATE or DELETE statement. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, false, true, Statement.NO_GENERATED_KEYS, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Execute the given SQL statement and signals the driver with the given flag about whether the auto-generated keys produced by this Statement object should be made available for retrieval.
 * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQLstatement that returns nothing
 * @param autoGeneratedKeys - a flag indicating whether auto-generated keysshould be made available for retrieval; one of the following constants: Statement.RETURN_GENERATED_KEYS Statement.NO_GENERATED_KEYS
 * @return either the row count for INSERT, UPDATE or DELETE; or 0for SQL statements that return nothing
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>autoGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeLargeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 Execute the given SQL statement and signals the driver with the given flag about whether the auto-generated keys produced by this Statement object should be made available for retrieval. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>autoGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, false, true, autoGeneratedKeys, null, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. The driver will ignore the array if the SQL statement is not an INSERT statement
 * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQLstatement that returns nothing
 * @param columnIndexes - an array of column indexes indicating thecolumns that should be returned from the inserted row
 * @return either the row count for INSERT, UPDATE or DELETE; or 0for SQL statements that return nothing
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeLargeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. The driver will ignore the array if the SQL statement is not an INSERT/UPDATE statement. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, false, true, ((columnIndexes == null) || (columnIndexes.length == 0)) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS, columnIndexes, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. The driver will ignore the array if the SQL statement is not an INSERT statement
 * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQLstatement that returns nothing
 * @param columnNames - an array of the names of the columnsthat should be returned from the inserted row
 * @return either the row count for INSERT, UPDATE or DELETE; or 0for SQL statements that return nothing
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeLargeUpdate</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. The driver will ignore the array if the SQL statement is not an INSERT/UPDATE statement. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;execute;[sql, false, true, ((columnNames == null) || (columnNames.length == 0)) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS, null, columnNames]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkIfInMiddleOfBatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosed</MethodName>
            <MethodComment>/** 
 * Tell whether this statment has been closed or not.
 * @return &lt;code&gt;true&lt;/code&gt; is closed, &lt;code&gt;false&lt;/code&gt; otherwise.
 * @exception SQLException if a database access error occurs.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * In many cases, it is desirable to immediately release a Statements's database and JDBC resources instead of waiting for this to happen when it is automatically closed; the close method provides this immediate release. &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; A Statement is automatically closed when it is garbage collected. When a Statement is closed its current ResultSet, if one exists, is also closed.
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finalize</MethodName>
            <MethodComment>/** 
 * Mark the statement and its single-use activation as unused. This method should be called from &lt;code&gt;EmbedPreparedStatement&lt;/code&gt;'s finalizer as well, even though prepared statements reuse activations, since &lt;code&gt;getGeneratedKeys()&lt;/code&gt; uses a single-use activation regardless of statement type. &lt;BR&gt; Dynamic result sets (those in dynamicResults array) need not be handled here as they will be handled by the statement object that created them. In some cases results will point to a ResultSet in dynamicResults but all that will happen is that the activation will get marked as unused twice.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Throwable</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeActions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxFieldSize</MethodName>
            <MethodComment>/** 
 * The maxFieldSize limit (in bytes) is the maximum amount of data returned for any column value; it only applies to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR columns.  If the limit is exceeded, the excess data is silently discarded.
 * @return the current max column size limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMaxFieldSize</MethodName>
            <MethodComment>/** 
 * The maxFieldSize limit (in bytes) is set to limit the size of data that can be returned for any column value; it only applies to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR fields.  If the limit is exceeded, the excess data is silently discarded.
 * @param max the new max column size limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>max</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaxRows</MethodName>
            <MethodComment>/** 
 * The maxRows limit is the maximum number of rows that a ResultSet can contain.  If the limit is exceeded, the excess rows are silently dropped.
 * @return the current max row limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLargeMaxRows</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 The maxRows limit is the maximum number of rows that a ResultSet can contain.  If the limit is exceeded, the excess rows are silently dropped. For use with statements which may touch more than Integer.MAX_VALUE rows.
 * @return the current max row limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setMaxRows</MethodName>
            <MethodComment>/** 
 * The maxRows limit is set to limit the number of rows that any ResultSet can contain.  If the limit is exceeded, the excess rows are silently dropped.
 * @param max the new max rows limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>max</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setLargeMaxRows;[max]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLargeMaxRows</MethodName>
            <MethodComment>/** 
 * The maxRows limit is set to limit the number of rows that any ResultSet can contain.  If the limit is exceeded, the excess rows are silently dropped.
 * @param max the new max rows limit; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>max</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEscapeProcessing</MethodName>
            <MethodComment>/** 
 * If escape scanning is on (the default) the driver will do escape substitution before sending the SQL to the database.
 * @param enable true to enable; false to disable
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>enable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getQueryTimeout</MethodName>
            <MethodComment>/** 
 * The queryTimeout limit is the number of seconds the driver will wait for a Statement to execute. If the limit is exceeded a SQLException is thrown.
 * @return the current query timeout limit in seconds; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setQueryTimeout</MethodName>
            <MethodComment>/** 
 * The queryTimeout limit is the number of seconds the driver will wait for a Statement to execute. If the limit is exceeded a SQLException is thrown.
 * @param seconds the new query timeout limit in seconds; zero means unlimited
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>seconds</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cancel</MethodName>
            <MethodComment>/** 
 * Cancel can be used by one thread to cancel a statement that is being executed by another thread.
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getWarnings</MethodName>
            <MethodComment>/** 
 * The first warning reported by calls on this Statement is returned.  A Statment's execute methods clear its SQLWarning chain. Subsequent Statement warnings will be chained to this SQLWarning. &lt;p&gt;The warning chain is automatically cleared each time a statement is (re)executed. &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If you are processing a ResultSet then any warnings associated with ResultSet reads will be chained on the ResultSet object.
 * @return the first SQLWarning or null
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>SQLWarning</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearWarnings</MethodName>
            <MethodComment>/** 
 * After this call getWarnings returns null until a new warning is reported for this Statement.
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCursorName</MethodName>
            <MethodComment>/** 
 * setCursorName defines the SQL cursor name that will be used by subsequent Statement execute methods. This name can then be used in SQL positioned update/delete statements to identify the current row in the ResultSet generated by this statement.  If the database doesn't support positioned update/delete, this method is a noop. &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; By definition, positioned update/delete execution must be done by a different Statement than the one which generated the ResultSet being used for positioning. Also, cursor names must be unique within a Connection.
 * @param name the new cursor name.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Execute a SQL statement that may return multiple results. Under some (uncommon) situations a single SQL statement may return multiple result sets and/or update counts.  Normally you can ignore this, unless you're executing a stored procedure that you know may return multiple results, or unless you're dynamically executing an unknown SQL string.  The "execute", "getMoreResults", "getResultSet" and "getUpdateCount" methods let you navigate through multiple results. The "execute" method executes a SQL statement and indicates the form of the first result.  You can then use getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s).
 * @param sql					any SQL statement
 * @return true if the first result is a ResultSet; false if it is an integer
 * @see #getResultSet
 * @see #getUpdateCount
 * @see #getMoreResults
 * @exception SQLException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * Execute a SQL statement that may return multiple results. Under some (uncommon) situations a single SQL statement may return multiple result sets and/or update counts.  Normally you can ignore this, unless you're executing a stored procedure that you know may return multiple results, or unless you're dynamically executing an unknown SQL string.  The "execute", "getMoreResults", "getResultSet" and "getUpdateCount" methods let you navigate through multiple results. The "execute" method executes a SQL statement and indicates the form of the first result.  You can then use getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s).
 * @param sql					any SQL statement
 * @param executeQuery			caller is executeQuery()
 * @param executeUpdate			caller is executeUpdate()
 * @param autoGeneratedKeys
 * @param columnIndexes
 * @param columnNames
 * @return true if the first result is a ResultSet; false if it is an integer
 * @see #getResultSet
 * @see #getUpdateCount
 * @see #getMoreResults
 * @exception SQLException thrown on failure
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executeQuery</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executeUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>autoGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Executes the given SQL statement, which may return multiple results, and signals the driver that any auto-generated keys should be made available for retrieval. The driver will ignore this signal if the SQL statement is not an INSERT/UPDATE statement.
 * @param sql any SQL statement
 * @param autoGeneratedKeys - a constant indicating whetherauto-generated keys should be made available for retrieval using the method getGeneratedKeys; one of the following constants: Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
 * @return rue if the first result is a ResultSet object; false ifit is an update count or there are no results
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>autoGeneratedKeys</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Executes the given SQL statement, which may return multiple results, and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. This array contains the indexes of the columns in the target table that contain the auto-generated keys that should be made available. The driver will ignore the array if the given SQL statement is not an INSERT/UPDATE statement.
 * @param sql any SQL statement
 * @param columnIndexes - an array of the indexes of the columns in theinserted/updated row that should be made available for retrieval by a call to the method getGeneratedKeys
 * @return rue if the first result is a ResultSet object; false ifit is an update count or there are no results
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnIndexes</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>execute</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Executes the given SQL statement, which may return multiple results, and signals the driver that the auto-generated keys indicated in the given array should be made available for retrieval. This array contains the names of the columns in the target table that contain the auto-generated keys that should be made available. The driver will ignore the array if the given SQL statement is not an INSERT/UPDATE statement.
 * @param sql any SQL statement
 * @param columnNames - an array of the names of the columns in theinserted/updated row that should be made available for retrieval by a call to the method getGeneratedKeys
 * @return rue if the first result is a ResultSet object; false ifit is an update count or there are no results
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSet</MethodName>
            <MethodComment>/** 
 * getResultSet returns the current result as a ResultSet.  It should only be called once per result.
 * @return the current result as a ResultSet; null if the resultis an update count or there are no more results or the statement was closed.
 * @see #execute
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUpdateCount</MethodName>
            <MethodComment>/** 
 * getUpdateCount returns the current result as an update count; if the result is a ResultSet or there are no more results -1 is returned.  It should only be called once per result. &lt;P&gt;The only way to tell for sure that the result is an update count is to first test to see if it is a ResultSet. If it is not a ResultSet it is either an update count or there are no more results.
 * @return the current result as an update count; -1 if it is aResultSet or there are no more results
 * @see #execute
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLargeUpdateCount</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 getLargeUpdateCount returns the current result as an update count; if the result is a ResultSet or there are no more results -1 is returned.  It should only be called once per result. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMoreResults</MethodName>
            <MethodComment>/** 
 * getMoreResults moves to a Statement's next result.  It returns true if this result is a ResultSet.  getMoreResults also implicitly closes any current ResultSet obtained with getResultSet. There are no more results when (!getMoreResults() &amp;amp;&amp;amp; (getUpdateCount() == -1)
 * @return true if the next result is a ResultSet; false if it isan update count or there are no more results
 * @see #execute
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetType</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine the result set type.
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFetchDirection</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Give a hint as to the direction in which the rows in a result set will be processed. The hint applies only to result sets created using this Statement object.  The default value is  ResultSet.FETCH_FORWARD.
 * @param direction the initial direction for processing rows
 * @exception SQLException if a database-access error occurs or directionis not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or ResultSet.FETCH_UNKNOWN
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>direction</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFetchDirection</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine the fetch direction.
 * @return the default fetch direction
 * @exception SQLException if a database-access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFetchSize</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Give the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are needed.  The number  of rows specified only affects result sets created using this  statement. If the value specified is zero, then the hint is ignored. The default value is zero.
 * @param rows the number of rows to fetch
 * @exception SQLException if a database-access error occurs, or thecondition 0 &amp;lt;= rows &amp;lt;= this.getMaxRows() is not satisfied.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFetchSize</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine the default fetch size.
 * @exception SQLException if a database-access error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetConcurrency</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Determine the result set concurrency.
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetHoldability</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves the result set holdability for ResultSet objects generated by this Statement object.
 * @return either ResultSet.HOLD_CURSORS_OVER_COMMIT orResultSet.CLOSE_CURSORS_AT_COMMIT
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addBatch</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Adds a SQL command to the current batch of commmands for the statement. This method is optional.
 * @param sql typically this is a static SQL INSERT or UPDATE statement
 * @exception SQLException if a database-access error occurs, or thedriver does not support batch statements
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearBatch</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Make the set of commands in the current batch empty. This method is optional.
 * @exception SQLException if a database-access error occurs, or thedriver does not support batch statements
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeBatch</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Submit a batch of commands to the database for execution. This method is optional. Moving jdbc2.0 batch related code in this class because callableStatement in jdbc 20 needs this code too and it doesn't derive from prepared statement in jdbc 20 in our implementation.  BatchUpdateException is the only new class from jdbc 20 which is being referenced here and in order to avoid any jdk11x problems, using reflection code to make an instance of that class. 
 * @return an array of update counts containing one element for eachcommand in the batch.  The array is ordered according to the order in which commands were inserted into the batch
 * @exception SQLException if a database-access error occurs, or thedriver does not support batch statements
 */
</MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeLargeBatch</MethodName>
            <MethodComment>/** 
 * JDBC 4.2 Submit a batch of commands to the database for execution. This method is optional. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
</MethodComment>
            <ReturnType>long[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkExecStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeBatchElement</MethodName>
            <MethodComment>/** 
 * Execute a single element of the batch. Overridden by EmbedPreparedStatement
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>batchElement</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConnection</MethodName>
            <MethodComment>/** 
 * JDBC 2.0 Return the Connection that produced the Statement.
 * @exception SQLException Exception if it cannot find the connectionassociated to this statement.
 */
</MethodComment>
            <ReturnType>java.sql.Connection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>java.sql.Connection [appConn=getEmbedConnection().getApplicationConnection()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMoreResults</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Moves to this Statement obect's next result, deals with any current ResultSet object(s) according to the instructions specified by the given flag, and returns true if the next result is a ResultSet object
 * @param current - one of the following Statement constants indicating whatshould happen to current ResultSet objects obtained using the method getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
 * @return true if the next result is a ResultSet; false if it isan update count or there are no more results
 * @see #execute
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>current</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkExecStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGeneratedKeys</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves any auto-generated keys created as a result of executing this Statement object. If this Statement is a non-insert statement, a null ResultSet object is returned.
 * @return a ResultSet object containing the auto-generated key(s) generated bythe execution of this Statement object
 * @exception SQLException if a database access error occurs
 */
</MethodComment>
            <ReturnType>java.sql.ResultSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeStatement</MethodName>
            <MethodComment>/** 
 * Execute the current statement.
 * @exception SQLException thrown on failure.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executeQuery</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>executeUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addWarning</MethodName>
            <MethodComment>/** 
 * Add a SQLWarning to this Statement object. If the Statement already has a SQLWarning then it is added to the end of the chain.
 * @see #getWarnings()
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sw</ParamName>
                    <ParamType>SQLWarning</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLText</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterValueSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ParameterValueSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkStatus</MethodName>
            <MethodComment>/** 
 * Throw an exception if this Statement has been closed explictly or it has noticed it has been closed implicitly. JDBC specifications require nearly all methods throw a SQLException if the Statement has been closed, thus most methods call this method or checkExecStatus first.
 * @exception SQLException Thrown if the statement is marked as closed.
 * @see #checkExecStatus()
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkExecStatus</MethodName>
            <MethodComment>/** 
 * A heavier weight version of checkStatus() that ensures the application's Connection object is still open. This is to stop errors or unexpected behaviour when a [Prepared]Statement object is used after the application has been closed. In particular to ensure that a Statement obtained from a PooledConnection cannot be used after the application has closed its connection (as the underlying Connection is still active). To avoid this heavier weight check on every method of [Prepared]Statement it is only used on those methods that would end up using the database's connection to read or modify data. E.g. execute*(), but not setXXX, etc. &lt;BR&gt; If this Statement's Connection is closed an exception will be thrown and the active field will be set to false, completely marking the Statement as closed. &lt;BR&gt; If the Statement is not currently connected to an active transaction, i.e. a suspended global transaction, then this method will throw a SQLException but the Statement will remain open. The Statement is open but unable to process any new requests until its global transaction is resumed. &lt;BR&gt; Upon return from the method, with or without a SQLException the field active will correctly represent the open state of the Statement.
 * @exception SQLException Thrown if the statement is marked as closedor the Statement's transaction is suspended.
 * @see #checkStatus()
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearResultSets</MethodName>
            <MethodComment>/** 
 * Close and clear all result sets associated with this statement from the last execution.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearResultSetsMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>SQLException [sqle=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkRequiresCallableStatement</MethodName>
            <MethodComment>/** 
 * Check to see if a statement requires to be executed via a callable statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ParameterValueSet [pvs=activation.getParameterValueSet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transferBatch</MethodName>
            <MethodComment>/** 
 * Transfer my batch of Statements to a newly created Statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>EmbedStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setApplicationStatement</MethodName>
            <MethodComment>/** 
 * Set the application statement for this Statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>EngineStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processDynamicResults</MethodName>
            <MethodComment>/** 
 * Go through a holder of dynamic result sets, remove those that should not be returned, and sort the result sets according to their creation.
 * @param holder a holder of dynamic result sets
 * @param maxDynamicResultSets the maximum number of result setsto be returned
 * @return the actual number of result sets
 * @exception SQLException if an error occurs
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>holder</ParamName>
                    <ParamType>java.sql.ResultSet[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxDynamicResultSets</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EmbedResultSet[] [sorted=new EmbedResultSet[holder.length]]</InnerVar>
                <InnerVar>int [actualCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processDynamicResult</MethodName>
            <MethodComment>/** 
 * Process a ResultSet created in a Java procedure as a dynamic result. To be a valid dynamic result the ResultSet must be: &lt;UL&gt; &lt;LI&gt; From a Derby system &lt;LI&gt; From a nested connection of connection passed in or from the connection itself. &lt;LI&gt; Open &lt;/UL&gt; Any invalid ResultSet is ignored.
 * @param conn Connection ResultSet needs to belong to
 * @param resultSet ResultSet to be tested
 * @param callStatement Statement that executed the CALL, null if 
 * @return The result set cast down to EmbedResultSet, null if not a validdynamic result.
 */
</MethodComment>
            <ReturnType>EmbedResultSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>java.sql.ResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>callStatement</ParamName>
                    <ParamType>EmbedStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EmbedResultSet [lrs=(EmbedResultSet)resultSet]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lrs;setDynamicResultSet;[callStatement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resultSetClosing</MethodName>
            <MethodComment>/** 
 * Callback on the statement when one of its result sets is closed. This allows the statement to control when it completes and hence when it commits in auto commit mode. Must have connection synchronization and setupContextStack(), this is required for the call to commitIfNeeded().
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>closingLRS</ParamName>
                    <ParamType>EmbedResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;commitIfAutoCommit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecuteHoldable</MethodName>
            <MethodComment>/** 
 * Get the execute time holdability for the Statement. When in a global transaction holdabilty defaults to false.
 * @throws SQLException Error from getResultSetHoldability.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPoolable</MethodName>
            <MethodComment>/** 
 * Returns the value of the EmbedStatement's poolable hint, indicating whether pooling is requested.
 * @return The value of the poolable hint.
 * @throws SQLException if the Statement has been closed.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPoolable</MethodName>
            <MethodComment>/** 
 * Requests that an EmbedStatement be pooled or not.
 * @param poolable requests that the EmbedStatement be pooled if trueand not be pooled if false.
 * @throws SQLException if the EmbedStatement has been closed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>poolable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isWrapperFor</MethodName>
            <MethodComment>/** 
 * Returns false unless  {@code interfaces} is implemented.
 * @param interfaces a Class defining an interface.
 * @return true if this implements the interface or directly or indirectlywraps an object that does.
 * @throws SQLException if an error occurs while determiningwhether this is a wrapper for an object with the given interface.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>interfaces</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unwrap</MethodName>
            <MethodComment>/** 
 * Returns  {@code this} if this class implements the interface.
 * @param interfaces a Class defining an interface
 * @return an object that implements the interface
 * @throws SQLException if no object if found that implements the interface
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>interfaces</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeOnCompletion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCloseOnCompletion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStatus;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeMeOnCompletion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOpen</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rs</ParamName>
                    <ParamType>EmbedResultSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>