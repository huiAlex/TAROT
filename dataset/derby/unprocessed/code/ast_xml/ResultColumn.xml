<Class>
    <Id>1035</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ResultColumn</ClassName>
    <SuperClass>ValueNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>ResultColumnDescriptor</SuperInterface>
        <SuperInterface>Comparable</SuperInterface>
        <SuperInterface>ResultColumn</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ResultColumn  /** 
 * A ResultColumn represents a result column in a SELECT, INSERT, or UPDATE statement.  In a SELECT statement, the result column just represents an expression in a row being returned to the client.  For INSERT and UPDATE statements, the result column represents an column in a stored table. So, a ResultColumn has to be bound differently depending on the type of statement it appears in. &lt;P&gt; The type of the ResultColumn can differ from its underlying expression, for example in certain joins the ResultColumn can be nullable even if its underlying column is not. In an INSERT or UPDATE the ResultColumn will represent the type of the column in the table, the type of the underlying expression will be the type of the source of the value to be insert or updated. The method columnTypeAndLengthMatch() can be used to detect when normalization is required between the expression and the type of ResultColumn. This class does not implement any type normalization (conversion), this is typically handled by a NormalizeResultSetNode.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>_underlyingName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_derivedColumnName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_unqualifiedTableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_unqualifiedSourceTableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_sourceSchemaName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>_expression</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>_columnDescriptor</FieldName>
            <FieldType>ColumnDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>_isGenerated</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_isGeneratedForUnmatchedColumnInInsert</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_isGroupingColumn</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_isReferenced</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_isRedundant</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_isNameGenerated</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_updated</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_updatableByCursor</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>defaultColumn</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>wasDefault</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rightOuterJoinUsingClause</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>joinResultSet</FieldName>
            <FieldType>JoinNode</FieldType>
        </Field>
        <Field>
            <FieldName>_autoincrementGenerated</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>_autoincrement</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>_reference</FieldName>
            <FieldType>ColumnReference</FieldType>
        </Field>
        <Field>
            <FieldName>virtualColumnId</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ResultColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ResultColumn</MethodName>
            <MethodComment>/** 
 * @param underlyingName The name of the column, if any.
 * @param expression The expression this result column represents
 * @param cm context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>underlyingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTypeExpressionAndDefault;[expression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ResultColumn</MethodName>
            <MethodComment>/** 
 * @param cr A column reference node
 * @param expression The expression this result column represents
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cr</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTypeExpressionAndDefault;[expression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ResultColumn</MethodName>
            <MethodComment>/** 
 * @param cd The column descriptor
 * @param expression The expression this result column represents
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTypeExpressionAndDefault;[expression]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[cd.getType()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ResultColumn</MethodName>
            <MethodComment>/** 
 * @param dtd The type of the column
 * @param expression The expression this result column represents
 * @param cm context manager
 * @throws StandardException
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTypeExpressionAndDefault;[expression]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setType;[dtd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTypeExpressionAndDefault</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setExpression;[expression]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRightOuterJoinUsingClause</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the ResultColumn is join column for a RIGHT OUTER  JOIN with USING/NATURAL. More comments at the top of this class where rightOuterJoinUsingClause is defined.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRightOuterJoinUsingClause</MethodName>
            <MethodComment>/** 
 * Will be set to TRUE if this ResultColumn is join column for a  RIGHT OUTER JOIN with USING/NATURAL. More comments at the top of  this class where rightOuterJoinUsingClause is defined. 2 eg cases 1)select c from t1 right join t2 using (c) This case is talking about column c as in "select c" 2)select c from t1 right join t2 using (c) For "using(c)", a join predicate will be created as follows t1.c=t2.c This case is talking about column t2.c of the join predicate. This method gets called for Case 1) during the bind phase of ResultColumn(ResultColumn.bindExpression). This method gets called for Case 2) during the bind phase of JoinNode while we are going through the list of join columns for a NATURAL JOIN or user supplied list of join columns for USING clause(JoinNode.getMatchingColumn).
 * @param value True/False
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJoinResultSet</MethodName>
            <MethodComment>/** 
 * Returns a non-null value if the ResultColumn represents the join column which is part of the SELECT list of a RIGHT OUTER JOIN with USING/NATURAL. eg select c from t1 right join t2 using (c) The join column we are talking about is column c as in "select c" The return value of following method will show the association of this  result column to the join resultset created for the RIGHT OUTER JOIN  with USING/NATURAL. This information along with  rightOuterJoinUsingClause will be used during the code generation  time.
 */
</MethodComment>
            <ReturnType>JoinNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setJoinResultset</MethodName>
            <MethodComment>/** 
 * This method gets called during the bind phase of a ResultColumn if it is determined that the ResultColumn represents the join column which is part of the SELECT list of a RIGHT OUTER JOIN with  USING/NATURAL. eg select c from t1 right join t2 using (c) This case is talking about column c as in "select c"
 * @param resultSet - The ResultColumn belongs to this JoinNode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSet</ParamName>
                    <ParamType>JoinNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDefaultColumn</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the ResultColumn is standing in for a DEFAULT keyword in an insert/update statement.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDefaultColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>wasDefaultColumn</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the ResultColumn used to stand in for a DEFAULT keyword in an insert/update statement.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setWasDefaultColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnNameMatches</MethodName>
            <MethodComment>/** 
 * Return TRUE if this result column matches the provided column name. This function is used by ORDER BY column resolution. For the ORDER BY clause, Derby will prefer to match on the column's alias (_derivedColumnName), but will also successfully match on the underlying column name. Thus the following statements are treated equally: select name from person order by name; select name as person_name from person order by name; select name as person_name from person order by person_name; See DERBY-2351 for more discussion.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUnderlyingOrAliasName</MethodName>
            <MethodComment>/** 
 * Get non-null column name. This method is called during the bind phase to see if we are dealing with ResultColumn in the SELECT list that  belongs to a RIGHT OUTER JOIN(NATURAL OR USING)'s join column. For a query like following, we want to use column name x and not the alias x1 when looking in the JoinNode for join column SELECT x x1 FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1; For a query like following, getSourceColumnName() will return null because we are dealing with a function for the column. For this case, "name" will return the alias name cx SELECT coalesce(derby4631_t2.x, derby4631_t1.x) cx FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;	 For a query like following, getSourceColumnName() and name will  return null and hence need to use the generated name SELECT ''dummy="'|| TRIM(CHAR(x))|| '"' FROM (derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1);
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUpdatable</MethodName>
            <MethodComment>/** 
 * Returns true if this column is updatable. This method is used for determining if updateRow and insertRow are allowed for this cursor (DERBY-1773). Since the updateRow and insertRow implementations dynamically build SQL statements on the fly, the critical issue here is whether we have a column that has been aliased, because if it has been aliased, the dynamic SQL generation logic won't be able to compute the proper true base column name when it needs to.
 * @return true if this result column is updatable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceColumnName</MethodName>
            <MethodComment>/** 
 * Returns the underlying source column name, if this ResultColumn is a simple direct reference to a table column, or NULL otherwise.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getName</MethodName>
            <MethodComment>/** 
 * The following methods implement the ResultColumnDescriptor interface.  See the Language Module Interface for details.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceTableName</MethodName>
            <MethodComment>/** 
 * @see ResultColumnDescriptor#getSourceTableName
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSourceSchemaName</MethodName>
            <MethodComment>/** 
 * @see ResultColumnDescriptor#getSourceSchemaName
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearTableName</MethodName>
            <MethodComment>/** 
 * Clear the table name for the underlying ColumnReference. See UpdateNode.scrubResultColumns() for full explaination.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setExpression</MethodName>
            <MethodComment>/** 
 * Set the expression in this ResultColumn.  This is useful in those cases where you don't know the expression in advance, like for INSERT statements with column lists, where the column list and SELECT or VALUES clause are parsed separately, and then have to be hooked up.
 * @param expression	The expression to be set in this ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExpression</MethodName>
            <MethodComment>/** 
 * Get the expression in this ResultColumn.  
 * @return ValueNode	this.expression
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setExpressionToNullNode</MethodName>
            <MethodComment>/** 
 * Set the expression to a null node of the correct type.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setExpression;[getNullNode(getTypeServices())]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setName</MethodName>
            <MethodComment>/** 
 * Set the name in this ResultColumn.  This is useful when you don't know the name at the time you create the ResultColumn, for example, in an insert-select statement, where you want the names of the result columns to match the table being inserted into, not the table they came from.
 * @param name	The name to set in this ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNameGenerated</MethodName>
            <MethodComment>/** 
 * Is the name for this ResultColumn generated?
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNameGenerated</MethodName>
            <MethodComment>/** 
 * Set that this result column name is generated.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultSetNumber</MethodName>
            <MethodComment>/** 
 * Set the resultSetNumber for this ResultColumn.  This is the  resultSetNumber for the ResultSet that we belong to.  This is useful for generate() and necessary since we do not have a back pointer to the RSN.
 * @param resultSetNumber	The resultSetNumber.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetNumber</MethodName>
            <MethodComment>/** 
 * Get the resultSetNumber for this ResultColumn.
 * @return int	The resultSetNumber.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustVirtualColumnId</MethodName>
            <MethodComment>/** 
 * Adjust the virtualColumnId for this ResultColumn	by the specified amount
 * @param adjust	The adjustment for the virtualColumnId
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>adjust</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setVirtualColumnId</MethodName>
            <MethodComment>/** 
 * Set the virtualColumnId for this ResultColumn
 * @param id	The virtualColumnId for this ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVirtualColumnId</MethodName>
            <MethodComment>/** 
 * Get the virtualColumnId for this ResultColumn
 * @return virtualColumnId for this ResultColumn
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collapseVirtualColumnIdGap</MethodName>
            <MethodComment>/** 
 * Adjust this virtualColumnId to account for the removal of a column This routine is called when bind processing finds and removes duplicate columns in the result list which were pulled up due to their presence in the ORDER BY clause, but were later found to be duplicate. If this column is a virtual column, and if this column's virtual column id is greater than the column id which is being removed, then we must logically shift this column to the left by decrementing its virtual column id.
 * @param removedColumnId   id of the column being removed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>removedColumnId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>guaranteeColumnName</MethodName>
            <MethodComment>/** 
 * Generate a unique (across the entire statement) column name for unnamed ResultColumns
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpression</MethodName>
            <MethodComment>/** 
 * Bind this expression.  This means binding the sub-expressions. In this case, we figure out what the result type of this result column is when we call one of the bindResultColumn*() methods. The reason is that there are different ways of binding the result columns depending on the statement type, and this is a standard interface that does not take the statement type as a parameter.
 * @param fromList		The FROM list for the query thisexpression is in, for binding columns.
 * @param subqueryList		The subquery list being built as we find SubqueryNodes
 * @param aggregates        The aggregate list being built as we find AggregateNodes
 * @return	The new top of the expression tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setExpression;[_expression.bindExpression(fromList,subqueryList,aggregates)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumnByPosition</MethodName>
            <MethodComment>/** 
 * Bind this result column by ordinal position and set the VirtualColumnId.   This is useful for INSERT statements like "insert into t values (1, 2, 3)",  where the user did not specify a column list. If a columnDescriptor is not found for a given position, then the user has specified more values than the # of columns in the table and an exception is thrown. NOTE: We must set the VirtualColumnId here because INSERT does not construct the ResultColumnList in the usual way.
 * @param tableDescriptor	The descriptor for the table beinginserted into
 * @param columnId		The ordinal position of the columnin the table, starting at 1.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [colDesc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setColumnDescriptor;[tableDescriptor, colDesc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setVirtualColumnId;[columnId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumnByName</MethodName>
            <MethodComment>/** 
 * Bind this result column by its name and set the VirtualColumnId.   This is useful for update statements, and for INSERT statements  like "insert into t (a, b, c) values (1, 2, 3)" where the user  specified a column list. An exception is thrown when a columnDescriptor cannot be found for a given name.  (There is no column with that name.) NOTE: We must set the VirtualColumnId here because INSERT does not construct the ResultColumnList in the usual way.
 * @param tableDescriptor	The descriptor for the table beingupdated or inserted into
 * @param columnId		The ordinal position of the columnin the table, starting at 1. (Used to set the VirtualColumnId.)
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [colDesc]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setColumnDescriptor;[tableDescriptor, colDesc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setVirtualColumnId;[columnId]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeUntypedNullExpression</MethodName>
            <MethodComment>/** 
 * Change an untyped null to a typed null.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bindingRC</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=bindingRC.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Set the column descriptor for this result column.  It also gets the data type services from the column descriptor and stores it in this result column: this is redundant, but we have to store the result type here for SELECT statements, and it is more orthogonal if the type can be found here regardless of what type of statement it is.
 * @param tableDescriptor	The TableDescriptor for the tablebeing updated or inserted into. This parameter is used only for error reporting.
 * @param columnDescriptor	The ColumnDescriptor to set inthis ResultColumn.
 * @exception StandardException tableNameMismatch
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnDescriptor</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumnToExpression</MethodName>
            <MethodComment>/** 
 * Bind the result column to the expression that lives under it. All this does is copy the datatype information to this node. This is useful for SELECT statements, where the result type of each column is the type of the column's expression.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setType;[_expression.getTypeServices()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSourceTableName</MethodName>
            <MethodComment>/** 
 * Set the column source's table name
 * @param t The source table name
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSourceSchemaName</MethodName>
            <MethodComment>/** 
 * Set the column source's schema name
 * @param s The source schema name
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess an expression tree.  We do a number of transformations here (including subqueries, IN lists, LIKE and BETWEEN) plus subquery flattening. NOTE: This is done before the outer ResultSetNode is preprocessed.
 * @param numTables			Number of tables in the DML Statement
 * @param outerFromList		FromList from outer query block
 * @param outerSubqueryList	SubqueryList from outer query block
 * @param outerPredicateList	PredicateList from outer query block
 * @return		The modified expression
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerSubqueryList</ParamName>
                    <ParamType>SubqueryList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerPredicateList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setExpression;[_expression.preprocess(numTables,outerFromList,outerSubqueryList,outerPredicateList)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkStorableExpression</MethodName>
            <MethodComment>/** 
 * This verifies that the expression is storable into the result column. It checks versus the given ResultColumn. This method should not be called until the result column and expression both have a valid type, i.e. after they are bound appropriately. Its use is for statements like insert, that need to verify if a given value can be stored into a column.
 * @exception StandardException thrown if types not suitable.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toStore</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStorableExpression;[(ValueNode)toStore]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkStorableExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [toStoreTypeId=source.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkStorableExpression</MethodName>
            <MethodComment>/** 
 * This verifies that the expression is storable into the result column. It checks versus the expression under this ResultColumn. This method should not be called until the result column and expression both have a valid type, i.e. after they are bound appropriately. Its use is for statements like update, that need to verify if a given value can be stored into a column.
 * @exception StandardException thrown if types not suitable.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkStorableExpression;[getExpression()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateExpression</MethodName>
            <MethodComment>/** 
 * Do code generation for a result column.  This consists of doing the code generation for the underlying expression.
 * @param ecb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ecb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>_expression;generateExpression;[ecb, mb]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnTypeAndLengthMatch</MethodName>
            <MethodComment>/** 
 * Check whether the column length and type of this result column match the expression under the columns.  This is useful for INSERT and UPDATE statements.  For SELECT statements this method should always return true.  There is no need to call this for a DELETE statement.
 * @return	true means the column matches its expressions,false means it doesn't match.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [expressionType=getExpression().getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnTypeAndLengthMatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherColumn</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [otherExpression=otherColumn.getExpression()]</InnerVar>
                <InnerVar>DataTypeDescriptor [resultColumnType=getTypeServices()]</InnerVar>
                <InnerVar>DataTypeDescriptor [otherResultColumnType=otherColumn.getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGenerated</MethodName>
            <MethodComment>/** 
 * Is this a generated column?
 * @return Boolean - whether or not this column is a generated column.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGeneratedForUnmatchedColumnInInsert</MethodName>
            <MethodComment>/** 
 * Is this columm generated for an unmatched column in an insert?
 * @return Boolean - whether or not this columm was generated for an unmatched column in an insert.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markGenerated</MethodName>
            <MethodComment>/** 
 * Mark this a columm as a generated column
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markGeneratedForUnmatchedColumnInInsert</MethodName>
            <MethodComment>/** 
 * Mark this a columm as generated for an unmatched column in an insert
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReferenced</MethodName>
            <MethodComment>/** 
 * Is this a referenced column?
 * @return Boolean - whether or not this column is a referenced column.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReferenced</MethodName>
            <MethodComment>/** 
 * Mark this column as a referenced column.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pullVirtualIsReferenced</MethodName>
            <MethodComment>/** 
 * Mark this column as a referenced column if it is already marked as referenced or if any result column in its chain of virtual columns is marked as referenced.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUnreferenced</MethodName>
            <MethodComment>/** 
 * Mark this column as an unreferenced column.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAllRCsInChainReferenced</MethodName>
            <MethodComment>/** 
 * Mark this RC and all RCs in the underlying RC/VCN chain as referenced.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ValueNode [vn=_expression]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setReferenced;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRedundant</MethodName>
            <MethodComment>/** 
 * Is this a redundant ResultColumn?
 * @return Boolean - whether or not this RC is redundant.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRedundant</MethodName>
            <MethodComment>/** 
 * Mark this ResultColumn as redundant.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsGroupingColumn</MethodName>
            <MethodComment>/** 
 * Mark this ResultColumn as a grouping column in the SELECT list
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rejectParameter</MethodName>
            <MethodComment>/** 
 * Look for and reject ?/-?/+? parameter under this ResultColumn.  This is called for SELECT statements.
 * @exception StandardException		Thrown if a ?/-?/+? parameter was founddirectly under this ResultColumn.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareTo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>ResultColumn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [otherResultColumn=other]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markUpdated</MethodName>
            <MethodComment>/** 
 * Mark this column as being updated by an update statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markUpdatableByCursor</MethodName>
            <MethodComment>/** 
 * Mark this column as being updatable, so we can make sure it is in the "for update" list of a positioned update.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updated</MethodName>
            <MethodComment>/** 
 * Tell whether this column is being updated.
 * @return	true means this column is being updated.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updatableByCursor</MethodName>
            <MethodComment>/** 
 * Tell whether this column is updatable by a positioned update.
 * @return	true means this column is updatable
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cloneMe</MethodName>
            <MethodComment>/** 
 * Make a copy of this ResultColumn in a new ResultColumn
 * @return	A new ResultColumn with the same contents as this one
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumn [newResultColumn]</InnerVar>
                <InnerVar>ValueNode [cloneExpr]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newResultColumn;setVirtualColumnId;[getVirtualColumnId()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;setName;[getName()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;setType;[getTypeServices()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;setNameGenerated;[isNameGenerated()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;setSourceTableName;[getSourceTableName()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;setSourceSchemaName;[getSourceSchemaName()]</InnerMethodInvoke>
                <InnerMethodInvoke>newResultColumn;copyTagsFrom;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumColumnSize</MethodName>
            <MethodComment>/** 
 * Get the maximum size of the column
 * @return the max size
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeServices</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [type=super.getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderableVariantType</MethodName>
            <MethodComment>/** 
 * Return the variant type for the underlying expression. The variant type can be: VARIANT				- variant within a scan (method calls and non-static field access) SCAN_INVARIANT		- invariant within a scan (column references from outer tables) QUERY_INVARIANT		- invariant within the life of a query CONSTANT				- constant
 * @return	The variant type for the underlying expression.
 * @exception StandardException	thrown on error
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [expType]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyOrderable</MethodName>
            <MethodComment>/** 
 * Verify that this RC is orderable.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableColumnDescriptor</MethodName>
            <MethodComment>/** 
 * If this ResultColumn is bound to a column in a table get the column descriptor for the column in the table. Otherwise return null.
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAutoincrementGenerated</MethodName>
            <MethodComment>/** 
 * Returns true if this result column is a placeholder for a generated autoincrement value.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrementGenerated</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resetAutoincrementGenerated</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAutoincrement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAutoincrement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isGroupingColumn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertConstant</MethodName>
            <MethodComment>/** 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>toTypeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constantValue</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [formatId=toTypeId.getTypeFormatId()]</InnerVar>
                <InnerVar>DataValueFactory [dvf=getDataValueFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableNameObject</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReference</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ColumnReference</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnDescriptor</MethodName>
            <MethodComment>/** 
 * Get the column descriptor 
 */
</MethodComment>
            <ReturnType>ColumnDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBaseColumnNode</MethodName>
            <MethodComment>/** 
 * Get the source BaseColumnNode for this result column. The BaseColumnNode cannot be found unless the ResultColumn is bound and is a simple reference to a column in a BaseFromTable.
 * @return a BaseColumnNode,or null if a BaseColumnNode cannot be found
 */
</MethodComment>
            <ReturnType>BaseColumnNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ValueNode [vn=_expression]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableNumber</MethodName>
            <MethodComment>/** 
 * Search the tree beneath this ResultColumn until we find the number of the table to which this RC points, and return that table number.  If we can't determine which table this RC is for, then return -1. There are two places we can find the table number: 1) if our expression is a ColumnReference, then we can get the target table number from the ColumnReference and that's it; 2) if expression is a VirtualColumnNode, then if the VirtualColumnNode points to a FromBaseTable, we can get that FBT's table number; otherwise, we walk the VirtualColumnNode-ResultColumn chain and do a recursive search.
 * @return The number of the table to which this ResultColumn	points, or -1 if we can't determine that from where we are.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEquivalent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasGenerationClause</MethodName>
            <MethodComment>/** 
 * Return true if this result column represents a generated column.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>