<Class>
    <Id>939</Id>
    <Package>org.apache.derby.impl.jdbc</Package>
    <ClassName>EmbedBlob</ClassName>
    <SuperClass>ConnectionChild</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Blob</SuperInterface>
        <SuperInterface>EngineLOB</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EmbedBlob  /** 
 * Implements java.sql.Blob (see the JDBC 2.0 spec). A blob sits on top of a BINARY, VARBINARY or LONG VARBINARY column. If its data is small (less than 1 page) it is a byte array taken from the SQLBit class. If it is large (more than 1 page) it is a long column in the database. The long column is accessed as a stream, and is implemented in store as an OverflowInputStream.  The Resetable interface allows sending messages to that stream to initialize itself (reopen its container and lock the corresponding row) and to reset itself to the beginning.  NOTE: In the case that the data is large, it is represented as a stream. This stream is returned to the user in the getBinaryStream() method. This means that we have limited control over the state of the stream, since the user can read bytes from it at any time.  Thus all methods here reset the stream to the beginning before doing any work. CAVEAT: The methods may not behave correctly if a user sets up multiple threads and sucks data from the stream (returned from getBinaryStream()) at the same time as calling the Blob methods. &lt;P&gt;&lt;B&gt;Supports&lt;/B&gt; &lt;UL&gt; &lt;LI&gt; JSR169 - no subsetting for java.sql.Blob &lt;LI&gt; JDBC 2.0 &lt;LI&gt; JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes, new update methods can safely be added into implementation. &lt;/UL&gt;
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>materialized</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>myStream</FieldName>
            <FieldType>PositionedStoreStream</FieldType>
        </Field>
        <Field>
            <FieldName>locator</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>streamLength</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>streamPositionOffset</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isValid</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>control</FieldName>
            <FieldType>LOBStreamControl</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>EmbedBlob</MethodName>
            <MethodComment>/** 
 * This constructor is used to create a empty Blob object. It is used by the Connection interface method createBlob().
 * @param blobBytes A byte array containing the data to be stores in the Blob.
 * @param con The EmbedConnection object associated with this Blob object.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>blobBytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>con</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>EmbedBlob</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dvd</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>con</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>con;addLOBReference;[this]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleStreamValue</MethodName>
            <MethodComment>/** 
 * Constructs a Blob object on top of a stream.
 * @param dvdStream the source stream
 * @param con the connection owning the Blob
 * @return The offset into the stream where the user data begins (used ifresetting the stream).
 * @throws StandardException if accessing the stream fails, or if writingdata to temporary storage fails
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dvdStream</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>con</ParamName>
                    <ParamType>EmbedConnection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBlobPosition</MethodName>
            <MethodComment>/** 
 * Sets the position of the Blob to  {@code logicalPos}, where position 0 is the beginning of the Blob content. &lt;p&gt; The position is only guaranteed to be valid from the time this method is invoked until the synchronization monitor is released, or until the next invokation of this method. &lt;p&gt; The position is logical in the sense that it specifies the requested position in the Blob content. This position might be at a different position in the underlying representation, for instance the Derby store stream prepends the Blob content with a length field.
 * @param logicalPos requested Blob position, 0-based
 * @return The new position, which will be equal to the requested position.
 * @throws IOException if reading/accessing the Blob fails
 * @throws StandardException throws BLOB_POSITION_TOO_LARGE if the requestedposition is larger than the Blob length, throws other SQL states if resetting the stream fails
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logicalPos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>read</MethodName>
            <MethodComment>/** 
 * Reads one byte from the Blob at the specified position. &lt;p&gt; Depending on the representation, this might result in a read from a byte array, a temporary file on disk or from a Derby store stream.
 * @return the byte at the current position, or -1 if end of file has beenreached
 * @throws IOException if reading from the underlying data representationfails
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [c]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>length</MethodName>
            <MethodComment>/** 
 * Returns the number of bytes in the &lt;code&gt;BLOB&lt;/code&gt; value designated by this &lt;code&gt;Blob&lt;/code&gt; object.
 * @return length of the &lt;code&gt;BLOB&lt;/code&gt; in bytes
 * @exception SQLException if there is an error accessing thelength of the &lt;code&gt;BLOB&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [pushStack=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBytes</MethodName>
            <MethodComment>/** 
 * Returns as an array of bytes part or all of the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object designates.  The byte array contains up to &lt;code&gt;length&lt;/code&gt; consecutive bytes starting at position &lt;code&gt;startPos&lt;/code&gt;. The starting position must be between 1 and the length of the BLOB plus 1. This allows for zero-length BLOB values, from which only zero-length byte arrays can be returned.  If a larger length is requested than there are bytes available, characters from the start position to the end of the BLOB are returned.
 * @param startPos the ordinal position of the first byte in the&lt;code&gt;BLOB&lt;/code&gt; value to be extracted; the first byte is at position 1
 * @param length is the number of consecutive bytes to be copied
 * @return a byte array containing up to &lt;code&gt;length&lt;/code&gt;consecutive bytes from the &lt;code&gt;BLOB&lt;/code&gt; value designated by this &lt;code&gt;Blob&lt;/code&gt; object, starting with the byte at position &lt;code&gt;startPos&lt;/code&gt;.
 * @exception SQLException if there is an error accessing the&lt;code&gt;BLOB&lt;/code&gt; NOTE: If the starting position is the length of the BLOB plus 1, zero bytess are returned regardless of the length requested.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>startPos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushStack=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBinaryStream</MethodName>
            <MethodComment>/** 
 * Retrieves the &lt;code&gt;BLOB&lt;/code&gt; designated by this &lt;code&gt;Blob&lt;/code&gt; instance as a stream.
 * @return a stream containing the &lt;code&gt;BLOB&lt;/code&gt; data
 * @exception SQLException if there is an error accessing the&lt;code&gt;BLOB&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>java.io.InputStream</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [pushStack=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>position</MethodName>
            <MethodComment>/** 
 * Determines the byte position at which the specified byte &lt;code&gt;pattern&lt;/code&gt; begins within the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents.  The search for &lt;code&gt;pattern&lt;/code&gt;. begins at position &lt;code&gt;start&lt;/code&gt;
 * @param pattern the byte array for which to search
 * @param start the position at which to begin searching; thefirst position is 1
 * @return the position at which the pattern appears, else -1.
 * @exception SQLException if there is an error accessing the&lt;code&gt;BLOB&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushStack=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkMatch</MethodName>
            <MethodComment>/** 
 * Checks if the pattern (starting from the second byte) appears inside the Blob content. &lt;p&gt; At this point, the first byte of the pattern must already have been matched, and  {@code pos} must be pointing at the second byte to compare.
 * @param pattern the byte array to search for, passed in by the user
 * @param pos the position in the Blob content to start searching from
 * @return {@code true} if a match is found, {@code false} if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>position</MethodName>
            <MethodComment>/** 
 * Determines the byte position in the &lt;code&gt;BLOB&lt;/code&gt; value designated by this &lt;code&gt;Blob&lt;/code&gt; object at which &lt;code&gt;pattern&lt;/code&gt; begins.  The search begins at position &lt;code&gt;start&lt;/code&gt;.
 * @param pattern the &lt;code&gt;Blob&lt;/code&gt; object designatingthe &lt;code&gt;BLOB&lt;/code&gt; value for which to search
 * @param start the position in the &lt;code&gt;BLOB&lt;/code&gt; valueat which to begin searching; the first position is 1
 * @return the position at which the pattern begins, else -1
 * @exception SQLException if there is an error accessing the&lt;code&gt;BLOB&lt;/code&gt;
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Blob</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [pushStack=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkMatch</MethodName>
            <MethodComment>/** 
 * Checks if the pattern (starting from the second byte) appears inside the Blob content.
 * @param pattern the Blob to search for, passed in by the user
 * @param pos the position in the Blob (this) content to start searching
 * @return {@code true} if a match is found, {@code false} if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Blob</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>InputStream [pStream]</InnerVar>
                <InnerVar>int [b1=pStream.read()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>handleMyExceptions</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SQLException</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>t</ParamName>
                    <ParamType>Throwable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finalize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBytes</MethodName>
            <MethodComment>/** 
 * Writes the given array of bytes to the BLOB value that this Blob object represents, starting at position pos, and returns the number of bytes written.
 * @param pos the position in the BLOB object at which to start writing
 * @param bytes the array of bytes to be written to the BLOB value that thisBlob object represents
 * @return The number of bytes written to the BLOB.
 * @throws SQLException if writing the bytes to the BLOB fails
 * @since 1.4
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBytes</MethodName>
            <MethodComment>/** 
 * Writes all or part of the given array of byte array to the BLOB value that this Blob object represents and returns the number of bytes written. Writing starts at position pos in the BLOB value; len bytes from the given byte array are written.
 * @param pos the position in the BLOB object at which to start writing
 * @param bytes the array of bytes to be written to the BLOB value that thisBlob object represents
 * @param offset the offset into the byte array at which to start readingthe bytes to be written
 * @param len the number of bytes to be written to the BLOB value from thearray of bytes bytes
 * @return The number of bytes written to the BLOB.
 * @throws SQLException if writing the bytes to the BLOB fails
 * @throws IndexOutOfBoundsException if {@code len} is larger than{@code bytes.length - offset}
 * @since 1.4
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bytes</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBinaryStream</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Retrieves a stream that can be used to write to the BLOB value that this Blob object represents. The stream begins at position pos. 
 * @param pos - the position in the BLOB object at which to start writing
 * @return a java.io.OutputStream object to which data can be written 
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>java.io.OutputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncate</MethodName>
            <MethodComment>/** 
 * JDBC 3.0 Truncates the BLOB value that this Blob object represents to be len bytes in length.
 * @param len - the length, in bytes, to which the BLOB value that this Blobobject represents should be truncated
 * @exception SQLException Feature not implemented for now.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>len</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>free</MethodName>
            <MethodComment>/** 
 * This method frees the &lt;code&gt;Blob&lt;/code&gt; object and releases the resources that  it holds. The object is invalid once the &lt;code&gt;free&lt;/code&gt; method is called. If &lt;code&gt;free&lt;/code&gt; is called multiple times, the subsequent calls to &lt;code&gt;free&lt;/code&gt; are treated as a no-op.
 * @throws SQLException if an error occurs releasingthe Blob's resources
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBinaryStream</MethodName>
            <MethodComment>/** 
 * Returns an &lt;code&gt;InputStream&lt;/code&gt; object that contains a partial  &lt;code&gt;Blob&lt;/code&gt; value, starting with the byte specified by pos,  which is length bytes in length.
 * @param pos the offset to the first byte of the partial value to be retrieved. The first byte in the &lt;code&gt;Blob&lt;/code&gt; is at  position 1
 * @param length the length in bytes of the partial value to be retrieved
 * @return through which the partial &lt;code&gt;Blob&lt;/code&gt; value can be read. 
 * @throws SQLException if pos is less than 1 or if pos is greater than the number of bytes in the  {@code Blob} or if {@code pos + length}is greater than  {@code Blob.length() +1}
 */
</MethodComment>
            <ReturnType>InputStream</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;checkValidity;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkValidity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getEmbedConnection();checkIfClosed;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isMaterialized</MethodName>
            <MethodComment>/** 
 * Returns if blob data is stored locally (using LOBStreamControl).
 * @return true if materialized else false
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLocator</MethodName>
            <MethodComment>/** 
 * Return locator for this lob.
 * @return The locator identifying this lob.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>