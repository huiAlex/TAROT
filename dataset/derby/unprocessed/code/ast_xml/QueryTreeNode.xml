<Class>
    <Id>1647</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>QueryTreeNode</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Visitable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>QueryTreeNode  /** 
 * QueryTreeNode is the root class for all query tree nodes. All query tree nodes inherit from QueryTreeNode except for those that extend QueryTreeNodeVector.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>AUTOINCREMENT_START_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AUTOINCREMENT_INC_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AUTOINCREMENT_IS_AUTOINCREMENT_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AUTOINCREMENT_CREATE_MODIFY</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>AUTOINCREMENT_CYCLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>beginOffset</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>endOffset</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>cm</FieldName>
            <FieldType>ContextManager</FieldType>
        </Field>
        <Field>
            <FieldName>lcc</FieldName>
            <FieldType>LanguageConnectionContext</FieldType>
        </Field>
        <Field>
            <FieldName>constantActionFactory</FieldName>
            <FieldType>GenericConstantActionFactory</FieldType>
        </Field>
        <Field>
            <FieldName>visitableTags</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>visitableTags</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>isPrivilegeCollectionRequired</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>QueryTreeNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextManager</MethodName>
            <MethodComment>/** 
 * Get the current ContextManager.
 * @return The current ContextManager.
 */
</MethodComment>
            <ReturnType>ContextManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerFactory</MethodName>
            <MethodComment>/** 
 * Gets the NodeFactory for this database.
 * @return	the node factory for this database.
 */
</MethodComment>
            <ReturnType>OptimizerFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerTracer</MethodName>
            <MethodComment>/** 
 * Convenience method for finding the optimizer tracer 
 */
</MethodComment>
            <ReturnType>OptTrace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimizerTracingIsOn</MethodName>
            <MethodComment>/** 
 * Convenience method for checking whether optimizer tracing is on 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getGenericConstantActionFactory</MethodName>
            <MethodComment>/** 
 * Gets the constant action factory for this database.
 * @return	the constant action factory.
 */
</MethodComment>
            <ReturnType>GenericConstantActionFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExecutionFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecutionFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ExecutionFactory [ef=getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getClassFactory</MethodName>
            <MethodComment>/** 
 * Get the ClassFactory to use with this database.
 */
</MethodComment>
            <ReturnType>ClassFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageConnectionContext</MethodName>
            <MethodComment>/** 
 * Gets the LanguageConnectionContext for this connection.
 * @return	the lcc for this connection
 */
</MethodComment>
            <ReturnType>LanguageConnectionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBeginOffset</MethodName>
            <MethodComment>/** 
 * Gets the beginning offset of the SQL substring which this query node represents.
 * @return	The beginning offset of the SQL substring. -1 means unknown.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setBeginOffset</MethodName>
            <MethodComment>/** 
 * Sets the beginning offset of the SQL substring which this query node represents.
 * @param beginOffset	The beginning offset of the SQL substring.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>beginOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEndOffset</MethodName>
            <MethodComment>/** 
 * Gets the ending offset of the SQL substring which this query node represents.
 * @return	The ending offset of the SQL substring. -1 means unknown.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEndOffset</MethodName>
            <MethodComment>/** 
 * Sets the ending offset of the SQL substring which this query node represents.
 * @param endOffset	The ending offset of the SQL substring.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>endOffset</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nodeHeader</MethodName>
            <MethodComment>/** 
 * Return header information for debug printing of this query tree node.
 * @return	Header information for debug printing of this querytree node.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>formatNodeString</MethodName>
            <MethodComment>/** 
 * Format a node that has been converted to a String for printing as part of a tree.  This method indents the String to the given depth by inserting tabs at the beginning of the string, and also after every newline.
 * @param nodeString	The node formatted as a String
 * @param depth		The depth to indent the given node
 * @return	The node String reformatted with tab indentation
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nodeString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>treePrint</MethodName>
            <MethodComment>/** 
 * Print this tree for debugging purposes.  This recurses through all the sub-nodes and prints them indented by their depth in the tree.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stackPrint</MethodName>
            <MethodComment>/** 
 * Print call stack for debug purposes
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>treePrint</MethodName>
            <MethodComment>/** 
 * Print this tree for debugging purposes.  This recurses through all the sub-nodes and prints them indented by their depth in the tree, starting with the given indentation.
 * @param depth		The depth of this node in the tree, thus,the amount to indent it when printing it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>containsInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugPrint</MethodName>
            <MethodComment>/** 
 * Print a String for debugging
 * @param outputString	The String to print
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outputString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugFlush</MethodName>
            <MethodComment>/** 
 * Flush the debug stream out
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Print the sub-nodes of this node. Each sub-class of QueryTreeNode is expected to provide its own printSubNodes() method.  In each case, it calls super.printSubNodes(), passing along its depth, to get the sub-nodes of the super-class. Then it prints its own sub-nodes by calling treePrint() on each of its members that is a type of QueryTreeNode.  In each case where it calls treePrint(), it should pass "depth + 1" to indicate that the sub-node should be indented one more level when printing. Also, it should call printLabel() to print the name of each sub-node before calling treePrint() on the sub-node, so that the reader of the printed tree can tell what the sub-node is. This printSubNodes() exists in here merely to act as a backstop. In other words, the calls to printSubNodes() move up the type hierarchy, and in this node the calls stop. I would have liked to put the call to super.printSubNodes() in this super-class, but Java resolves "super" statically, so it wouldn't get to the right super-class.
 * @param depth		The depth to indent the sub-nodes
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Format this node as a string Each sub-class of QueryTreeNode should implement its own toString() method.  In each case, toString() should format the class members that are not sub-types of QueryTreeNode (printSubNodes() takes care of following the references to sub-nodes, and toString() takes care of all members that are not sub-nodes).  Newlines should be used liberally - one good way to do this is to have a newline at the end of each formatted member.  It's also a good idea to put the name of each member in front of the formatted value.  For example, the code might look like: "memberName: " + memberName + "\n" + ... Vector members containing subclasses of QueryTreeNode should subclass QueryTreeNodeVector. Such subclasses form a special case: These classes should not implement printSubNodes, since there is generic handling in QueryTreeNodeVector.  They should only implement toString if they contain additional members.
 * @return	This node formatted as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printLabel</MethodName>
            <MethodComment>/** 
 * Print the given label at the given indentation depth.
 * @param depth		The depth of indentation to use when printingthe label
 * @param label		The String to print
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>label</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSessionSchema</MethodName>
            <MethodComment>/** 
 * Checks if the passed schema descriptor is for SESSION schema
 * @return	true if the passed schema descriptor is for SESSION schema
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isSessionSchema</MethodName>
            <MethodComment>/** 
 * Checks if the passed schema name is for SESSION schema
 * @return	true if the passed schema name is for SESSION schema
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disablePrivilegeCollection</MethodName>
            <MethodComment>/** 
 * Triggers, constraints and views get executed with their definers' privileges and they can exist in the system only if their definers still have all the privileges to create them. Based on this, any time a trigger/view/constraint is executing, we do not need to waste time in checking if the definer still has the right set of privileges. At compile time, we will make sure that we do not collect the privilege requirement for objects accessed with definer privileges by calling the following method. 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPrivilegeCollectionRequired</MethodName>
            <MethodComment>/** 
 * Return true from this method means that we need to collect privilege requirement for this node. For following cases, this method will return true. 1)execute view - collect privilege to access view but do not collect privilege requirements for objects accessed by actual view uqery 2)execute select - collect privilege requirements for objects accessed by select statement 3)create view -  collect privileges for select statement : the select statement for create view falls under 2) category above.
 * @return true if need to collect privilege requirement for this node
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Do the code generation for this node.  This is a place-holder method - it should be over-ridden in the sub-classes.
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb	The method for the generated code to go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getParameterTypes</MethodName>
            <MethodComment>/** 
 * Parameter info is stored in the compiler context. Hide this from the callers.
 * @return	null
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment>/** 
 * This creates a class that will do the work that's constant across all Executions of a PreparedStatement. It's up to our subclasses to override this method if they need to compile constant actions into PreparedStatements.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataDictionary</MethodName>
            <MethodComment>/** 
 * Get the DataDictionary
 * @return The DataDictionary
 */
</MethodComment>
            <ReturnType>DataDictionary</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDependencyManager</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DependencyManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCompilerContext</MethodName>
            <MethodComment>/** 
 * Get the CompilerContext
 * @return The CompilerContext
 */
</MethodComment>
            <ReturnType>CompilerContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeCompiler</MethodName>
            <MethodComment>/** 
 * Get the TypeCompiler associated with the given TypeId
 * @param typeId	The TypeId to get a TypeCompiler for
 * @return	The corresponding TypeCompiler
 */
</MethodComment>
            <ReturnType>TypeCompiler</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>accept</MethodName>
            <MethodComment>/** 
 * Accept a visitor, and call  {@code v.visit()} on child nodes asnecessary. Sub-classes should not override this method, but instead override the  {@link #acceptChildren(Visitor)} method.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>Visitable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [childrenFirst=v.visitChildrenFirst(this)]</InnerVar>
                <InnerVar>boolean [skipChildren=v.skipChildren(this)]</InnerVar>
                <InnerVar>Visitable [ret=v.stopTraversal() ? this : v.visit(this)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept a visitor on all child nodes. All sub-classes that add fields that should be visited, should override this method and call {@code accept(v)} on all visitable fields, as well as{@code super.acceptChildren(v)} to make sure all visitable fieldsdefined by the super-class are accepted too.
 * @param v the visitor
 * @throws StandardException on errors raised by the visitor
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTag</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tag</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>visitableTags;add;[tag]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>taggedWith</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tag</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyTagsFrom</MethodName>
            <MethodComment>/** 
 * Copy the tags from another QueryTreeNode 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>that</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getIntProperty</MethodName>
            <MethodComment>/** 
 * Get the int value of a Property
 * @param value		Property value as a String
 * @param key		Key value of property
 * @return	The int value of the property
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [intVal=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLongProperty</MethodName>
            <MethodComment>/** 
 * Get the long value of a Property
 * @param value     Property value as a String
 * @param key       Key value of property
 * @return  The long value of the property
 * @exception StandardException     Thrown on failure
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [longVal=-1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseStatement</MethodName>
            <MethodComment>/** 
 * Parse the a SQL statement from the body of another SQL statement. Pushes and pops a separate CompilerContext to perform the compilation.
 */
</MethodComment>
            <ReturnType>StatementNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>internalSQL</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseSearchCondition</MethodName>
            <MethodComment>/** 
 * Parse an SQL fragment that represents a  {@code &lt;search condition&gt;}.
 * @param sql a fragment of an SQL statement
 * @param internalSQL {@code true} if the SQL fragment is allowed tocontain internal syntax,  {@code false} otherwise
 * @return a {@code ValueNode} representing the parse tree of theSQL fragment
 * @throws StandardException if an error happens while parsing
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>internalSQL</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseStatementOrSearchCondition</MethodName>
            <MethodComment>/** 
 * Parse a full SQL statement or a fragment representing a  {@code &lt;searchcondition&gt;}. This is a worker method that contains common logic for {@link #parseStatement} and {@link #parseSearchCondition}.
 * @param sql the SQL statement or fragment to parse
 * @param internalSQL {@code true} if it is allowed to contain internalsyntax,  {@code false} otherwise
 * @param isStatement {@code true} if {@code sql} is a full SQL statement,{@code false} if it is a fragment
 * @return a parse tree
 * @throws StandardException if an error happens while parsing
 */
</MethodComment>
            <ReturnType>Visitable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sql</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>internalSQL</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isStatement</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>CompilerContext [newCC=lcc.pushCompilerContext()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementType</MethodName>
            <MethodComment>/** 
 * Return the type of statement, something from StatementType.
 * @return the type of statement
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullNode</MethodName>
            <MethodComment>/** 
 * Get a ConstantNode to represent a typed null value. 
 * @param type Type of the null node.
 * @return	A ConstantNode with the specified type, and a value of null
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ConstantNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>convertDefaultNode</MethodName>
            <MethodComment>/** 
 * Translate a Default node into a default value, given a type descriptor.
 * @param typeDescriptor	A description of the required data type.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeDescriptor</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeTableName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flatName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeTableName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextManager</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>flatName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAtomic</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTableDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named table within the given schema. If the schema parameter is NULL, it looks for the table in the current (default) schema. Table descriptors include object ids, object types (table, view, etc.) If the schema is SESSION, then before looking into the data dictionary for persistent tables, it first looks into LCC for temporary tables. If no temporary table tableName found for the SESSION schema, then it goes and looks through the data dictionary for persistent table We added getTableDescriptor here so that we can look for non data dictionary tables(ie temp tables) here. Any calls to getTableDescriptor in data dictionary should be only for persistent tables
 * @param tableName	The name of the table to get the descriptor for
 * @param schema	The descriptor for the schema the table lives in.If null, use the current (default) schema.
 * @return	The descriptor for the table, null if table does notexist.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>TableDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schema</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableDescriptor [retval]</InnerVar>
                <InnerVar>TableDescriptor [td=getDataDictionary().getTableDescriptor(tableName,schema,this.getLanguageConnectionContext().getTransactionCompile())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named schema. If the schemaName parameter is NULL, it gets the descriptor for the current compilation schema. QueryTreeNodes must obtain schemas using this method or the two argument version of it. This is to ensure that the correct default compliation schema is returned and to allow determination of if the statement being compiled depends on the current schema.  Schema descriptors include authorization ids and schema ids. SQL92 allows a schema to specify a default character set - we will not support this.  Will check default schema for a match before scanning a system table.
 * @param schemaName	The name of the schema we're interested in.If the name is NULL, get the descriptor for the current compilation schema.
 * @return	The descriptor for the schema.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSchemaDescriptor</MethodName>
            <MethodComment>/** 
 * Get the descriptor for the named schema. If the schemaName parameter is NULL, it gets the descriptor for the current compilation schema. QueryTreeNodes must obtain schemas using this method or the single argument version of it. This is to ensure that the correct default compliation schema is returned and to allow determination of if the statement being compiled depends on the current schema. 
 * @param schemaName The name of the schema we're interested in.If the name is NULL, get the descriptor for the current compilation schema.
 * @param raiseError True to raise an error if the schema does not exist,false to return null if the schema does not exist.
 * @return Valid SchemaDescriptor or null if raiseError is false and theschema does not exist. 
 * @throws StandardException Schema does not exist and raiseError is true.
 */
</MethodComment>
            <ReturnType>SchemaDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>raiseError</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resolveTableToSynonym</MethodName>
            <MethodComment>/** 
 * Resolve table/view reference to a synonym. May have to follow a synonym chain.
 * @param tabName to match for a synonym
 * @return	Synonym TableName if a match is found, NULL otherwise.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tabName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>String [nextSynonymTable=tabName.getTableName()]</InnerVar>
                <InnerVar>String [nextSynonymSchema=tabName.getSchemaName()]</InnerVar>
                <InnerVar>boolean [found=false]</InnerVar>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>TableName [tableName=new TableName(nextSynonymSchema,nextSynonymTable,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifyClassExist</MethodName>
            <MethodComment>/** 
 * Verify that a java class exists, is accessible (public) and not a class representing a primitive type.
 * @param javaClassName	The name of the java class to resolve.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaClassName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassInspector [classInspector=getClassFactory().getClassInspector()]</InnerVar>
                <InnerVar>Throwable [reason=null]</InnerVar>
                <InnerVar>boolean [foundMatch=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setRefActionInfo</MethodName>
            <MethodComment>/** 
 * set the Information gathered from the parent table that is  required to perform a referential action on dependent table.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fkIndexConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkColArray</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentResultSetId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dependentScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateAuthorizeCheck</MethodName>
            <MethodComment>/** 
 * Add an authorization check into the passed in method.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sqlOperation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>acb;pushThisAsActivation;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, null, "getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, null, "getAuthorizer", ClassName.Authorizer, 0]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushThisAsActivation;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[sqlOperation]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, null, "authorize", "void", 2]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkReliability</MethodName>
            <MethodComment>/** 
 * Bind time logic. Raises an error if this ValueNode, once compiled, returns unstable results AND if we're in a context where unstable results are forbidden. Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
 * @param fragmentType	Type of fragment as a String, for inclusion in error messages.
 * @param fragmentBitMask	Type of fragment as a bitmask of possible fragment types
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fragmentType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fragmentBitMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkReliability</MethodName>
            <MethodComment>/** 
 * Bind time logic. Raises an error if this ValueNode, once compiled, returns unstable results AND if we're in a context where unstable results are forbidden. Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
 * @param fragmentBitMask	Type of fragment as a bitmask of possible fragment types
 * @param fragmentType	Type of fragment as a String, to be fetch for the error message.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fragmentBitMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fragmentType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUserType</MethodName>
            <MethodComment>/** 
 * Bind a UDT. This involves looking it up in the DataDictionary and filling in its class name.
 * @param originalDTD A datatype: might be an unbound UDT and might not be
 * @return The bound UDT if originalDTD was an unbound UDT; otherwise returns originalDTD.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>originalDTD</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UserDefinedTypeIdImpl [userTypeID=(UserDefinedTypeIdImpl)originalDTD.getTypeId().getBaseTypeId()]</InnerVar>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>SchemaDescriptor [typeSchema=getSchemaDescriptor(userTypeID.getSchemaName())]</InnerVar>
                <InnerVar>char [udtNameSpace=AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR]</InnerVar>
                <InnerVar>String [unqualifiedTypeName=userTypeID.getUnqualifiedName()]</InnerVar>
                <InnerVar>AliasDescriptor [ad=dd.getAliasDescriptor(typeSchema.getUUID().toString(),unqualifiedTypeName,udtNameSpace)]</InnerVar>
                <InnerVar>DataTypeDescriptor [result=new DataTypeDescriptor(TypeId.getUserDefinedTypeId(typeSchema.getSchemaName(),unqualifiedTypeName,ad.getJavaClassName()),originalDTD.isNullable())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;createTypeDependency;[ad]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUserCatalogType</MethodName>
            <MethodComment>/** 
 * Bind user defined types as necessary 
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUDTDesc</MethodName>
            <MethodComment>/** 
 * Get the AliasDescriptor of a UDT 
 */
</MethodComment>
            <ReturnType>AliasDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UserDefinedTypeIdImpl [userTypeID=(UserDefinedTypeIdImpl)dtd.getTypeId().getBaseTypeId()]</InnerVar>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>SchemaDescriptor [typeSchema=getSchemaDescriptor(userTypeID.getSchemaName())]</InnerVar>
                <InnerVar>char [udtNameSpace=AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR]</InnerVar>
                <InnerVar>String [unqualifiedTypeName=userTypeID.getUnqualifiedName()]</InnerVar>
                <InnerVar>AliasDescriptor [ad=dd.getAliasDescriptor(typeSchema.getUUID().toString(),unqualifiedTypeName,udtNameSpace)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUDTUsagePriv</MethodName>
            <MethodComment>/** 
 * Add USAGE privilege for all UDTs mentioned in the indicated ValueNodes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>valueNodes</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addUDTUsagePriv</MethodName>
            <MethodComment>/** 
 * Add USAGE privilege for a single UDT.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>val</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [dtd=val.getTypeServices()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindRowMultiSet</MethodName>
            <MethodComment>/** 
 * Bind the UDTs in a table type.
 * @param originalDTD A datatype: might be an unbound UDT and might not be
 * @return The bound table type if originalDTD was an unbound table type; otherwise returns originalDTD.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>originalDTD</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowMultiSetImpl [originalMultiSet=(RowMultiSetImpl)originalDTD.getTypeId().getBaseTypeId()]</InnerVar>
                <InnerVar>TypeDescriptor[] [columnTypes=originalMultiSet.getTypes()]</InnerVar>
                <InnerVar>int [columnCount=columnTypes.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>originalMultiSet;setTypes;[columnTypes]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTypeDependency</MethodName>
            <MethodComment>/** 
 * Declare a dependency on a type and check that you have privilege to use it. This is only used if the type is an ANSI UDT.
 * @param dtd Type which may have a dependency declared on it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AliasDescriptor [ad=getDataDictionary().getAliasDescriptorForUDT(null,dtd)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTypeDependency</MethodName>
            <MethodComment>/** 
 * Declare a dependency on an ANSI UDT, identified by its AliasDescriptor, and check that you have privilege to use it.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ad</ParamName>
                    <ParamType>AliasDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getCompilerContext();createDependency;[ad]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>throwReliabilityException</MethodName>
            <MethodComment>/** 
 * Common code for the 2 checkReliability functions.  Always throws StandardException.
 * @param fragmentType Type of fragment as a string, for inclusion in error messages.
 * @param fragmentBitMask Describes the kinds of expressions we ar suspicious of
 * @exception StandardException        Throws an error, always.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fragmentType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fragmentBitMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [reliability=getCompilerContext().getReliability()]</InnerVar>
                <InnerVar>String [sqlState]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orReliability</MethodName>
            <MethodComment>/** 
 * OR in more reliability bits and return the old reliability value.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newBits</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CompilerContext [cc=getCompilerContext()]</InnerVar>
                <InnerVar>int [previousReliability=cc.getReliability()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cc;setReliability;[previousReliability | newBits]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindOffsetFetch</MethodName>
            <MethodComment>/** 
 * Bind the parameters of OFFSET n ROWS and FETCH FIRST n ROWS ONLY, if any.
 * @param offset the OFFSET parameter, if any
 * @param fetchFirst the FETCH parameter, if any
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchFirst</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOffsetOrderedNodes</MethodName>
            <MethodComment>/** 
 * Get all child nodes of a specific type, and return them in the order in which they appear in the SQL text.
 * @param &lt; N &gt; the type of node to look for
 * @param type the type of node to look for
 * @return all nodes of the specified type
 * @throws StandardException if an error occurs
 */
</MethodComment>
            <ReturnType>N</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>N</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>OffsetOrderVisitor&lt;N&gt; [visitor=new OffsetOrderVisitor&lt;N&gt;(type,getBeginOffset(),getEndOffset() + 1)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;accept;[visitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContext</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be package protected so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>