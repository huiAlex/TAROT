<Class>
    <Id>256</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>DataTypeDescriptor</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Formatable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DataTypeDescriptor  /** 
 * DataTypeDescriptor describes a runtime SQL type. It consists of a catalog type (TypeDescriptor) and runtime attributes. The list of runtime attributes is: &lt;UL&gt; &lt;LI&gt; Collation Derivation &lt;/UL&gt; &lt;P&gt; A DataTypeDescriptor is immutable.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>INTEGER</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>INTEGER_NOT_NULL</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_NOT_NULL</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE</FieldName>
            <FieldType>DataTypeDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>MIN_VALUE_IDX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_VALUE_IDX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_MIN_ARRAY_SIZE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>typeDescriptor</FieldName>
            <FieldType>TypeDescriptorImpl</FieldType>
        </Field>
        <Field>
            <FieldName>typeId</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>collationDerivation</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a descriptor that corresponds to a nullable builtin JDBC type. If a variable length type then the size information will be set  to the maximum possible. Collation type will be UCS_BASIC and derivation IMPLICIT. For well known types code may also use the pre-defined runtime types that are fields of this class, such as INTEGER.
 * @param jdbcType	The int type of the JDBC type for which to geta corresponding SQL DataTypeDescriptor
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a descriptor that corresponds to a nullable builtin variable length JDBC type. Collation type will be UCS_BASIC and derivation IMPLICIT.
 * @param jdbcType  The int type of the JDBC type for which to geta corresponding SQL DataTypeDescriptor
 * @return  A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getType</MethodName>
            <MethodComment>/** 
 * Return a runtime type for a catalog type.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDescriptorImpl [typeDescriptor=(TypeDescriptorImpl)catalogType]</InnerVar>
                <InnerVar>TypeId [typeId=TypeId.getTypeId(catalogType)]</InnerVar>
                <InnerVar>DataTypeDescriptor [dtd=new DataTypeDescriptor(typeDescriptor,typeId)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogType</MethodName>
            <MethodComment>/** 
 * Return a nullable catalog type for a JDBC builtin type and length.
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogType</MethodName>
            <MethodComment>/** 
 * Return a nullable catalog type for a fixed length JDBC builtin type.
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogType</MethodName>
            <MethodComment>/** 
 * Get a catlog type identical to the passed in type exception that the collationType is set to the passed in value.
 * @param catalogType Type to be based upon.
 * @param collationType Collation type of returned type.
 * @return catalogType if it already has the correct collation,otherwise a new TypeDescriptor with the correct collation.
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a descriptor that corresponds to a builtin JDBC type. For well known types code may also use the pre-defined runtime types that are fields of this class, such as INTEGER. E.g. using DataTypeDescriptor.INTEGER is preferred to DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, true) (both will return the same immutable object).
 * @param jdbcType	The int type of the JDBC type for which to geta corresponding SQL DataTypeDescriptor
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=TypeId.getBuiltInTypeId(jdbcType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a descriptor that corresponds to a builtin JDBC type. Collation type will be UCS_BASIC and derivation IMPLICIT.
 * @param jdbcType	The int type of the JDBC type for which to geta corresponding SQL DataTypeDescriptor
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=TypeId.getBuiltInTypeId(jdbcType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a DataTypeServices that corresponds to a nullable builtin SQL type. Collation type will be UCS_BASIC and derivation IMPLICIT.
 * @param sqlTypeName	The name of the type for which to geta corresponding SQL DataTypeDescriptor
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type (only for 'char')
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a DataTypeServices that corresponds to a builtin SQL type Collation type will be UCS_BASIC and derivation IMPLICIT.
 * @param sqlTypeName	The name of the type for which to geta corresponding SQL DataTypeDescriptor
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type (only for 'char')
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sqlTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a DataTypeServices that corresponds to a Java type
 * @param javaTypeName	The name of the Java type for which to geta corresponding SQL DataTypeDescriptor
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type (only for 'char')
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a DataTypeServices that corresponds to a Java type
 * @param javaTypeName	The name of the Java type for which to geta corresponding SQL DataTypeDescriptor
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type (only for 'char')
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=TypeId.getSQLTypeForJavaType(javaTypeName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLDataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Get a DataTypeDescriptor that corresponds to a Java type
 * @param javaTypeName	The name of the Java type for which to geta corresponding SQL DataTypeDescriptor
 * @param precision	The number of decimal digits
 * @param scale		The number of digits after the decimal point
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum width of a data valuerepresented by this type.
 * @return	A new DataTypeDescriptor that corresponds to the Java type.A null return value means there is no corresponding SQL type.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=TypeId.getSQLTypeForJavaType(javaTypeName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowMultiSet</MethodName>
            <MethodComment>/** 
 * Get a catalog type that corresponds to a SQL Row Multiset
 * @param columnNames   Names of the columns in the Row Muliset
 * @param catalogTypes  Types of the columns in the Row Muliset
 * @return	A new DataTypeDescriptor describing the SQL Row Multiset
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>catalogTypes</ParamName>
                    <ParamType>TypeDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RowMultiSetImpl [rms=new RowMultiSetImpl(columnNames,catalogTypes)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Public niladic constructor. Needed for Formatable interface to work.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for use with numeric types
 * @param typeId	The typeId of the type being described
 * @param precision	The number of decimal digits.
 * @param scale		The number of digits after the decimal point.
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum number of bytes for this datatype
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor to use when the caller doesn't know if it is requesting numeric or no-numeric DTD. For instance, when dealing with MAX/MIN  aggregrate operators, AggregateNode.bindExpression could be dealing with a character string operand or a numeric operand. The result of MAX/MIN will depend on the type of it's operand. And hence when this constructor gets called by AggregateNode.bindExpression, we don't know  what type we are constructing and hence this constructor supports  arguments for both numeric and non-numeric types.
 * @param typeId	The typeId of the type being described
 * @param precision	The number of decimal digits.
 * @param scale		The number of digits after the decimal point.
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum number of bytes for this datatype
 * @param collationType The collation type of a string data type
 * @param collationDerivation Collation Derivation of a string data type
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationDerivation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for use with non-numeric types
 * @param typeId	The typeId of the type being described
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum number of bytes for this datatype
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationDerivation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for internal uses only.   (This is useful when the precision and scale are potentially wider than those in the source, like when determining the dominant data type.)
 * @param source	The DTSI to copy
 * @param precision	The number of decimal digits.
 * @param scale		The number of digits after the decimal point.
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum number of bytes for this datatype
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>precision</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scale</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for internal uses only
 * @param source	The DTSI to copy
 * @param isNullable	TRUE means it could contain NULL, FALSE meansit definitely cannot contain NULL.
 * @param maximumWidth	The maximum number of bytes for this datatype
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maximumWidth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>DataTypeDescriptor</MethodName>
            <MethodComment>/** 
 * Constructor for use in reconstructing a DataTypeDescriptor from a TypeDescriptorImpl and a TypeId
 * @param source	The TypeDescriptorImpl to construct this DTSI from
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>TypeDescriptorImpl</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeId</ParamName>
                    <ParamType>TypeId</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>normalize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>source</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cachedDest</ParamName>
                    <ParamType>DataValueDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDominantType</MethodName>
            <MethodComment>/** 
 * Get the dominant type (DataTypeDescriptor) of the 2. For variable length types, the resulting type will have the biggest max length of the 2. If either side is nullable, then the result will also be nullable. If dealing with character string types, then make sure to set the collation info on the dominant type. Following algorithm will be used  for dominant DTD's collation determination. Each of the steps of the  algorithm have been numbered in the comments below and those same  numbers are used in the actual algorithm below so it is easier to  understand and maintain. Step 1 If the DTD for "this" node has the same collation derivation as the  otherDTS, then check if their collation types match too. If the  collation types match too, then DTD for dominant type will get the same  collation derivation and type. Step 2 If the collation derivation for DTD for "this" node and otherDTS do not  match, then check if one of them has the collation derivation of NONE.  If that is the case, then dominant DTD will get the collation type and  derivation of DTD whose collation derivation is not NONE. Step 3 If the collation derivation for DTD for "this" node and otherDTS do not  match, and none of them have the derivation of NONE then it means that  we are dealing with collation derivation of IMPLICIT and EXPLICIT and  hence the dominant DTD should get collation derivation of NONE. This is  not a possibility in Derby 10.3 because the only 2 possible collation  derivation supported are IMPLICIT and NONE. Step 4 If the collation derivation for DTD for "this" node and otherDTS match,  then check if the collation types match too. If not, then the dominant  DTD should get collation derivation of NONE. 
 * @param otherDTS	DataTypeDescriptor to compare with.
 * @param cf		A ClassFactory
 * @return DataTypeDescriptor  DTS for dominant type
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherDTS</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [nullable]</InnerVar>
                <InnerVar>TypeId [thisType]</InnerVar>
                <InnerVar>TypeId [otherType]</InnerVar>
                <InnerVar>DataTypeDescriptor [higherType]</InnerVar>
                <InnerVar>DataTypeDescriptor [lowerType=null]</InnerVar>
                <InnerVar>int [maximumWidth]</InnerVar>
                <InnerVar>int [precision=getPrecision()]</InnerVar>
                <InnerVar>int [scale=getScale()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isExactTypeAndLengthMatch</MethodName>
            <MethodComment>/** 
 * Check whether or not the 2 types (DataTypeDescriptor) have the same type and length. This is useful for UNION when trying to decide whether a NormalizeResultSet is required.
 * @param otherDTS	DataTypeDescriptor to compare with.
 * @return boolean  Whether or not the 2 DTSs have the same type and length.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>otherDTS</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [thisType=getTypeId()]</InnerVar>
                <InnerVar>TypeId [otherType=otherDTS.getTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumWidth</MethodName>
            <MethodComment>/** 
 * Shorthand method for getCatalogType().getMaximumWidth().
 * @see TypeDescriptor#getMaximumWidth
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeId</MethodName>
            <MethodComment>/** 
 * Gets the TypeId for the datatype.
 * @return	The TypeId for the datatype.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNull</MethodName>
            <MethodComment>/** 
 * Get a Null for this type.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataValueDescriptor [returnDVD=typeId.getNull()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeName</MethodName>
            <MethodComment>/** 
 * Gets the name of this datatype.
 * @return	the name of this datatype
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJDBCTypeId</MethodName>
            <MethodComment>/** 
 * Get the jdbc type id for this type.  JDBC type can be found in java.sql.Types.  Shorthand method for getCatalogType().getJDBCTypeId().
 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
 * @see Types
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrecision</MethodName>
            <MethodComment>/** 
 * Returns the number of decimal digits for the datatype, if applicable. Shorthand method for getCatalogType().getPrecision().
 * @return	The number of decimal digits for the datatype.  Returnszero for non-numeric datatypes.
 * @see TypeDescriptor#getPrecision()
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScale</MethodName>
            <MethodComment>/** 
 * Returns the number of digits to the right of the decimal for the datatype, if applicable. Shorthand method for getCatalogType().getScale().
 * @return	The number of digits to the right of the decimal forthe datatype.  Returns zero for non-numeric datatypes.
 * @see TypeDescriptor#getScale()
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationType</MethodName>
            <MethodComment>/** 
 * Obtain the collation type of the underlying catalog type. Shorthand method for getCatalogType().getCollationType().
 * @see TypeDescriptor#getCollationType()
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationType</MethodName>
            <MethodComment>/** 
 * Obtain the collation type from a collation property value.
 * @return The collation type, or -1 if not recognized.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationName</MethodName>
            <MethodComment>/** 
 * Gets the name of the collation type in this descriptor if the collation derivation is not NONE. If the collation derivation is NONE, then this method will return "NONE". &lt;p&gt; This method is used for generating error messages which will use correct string describing collation type/derivation.
 * @return the name of the collation being used in this type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationName</MethodName>
            <MethodComment>/** 
 * Gets the name of the specified collation type.
 * @param collationType The collation type.
 * @return The name, e g "TERRITORY_BASED:PRIMARY".
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollationDerivation</MethodName>
            <MethodComment>/** 
 * Get the collation derivation for this type. This applies only for character string types. For the other types, this api should be ignored. SQL spec talks about character string types having collation type and  collation derivation associated with them (SQL spec Section 4.2.2  Comparison of character strings). If collation derivation says explicit  or implicit, then it means that there is a valid collation type  associated with the charcter string type. If the collation derivation is  none, then it means that collation type can't be established for the  character string type. 1)Collation derivation will be explicit if SQL COLLATE clause has been   used for character string type (this is not a possibility for Derby 10.3  because we are not planning to support SQL COLLATE clause in the 10.3 release).  2)Collation derivation will be implicit if the collation can be  determined w/o the COLLATE clause eg CREATE TABLE t1(c11 char(4)) then  c11 will have collation of USER character set. Another eg, TRIM(c11)  then the result character string of TRIM operation will have collation  of the operand, c11. 3)Collation derivation will be none if the aggregate methods are dealing  with character strings with different collations (Section 9.3 Data types  of results of aggregations Syntax Rule 3aii). Collation derivation will be initialized to COLLATION_DERIVATION_IMPLICIT if not explicitly set.
 * @return Should be COLLATION_DERIVATION_NONE or COLLATION_DERIVATION_IMPLICIT
 * @see StringDataValue#COLLATION_DERIVATION_NONE
 * @see StringDataValue#COLLATION_DERIVATION_IMPLICIT
 * @see StringDataValue#COLLATION_DERIVATION_EXPLICIT
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNullable</MethodName>
            <MethodComment>/** 
 * Returns TRUE if the datatype can contain NULL, FALSE if not. JDBC supports a return value meaning "nullability unknown" - I assume we will never have columns where the nullability is unknown. Shorthand method for getCatalogType().isNullable();
 * @return	TRUE if the datatype can contain NULL, FALSE if not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNullabilityType</MethodName>
            <MethodComment>/** 
 * Return a type descriptor identical to the this type with the exception of its nullability. If the nullablity required matches the nullability of this then this is returned.
 * @param isNullable True to return a nullable type, false otherwise.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>isNullable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCollatedType</MethodName>
            <MethodComment>/** 
 * Return a type description identical to this type with the exception that its collation information is taken from the passed in information. If the type does not represent a string type then the collation will be unchanged and this is returned.
 * @return This if collation would be unchanged otherwise a new type.
 */
</MethodComment>
            <ReturnType>DataTypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationDerivation</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowMultiSetCollation</MethodName>
            <MethodComment>/** 
 * For a row multi set type return an identical type with the collation type changed. Note that since row types are only ever catalog types the derivation is not used (since derivation is a property of runtime types). &lt;BR&gt;
 * @param collationType
 * @return this  will be returned if no changes are required (e.g.no string types or collation is already correct), otherwise a new instance is returned (leaving this unchanged).
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>collationType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDescriptor[] [rowTypes=catalogType.getRowTypes()]</InnerVar>
                <InnerVar>TypeDescriptor[] [newTypes=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * Compare if two DataTypeDescriptors are exactly the same
 * @param other the type to compare to.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>other</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DataTypeDescriptor [odtd=(DataTypeDescriptor)other]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>comparable</MethodName>
            <MethodComment>/** 
 * Check if this type is comparable with the passed type.
 * @param compareWithDTD the type of the instance to compare with this type.
 * @param forEquals True if this is an = or != comparison, falseotherwise.
 * @param cf		A ClassFactory
 * @return true if compareWithDTD is comparable to this type, else false.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compareWithDTD</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forEquals</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [compareWithTypeID=compareWithDTD.getTypeId()]</InnerVar>
                <InnerVar>int [compareWithJDBCTypeId=compareWithTypeID.getJDBCTypeId()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compareCollationInfo</MethodName>
            <MethodComment>/** 
 * Compare the collation info on this DTD with the passed DTD. The rules for comparison are as follows (these are as per SQL standard 2003  Section 9.13) 1)If both the DTDs have collation derivation of NONE, then they can't be compared and we return false. 2)If both the DTDs have same collation derivation (which in Derby's case at this point will mean collation derivation of IMPLICIT), then check the collation types. If they match, then return true. If they do not  match, then they can't be compared and hence return false. 3)If one DTD has collation derivation of IMPLICIT and other DTD has collation derivation of NONE, then 2 DTDs are comparable using the collation type of DTD with collation derivation of IMPLICIT. Derby does not implement this rule currently and it is being traked as DERBY-2678. Derby's current behavior is to throw an exception if both the DTDs  involved in collation operation do not have collation derivation of  IMPLICIT. This behavior is a subset of SQL standard. 4)Derby currently does not support collation derivation of EXPLICIT and hence we do not have the code to enforce rules as mentioned in Section 9.13 of SQL spec for collation derivation of EXPLICIT. When we implement collation derivation of EXPLICIT, we should make sure that we follow the rules as specified in the SQL spec for comparability.
 * @param compareWithDTD compare this DTD's collation info
 * @return value depends on the algorithm above.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>compareWithDTD</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLstring</MethodName>
            <MethodComment>/** 
 * Converts this data type descriptor (including length/precision) to a string. E.g. VARCHAR(30) or java.util.Hashtable 
 * @return	String version of datatype, suitable for running throughthe Parser.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCatalogType</MethodName>
            <MethodComment>/** 
 * Get the simplified type descriptor that is intended to be stored in the system tables.
 */
</MethodComment>
            <ReturnType>TypeDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>estimatedMemoryUsage</MethodName>
            <MethodComment>/** 
 * Get the estimated memory usage for this type descriptor.
 */
</MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isJDBCTypeEquivalent</MethodName>
            <MethodComment>/** 
 * Compare JdbcTypeIds to determine if they represent equivalent SQL types. For example Types.NUMERIC and Types.DECIMAL are equivalent
 * @param existingType  JDBC type id of Derby data type
 * @param jdbcTypeId   JDBC type id passed in from application.
 * @return boolean true if types are equivalent, false if not
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>existingType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>jdbcTypeId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNumericType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCharacterType</MethodName>
            <MethodComment>/** 
 * Check whether a JDBC type is one of the character types that are compatible with the Java type &lt;code&gt;String&lt;/code&gt;. &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;CLOB&lt;/code&gt; is not compatible with &lt;code&gt;String&lt;/code&gt;. See tables B-4, B-5 and B-6 in the JDBC 3.0 Specification. &lt;p&gt; There are some non-character types that are compatible with &lt;code&gt;String&lt;/code&gt; (examples: numeric types, binary types and time-related types), but they are not covered by this method.
 * @param jdbcType a JDBC type
 * @return &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;jdbcType&lt;/code&gt; is a character typeand compatible with &lt;code&gt;String&lt;/code&gt;
 * @see java.sql.Types
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBinaryType</MethodName>
            <MethodComment>/** 
 * Check whether a JDBC type is compatible with the Java type &lt;code&gt;byte[]&lt;/code&gt;. &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;BLOB&lt;/code&gt; is not compatible with &lt;code&gt;byte[]&lt;/code&gt;. See tables B-4, B-5 and B-6 in the JDBC 3.0 Specification.
 * @param jdbcType a JDBC type
 * @return &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;jdbcType&lt;/code&gt; is compatible with&lt;code&gt;byte[]&lt;/code&gt;
 * @see java.sql.Types
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isAsciiStreamAssignable</MethodName>
            <MethodComment>/** 
 * Determine if an ASCII stream can be inserted into a column or parameter of type &lt;code&gt;jdbcType&lt;/code&gt;.
 * @param jdbcType JDBC type of column or parameter
 * @return &lt;code&gt;true&lt;/code&gt; if an ASCII stream can be inserted;&lt;code&gt;false&lt;/code&gt; otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBinaryStreamAssignable</MethodName>
            <MethodComment>/** 
 * Determine if a binary stream can be inserted into a column or parameter of type &lt;code&gt;jdbcType&lt;/code&gt;.
 * @param jdbcType JDBC type of column or parameter
 * @return &lt;code&gt;true&lt;/code&gt; if a binary stream can be inserted;&lt;code&gt;false&lt;/code&gt; otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCharacterStreamAssignable</MethodName>
            <MethodComment>/** 
 * Determine if a character stream can be inserted into a column or parameter of type &lt;code&gt;jdbcType&lt;/code&gt;.
 * @param jdbcType JDBC type of column or parameter
 * @return &lt;code&gt;true&lt;/code&gt; if a character stream can be inserted;&lt;code&gt;false&lt;/code&gt; otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>jdbcType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment>/** 
 * Read this object from a stream of stored objects.
 * @param in read this.
 * @exception IOException					thrown on error
 * @exception ClassNotFoundException		thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment>/** 
 * Write this object to a stream of stored objects.
 * @param out write bytes here.
 * @exception IOException		thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeObject;[typeDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>out;writeInt;[getCollationDerivation()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Get the formatID which corresponds to this class.
 * @return	the formatID of this class
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUserCreatableType</MethodName>
            <MethodComment>/** 
 * Check to make sure that this type id is something a user can create him/herself directly through an SQL CREATE TABLE statement. This method is used for CREATE TABLE AS ... WITH [NO] DATA binding because it's possible for the query to return types which are not actually creatable for a user.  DERBY-2605. Three examples are: JAVA_OBJECT: A user can select columns of various java object types from system tables, but s/he is not allowed to create such a column him/herself. DECIMAL: A user can specify a VALUES clause with a constant that has a precision of greater than 31.  Derby can apparently handle such a value internally, but the user is not supposed to be able create such a column him/herself.
 * @return True if the type associated with this DTD can be created viathe CREATE TABLE syntax; false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFullSQLTypeName</MethodName>
            <MethodComment>/** 
 * Return the SQL type name and, if applicable, scale/precision/length for this DataTypeDescriptor.  Note that we want the values from *this object specifically, not the max values defined on this.typeId.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>StringBuffer [sbuf=new StringBuffer(typeId.getSQLTypeName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLTypeNameWithCollation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [name=typeId.getSQLTypeName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNumericBounds</MethodName>
            <MethodComment>/** 
 * Get the maximum and minimum value for a fixed numeric type. Throws an unimplemented feature exception for a non-numeric type.
 */
</MethodComment>
            <ReturnType>long[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long[] [retval=new long[MAX_MIN_ARRAY_SIZE]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>