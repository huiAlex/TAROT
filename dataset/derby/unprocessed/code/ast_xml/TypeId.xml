<Class>
    <Id>1154</Id>
    <Package>org.apache.derby.iapi.types</Package>
    <ClassName>TypeId</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>TypeId  /** 
 * TypeId describes the static information about a SQL type independent of any specific attributes of the type such as length. So the TypeId for CHARACTER describes the fundamental information about CHARACTER. A specific type (e.g. CHARACTER(10)) is described by a TypeDescriptor for a catlog type and a DataTypeDescriptor for a runtime type. (note a DataTypeDescriptor adds runtime attributes to the TypeDescriptor it has). &lt;P&gt; A TypeId is immutable. &lt;P&gt; The equals(Object) method can be used to determine if two typeIds are for the same type, which defines type id equality.
 * @see DataTypeDescriptor
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>LONGINT_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGINT_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGINT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INT_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INT_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_PRECISION_IN_DIGITS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_PRECISION_IN_DIGITS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_PRECISION</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHAR_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VARCHAR_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARCHAR_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BIT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VARBIT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBIT_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BLOB_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CLOB_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XML_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DATE_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIME_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP_MAXWIDTH</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIME_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP_SCALE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BIT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>VARBIT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBIT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>INTEGER_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BIGINT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>FLOAT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NUMERIC_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>VARCHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARCHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DATE_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TIME_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BINARY_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>VARBINARY_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBINARY_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>REF_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>REF_CURSOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NATIONAL_CHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NATIONAL_VARCHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NATIONAL_LONGVARCHAR_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>BLOB_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CLOB_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>NCLOB_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>XML_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ARRAY_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>STRUCT_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>DATALINK_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ROWID_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>SQLXML_NAME</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>USER_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>XML_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BLOB_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBIT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VARBIT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BIT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIME_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DATE_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>NUMERIC_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGINT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REF_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CLOB_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARCHAR_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>VARCHAR_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHAR_PRECEDENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BOOLEAN_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>SMALLINT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>INTEGER_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>CHAR_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>TINYINT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>BIGINT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>REAL_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>DOUBLE_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>DECIMAL_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>NUMERIC_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>VARCHAR_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>DATE_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>TIME_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>TIMESTAMP_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>BIT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>VARBIT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>REF_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARCHAR_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>LONGVARBIT_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>BLOB_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>CLOB_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>XML_ID</FieldName>
            <FieldType>TypeId</FieldType>
        </Field>
        <Field>
            <FieldName>ALL_BUILTIN_TYPE_IDS</FieldName>
            <FieldType>TypeId[]</FieldType>
        </Field>
        <Field>
            <FieldName>baseTypeId</FieldName>
            <FieldType>BaseTypeIdImpl</FieldType>
        </Field>
        <Field>
            <FieldName>formatId</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isBitTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isLOBTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isBooleanTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isConcatableTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isDecimalTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isLongConcatableTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isNumericTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isRefTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isStringTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isFloatingPointTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isRealTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isDateTimeTimeStampTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isUserDefinedTypeId</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>maxPrecision</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>maxScale</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>typePrecedence</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>javaTypeName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>maxMaxWidth</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>create</MethodName>
            <MethodComment>/** 
 * Create a TypeId for the given format identifiers using a BaseTypeIdImpl. Used to create the static final variables of this class.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeFormatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>implTypeFormatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllBuiltinTypeIds</MethodName>
            <MethodComment>/** 
 * Return all of the builtin type ids.
 */
</MethodComment>
            <ReturnType>TypeId[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [count=ALL_BUILTIN_TYPE_IDS.length]</InnerVar>
                <InnerVar>TypeId[] [retval=new TypeId[count]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInTypeId</MethodName>
            <MethodComment>/** 
 * Get a TypeId of the given JDBC type.  This factory method is intended to be used for built-in types.  For user-defined types, we will need a factory method that takes a Java type name.
 * @param JDBCTypeId    The JDBC Id of the type, as listed injava.sql.Types
 * @return      The appropriate TypeId, or null if there is no suchTypeId.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>JDBCTypeId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserDefinedTypeId</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getUserDefinedTypeId</MethodName>
            <MethodComment>/** 
 * This factory  method is used for ANSI UDTs. If the className argument is null, then this TypeId will have to be bound.
 * @param schemaName Schema that the type definition lives in.
 * @param unqualifiedName The second part of the ANSI dot-separated name for the type.
 * @param className The Java class which is bound to the schema-qualified name by the CREATE TYPE statement.
 * @return A bound type TypeId describing this ANSI UDT.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unqualifiedName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLTypeForJavaType</MethodName>
            <MethodComment>/** 
 * Get a TypeId for the class that corresponds to the given Java type name.
 * @param javaTypeName The name of the Java type
 * @return A TypeId for the SQL type that corresponds to the Java type,null if there is no corresponding type.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBuiltInTypeId</MethodName>
            <MethodComment>/** 
 * Given a SQL type name return the corresponding TypeId.
 * @param SQLTypeName Name of SQL type
 * @return TypeId or null if there is no corresponding SQL type.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>SQLTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeId</MethodName>
            <MethodComment>/** 
 * Get the TypeId (fundemental type information) for a catalog type.
 * @param catalogType
 * @return TypeId that represents the base type, null if not applicable.
 */
</MethodComment>
            <ReturnType>TypeId</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>catalogType</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDescriptorImpl [tdi=(TypeDescriptorImpl)catalogType]</InnerVar>
                <InnerVar>int [jdbcType=catalogType.getJDBCTypeId()]</InnerVar>
                <InnerVar>TypeId [typeId=TypeId.getBuiltInTypeId(jdbcType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>TypeId</MethodName>
            <MethodComment>/** 
 * Constructor for a TypeId
 * @param formatId      Format id of specific type id.
 * @param baseTypeId    The Base type id
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>formatId</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTypeId</ParamName>
                    <ParamType>BaseTypeIdImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setTypeIdSpecificInstanceVariables;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment>/** 
 * we want equals to say if these are the same type id or not.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>that</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hashCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTypeIdSpecificInstanceVariables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getJDBCTypeId</MethodName>
            <MethodComment>/** 
 * JDBC has its own idea of type identifiers which is different from the Derby internal type ids.  The JDBC type ids are defined as public final static ints in java.sql.Types.  This method translates a Derby internal TypeId to a JDBC type id. For java objects this returns JAVA_OBJECT in Java2 and OTHER in JDK 1.1. For Boolean datatypes, this returns Type.BOOLEAN in JDK1.4 and Type.BIT for jdks prior to 1.4
 * @return      The JDBC type Id for this type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSQLTypeName</MethodName>
            <MethodComment>/** 
 * Returns the SQL name of the datatype. If it is a user-defined type, it returns the full Java path name for the datatype, meaning the dot-separated path including the package names.
 * @return      A String containing the SQL name of this type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>userType</MethodName>
            <MethodComment>/** 
 * Tell whether this is a built-in type. NOTE: There are 3 "classes" of types: built-in                - system provided types which are implemented internally (int, smallint, etc.) system built-in - system provided types, independent of implementation (date, time, etc.) user types              - types implemented outside of the system (java.lang.Integer, asdf.asdf.asdf, etc.)
 * @return      true for built-in types, false for user-defined types.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumPrecision</MethodName>
            <MethodComment>/** 
 * Get the maximum precision of the type.  For types with variable precision, this is an arbitrary high precision.
 * @return      The maximum precision of the type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumScale</MethodName>
            <MethodComment>/** 
 * Get the maximum scale of the type.  For types with variable scale, this is an arbitrary high scale.
 * @return      The maximum scale of the type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUserTypeIdInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>UserDefinedTypeIdImpl [baseUserTypeId=(UserDefinedTypeIdImpl)baseTypeId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStringTypeId</MethodName>
            <MethodComment>/** 
 * Does this TypeId represent a TypeId for a StringDataType.
 * @return Whether or not this TypeId represents a TypeId for a StringDataType.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDateTimeTimeStampTypeId</MethodName>
            <MethodComment>/** 
 * Is this a TypeId for DATE/TIME/TIMESTAMP
 * @return true if this is a DATE/TIME/TIMESTAMP
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRealTypeId</MethodName>
            <MethodComment>/** 
 * Is this a TypeId for REAL
 * @return true if this is a REAL
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isFloatingPointTypeId</MethodName>
            <MethodComment>/** 
 * Is this a TypeId for floating point (REAL/DOUBLE)
 * @return true if this is a REAL or DOUBLE
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDoubleTypeId</MethodName>
            <MethodComment>/** 
 * Is this a TypeId for DOUBLE
 * @return true if this is a DOUBLE
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isFixedStringTypeId</MethodName>
            <MethodComment>/** 
 * Is this a fixed string type?
 * @return true if this is CHAR
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClobTypeId</MethodName>
            <MethodComment>/** 
 * Is this a Clob?
 * @return true if this is CLOB
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBlobTypeId</MethodName>
            <MethodComment>/** 
 * Is this a Blob?
 * @return true if this is BLOB
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLongVarcharTypeId</MethodName>
            <MethodComment>/** 
 * Is this a LongVarchar?
 * @return true if this is LongVarchar
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLongVarbinaryTypeId</MethodName>
            <MethodComment>/** 
 * Is this a LongVarbinary?
 * @return true if this is LongVarbinary
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDateTimeTimeStampTypeID</MethodName>
            <MethodComment>/** 
 * Is this DATE/TIME or TIMESTAMP?
 * @return true if this DATE/TIME or TIMESTAMP
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTimestampId</MethodName>
            <MethodComment>/** 
 * Is this a TIMESTAMP?
 * @return true if this is a TIMESTAMP
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isXMLTypeId</MethodName>
            <MethodComment>/** 
 * Is this an XML doc?
 * @return true if this is XML
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>orderable</MethodName>
            <MethodComment>/** 
 * Tell whether this type is orderable, that is, can participate in comparisons.
 * @param cf    A ClassFactory
 * @return      true for orderable types, false for non-orderable types.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [orderable]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typePrecedence</MethodName>
            <MethodComment>/** 
 * Each built-in type in JSQL has a precedence.  This precedence determines how to do type promotion when using binary operators.  For example, float has a higher precedence than int, so when adding an int to a float, the result type is float. The precedence for some types is arbitrary.  For example, it doesn't matter what the precedence of the boolean type is, since it can't be mixed with other types.  But the precedence for the number types is critical.  The SQL standard requires that exact numeric types be promoted to approximate numeric when one operator uses both.  Also, the precedence is arranged so that one will not lose precision when promoting a type. NOTE: char, varchar, and longvarchar must appear at the bottom of the hierarchy, but above USER_PRECEDENCE, since we allow the implicit conversion of those types to any other built-in system type.
 * @return              The precedence of this type.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCorrespondingJavaTypeName</MethodName>
            <MethodComment>/** 
 * Get the name of the corresponding Java type. Each SQL type has a corresponding Java type.  When a SQL value is passed to a Java method, it is translated to its corresponding Java type.  For example, when a SQL date column is passed to a method, it is translated to a java.sql.Date.
 * @return      The name of the corresponding Java type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetMetaDataTypeName</MethodName>
            <MethodComment>/** 
 * Get the name of the corresponding Java type. This method is used directly from EmbedResultSetMetaData (jdbc) to return the corresponding type (as choosen by getObject). It solves a specific problem for BLOB types where the  getCorrespondingJavaTypeName() is used internall for casting which doesn't work if changed from byte[] to java.sql.Blob. So we do it here instread, to avoid unexpected sideeffects.
 * @return      The name of the corresponding Java type.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMaximumMaximumWidth</MethodName>
            <MethodComment>/** 
 * Get the maximum maximum width of the type (that's not a typo).  For types with variable length, this is the absolute maximum for the type.
 * @return      The maximum maximum width of the type
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toParsableString</MethodName>
            <MethodComment>/** 
 * Converts this TypeId, given a data type descriptor (including length/precision), to a string. E.g. VARCHAR(30) For most data types, we just return the SQL type name.
 * @param dts     Data type descriptor that holds the length/precision etc. as necessary
 * @return        String version of datatype, suitable for running throughthe Parser.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dts</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNumericTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a numeric type?
 * @return Whether or not this a type id for a numeric type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDecimalTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a decimal type?
 * @return Whether or not this a type id for a decimal type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBooleanTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a boolean type?
 * @return Whether or not this a type id for a boolean type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isRefTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a ref type?
 * @return Whether or not this a type id for a ref type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConcatableTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a concatable type?
 * @return Whether or not this a type id for a concatable type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isBitTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a bit type?
 * @return Whether or not this a type id for a bit type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLOBTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a LOB type?
 * @return Whether or not this a type id for a LOB type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLongConcatableTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a long concatable type?
 * @return Whether or not this a type id for a long concatable type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUserDefinedTypeId</MethodName>
            <MethodComment>/** 
 * Is this a type id for a user defined type?
 * @return Whether or not this a type id for a user defined type.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTypeFormatId</MethodName>
            <MethodComment>/** 
 * Get the formatID which corresponds to this class.
 * @return the formatID of this class
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNull</MethodName>
            <MethodComment>/** 
 * Get SQL null value.
 * @return SQL null value for this type.
 */
</MethodComment>
            <ReturnType>DataValueDescriptor</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>streamStorable</MethodName>
            <MethodComment>/** 
 * Is this type StreamStorable?
 * @return      true if this type has variable length.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getApproximateLengthInBytes</MethodName>
            <MethodComment>/** 
 * Get the approximate length of this type in bytes. For most datatypes this is just going to be dts.getMaximumWidth().  Some types, such as bit, will override this.
 * @param dts Data type descriptor that holds the length/precision etc. as necessary
 * @return the length in bytes
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dts</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBaseTypeId</MethodName>
            <MethodComment>/** 
 * Get the base type id that is embedded in this type id.  The base type id is an object with a minimal implementation of TypeId that is intended to be usable on the client side.
 */
</MethodComment>
            <ReturnType>BaseTypeIdImpl</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrecision</MethodName>
            <MethodComment>/** 
 * Get the precision of the merge of two Decimals
 * @param leftType the left type
 * @param rightType the left type
 * @return      the resultant precision
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [lscale=(long)leftType.getScale()]</InnerVar>
                <InnerVar>long [rscale=(long)rightType.getScale()]</InnerVar>
                <InnerVar>long [lprec=(long)leftType.getPrecision()]</InnerVar>
                <InnerVar>long [rprec=(long)rightType.getPrecision()]</InnerVar>
                <InnerVar>long [val]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScale</MethodName>
            <MethodComment>/** 
 * Get the scale of the merge of two decimals
 * @param leftType the left type
 * @param rightType the left type
 * @return      the resultant precision
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightType</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>variableLength</MethodName>
            <MethodComment>/** 
 * Does type hava a declared variable length (defined by the application). Examples are CHAR(10), CLOB(1M). Unbounded long types, like LONG VARCHAR return false here.
 * @return boolean true if type is variable length false if not.  
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>