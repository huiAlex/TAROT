<Class>
    <Id>2052</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ActivationClassBuilder</ClassName>
    <SuperClass>ExpressionClassBuilder</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ActivationClassBuilder  /** 
 * ActivationClassBuilder provides an interface to satisfy generation's common tasks in building an activation class, as well as a repository for the JavaFactory used to generate the basic language constructs for the methods in the class. Common tasks include the setting of a static field for each expression function that gets added, the creation of the execute method that gets expanded as the query tree is walked, setting the superclass. &lt;p&gt; An activation class is defined for each statement. It has the following basic layout: TBD See the document \\Jeeves\Unversioned Repository 1\Internal Technical Documents\Other\GenAndExec.doc for details. &lt;p&gt; We could also verify methods as they are added, to have 0 parameters, ...
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>targetResultSetField</FieldName>
            <FieldType>LocalField</FieldType>
        </Field>
        <Field>
            <FieldName>cursorResultSetField</FieldName>
            <FieldType>LocalField</FieldType>
        </Field>
        <Field>
            <FieldName>closeActivationMethod</FieldName>
            <FieldType>MethodBuilder</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ActivationClassBuilder</MethodName>
            <MethodComment>/** 
 * By the time this is done, it has constructed the following class: &lt;pre&gt; final public class #className extends #superClass { // public void reset() { return; } protected ResultSet doExecute() throws StandardException { // statements must be added here } public #className() { super(); } } &lt;/pre&gt;
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>superClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cc</ParamName>
                    <ParamType>CompilerContext</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPackageName</MethodName>
            <MethodComment>/** 
 * Get the package name that this generated class lives in
 * @return	package name
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getBaseClassName</MethodName>
            <MethodComment>/** 
 * The base class for activations is BaseActivation
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowCount</MethodName>
            <MethodComment>/** 
 * Get the number of ExecRows to allocate
 * @exception StandardException thrown on failure
 * @return	package name
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setNumSubqueries</MethodName>
            <MethodComment>/** 
 * Generate the assignment for numSubqueries = x
 * @exception StandardException thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [numSubqueries=myCompCtx.getNumSubquerys()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>constructor;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>constructor;push;[numSubqueries]</InnerMethodInvoke>
                <InnerMethodInvoke>constructor;putField;[ClassName.BaseActivation, "numSubqueries", "int"]</InnerMethodInvoke>
                <InnerMethodInvoke>constructor;endStatement;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startResetMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodBuilder</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MethodBuilder [mb=cb.newMethodBuilder(Modifier.PUBLIC,"void","reset")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;addThrownException;[ClassName.StandardException]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;pushThis;[]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKESPECIAL, ClassName.BaseActivation, "reset", "void", 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finishExecuteMethod</MethodName>
            <MethodComment>/** 
 * An execute method always ends in a return statement, returning the result set that has been constructed.  We want to do some bookkeeping on that statement, so we generate the return given the result set. Upon entry the only word on the stack is the result set expression
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addCursorPositionCode</MethodName>
            <MethodComment>/** 
 * Updatable cursors need to add a getter method for use in BaseActivation to access the result set that identifies target rows for a positioned update or delete. &lt;p&gt; The code that is generated is: &lt;pre&gt;&lt;verbatim&gt; public CursorResultSet getTargetResultSet() { return targetResultSet; } public CursorResultSet getCursorResultSet() { return cursorResultSet; } &lt;/verbatim&gt;&lt;/pre&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MethodBuilder [getter=cb.newMethodBuilder(Modifier.PUBLIC,ClassName.CursorResultSet,"getTargetResultSet")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>getter;getField;[targetResultSetField]</InnerMethodInvoke>
                <InnerMethodInvoke>getter;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getter;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getter;getField;[cursorResultSetField]</InnerMethodInvoke>
                <InnerMethodInvoke>getter;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>getter;complete;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rememberCursorTarget</MethodName>
            <MethodComment>/** 
 * Updatable cursors need to add a field and its initialization for use in BaseActivation to access the result set that identifies target rows for a positioned update or delete. &lt;p&gt; The code that is generated is: &lt;pre&gt;&lt;verbatim&gt; private CursorResultSet targetResultSet; &lt;/verbatim&gt;&lt;/pre&gt; The expression that is generated is: &lt;pre&gt;&lt;verbatim&gt; (ResultSet) (targetResultSet = (CursorResultSet) #expression#) &lt;/verbatim&gt;&lt;/pre&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;cast;[ClassName.CursorResultSet]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;putField;[targetResultSetField]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;cast;[ClassName.NoPutResultSet]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rememberCursor</MethodName>
            <MethodComment>/** 
 * Updatable cursors need to add a field and its initialization for use in BaseActivation to access the result set that identifies cursor result rows for a positioned update or delete. &lt;p&gt; The code that is generated is: &lt;pre&gt;&lt;verbatim&gt; private CursorResultSet cursorResultSet; &lt;/verbatim&gt;&lt;/pre&gt; The expression that is generated is: &lt;pre&gt;&lt;verbatim&gt; (ResultSet) (cursorResultSet = (CursorResultSet) #expression#) &lt;/verbatim&gt;&lt;/pre&gt; The expression must be the top stack word when this method is called.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;cast;[ClassName.CursorResultSet]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;putField;[cursorResultSetField]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;cast;[ClassName.ResultSet]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentSetup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LocalField</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LocalField [lf=super.getCurrentSetup()]</InnerVar>
                <InnerVar>MethodBuilder [execute=getExecuteMethod()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>execute;getField;[lf]</InnerMethodInvoke>
                <InnerMethodInvoke>execute;callMethod;[VMOpcode.INVOKEVIRTUAL, (String)null, "forget", "void", 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCloseActivationMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodBuilder</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>