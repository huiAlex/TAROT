<Class>
    <Id>1368</Id>
    <Package>org.apache.derbyTesting.functionTests.tests.upgradeTests</Package>
    <ClassName>BasicSetup</ClassName>
    <SuperClass>UpgradeChange</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BasicSetup  /** 
 * Basic fixtures and setup for the upgrade test, not tied to any specific release.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>TEST_COUNT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FAILURES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>A_COL</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>B_COL</FieldName>
            <FieldType>String</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>suite</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Test</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>BaseTestSuite [suite=new BaseTestSuite("Upgrade basic setup")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>suite;addTest;[new BaseTestSuite(BasicSetup.class)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>BasicSetup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testTriggerBasic</MethodName>
            <MethodComment>/** 
 * Simple test of the triggers. Added for DERBY-4835
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testOldVersion</MethodName>
            <MethodComment>/** 
 * Simple test of the old version from the meta data.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDML</MethodName>
            <MethodComment>/** 
 * Test general DML. Just execute some INSERT/UPDATE/DELETE statements in all phases to see that generally the database works.
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [phase=getPhase()]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>PreparedStatement [ps=prepareStatement("INSERT INTO PHASE(id) VALUES (?)")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;setInt;[1, phase]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;executeUpdate;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testCreateTable</MethodName>
            <MethodComment>/** 
 * Make sure table created in soft upgrade mode can be  accessed after shutdown.  DERBY-2931
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [stmt=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs=stmt.executeQuery("SELECT * from t")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;executeUpdate;["CREATE TABLE T (I INT)"]</InnerMethodInvoke>
                <InnerMethodInvoke>TestConfiguration.getCurrent();shutdownDatabase;[]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertEmpty;[rs]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testIndex</MethodName>
            <MethodComment>/** 
 * Test table with index can be read after shutdown DERBY-2931
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [stmt=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs=stmt.executeQuery("SELECT * from TI ORDER BY I")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmt;executeUpdate;["CREATE TABLE TI (I INT primary key not null)"]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;executeUpdate;["INSERT INTO  TI values(1)"]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;executeUpdate;["INSERT INTO  TI values(2)"]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;executeUpdate;["INSERT INTO  TI values(3)"]</InnerMethodInvoke>
                <InnerMethodInvoke>TestConfiguration.getCurrent();shutdownDatabase;[]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[rs, new String[][]{{"1"},{"2"},{"3"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>noConnectionAfterHardUpgrade</MethodName>
            <MethodComment>/** 
 * Ensure that after hard upgrade (with the old version) we can no longer connect to the database.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropAllTriggerPlans</MethodName>
            <MethodComment>/** 
 * Test case that drops all trigger plans. Should be run at the end of soft upgrade if the old version suffers from DERBY-4835 or DERBY-5289. Otherwise, the database may fail to boot again with the old version.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;execute;["create procedure clear_sps_plans() language java " + "parameter style java external name '" + getClass().getName() + ".clearSPSPlans'"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["call clear_sps_plans()"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["drop procedure clear_sps_plans"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearSPSPlans</MethodName>
            <MethodComment>/** 
 * Stored procedure that clears all SPS plans in the database. It does the same as SYSCS_UTIL.SYSCS_INVALIDATE_STORED_STATEMENTS, but we need to create our own procedure since the built-in procedure might not be available in soft upgrade.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SystemProcedures;SYSCS_INVALIDATE_STORED_STATEMENTS;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDropTableAfterUpgradeWithConstraint</MethodName>
            <MethodComment>/** 
 * DERBY-5249 table created with primary and foreign key can't be dropped Test currently disabled. Remove the x from the name to enable the  test once the bug is fixed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [phase=getPhase()]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5121TriggerTest2</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
                <InnerVar>String [updateSQL="update media " + "set name = 'Mon Liza', description = 'Something snarky.' " + "where mediaID = 1"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preapreFortDERBY5120</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropTable;["ATDC_TAB1"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropTable;["ATDC_BKUP1"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table ATDC_TAB1(c11 int, c12 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["insert into ATDC_TAB1 values (1,11)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table ATDC_BKUP1(c111 int, c112 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create trigger ATDC_TAB1_TRG1 after update " + "of C11 on ATDC_TAB1 REFERENCING old_table as old " + "for each statement " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "insert into ATDC_BKUP1 select * from old"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create trigger ATDC_TAB1_TRG2 after update " + "on ATDC_TAB1 for each row " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "values(1,2)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5120NumRowsInSydependsForTrigger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>int [sysdependsRowCountBeforeCreateTrigger]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numberOfRowsInSysdepends</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>st</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs=st.executeQuery("SELECT COUNT(*) FROM SYS.SYSDEPENDS")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;next;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5044_And_DERBY5120_DropColumn</MethodName>
            <MethodComment>/** 
 * Following test is for checking the upgrade scenario for DERBY-5044 and DERBY-5120.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumn_triggersql_DERBY5044_And_DERBY5120</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preapreForDERBY5044_And_DERBY5120</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropTable;["TAB1_5044_5120"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropTable;["BKUP1_5044_5120"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table TAB1_5044_5120(c11 int, c12 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["insert into TAB1_5044_5120 values (1,11)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table BKUP1_5044_5120(c111 int, c112 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create trigger TAB1_TRG1 after update " + "of C11 on TAB1_5044_5120 REFERENCING old_table as old " + "for each statement " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "insert into BKUP1_5044_5120 select * from old"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create trigger TAB1_TRG2 after update " + "on TAB1_5044_5120 for each row " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "values(1,2)"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>triggersql_for_DERBY5044_And_DERBY5120</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>Statement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultSet [rs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[rs, new String[][]{{"1","11"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertEmpty;[rs]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;["update TAB1_5044_5120 set c11=99"]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[rs, new String[][]{{"99","11"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[rs, new String[][]{{"1","11"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;["delete from BKUP1_5044_5120"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5044AlterTableDropColumn</MethodName>
            <MethodComment>/** 
 * DERBY-5044(ALTER TABLE DROP COLUMN will not detect triggers defined  on other tables with their trigger action using the column being  dropped) ALTER TABLE DROP COLUMN should detect triggers defined on other table but using the table being altered in their trigger action. If the  column getting dropped is used in such a trigger, then ALTER TABLE DROP COLUMN .. RESTRICT should fail and ALTER TABLE DROP COLUMN .. CASCADE should drop such triggers.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preapreFortDERBY5044</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;dropTable;["ATDC_13_TAB1"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropTable;["ATDC_13_TAB1_BACKUP"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;dropTable;["ATDC_13_TAB2"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table ATDC_13_TAB1(c11 int, c12 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["insert into ATDC_13_TAB1 values (1,11)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table ATDC_13_TAB1_BACKUP(c11 int, c12 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["insert into ATDC_13_TAB1_BACKUP values (1,11)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["create table ATDC_13_TAB2(c21 int, c22 int)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["insert into ATDC_13_TAB2 values (1,11)"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;[" create trigger ATDC_13_TAB1_trg1 after update " + "on ATDC_13_TAB1 for each row " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "DELETE FROM ATDC_13_TAB1_BACKUP "+ "WHERE C12&gt;=1"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;[" create trigger ATDC_13_TAB1_trg2 after update " + "on ATDC_13_TAB1 for each row " + (modeDb2SqlOptional ? "" : "MODE DB2SQL ") + "DELETE FROM ATDC_13_TAB2 WHERE "+ "C22 IN (values(11))"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5121TriggerDataCorruption</MethodName>
            <MethodComment>/** 
 * Changes made for DERBY-1482 caused corruption which is being logged  under DERBY-5121. The issue is that the generated trigger action sql could be looking for columns (by positions, not names) in incorrect positions. With DERBY-1482, trigger assumed that the runtime resultset that they will get will only have trigger columns and trigger action columns used through the REFERENCING column. That is an incorrect assumption because the resultset could have more columns if the triggering sql requires more columns. DERBY-1482 changes are in 10.7 and higher codelines. Because of this bug, the changes for DERBY-1482 have been backed out from 10.7 and 10.8 codelines so they now match 10.6 and earlier releases. This in  other words means that the resultset presented to the trigger will have all the columns from the trigger table and the trigger action generated sql should look for the columns in the trigger table by their absolution column position in the trigger table. This disabling of code will make sure that all the future triggers get created correctly. The existing triggers at the time of  upgrade (to the releases with DERBY-1482 backout changes in them) will get marked invalid and when they fire next time around, the regenerated sql for them will be generated again and they will start behaving correctly. So, it is highly recommended that we upgrade 10.7.1.1 to next point release of 10.7 or to 10.8
 * @throws Exception
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>atestTriggersWithLOBcolumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs]</InnerVar>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
                <InnerVar>int [lobsize=50000 * 1024]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testExhuastivePermutationOfTriggerColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [STATUS_COUNTERS=FAILURES + 1]</InnerVar>
                <InnerVar>int [columnCount=3]</InnerVar>
                <InnerVar>int[][] [powerSet=constructPowerSet(columnCount)]</InnerVar>
                <InnerVar>int[][] [permutations=permute(powerSet)]</InnerVar>
                <InnerVar>int[] [statusCounters=new int[STATUS_COUNTERS]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;summarize;[statusCounters]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constructPowerSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[][]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;int[]&gt; [list=new ArrayList&lt;int[]&gt;()]</InnerVar>
                <InnerVar>boolean[] [inclusions=new boolean[count]]</InnerVar>
                <InnerVar>int[][] [result=new int[list.size()][]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;include;[list, 0, inclusions]</InnerMethodInvoke>
                <InnerMethodInvoke>list;toArray;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>include</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>idx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inclusions</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;include;[list, idx, inclusions, false]</InnerMethodInvoke>
                <InnerMethodInvoke>null;include;[list, idx, inclusions, true]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>include</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>idx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inclusions</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>currentCell</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;include;[list, idx, inclusions]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>permute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[][]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>original</ParamName>
                    <ParamType>int[][]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;int[]&gt; [list=new ArrayList&lt;int[]&gt;()]</InnerVar>
                <InnerVar>int[][] [result=new int[list.size()][]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>list;toArray;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>permute</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>remainder</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [startLength=start.length]</InnerVar>
                <InnerVar>int [remainderLength=remainder.length]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>idx</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createT1</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["create table " + makeTableName("t1",triggerCols,permutation) + "( "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[" )"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;[buffer.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createT2</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["create table " + makeTableName("t2",triggerCols,permutation) + "( "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[" )"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;[buffer.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeTableName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;[stub]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["__"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createTrigger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [modeDb2SqlOptional=oldAtLeast(10,3)]</InnerVar>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["create trigger " + makeTriggerName("UTrg",triggerCols,permutation) + " after update of "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["\n\ton " + makeTableName("t2",triggerCols,permutation) + " referencing new as nr for each row "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[modeDb2SqlOptional ? "" : "\n\tMODE DB2SQL "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["\n\tinsert into " + makeTableName("t1",triggerCols,permutation) + " values ( "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[" )"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;[buffer.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeTriggerName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stub</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;[stub]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["__"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResults</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowLength</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=prepareStatement(text)]</InnerVar>
                <InnerVar>ResultSet [rs=ps.executeQuery()]</InnerVar>
                <InnerVar>int[] [result=new int[rowLength]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>overlap</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>vetData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statusCounters</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateStatement</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [t1Name=makeTableName("t1",triggerCols,permutation)]</InnerVar>
                <InnerVar>String [t2Name=makeTableName("t2",triggerCols,permutation)]</InnerVar>
                <InnerVar>int [rowLength=permutation.length]</InnerVar>
                <InnerVar>int[] [t1Row=getResults(rowLength,"select * from " + t1Name)]</InnerVar>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
                <InnerVar>int[] [t2Row=getResults(rowLength,buffer.toString())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["select "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[" from " + t2Name]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>runTrigger</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statusCounters</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [updateStatement=updateData(statusCounters,triggerCols,permutation,updateColumns)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;loadData;[columnCount, triggerCols, permutation]</InnerMethodInvoke>
                <InnerMethodInvoke>null;vetData;[statusCounters, triggerCols, permutation, updateColumns, updateStatement]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnCount</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [t1Name=makeTableName("t1",triggerCols,permutation)]</InnerVar>
                <InnerVar>String [t2Name=makeTableName("t2",triggerCols,permutation)]</InnerVar>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>s;execute;["delete from " + t1Name]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;["delete from " + t2Name]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["insert into " + t2Name + " values ( "]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;[" )"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;execute;[buffer.toString()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateData</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statusCounters</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [t2Name=makeTableName("t2",triggerCols,permutation)]</InnerVar>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
                <InnerVar>String [updateStatement=buffer.toString()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["update " + t2Name + " set "]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>Exception</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fail</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statusCounters</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permutation</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateColumns</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>detail</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [message="FAILED for triggerCols = " + stringify(triggerCols) + " and permutation = "+ stringify(permutation)+ " and updateColumns = "+ stringify(updateColumns)+ ". "+ detail]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System.out;println;[message]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>summarize</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statusCounters</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [testCount=statusCounters[TEST_COUNT]]</InnerVar>
                <InnerVar>int [failures=statusCounters[FAILURES]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringify</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>int[][]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["["]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["\n]\n"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringify</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>array</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuffer [buffer=new StringBuffer()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>buffer;append;["["]</InnerMethodInvoke>
                <InnerMethodInvoke>buffer;append;["]"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>xmlTestTriggerWithXMLOperators</MethodName>
            <MethodComment>/** 
 * Test that triggers that use XML operators work after upgrade. The first fix for DERBY-3870 broke upgrade of such triggers because the old execution plans failed to deserialize on the new version.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
                <InnerVar>ResultSet [rs=s.executeQuery("select 1 from sys.systriggers where triggername = 'D3870_TR'")]</InnerVar>
                <InnerVar>boolean [hasTrigger=rs.next()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY5289TriggerUpgradeFormat</MethodName>
            <MethodComment>/** 
 * DERBY-5289 Upgrade could fail during upgrade with triggers due to  failure reading serializable or SQLData object
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assertDERBY5289ResultsAndDelete</MethodName>
            <MethodComment>/** 
 * Private helper method for fixture testDERBY5289TriggerUpgradeFormat to check and cleanup date in each phase.
 * @throws SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>Statement [s=createStatement()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[s.executeQuery("SELECT * FROM D5289TABLE1"), new String[][]{{"bbb"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[s.executeQuery("SELECT * FROM D5289TABLE2"), new String[][]{{"bbb"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>JDBC;assertFullResultSet;[s.executeQuery("SELECT * FROM D5289TABLE3"), new String[][]{{"ccc"}}]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;["DELETE FROM D5289TABLE1"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;["DELETE FROM D5289TABLE2"]</InnerMethodInvoke>
                <InnerMethodInvoke>s;executeUpdate;["DELETE FROM D5289TABLE3"]</InnerMethodInvoke>
                <InnerMethodInvoke>null;commit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY6314</MethodName>
            <MethodComment>/** 
 * Regression test case for DERBY-6314, which caused upgrade to fail if a metadata query had been executed with the old version of the database.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>JDBC;assertDrainResults;[getConnection().getMetaData().getSchemas()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>testDERBY4753</MethodName>
            <MethodComment>/** 
 * Verify that recompilation of a stale meta-data query works in soft upgrade. Before DERBY-4753, it used to fail with a syntax error because the recompilation didn't accept internal syntax.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>DataSource [ds=JDBCDataSource.getDataSourceLogical("DERBY-4753")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>