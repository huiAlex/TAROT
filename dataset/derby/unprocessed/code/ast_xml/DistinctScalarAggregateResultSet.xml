<Class>
    <Id>1340</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>DistinctScalarAggregateResultSet</ClassName>
    <SuperClass>ScalarAggregateResultSet</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DistinctScalarAggregateResultSet  /** 
 * This ResultSet evaluates scalar aggregates where 1 (or more, in the future) of the aggregates are distinct. It will scan the entire source result set and calculate the scalar aggregates when scanning the source during the  first call to next().
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>order</FieldName>
            <FieldType>ColumnOrdering[]</FieldType>
        </Field>
        <Field>
            <FieldName>maxRowSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>dropDistinctAggSort</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>sortId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>scanController</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
        <Field>
            <FieldName>sortResultRow</FieldName>
            <FieldType>ExecIndexRow</FieldType>
        </Field>
        <Field>
            <FieldName>sorted</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DistinctScalarAggregateResultSet</MethodName>
            <MethodComment>/** 
 * Constructor
 * @param s			input result set
 * @param isInSortedOrder	true if the source results are in sorted order
 * @param aggregateItem	indicates the number of theSavedObject off of the PreparedStatement that holds the AggregatorInfoList used by this routine. 
 * @param a				activation
 * @param ra				saved object that builds an empty output row
 * @param resultSetNumber	The resultSetNumber for this result set
 * @exception StandardException Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>NoPutResultSet</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isInSortedOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>aggregateItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>orderingItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>a</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ra</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>maxRowSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singleInputRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;recordConstructorTime;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openCore</MethodName>
            <MethodComment>/** 
 * Open the scan.  Load the sorter and prepare to get rows from it.
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;openCore;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowCore</MethodName>
            <MethodComment>/** 
 * Return the next row.  If it is a scalar aggregate scan
 * @exception StandardException thrown on failure.
 * @exception StandardException ResultSetNotOpen thrown if not yet open.
 * @return the next row in the result
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ExecIndexRow [execIndexRow=null]</InnerVar>
                <InnerVar>ExecIndexRow [aggResult=null]</InnerVar>
                <InnerVar>boolean [cloneArg=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenCore</MethodName>
            <MethodComment>/** 
 * reopen a scan on the table. scan parameters are evaluated at each open, so there is probably some way of altering their values...
 * @exception StandardException thrown if cursor finished.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;reopenCore;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * If the result set has been opened, close the open scan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;closeSource;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowFromResultSet</MethodName>
            <MethodComment>/** 
 * Get a row from the sorter.  Side effects: sets currentRow.
 * @exception StandardException Thrown on error
 */
</MethodComment>
            <ReturnType>ExecIndexRow</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>doClone</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ExecIndexRow [inputRow=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeSource</MethodName>
            <MethodComment>/** 
 * Close the source of whatever we have been scanning.
 * @exception StandardException thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>source;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>loadSorter</MethodName>
            <MethodComment>/** 
 * Load up the sorter.  Feed it every row from the source scan.  If we have a vector aggregate, initialize the aggregator for each source row.  When done, close the source scan and open the sort.  Return the sort scan controller.
 * @exception StandardException thrown on failure.
 * @return	the sort controller
 */
</MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>SortController [sorter]</InnerVar>
                <InnerVar>ExecRow [sourceRow]</InnerVar>
                <InnerVar>ExecIndexRow [sortTemplateRow=getRowTemplate()]</InnerVar>
                <InnerVar>int [inputRowCountEstimate=(int)optimizerEstimatedRowCount]</InnerVar>
                <InnerVar>TransactionController [tc=getTransactionController()]</InnerVar>
                <InnerVar>GenericAggregator[] [aggsNoDistinct=getSortAggregators(aggInfoList,true,activation.getLanguageConnectionContext(),source)]</InnerVar>
                <InnerVar>SortObserver [sortObserver=new AggregateSortObserver(true,aggsNoDistinct,aggregates,sortTemplateRow)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sorter;completedInserts;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>