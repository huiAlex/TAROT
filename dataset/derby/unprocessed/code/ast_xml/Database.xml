<Class>
    <Id>818</Id>
    <Package>org.apache.derby.impl.drda</Package>
    <ClassName>Database</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>Database  /** 
 * Database stores information about the current database It is used so that a session may have more than one database
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>dbName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>shortDbName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>attrString</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>securityMechanism</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>userId</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>password</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>decryptedUserId</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>decryptedPassword</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>passwordSubstitute</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>rdbAllowUpdates</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>accessCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>secTokenIn</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>secTokenOut</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>crrtkn</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>typDefNam</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>byteOrder</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidSBC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidDBC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidMBC</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidSBCEncoding</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidDBCEncoding</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>ccsidMBCEncoding</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>RDBUPDRM_sent</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>sendTRGDFTRT</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>conn</FieldName>
            <FieldType>EngineConnection</FieldType>
        </Field>
        <Field>
            <FieldName>defaultStatement</FieldName>
            <FieldType>DRDAStatement</FieldType>
        </Field>
        <Field>
            <FieldName>currentStatement</FieldName>
            <FieldType>DRDAStatement</FieldType>
        </Field>
        <Field>
            <FieldName>stmtTable</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>stmtTable</FieldName>
            <FieldType>Object</FieldType>
        </Field>
        <Field>
            <FieldName>locatorSupport</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>locatorSupportChecked</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>pbsd_</FieldName>
            <FieldType>PiggyBackedSessionData</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>Database</MethodName>
            <MethodComment>/** 
 * Database constructor
 * @param dbName    database name
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setDatabaseName;[dbName]</InnerMethodInvoke>
                <InnerMethodInvoke>null;initializeDefaultStatement;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDatabaseName</MethodName>
            <MethodComment>/** 
 * Take database name including attributes and set attrString and shortDbName accordingly.
 * @param dbName database name, including attributes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDatabaseName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getShortDbName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initializeDefaultStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setConnection</MethodName>
            <MethodComment>/** 
 * Set connection and create the SQL statement for the default statement
 * @param conn Connection
 * @exception SQLException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conn</ParamName>
                    <ParamType>EngineConnection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConnection</MethodName>
            <MethodComment>/** 
 * Get the connection
 * @return connection
 */
</MethodComment>
            <ReturnType>EngineConnection</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentStatement</MethodName>
            <MethodComment>/** 
 * Get current DRDA statement 
 * @return DRDAStatement
 * @exception SQLException
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultStatement</MethodName>
            <MethodComment>/** 
 * Get default statement for use in EXCIMM
 * @return DRDAStatement
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultStatement</MethodName>
            <MethodComment>/** 
 * Get default statement for use in EXCIMM with specified pkgnamcsn The pkgnamcsn has the encoded isolation level
 * @param pkgnamcsn package/ section # for statement
 * @return DRDAStatement
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkgnamcsn</ParamName>
                    <ParamType>Pkgnamcsn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>currentStatement;setPkgnamcsn;[pkgnamcsn]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newDRDAStatement</MethodName>
            <MethodComment>/** 
 * Get a new DRDA statement and store it in the stmtTable if stortStmt is  true. If possible recycle an existing statement. When the server gets a new statement with a previously used pkgnamcsn, it means that  client-side statement associated with this pkgnamcsn has been closed. In  this case, server can re-use the DRDAStatement by doing the following:   1) Retrieve the old DRDAStatement associated with this pkgnamcsn and close it. 2) Reset the DRDAStatement state for re-use.
 * @param pkgnamcsn  Package name and section
 * @return DRDAStatement  
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkgnamcsn</ParamName>
                    <ParamType>Pkgnamcsn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DRDAStatement [stmt=getDRDAStatement(pkgnamcsn)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDRDAStatement</MethodName>
            <MethodComment>/** 
 * Get DRDA statement based on pkgnamcsn
 * @param pkgnamcsn - key to access statement
 * @return DRDAStatement
 */
</MethodComment>
            <ReturnType>DRDAStatement</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkgnamcsn</ParamName>
                    <ParamType>Pkgnamcsn</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DRDAStatement [newStmt=(DRDAStatement)stmtTable.get(pkgnamcsn.getStatementKey())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConnection</MethodName>
            <MethodComment>/** 
 * Make a new connection using the database name and set  the connection in the database
 * @param p Properties for connection attributes to pass to connect
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EngineConnection [conn=(EngineConnection)NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL + shortDbName + attrString,p)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>p;put;[Attribute.USERNAME_ATTR, userId]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setConnection;[conn]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeDummyConnection</MethodName>
            <MethodComment>/** 
 * This makes a dummy connection to the database in order to  boot and/or create this last one. If database cannot be found or authentication does not succeed, this will throw a SQLException which we catch and do nothing. We don't pass a userid and password here as we don't need to for the purpose of this method - main goal is to cause the database to be booted via a dummy connection.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>appendAttrString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Enumeration [pKeys=p.propertyNames()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeStatement</MethodName>
            <MethodComment>/** 
 * Store DRDA prepared statement
 * @param stmt DRDA prepared statement
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmtTable;put;[stmt.getPkgnamcsn().getStatementKey(), stmt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>removeStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>stmtTable;remove;[stmt.getPkgnamcsn().getStatementKey()]</InnerMethodInvoke>
                <InnerMethodInvoke>stmt;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCurrentStatement</MethodName>
            <MethodComment>/** 
 * Make statement the current statement
 * @param stmt
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>stmt</ParamName>
                    <ParamType>DRDAStatement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rollback</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Database close does following cleanup tasks 1)Rollback any pending transaction on the Connection object (except  for a global-XA Connection obejct) before closing the Connection.  Without the rollback, the Connection close will result into an  exception if there is a pending transaction on that Connection. 2)Clean up the statement table 
 * @throws SQLException on conn.close() error to be handled in DRDAConnThread.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setDrdaID</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drdaID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setPrepareIsolation</MethodName>
            <MethodComment>/** 
 * Set the internal isolation level to use for preparing statements. Subsequent prepares will use this isoalation level
 * @param level internal isolation level 
 * @throws SQLException
 * @see EngineConnection#setPrepareIsolation
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conn;setPrepareIsolation;[level]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPrepareIsolation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildRuntimeInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indent</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>localLangUtil</ParamName>
                    <ParamType>LocalizedResource</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Hashtable&lt;Object,DRDAStatement&gt; [statements=stmtTable]</InnerVar>
                <InnerVar>String [s=indent + localLangUtil.getTextMessage("DRDA_RuntimeInfoDatabase.I") + dbName+ "\n"+ localLangUtil.getTextMessage("DRDA_RuntimeInfoUser.I")+ userId+ "\n"+ localLangUtil.getTextMessage("DRDA_RuntimeInfoNumStatements.I")+ (statements == null ? 0 : statements.size())+ "\n"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsLocator</MethodName>
            <MethodComment>/** 
 * Checks whether database can support locators.  This is done by checking whether one of the stored procedures needed for locators exists.  (If the database has been soft-upgraded from an earlier version, the procedures will not exist).
 * @throws SQLException if metadata call fails
 * @return &lt;code&gt;true&lt;/code&gt; if locators are supported,&lt;code&gt;false&lt;/code&gt; otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reset</MethodName>
            <MethodComment>/** 
 * This method resets the state of this Database object so that it can be re-used. Note: currently this method resets the variables related to security mechanisms that have been investigated as needing a reset.   TODO: Investigate what all variables in this class need to be  reset when this database object is re-used on a connection pooling or transaction pooling. see DRDAConnThread.parseACCSEC (CodePoint.RDBNAM) where database object is re-used on a connection reset.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPiggyBackedSessionData</MethodName>
            <MethodComment>/** 
 * Get a reference (handle) to the PiggyBackedSessionData object. Null will be returned either if Database.conn is not a valid connection, or if the create argument is false and no object has yet been created.
 * @param createOnDemand if true create the PiggyBackedSessionData on demand
 * @return a reference to the PBSD object or null
 * @throws java.sql.SQLException
 */
</MethodComment>
            <ReturnType>PiggyBackedSessionData</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>createOnDemand</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>SQLException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>