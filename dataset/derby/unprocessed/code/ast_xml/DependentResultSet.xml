<Class>
    <Id>1277</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>DependentResultSet</ClassName>
    <SuperClass>ScanResultSet</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>CursorResultSet</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DependentResultSet  /** 
 * DependentResultSet should be used by only ON DELETE CASCADE/ON DELETE SET NULL ref actions implementation to gather the rows from the dependent tables.   Idea is to scan the foreign key index for the rows in  the source table materialized temporary result set. Scanning of foreign key index gives us the rows that needs to be deleted on dependent tables. Using the row location  we got from the index , base row is fetched.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>heapCC</FieldName>
            <FieldType>ConglomerateController</FieldType>
        </Field>
        <Field>
            <FieldName>baseRowLocation</FieldName>
            <FieldType>RowLocation</FieldType>
        </Field>
        <Field>
            <FieldName>indexRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>indexQualifierRow</FieldName>
            <FieldType>IndexRow</FieldType>
        </Field>
        <Field>
            <FieldName>indexSC</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
        <Field>
            <FieldName>indexScoci</FieldName>
            <FieldType>StaticCompiledOpenConglomInfo</FieldType>
        </Field>
        <Field>
            <FieldName>indexDcoci</FieldName>
            <FieldType>DynamicCompiledOpenConglomInfo</FieldType>
        </Field>
        <Field>
            <FieldName>numFkColumns</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>isOpen</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>source</FieldName>
            <FieldType>TemporaryRowHolderResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>parentResultSetId</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>fkColArray</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>rowLocation</FieldName>
            <FieldType>RowLocation</FieldType>
        </Field>
        <Field>
            <FieldName>sourceRowHolders</FieldName>
            <FieldType>TemporaryRowHolder[]</FieldType>
        </Field>
        <Field>
            <FieldName>sourceResultSets</FieldName>
            <FieldType>TemporaryRowHolderResultSet[]</FieldType>
        </Field>
        <Field>
            <FieldName>sourceOpened</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>sArrayIndex</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sVector</FieldName>
            <FieldType>Vector</FieldType>
        </Field>
        <Field>
            <FieldName>sVector</FieldName>
            <FieldType>TemporaryRowHolder</FieldType>
        </Field>
        <Field>
            <FieldName>scanController</FieldName>
            <FieldType>ScanController</FieldType>
        </Field>
        <Field>
            <FieldName>scanControllerOpened</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isKeyed</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>firstScan</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>startPosition</FieldName>
            <FieldType>ExecIndexRow</FieldType>
        </Field>
        <Field>
            <FieldName>stopPosition</FieldName>
            <FieldType>ExecIndexRow</FieldType>
        </Field>
        <Field>
            <FieldName>conglomId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>heapDcoci</FieldName>
            <FieldType>DynamicCompiledOpenConglomInfo</FieldType>
        </Field>
        <Field>
            <FieldName>heapScoci</FieldName>
            <FieldType>StaticCompiledOpenConglomInfo</FieldType>
        </Field>
        <Field>
            <FieldName>startSearchOperator</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>stopSearchOperator</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>qualifiers</FieldName>
            <FieldType>Qualifier[][]</FieldType>
        </Field>
        <Field>
            <FieldName>userSuppliedOptimizerOverrides</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>runTimeStatisticsOn</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rowsPerRead</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>forUpdate</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>scanProperties</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>startPositionString</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>stopPositionString</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>isConstraint</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>coarserLock</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>oneRowScan</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rowsThisScan</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>searchRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DependentResultSet</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>scoci</ParamName>
                    <ParamType>StaticCompiledOpenConglomInfo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultRowTemplate</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopKeyGetter</ParamName>
                    <ParamType>GeneratedMethod</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>stopSearchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sameStartStopPosition</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qualifiers</ParamName>
                    <ParamType>Qualifier[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>userSuppliedOptimizerOverrides</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isConstraint</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>forUpdate</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colRefItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockMode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableLocked</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isolationLevel</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowsPerRead</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oneRowScan</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedRowCount</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizerEstimatedCost</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parentResultSetId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkIndexConglomId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fkColArrayItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rltItem</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;recordConstructorTime;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openIndexScanController</MethodName>
            <MethodComment>/** 
 * Get a scan controller positioned using searchRow as the start/stop position.  The assumption is that searchRow is of the same format as the index being opened. 
 * @param searchRow			the row to match
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>ScanController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setupQualifierRow;[searchRow]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopenIndexScanController</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setupQualifierRow;[searchRow]</InnerMethodInvoke>
                <InnerMethodInvoke>indexSC;reopenScan;[indexQualifierRow.getRowArray(), ScanController.GE, null, indexQualifierRow.getRowArray(), ScanController.GT]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setupQualifierRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Object[] [indexColArray=indexQualifierRow.getRowArray()]</InnerVar>
                <InnerVar>Object[] [baseColArray=searchRow.getRowArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openIndexScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchIndexRow</MethodName>
            <MethodComment>/** 
 * Fetch a row from the index scan.
 * @return The row or null. Note that the next call to fetch willreplace the columns in the returned row.
 * @exception StandardException Ooops
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fetchBaseRow</MethodName>
            <MethodComment>/** 
 * Fetch the base row corresponding to the current index row
 * @return The base row row or null.
 * @exception StandardException Ooops
 */
</MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>boolean [base_row_exists=heapCC.fetch(baseRowLocation,candidate.getRowArray(),accessedCols)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ExecRow [currentIndexRow=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextParentRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ExecRow [cRow]</InnerVar>
                <InnerVar>TemporaryRowHolder [rowHolder]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openHeapConglomerateController</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ConglomerateController</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the all the opens we did in this result set.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>finish</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;finishAndRTS;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openCore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=sVector.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initIsolationLevel;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNewSources</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [size=sVector.size()]</InnerVar>
                <InnerVar>TemporaryRowHolder[] [tsourceRowHolders=new TemporaryRowHolder[size]]</InnerVar>
                <InnerVar>int[] [tsourceOpened=new int[size]]</InnerVar>
                <InnerVar>TemporaryRowHolderResultSet[] [tsourceResultSets=new TemporaryRowHolderResultSet[size]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>System;arraycopy;[sourceRowHolders, 0, tsourceRowHolders, 0, sourceRowHolders.length]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[sourceOpened, 0, tsourceOpened, 0, sourceOpened.length]</InnerMethodInvoke>
                <InnerMethodInvoke>System;arraycopy;[sourceResultSets, 0, tsourceResultSets, 0, sourceResultSets.length]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canGetInstantaneousLocks</MethodName>
            <MethodComment>/** 
 * Can we get instantaneous locks when getting share row locks at READ COMMITTED.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTimeSpent</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RowLocation</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentRow</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ExecRow</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Properties</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printStartPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printStopPosition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printPosition</MethodName>
            <MethodComment>/** 
 * Return a start or stop positioner as a String. If we already generated the information, then use that.  Otherwise, invoke the activation to get it.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>searchOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>positioner</ParamName>
                    <ParamType>ExecIndexRow</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [output=""]</InnerVar>
                <InnerVar>String [searchOp]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printQualifiers</MethodName>
            <MethodComment>/** 
 * Return an array of Qualifiers as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [idt=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>