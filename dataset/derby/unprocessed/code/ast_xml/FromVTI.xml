<Class>
    <Id>1695</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>FromVTI</ClassName>
    <SuperClass>FromTable</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>VTIEnvironment</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>FromVTI  /** 
 * A FromVTI represents a VTI in the FROM list of a DML statement.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>correlationMap</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>dependencyMap</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>methodCall</FieldName>
            <FieldType>MethodCallNode</FieldType>
        </Field>
        <Field>
            <FieldName>exposedName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>subqueryList</FieldName>
            <FieldType>SubqueryList</FieldType>
        </Field>
        <Field>
            <FieldName>implementsVTICosting</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>optimized</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>materializable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isTarget</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isDerbyStyleTableFunction</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isRestrictedTableFunction</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>rs</FieldName>
            <FieldType>ResultSet</FieldType>
        </Field>
        <Field>
            <FieldName>compileTimeConstants</FieldName>
            <FieldType>FormatableHashtable</FieldType>
        </Field>
        <Field>
            <FieldName>numVTICols</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>restrictionList</FieldName>
            <FieldType>PredicateList</FieldType>
        </Field>
        <Field>
            <FieldName>estimatedCost</FieldName>
            <FieldType>double</FieldType>
        </Field>
        <Field>
            <FieldName>estimatedRowCount</FieldName>
            <FieldType>double</FieldType>
        </Field>
        <Field>
            <FieldName>supportsMultipleInstantiations</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>vtiCosted</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>version2</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>implementsPushable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>ps</FieldName>
            <FieldType>PreparedStatement</FieldType>
        </Field>
        <Field>
            <FieldName>methodParms</FieldName>
            <FieldType>JavaValueNode[]</FieldType>
        </Field>
        <Field>
            <FieldName>controlsDeferral</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>resultSetType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>projectedColumnNames</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>vtiRestriction</FieldName>
            <FieldType>Restriction</FieldType>
        </Field>
        <Field>
            <FieldName>outerFromLists</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>outerFromLists</FieldName>
            <FieldType>FromList</FieldType>
        </Field>
        <Field>
            <FieldName>argSources</FieldName>
            <FieldType>HashMap</FieldType>
        </Field>
        <Field>
            <FieldName>argSources</FieldName>
            <FieldType>Integer</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>FromVTI</MethodName>
            <MethodComment>/** 
 * Constructor.
 * @param invocation		The constructor or static method for the VTI
 * @param correlationName	The correlation name
 * @param derivedRCL		The derived column list
 * @param tableProperties	Properties list associated with the table
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>invocation</ParamName>
                    <ParamType>MethodCallNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>correlationName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>derivedRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[invocation, derivedRCL, makeTableName(null,correlationName)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>FromVTI</MethodName>
            <MethodComment>/** 
 * Constructor.
 * @param invocation		The constructor or static method for the VTI
 * @param correlationName	The correlation name
 * @param derivedRCL		The derived column list
 * @param tableProperties	Properties list associated with the table
 * @param exposedTableName  The table name (TableName class)
 * @param cm                The context manager
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>invocation</ParamName>
                    <ParamType>MethodCallNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>correlationName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>derivedRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableProperties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exposedTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constructorMinion;[invocation, derivedRCL, exposedTableName]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constructorMinion</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>invocation</ParamName>
                    <ParamType>MethodCallNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>derivedRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exposedTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setResultColumns;[derivedRCL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>estimateCost</MethodName>
            <MethodComment>/** 
 * @see Optimizable#estimateCost
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predList</ParamName>
                    <ParamType>OptimizablePredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cd</ParamName>
                    <ParamType>ConglomerateDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerCost</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>optimizer</ParamName>
                    <ParamType>Optimizer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rowOrdering</ParamName>
                    <ParamType>RowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCostEstimate;[getCostEstimate(optimizer)]</InnerMethodInvoke>
                <InnerMethodInvoke>getCostEstimate();setCost;[estimatedCost, estimatedRowCount, estimatedRowCount]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>legalJoinOrder</MethodName>
            <MethodComment>/** 
 * @see Optimizable#legalJoinOrder
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>assignedTableMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JBitSet [tempBitSet=assignedTableMap]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tempBitSet;or;[correlationMap]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isMaterializable</MethodName>
            <MethodComment>/** 
 * @see Optimizable#isMaterializable 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>supportsMultipleInstantiations</MethodName>
            <MethodComment>/** 
 * @see Optimizable#supportsMultipleInstantiations 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDerbyStyleTableFunction</MethodName>
            <MethodComment>/** 
 * Return true if this is a user-defined table function 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * @see ResultSetNode#adjustForSortElimination()
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyAccessPath</MethodName>
            <MethodComment>/** 
 * @see Optimizable#modifyAccessPath
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>Optimizable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addOuterFromList</MethodName>
            <MethodComment>/** 
 * Add a FromList to the collection of FromLists which bindExpressions() checks when vetting VTI arguments which reference columns in other tables. See DERBY-5554 and DERBY-5779.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>outerFromLists;add;[fromList]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushOptPredicate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optimizablePredicate</ParamName>
                    <ParamType>OptimizablePredicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>restrictionList;addPredicate;[(Predicate)optimizablePredicate]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isConstructor</MethodName>
            <MethodComment>/** 
 * Return true if this VTI is a constructor. Otherwise, it is a static method.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMethodCall</MethodName>
            <MethodComment>/** 
 * Return the constructor or static method invoked from this node
 */
</MethodComment>
            <ReturnType>MethodCallNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExposedName</MethodName>
            <MethodComment>/** 
 * Get the exposed name for this table, which is the name that can be used to refer to it in the rest of the query.
 * @return	The exposed name for this table.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getExposedTableName</MethodName>
            <MethodComment>/** 
 * @return the table name used for matching with column references.
 */
</MethodComment>
            <ReturnType>TableName</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTarget</MethodName>
            <MethodComment>/** 
 * Mark this VTI as the target of a delete or update.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindNonVTITables</MethodName>
            <MethodComment>/** 
 * Bind the non VTI tables in this ResultSetNode.  This includes getting their descriptors from the data dictionary and numbering them.
 * @param dataDictionary	The DataDictionary to use for binding
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVTIName</MethodName>
            <MethodComment>/** 
 * @return The name of the VTI, mainly for debugging and error messages.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindVTITables</MethodName>
            <MethodComment>/** 
 * Bind this VTI that appears in the FROM list.
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode		The bound FromVTI.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [derivedRCL=getResultColumns()]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>ArrayList&lt;AggregateNode&gt; [aggregates=new ArrayList&lt;AggregateNode&gt;()]</InnerVar>
                <InnerVar>RoutineAliasInfo [routineInfo=methodCall.getRoutineInfo()]</InnerVar>
                <InnerVar>UUID [triggerTableId]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodCall;bindExpression;[fromListParam, subqueryList, aggregates]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetMetaData</MethodName>
            <MethodComment>/** 
 * Get the ResultSetMetaData for the class/object.  We first look for  the optional static method which has the same signature as the constructor. If it doesn't exist, then we instantiate an object and get the ResultSetMetaData from that object.
 * @return The ResultSetMetaData from the class/object.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetMetaData</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultSetMetaData [rsmd=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewInstance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>NewInvocationNode [constructor=(NewInvocationNode)methodCall]</InnerVar>
                <InnerVar>Class&lt;?&gt;[] [paramTypeClasses=constructor.getMethodParameterClasses()]</InnerVar>
                <InnerVar>Object[] [paramObjects]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDeferralControl</MethodName>
            <MethodComment>/** 
 * Get the DeferModification interface associated with this VTI
 * @return null if the VTI uses the default modification deferral
 */
</MethodComment>
            <ReturnType>DeferModification</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetType</MethodName>
            <MethodComment>/** 
 * @return the ResultSet type of the VTI, TYPE_FORWARD_ONLY if the getResultSetType() methodof the VTI class throws an exception.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressions</MethodName>
            <MethodComment>/** 
 * Bind the expressions in this VTI.  This means  binding the sub-expressions, as well as figuring out what the return  type is for each expression.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ArrayList&lt;AggregateNode&gt; [aggregates=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnInFromList</MethodName>
            <MethodComment>/** 
 * If the referenced column appears in the indicated FROM list, then return the table it appears in.
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ref</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [referencedTableNumber=ref.getTableNumber()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNodesFromParameters</MethodName>
            <MethodComment>/** 
 * Get all of the nodes of the specified class from the parameters to this VTI.
 * @param nodeClass	The Class of interest.
 * @return A list containing all of the nodes of interest.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>T</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>nodeClass</ParamName>
                    <ParamType>T</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;T&gt; [getCRs=new CollectNodesVisitor&lt;T&gt;(nodeClass)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodCall;accept;[getCRs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllResultColumns</MethodName>
            <MethodComment>/** 
 * Expand a "*" into a ResultColumnList with all of the result columns from the subquery.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TableName [toCompare]</InnerVar>
                <InnerVar>ContextManager [cm=getContextManager()]</InnerVar>
                <InnerVar>ResultColumnList [rcList=new ResultColumnList(cm)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMatchingColumn</MethodName>
            <MethodComment>/** 
 * Try to find a ResultColumn in the table represented by this FromBaseTable that matches the name in the given ColumnReference.
 * @param columnReference	The columnReference whose name we're lookingfor in the given table.
 * @return	A ResultColumn whose expression is the ColumnNodethat matches the ColumnReference. Returns null if there is no match.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnReference</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [resultColumn=null]</InnerVar>
                <InnerVar>TableName [columnsTableName]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess a ResultSetNode - this currently means: o  Generating a referenced table map for each ResultSetNode. o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF). o  Converting the WHERE and HAVING clauses into PredicateLists and classifying them. o  Ensuring that a ProjectRestrictNode is generated on top of every  FromBaseTable and generated in place of every FromSubquery.   o  Pushing single table predicates down to the new ProjectRestrictNodes.
 * @param numTables			The number of tables in the DML Statement
 * @param gbl				The group by list, if any
 * @param fromList			The from list, if any
 * @return ResultSetNode at top of preprocessed tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodCall;preprocess;[numTables, new FromList(getOptimizerFactory().doJoinOrderOptimization(),getContextManager()), new SubqueryList(getContextManager()), new PredicateList(getContextManager())]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setReferencedTableMap;[new JBitSet(numTables)]</InnerMethodInvoke>
                <InnerMethodInvoke>getReferencedTableMap();set;[tableNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>methodCall;categorize;[dependencyMap, false]</InnerMethodInvoke>
                <InnerMethodInvoke>dependencyMap;clear;[tableNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>methodCall;getCorrelationTables;[correlationMap]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genProjectRestrict</MethodName>
            <MethodComment>/** 
 * Put a ProjectRestrictNode on top of each FromTable in the FromList. ColumnReferences must continue to point to the same ResultColumn, so that ResultColumn must percolate up to the new PRN.  However, that ResultColumn will point to a new expression, a VirtualColumnNode,  which points to the FromTable and the ResultColumn that is the source for the ColumnReference.   (The new PRN will have the original of the ResultColumnList and the ResultColumns from that list.  The FromTable will get shallow copies of the ResultColumnList and its ResultColumns.  ResultColumn.expression will remain at the FromTable, with the PRN getting a new  VirtualColumnNode for each ResultColumn.expression.) We then project out the non-referenced columns.  If there are no referenced columns, then the PRN's ResultColumnList will consist of a single ResultColumn whose expression is 1.
 * @param numTables			Number of tables in the DML Statement
 * @return The generated ProjectRestrictNode atop the original FromTable.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [prRCList]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setResultColumns;[getResultColumns().copyListAndObjects()]</InnerMethodInvoke>
                <InnerMethodInvoke>prRCList;genVirtualColumnNodes;[this, getResultColumns(), false]</InnerMethodInvoke>
                <InnerMethodInvoke>prRCList;doProjection;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performMaterialization</MethodName>
            <MethodComment>/** 
 * Return whether or not to materialize this ResultSet tree.
 * @return Whether or not to materialize this ResultSet tree.would return valid results.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeProjectionAndRestriction</MethodName>
            <MethodComment>/** 
 * Compute the projection and restriction to be pushed to the external table function if it is a RestrictedVTI. This method is called by the parent ProjectRestrictNode at code generation time. See DERBY-4357.
 * @param parentPredicates The full list of predicates to be applied by the parent ProjectRestrictNode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPredicates</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;computeRestriction;[parentPredicates, computeProjection()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeProjection</MethodName>
            <MethodComment>/** 
 * Fills in the array of projected column names suitable for handing to RestrictedVTI.initScan(). Returns a map of the exposed column names to the actual names of columns in the table function. This is useful because the predicate refers to the exposed column names.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>HashMap&lt;String,String&gt; [nameMap=new HashMap&lt;String,String&gt;()]</InnerVar>
                <InnerVar>ResultColumnList [allVTIColumns=getResultColumns()]</InnerVar>
                <InnerVar>int [totalColumnCount=allVTIColumns.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>computeRestriction</MethodName>
            <MethodComment>/** 
 * Fills in the restriction to be handed to a RestrictedVTI at run-time.
 * @param parentPredicates The full list of predicates to be applied by the parent ProjectRestrictNode
 * @param columnNameMap Mapping between the exposed column names used in the predicates and the actual column names declared for the table function at CREATE FUNCTION time.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parentPredicates</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNameMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>canBePushedDown</MethodName>
            <MethodComment>/** 
 * Return true if the predicate can be pushed into a RestrictedVTI 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>JBitSet [referencedSet=predicate.getReferencedSet()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeRestriction</MethodName>
            <MethodComment>/** 
 * Turn a compile-time WHERE clause fragment into a run-time Restriction. Returns null if the clause could not be understood.
 * @param clause The clause which should be turned into a Restriction.
 * @param columnNameMap Mapping between the exposed column names used in the predicates and the actual column names declared for the table function at CREATE FUNCTION time.
 */
</MethodComment>
            <ReturnType>Restriction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNameMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeLeafRestriction</MethodName>
            <MethodComment>/** 
 * Makes a Restriction out of a comparison between a constant and a column in the VTI.
 * @param clause The clause which should be turned into a Restriction.
 * @param columnNameMap Mapping between the exposed column names used in the predicates and the actual column names declared for the table function at CREATE FUNCTION time.
 */
</MethodComment>
            <ReturnType>Restriction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clause</ParamName>
                    <ParamType>BinaryRelationalOperatorNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNameMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [rawOperator=clause.getOperator()]</InnerVar>
                <InnerVar>ColumnReference [rawColumn]</InnerVar>
                <InnerVar>ValueNode [rawValue]</InnerVar>
                <InnerVar>int [comparisonOperator=mapOperator(rawOperator)]</InnerVar>
                <InnerVar>String [columnName=columnNameMap.get(rawColumn.getColumnName())]</InnerVar>
                <InnerVar>Object [constantOperand=squeezeConstantValue(rawValue)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeIsNullRestriction</MethodName>
            <MethodComment>/** 
 * Makes an IS NULL comparison of a column in the VTI.
 * @param clause The IS NULL (or IS NOT NULL) node
 * @param columnNameMap Mapping between the exposed column names used in the predicates and the actual column names declared for the table function at CREATE FUNCTION time.
 */
</MethodComment>
            <ReturnType>Restriction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clause</ParamName>
                    <ParamType>IsNullNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNameMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnReference [rawColumn=(ColumnReference)clause.getOperand()]</InnerVar>
                <InnerVar>int [comparisonOperator=mapOperator(clause.getOperator())]</InnerVar>
                <InnerVar>String [columnName=columnNameMap.get(rawColumn.getColumnName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>iAmConfused</MethodName>
            <MethodComment>/** 
 * This is a handy place to put instrumentation for tracing trees which we don't understand 
 */
</MethodComment>
            <ReturnType>Restriction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>clause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flipOperator</MethodName>
            <MethodComment>/** 
 * Flip the sense of a comparison 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rawOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mapOperator</MethodName>
            <MethodComment>/** 
 * Map internal operator constants to user-visible ones 
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rawOperator</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>squeezeConstantValue</MethodName>
            <MethodComment>/** 
 * Get the constant or parameter reference out of a comparand. Return null if we are confused. A parameter reference is wrapped in an integer array to distinguish it from a constant integer.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>valueNode</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generate</MethodName>
            <MethodComment>/** 
 * Generation on a FromVTI creates a wrapper around the user's java.sql.ResultSet
 * @param acb	The ActivationClassBuilder for the class being built
 * @param mb The MethodBuilder for the execute() method to be built
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RemapCRsVisitor [rcrv=new RemapCRsVisitor(true)]</InnerVar>
                <InnerVar>int [nargs=getScanArguments(acb,mb)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>methodCall;accept;[rcrv]</InnerMethodInvoke>
                <InnerMethodInvoke>null;remapBaseTableColumns;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;assignResultSetNumber;[]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushGetResultSetFactoryExpression;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, "getVTIResultSet", ClassName.NoPutResultSet, nargs]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>remapBaseTableColumns</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Remap the column references in vti arguments. Point those column references at the result columns for the base table. This prevents us from code-generating the args from references to unfilled columns in higher join nodes. See DERBY-5554. &lt;/p&gt;
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScanArguments</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [rclSize=getResultColumns().size()]</InnerVar>
                <InnerVar>FormatableBitSet [referencedCols=new FormatableBitSet(rclSize)]</InnerVar>
                <InnerVar>int [erdNumber=-1]</InnerVar>
                <InnerVar>int [numSet=0]</InnerVar>
                <InnerVar>int [ctcNumber=acb.addItem(compileTimeConstants)]</InnerVar>
                <InnerVar>boolean [reuseablePs=version2 &amp;&amp; (getNodesFromParameters(ParameterNode.class).isEmpty()) &amp;&amp; (getNodesFromParameters(ColumnReference.class).isEmpty())]</InnerVar>
                <InnerVar>int [rtNum=-1]</InnerVar>
                <InnerVar>TableName [fullName=methodCall.getFullName()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;setCostEstimate;[getFinalCostEstimate()]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushThisAsActivation;[mb]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[acb.addItem(getResultColumns().buildRowTemplate())]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getResultSetNumber()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;generateConstructor;[acb, mb, reuseablePs]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[methodCall.getJavaClassName()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[erdNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[version2]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[reuseablePs]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[ctcNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[isTarget]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCompilerContext().getScanIsolationLevel()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().rowCount()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().getEstimatedCost()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[isDerbyStyleTableFunction]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[rtNum]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[storeObjectInPS(acb,projectedColumnNames)]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[storeObjectInPS(acb,vtiRestriction)]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[(fullName == null) ? "" : fullName.getSchemaName()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[(fullName == null) ? "" : fullName.getTableName()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>storeObjectInPS</MethodName>
            <MethodComment>/** 
 * Store an object in the prepared statement.  Returns -1 if the object is null. Otherwise returns the object's retrieval handle.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obj</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateConstructor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>reuseablePs</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [vtiType=version2 ? "java.sql.PreparedStatement" : "java.sql.ResultSet"]</InnerVar>
                <InnerVar>MethodBuilder [userExprFun=acb.newGeneratedFun(vtiType,Modifier.PUBLIC)]</InnerVar>
                <InnerVar>LocalField [psHolder=reuseablePs ? acb.newFieldDeclaration(Modifier.PRIVATE,"java.sql.PreparedStatement") : null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>userExprFun;addThrownException;["java.lang.Exception"]</InnerMethodInvoke>
                <InnerMethodInvoke>methodCall;generateExpression;[acb, userExprFun]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;upCast;[vtiType]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;methodReturn;[]</InnerMethodInvoke>
                <InnerMethodInvoke>userExprFun;complete;[]</InnerMethodInvoke>
                <InnerMethodInvoke>acb;pushMethodReference;[mb, userExprFun]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesTarget</MethodName>
            <MethodComment>/** 
 * Search to see if a query references the specifed table name.
 * @param name		Table name (String) to search for.
 * @param baseTable	Whether or not name is for a base table
 * @return	true if found, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpecialTriggerVTITableName</MethodName>
            <MethodComment>/** 
 * Check and see if we have a special trigger VTI. If it cannot be bound (because we aren't actually  compiling or executing a trigger), then throw  an exception.
 * @return null if not a special trigger vti, or the tableid if it is
 */
</MethodComment>
            <ReturnType>UUID</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genResultColList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [rcList=new ResultColumnList((getContextManager()))]</InnerVar>
                <InnerVar>ColumnDescriptorList [cdl=td.getColumnDescriptorList()]</InnerVar>
                <InnerVar>int [cdlSize=cdl.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsSpecialRCLBinding</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUpdatableCursor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCompileTime</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOriginalSQL</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getStatementIsolationLevel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setSharedState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>java.io.Serializable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compileTimeConstants;put;[key, value]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSharedState</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createResultColumnsForTableFunction</MethodName>
            <MethodComment>/** 
 * Add result columns for a Derby-style Table Function
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TypeDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String[] [columnNames=td.getRowColumnNames()]</InnerVar>
                <InnerVar>TypeDescriptor[] [types=td.getRowTypes()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>implementsDerbyStyleVTICosting</MethodName>
            <MethodComment>/** 
 * Return true if this Derby Style Table Function implements the VTICosting interface. The class must satisfy the following conditions: &lt;ul&gt; &lt;li&gt;Implements VTICosting&lt;/li&gt; &lt;li&gt;Has a public, no-arg constructor&lt;/li&gt; &lt;/ul&gt;
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Constructor&lt;?&gt; [constructor=null]</InnerVar>
                <InnerVar>Class&lt;?&gt; [vtiClass=lookupClass(className)]</InnerVar>
                <InnerVar>Class&lt;?&gt; [vtiCostingClass=lookupClass(VTICosting.class.getName())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getVTICosting</MethodName>
            <MethodComment>/** 
 * Get the VTICosting implementation for this optimizable VTI.
 */
</MethodComment>
            <ReturnType>VTICosting</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [className=methodCall.getJavaClassName()]</InnerVar>
                <InnerVar>Class&lt;?&gt; [vtiClass=lookupClass(className)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lookupClass</MethodName>
            <MethodComment>/** 
 * Lookup the class that holds the VTI.
 */
</MethodComment>
            <ReturnType>?</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>