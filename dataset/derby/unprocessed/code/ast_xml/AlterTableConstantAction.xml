<Class>
    <Id>1331</Id>
    <Package>org.apache.derby.impl.sql.execute</Package>
    <ClassName>AlterTableConstantAction</ClassName>
    <SuperClass>DDLSingleTableConstantAction</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>RowLocationRetRowSource</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>AlterTableConstantAction  /** 
 * This class  describes actions that are ALWAYS performed for an ALTER TABLE Statement at Execution time.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>RANGE_TOP</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RANGE_BOTTOM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sd</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>tableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>schemaId</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>tableType</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>columnInfo</FieldName>
            <FieldType>ColumnInfo[]</FieldType>
        </Field>
        <Field>
            <FieldName>constraintActions</FieldName>
            <FieldType>ConstraintConstantAction[]</FieldType>
        </Field>
        <Field>
            <FieldName>lockGranularity</FieldName>
            <FieldType>char</FieldType>
        </Field>
        <Field>
            <FieldName>tableConglomerateId</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>compressTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>behavior</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>sequential</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>truncateTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>purge</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>defragment</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>truncateEndOfTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>updateStatistics</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>updateStatisticsAll</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dropStatistics</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>dropStatisticsAll</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>indexNameForStatistics</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>doneScan</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>needToDropSort</FieldName>
            <FieldType>boolean[]</FieldType>
        </Field>
        <Field>
            <FieldName>validRow</FieldName>
            <FieldType>boolean[]</FieldType>
        </Field>
        <Field>
            <FieldName>bulkFetchSize</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentCompressRow</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>numIndexes</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>rowCount</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>estimatedRowCount</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>indexConglomerateNumbers</FieldName>
            <FieldType>long[]</FieldType>
        </Field>
        <Field>
            <FieldName>sortIds</FieldName>
            <FieldType>long[]</FieldType>
        </Field>
        <Field>
            <FieldName>indexedCols</FieldName>
            <FieldType>FormatableBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>compressHeapCC</FieldName>
            <FieldType>ConglomerateController</FieldType>
        </Field>
        <Field>
            <FieldName>indexRows</FieldName>
            <FieldType>ExecIndexRow[]</FieldType>
        </Field>
        <Field>
            <FieldName>baseRow</FieldName>
            <FieldType>ExecRow[]</FieldType>
        </Field>
        <Field>
            <FieldName>currentRow</FieldName>
            <FieldType>ExecRow</FieldType>
        </Field>
        <Field>
            <FieldName>compressHeapGSC</FieldName>
            <FieldType>GroupFetchScanController</FieldType>
        </Field>
        <Field>
            <FieldName>compressIRGs</FieldName>
            <FieldType>IndexRowGenerator[]</FieldType>
        </Field>
        <Field>
            <FieldName>baseRowArray</FieldName>
            <FieldType>DataValueDescriptor[][]</FieldType>
        </Field>
        <Field>
            <FieldName>compressRL</FieldName>
            <FieldType>RowLocation[]</FieldType>
        </Field>
        <Field>
            <FieldName>sorters</FieldName>
            <FieldType>SortController[]</FieldType>
        </Field>
        <Field>
            <FieldName>droppedColumnPosition</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ordering</FieldName>
            <FieldType>ColumnOrdering[][]</FieldType>
        </Field>
        <Field>
            <FieldName>collation</FieldName>
            <FieldType>int[][]</FieldType>
        </Field>
        <Field>
            <FieldName>td</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>lcc</FieldName>
            <FieldType>LanguageConnectionContext</FieldType>
        </Field>
        <Field>
            <FieldName>dd</FieldName>
            <FieldType>DataDictionary</FieldType>
        </Field>
        <Field>
            <FieldName>dm</FieldName>
            <FieldType>DependencyManager</FieldType>
        </Field>
        <Field>
            <FieldName>tc</FieldName>
            <FieldType>TransactionController</FieldType>
        </Field>
        <Field>
            <FieldName>activation</FieldName>
            <FieldType>Activation</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>AlterTableConstantAction</MethodName>
            <MethodComment>/** 
 * Make the AlterAction for an ALTER TABLE statement.
 * @param sd			        descriptor for the table's schema.
 * @param tableName	        Name of table.
 * @param tableId		        UUID of table
 * @param tableConglomerateId	heap conglomerate number of table
 * @param tableType	        Type of table (e.g., BASE).
 * @param columnInfo	        Information on all the columns in the table.
 * @param constraintActions	ConstraintConstantAction[] for constraints
 * @param lockGranularity	    The lock granularity.
 * @param compressTable	    Whether or not this is a compress table
 * @param behavior		        drop behavior for dropping column
 * @param sequential	        If compress table/drop column, whether or not sequential
 * @param truncateTable	    Whether or not this is a truncate table
 * @param purge				PURGE during INPLACE COMPRESS?
 * @param defragment			DEFRAGMENT during INPLACE COMPRESS?
 * @param truncateEndOfTable	TRUNCATE END during INPLACE COMPRESS?
 * @param updateStatistics		TRUE means we are here to update statistics
 * @param updateStatisticsAll	TRUE means we are here to update statisticsof all the indexes. False means we are here to update statistics of only one index.
 * @param dropStatistics		TRUE means we are here to drop statistics
 * @param dropStatisticsAll	TRUE means we are here to drop statisticsof all the indexes. False means we are here to drop statistics of only one index.
 * @param indexNameForStatistics	Will name the index whose statisticswill be updated/dropped. This param is looked at only if  updateStatisticsAll/dropStatisticsAll is set to false and updateStatistics/dropStatistics is set to true.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sd</ParamName>
                    <ParamType>SchemaDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableId</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableConglomerateId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnInfo</ParamName>
                    <ParamType>ColumnInfo[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraintActions</ParamName>
                    <ParamType>ConstraintConstantAction[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lockGranularity</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>compressTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>behavior</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sequential</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>truncateTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>purge</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defragment</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>truncateEndOfTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateStatistics</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateStatisticsAll</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dropStatistics</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dropStatisticsAll</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>indexNameForStatistics</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeConstantAction</MethodName>
            <MethodComment>/** 
 * Run this constant action.
 * @param activation the activation in which to run the action
 * @throws StandardException if an error happens during executionof the action
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeConstantActionBody</MethodName>
            <MethodComment>/** 
 * This is the guts of the Execution-time logic for ALTER TABLE.
 * @see ConstantAction#executeConstantAction
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>activation</ParamName>
                    <ParamType>Activation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numRows=0]</InnerVar>
                <InnerVar>boolean [tableScanned=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;lockTableForDDL;[tc, tableConglomerateId, true]</InnerMethodInvoke>
                <InnerMethodInvoke>activation;setDDLTableDescriptor;[td]</InnerMethodInvoke>
                <InnerMethodInvoke>null;adjustUDTDependencies;[lcc, dd, td, columnInfo, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearState</MethodName>
            <MethodComment>/** 
 * Clear the state of this constant action.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropStatistics</MethodName>
            <MethodComment>/** 
 * Drop statistics of either all the indexes on the table or only one specific index depending on what user has requested.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;invalidateFor;[td, DependencyManager.UPDATE_STATISTICS, lcc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateStatistics</MethodName>
            <MethodComment>/** 
 * Update statistics of either all the indexes on the table or only one specific index depending on what user has requested.
 * @throws StandardException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [cds]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd.getIndexStatsRefresher(false);runExplicitly;[lcc, td, cds, "ALTER TABLE"]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncateEnd</MethodName>
            <MethodComment>/** 
 * Truncate end of conglomerate. &lt;p&gt; Returns the contiguous free space at the end of the table back to the operating system.  Takes care of space allocation bit maps, and OS call to return the actual space. &lt;p&gt;
 * @param tc                transaction controller to use to do updates.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defragmentRows</MethodName>
            <MethodComment>/** 
 * Defragment rows in the given table. &lt;p&gt; Scans the rows at the end of a table and moves them to free spots towards the beginning of the table.  In the same transaction all associated indexes are updated to reflect the new location of the base table row. &lt;p&gt; After a defragment pass, if was possible, there will be a set of empty pages at the end of the table which can be returned to the operating system by calling truncateEnd().  The allocation bit maps will be set so that new inserts will tend to go to empty and half filled pages starting from the front of the conglomerate.
 * @param tc                transaction controller to use to do updates.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroupFetchScanController [base_group_fetch_cc=null]</InnerVar>
                <InnerVar>int [num_indexes=0]</InnerVar>
                <InnerVar>int[][] [index_col_map=null]</InnerVar>
                <InnerVar>ScanController[] [index_scan=null]</InnerVar>
                <InnerVar>ConglomerateController[] [index_cc=null]</InnerVar>
                <InnerVar>DataValueDescriptor[][] [index_row=null]</InnerVar>
                <InnerVar>TransactionController [nested_tc=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setup_indexes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_col_map</ParamName>
                    <ParamType>int[][]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_scan</ParamName>
                    <ParamType>ScanController[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_cc</ParamName>
                    <ParamType>ConglomerateController[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_row</ParamName>
                    <ParamType>DataValueDescriptor[][]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ConglomerateDescriptor[] [conglom_descriptors=td.getConglomerateDescriptors()]</InnerVar>
                <InnerVar>int [index_idx=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fixIndex</MethodName>
            <MethodComment>/** 
 * Delete old index row and insert new index row in input index. &lt;p&gt;
 * @param base_row      all columns of base row
 * @param index_row     an index row template, filled in by this routine
 * @param old_row_loc   old location of base row, used to delete index
 * @param new_row_loc   new location of base row, used to update index
 * @param index_cc      index conglomerate to insert new row
 * @param index_scan    index scan to delete old entry
 * @param index_col_map description of mapping of index row to base row,
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>base_row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>old_row_loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>new_row_loc</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_cc</ParamName>
                    <ParamType>ConglomerateController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_scan</ParamName>
                    <ParamType>ScanController</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index_col_map</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>index_scan;reopenScan;[index_row, ScanController.GE, (Qualifier[][])null, index_row, ScanController.GT]</InnerMethodInvoke>
                <InnerMethodInvoke>index_cc;insert;[index_row]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>purgeRows</MethodName>
            <MethodComment>/** 
 * Purge committed deleted rows from conglomerate. &lt;p&gt; Scans the table and purges any committed deleted rows from the  table.  If all rows on a page are purged then page is also  reclaimed. &lt;p&gt;
 * @param tc                transaction controller to use to do updates.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNewColumnToTable</MethodName>
            <MethodComment>/** 
 * Workhorse for adding a new column to a table.
 * @param ix 			the index of the column specfication in the ALTER statement-- currently we allow only one.
 * @exception StandardException 	thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ix</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [columnDescriptor=td.getColumnDescriptor(columnInfo[ix].name)]</InnerVar>
                <InnerVar>DataValueDescriptor [storableDV]</InnerVar>
                <InnerVar>int [colNumber=td.getMaxColumnID() + ix]</InnerVar>
                <InnerVar>UUID [defaultUUID=columnInfo[ix].newDefaultUUID]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>tc;addColumnToConglomerate;[td.getHeapConglomerateId(), colNumber, storableDV, columnInfo[ix].dataType.getCollationType()]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[columnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>td.getColumnDescriptorList();add;[columnDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addColumnDependencies;[lcc, dd, td, columnInfo[ix]]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateSYSCOLPERMSforAddColumnToUserTable;[td.getUUID(), tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>dropColumnFromTable</MethodName>
            <MethodComment>/** 
 * Workhorse for dropping a column from a table. This routine drops a column from a table, taking care to properly handle the various related schema objects. The syntax which gets you here is: ALTER TABLE tbl DROP [COLUMN] col [CASCADE|RESTRICT] The keyword COLUMN is optional, and if you don't specify CASCADE or RESTRICT, the default is CASCADE (the default is chosen in the parser, not here). If you specify RESTRICT, then the column drop should be rejected if it would cause a dependent schema object to become invalid. If you specify CASCADE, then the column drop should additionally drop other schema objects which have become invalid. You may not drop the last (only) column in a table. Schema objects of interest include: - views - triggers - constraints - check constraints - primary key constraints - foreign key constraints - unique key constraints - not null constraints - privileges - indexes - default values Dropping a column may also change the column position numbers of other columns in the table, which may require fixup of schema objects (such as triggers and column privileges) which refer to columns by column position number. Indexes are a bit interesting. The official SQL spec doesn't talk about indexes; they are considered to be an imlementation-specific performance optimization. The current Derby behavior is that: - CASCADE/RESTRICT doesn't matter for indexes - when a column is dropped, it is removed from any indexes which contain it. - if that column was the only column in the index, the entire index is dropped. 
 * @param columnName the name of the column specfication in the ALTER statement-- currently we allow only one.
 * @exception StandardException 	thrown on failure.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [cascade=(behavior == StatementType.DROP_CASCADE)]</InnerVar>
                <InnerVar>ColumnDescriptorList [generatedColumnList=td.getGeneratedColumns()]</InnerVar>
                <InnerVar>int [generatedColumnCount=generatedColumnList.size()]</InnerVar>
                <InnerVar>ArrayList&lt;String&gt; [cascadedDroppedColumns=new ArrayList&lt;String&gt;()]</InnerVar>
                <InnerVar>DataDescriptorGenerator [ddg=dd.getDataDescriptorGenerator()]</InnerVar>
                <InnerVar>int [cascadedDrops=cascadedDroppedColumns.size()]</InnerVar>
                <InnerVar>int [sizeAfterCascadedDrops=td.getColumnDescriptorList().size() - cascadedDrops]</InnerVar>
                <InnerVar>ColumnDescriptor [columnDescriptor=td.getColumnDescriptor(columnName)]</InnerVar>
                <InnerVar>int [size=td.getColumnDescriptorList().size()]</InnerVar>
                <InnerVar>FormatableBitSet [toDrop=new FormatableBitSet(size + 1)]</InnerVar>
                <InnerVar>ConstraintDescriptorList [csdl=dd.getConstraintDescriptors(td)]</InnerVar>
                <InnerVar>int [csdl_size=csdl.size()]</InnerVar>
                <InnerVar>ArrayList&lt;ConstantAction&gt; [newCongloms=new ArrayList&lt;ConstantAction&gt;()]</InnerVar>
                <InnerVar>int [tbr_size=0]</InnerVar>
                <InnerVar>ConstraintDescriptor[] [toBeRemoved=new ConstraintDescriptor[csdl_size]]</InnerVar>
                <InnerVar>ColumnDescriptorList [tab_cdl=td.getColumnDescriptorList()]</InnerVar>
                <InnerVar>ColumnDescriptor[] [cdlArray=new ColumnDescriptor[size - columnDescriptor.getPosition()]]</InnerVar>
                <InnerVar>List&lt;DependencyDescriptor&gt; [depsOnAlterTableList=dd.getProvidersDescriptorList(td.getObjectID().toString())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>toDrop;set;[droppedColumnPosition]</InnerMethodInvoke>
                <InnerMethodInvoke>td;setReferencedColumnMap;[toDrop]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;invalidateFor;[td, (cascade ? DependencyManager.DROP_COLUMN : DependencyManager.DROP_COLUMN_RESTRICT), lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;createNewBackingCongloms;[newCongloms, (long[])null]</InnerMethodInvoke>
                <InnerMethodInvoke>null;compressTable;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;dropColumnDescriptor;[td.getUUID(), columnName, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptorArray;[cdlArray, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateSYSCOLPERMSforDropColumn;[td.getUUID(), tc, columnDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>tab_cdl;remove;[td.getColumnDescriptor(columnName)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnDroppedAndTriggerDependencies</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>trd</ParamName>
                    <ParamType>TriggerDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>spsUUID</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isWhenClause</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cascade</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>SchemaDescriptor [compSchema=dd.getSchemaDescriptor(dd.getSPSDescriptor(spsUUID).getCompSchemaId(),null)]</InnerVar>
                <InnerVar>CompilerContext [newCC=lcc.pushCompilerContext(compSchema)]</InnerVar>
                <InnerVar>Parser [pa=newCC.getParser()]</InnerVar>
                <InnerVar>String [originalSQL=isWhenClause ? trd.getWhenClauseText() : trd.getTriggerDefinition()]</InnerVar>
                <InnerVar>Visitable [node=isWhenClause ? pa.parseSearchCondition(originalSQL) : pa.parseStatement(originalSQL)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropTriggerDescriptor;[trd, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>lcc;popCompilerContext;[newCC]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[trd, sd, DataDictionary.SYSTRIGGERS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyColumnType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ix</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [columnDescriptor=td.getColumnDescriptor(columnInfo[ix].name)]</InnerVar>
                <InnerVar>ColumnDescriptor [newColumnDescriptor=new ColumnDescriptor(columnInfo[ix].name,columnDescriptor.getPosition(),columnInfo[ix].dataType,columnDescriptor.getDefaultValue(),columnDescriptor.getDefaultInfo(),td,columnDescriptor.getDefaultUUID(),columnInfo[ix].autoincStart,columnInfo[ix].autoincInc,columnInfo[ix].autoincCycle)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropColumnDescriptor;[td.getUUID(), columnInfo[ix].name, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[newColumnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyColumnConstraint</MethodName>
            <MethodComment>/** 
 * Workhorse for modifying column level constraints.  Right now it is restricted to modifying a null constraint to a not null constraint.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>colName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullability</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [columnDescriptor=td.getColumnDescriptor(colName)]</InnerVar>
                <InnerVar>DataTypeDescriptor [dataType=columnDescriptor.getType().getNullabilityType(nullability)]</InnerVar>
                <InnerVar>ConstraintDescriptorList [cdl=dd.getConstraintDescriptors(td)]</InnerVar>
                <InnerVar>int [columnPostion=columnDescriptor.getPosition()]</InnerVar>
                <InnerVar>ColumnDescriptor [newColumnDescriptor=new ColumnDescriptor(colName,columnDescriptor.getPosition(),dataType,columnDescriptor.getDefaultValue(),columnDescriptor.getDefaultInfo(),td,columnDescriptor.getDefaultUUID(),columnDescriptor.getAutoincStart(),columnDescriptor.getAutoincInc(),columnDescriptor.getAutoincCycle())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropColumnDescriptor;[td.getUUID(), colName, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[newColumnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyColumnDefault</MethodName>
            <MethodComment>/** 
 * Workhorse for modifying the default value of a column.
 * @param ix 		the index of the column specfication in the ALTER statement-- currently we allow only one.
 * @exception StandardException , thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ix</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [columnDescriptor=td.getColumnDescriptor(columnInfo[ix].name)]</InnerVar>
                <InnerVar>int [columnPosition=columnDescriptor.getPosition()]</InnerVar>
                <InnerVar>UUID [defaultUUID=columnInfo[ix].newDefaultUUID]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropColumnDescriptor;[td.getUUID(), columnInfo[ix].name, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[columnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRangeBound</MethodName>
            <MethodComment>/** 
 * Get the ran max or min range bound for an autoincrement column.
 * @param dtd The type of the autoincrement column.
 * @param topOrBottom RANGE_TOP or RANGE_BOTTOM
 * @return the top or bottom of the range
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dtd</ParamName>
                    <ParamType>DataTypeDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>topOrBottom</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeId [typeId=dtd.getTypeId()]</InnerVar>
                <InnerVar>boolean [bottom=(topOrBottom == RANGE_BOTTOM)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyIdentityState</MethodName>
            <MethodComment>/** 
 * Change an identity from ALWAYS to BY DEFAULT (or vice versa)
 * @param ix 		the index of the column specfication in the ALTER statement-- currently we allow only one.
 * @exception StandardException , thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ix</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ColumnDescriptor [oldColumnDescriptor=td.getColumnDescriptor(columnInfo[ix].name)]</InnerVar>
                <InnerVar>int [columnPosition=oldColumnDescriptor.getPosition()]</InnerVar>
                <InnerVar>boolean [wasGeneratedAlways=oldColumnDescriptor.isAutoincAlways()]</InnerVar>
                <InnerVar>boolean [willBeGeneratedAlways=(columnInfo[ix].action == ColumnInfo.MODIFY_COLUMN_GENERATED_ALWAYS)]</InnerVar>
                <InnerVar>UUID [defaultUUID=willBeGeneratedAlways ? null : dd.getUUIDFactory().createUUID()]</InnerVar>
                <InnerVar>ColumnDescriptor [newColumnDescriptor=new ColumnDescriptor(columnInfo[ix].name,columnPosition,oldColumnDescriptor.getType(),columnInfo[ix].defaultValue,columnInfo[ix].defaultInfo,td,defaultUUID,oldColumnDescriptor.getAutoincStart(),oldColumnDescriptor.getAutoincInc(),ColumnDefinitionNode.MODIFY_AUTOINCREMENT_ALWAYS_VS_DEFAULT,oldColumnDescriptor.getAutoincCycle())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>dd;dropColumnDescriptor;[td.getUUID(), columnInfo[ix].name, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;addDescriptor;[newColumnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressTable</MethodName>
            <MethodComment>/** 
 * routine to process compress table or ALTER TABLE &lt;t&gt; DROP COLUMN &lt;c&gt;; &lt;p&gt; Uses class level variable "compressTable" to determine if processing compress table or drop column: if (!compressTable) must be drop column. &lt;p&gt; Handles rebuilding of base conglomerate and all necessary indexes.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long [newHeapConglom]</InnerVar>
                <InnerVar>Properties [properties=new Properties()]</InnerVar>
                <InnerVar>RowLocation [rl]</InnerVar>
                <InnerVar>ExecRow [emptyHeapRow=td.getEmptyExecRow()]</InnerVar>
                <InnerVar>int[] [collation_ids=td.getColumnCollationIds()]</InnerVar>
                <InnerVar>ScanController [compressHeapSC=tc.openScan(newHeapConglom,false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_SERIALIZABLE,(FormatableBitSet)null,(DataValueDescriptor[])null,0,(Qualifier[][])null,(DataValueDescriptor[])null,0)]</InnerVar>
                <InnerVar>long [oldHeapConglom=td.getHeapConglomerateId()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cd=td.getConglomerateDescriptor(oldHeapConglom)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compressHeapCC;getInternalTablePropertySet;[properties]</InnerMethodInvoke>
                <InnerMethodInvoke>compressHeapCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getAffectedIndexes;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setUpAllSorts;[emptyHeapRow, rl]</InnerMethodInvoke>
                <InnerMethodInvoke>null;openBulkFetchScan;[td.getHeapConglomerateId()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;closeBulkFetchScan;[]</InnerMethodInvoke>
                <InnerMethodInvoke>compressHeapSC;setEstimatedRowCount;[rowCount]</InnerMethodInvoke>
                <InnerMethodInvoke>compressHeapSC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateConglomerateDescriptor;[cd, newHeapConglom, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;invalidateFor;[td, DependencyManager.COMPRESS_TABLE, lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[oldHeapConglom]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanUp;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>truncateTable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ExecRow [emptyHeapRow]</InnerVar>
                <InnerVar>long [newHeapConglom]</InnerVar>
                <InnerVar>Properties [properties=new Properties()]</InnerVar>
                <InnerVar>RowLocation [rl]</InnerVar>
                <InnerVar>long [oldHeapConglom=td.getHeapConglomerateId()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cd=td.getConglomerateDescriptor(oldHeapConglom)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compressHeapCC;getInternalTablePropertySet;[properties]</InnerMethodInvoke>
                <InnerMethodInvoke>compressHeapCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;getAffectedIndexes;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;startWriting;[lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateConglomerateDescriptor;[cd, newHeapConglom, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;invalidateFor;[td, DependencyManager.TRUNCATE_TABLE, lcc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[oldHeapConglom]</InnerMethodInvoke>
                <InnerMethodInvoke>null;cleanUp;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateAllIndexes</MethodName>
            <MethodComment>/** 
 * Update all of the indexes on a table when doing a bulk insert on an empty table.
 * @exception StandardException					thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newHeapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long[] [newIndexCongloms=new long[numIndexes]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newHeapConglom</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newIndexCongloms</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Properties [properties=new Properties()]</InnerVar>
                <InnerVar>ConglomerateDescriptor [cd=td.getConglomerateDescriptor(indexConglomerateNumbers[index])]</InnerVar>
                <InnerVar>ConglomerateController [indexCC=tc.openConglomerate(indexConglomerateNumbers[index],false,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_SERIALIZABLE)]</InnerVar>
                <InnerVar>int [indexRowLength=indexRows[index].nColumns()]</InnerVar>
                <InnerVar>RowLocationRetRowSource [cCount]</InnerVar>
                <InnerVar>boolean [statisticsExist=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>indexCC;getInternalTablePropertySet;[properties]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["baseConglomerateId", Long.toString(newHeapConglom)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["rowLocationColumn", Integer.toString(indexRowLength - 1)]</InnerMethodInvoke>
                <InnerMethodInvoke>properties;put;["nKeyFields", Integer.toString(indexRowLength)]</InnerMethodInvoke>
                <InnerMethodInvoke>indexCC;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>dd;updateConglomerateDescriptor;[td.getConglomerateDescriptors(indexConglomerateNumbers[index]), newIndexCongloms[index], tc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;dropConglomerate;[indexConglomerateNumbers[index]]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAffectedIndexes</MethodName>
            <MethodComment>/** 
 * Get info on the indexes on the table being compressed. 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>IndexLister [indexLister=td.getIndexLister()]</InnerVar>
                <InnerVar>Object[] [compressIndexResult=compressIndexArrays(indexConglomerateNumbers,compressIRGs)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createNewBackingCongloms</MethodName>
            <MethodComment>/** 
 * Iterate through the received list of CreateIndexConstantActions and execute each one, It's possible that one or more of the constant actions in the list has been rendered "unneeded" by the time we get here (because the index that the constant action was going to create is no longer needed), so we have to check for that.
 * @param newConglomActions Potentially empty list of constant actionsto execute, if still needed
 * @param ixCongNums Optional array of conglomerate numbers; if non-nullthen any entries in the array which correspond to a dropped physical conglomerate (as determined from the list of constant actions) will be updated to have the conglomerate number of the newly-created physical conglomerate.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newConglomActions</ParamName>
                    <ParamType>ConstantAction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ixCongNums</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [sz=newConglomActions.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setUpAllSorts</MethodName>
            <MethodComment>/** 
 * Set up to update all of the indexes on a table when doing a bulk insert on an empty table.
 * @exception StandardException					thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sourceRow</ParamName>
                    <ParamType>ExecRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getValidColumns</MethodName>
            <MethodComment>/** 
 * @see RowSource#getValidColumns
 */
</MethodComment>
            <ReturnType>FormatableBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextRowFromRowSource</MethodName>
            <MethodComment>/** 
 * @see RowSource#getNextRowFromRowSource
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>DataValueDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsToClone</MethodName>
            <MethodComment>/** 
 * @see RowSource#needsToClone
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeRowSource</MethodName>
            <MethodComment>/** 
 * @see RowSource#closeRowSource
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsRowLocation</MethodName>
            <MethodComment>/** 
 * @see RowLocationRetRowSource#needsRowLocation
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsRowLocationForDeferredCheckConstraints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rowLocation</MethodName>
            <MethodComment>/** 
 * @see RowLocationRetRowSource#rowLocation
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objectifyStreamingColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>insertIntoSorter</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>indexRows[index];getNewObjectArray;[]</InnerMethodInvoke>
                <InnerMethodInvoke>compressIRGs[index];getIndexRow;[currentRow, (RowLocation)rl.cloneValue(false), indexRows[index], (FormatableBitSet)null]</InnerMethodInvoke>
                <InnerMethodInvoke>sorters[index];insert;[indexRows[index].getRowArray()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanUp</MethodName>
            <MethodComment>/** 
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSemiRowCount</MethodName>
            <MethodComment>/** 
 * Return the "semi" row count of a table.  We are only interested in whether the table has 0, 1 or &amp;gt; 1 rows.
 * @return Number of rows (0, 1 or &amp;gt; 1) in table.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [numRows=0]</InnerVar>
                <InnerVar>ScanController [sc=tc.openScan(td.getHeapConglomerateId(),false,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_SERIALIZABLE,RowUtil.EMPTY_ROW_BITSET,null,ScanController.GE,null,null,ScanController.GT)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sc;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateNewColumnToDefault</MethodName>
            <MethodComment>/** 
 * Update a new column with its default. We could do the scan ourself here, but instead we get a nested connection and issue the appropriate update statement.
 * @param columnDescriptor  catalog descriptor for the column
 * @exception StandardException if update to default fails
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnDescriptor</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [columnName=columnDescriptor.getColumnName()]</InnerVar>
                <InnerVar>String [updateStmt="UPDATE " + IdUtil.mkQualifiedName(td.getSchemaName(),td.getName()) + " SET "+ IdUtil.normalToDelimited(columnName)+ "=DEFAULT"]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>AlterTableConstantAction;executeUpdate;[lcc, updateStmt]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>executeUpdate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>updateStmt</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PreparedStatement [ps=lcc.prepareInternalStatement(updateStmt)]</InnerVar>
                <InnerVar>ResultSet [rs=ps.executeSubStatement(lcc,true,0L)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnMax</MethodName>
            <MethodComment>/** 
 * computes the minimum/maximum value in a column of a table.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>td</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>increment</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [maxStr=(increment &gt; 0) ? "MAX" : "MIN"]</InnerVar>
                <InnerVar>String [maxStmt="SELECT  " + maxStr + "("+ IdUtil.normalToDelimited(columnName)+ ") FROM "+ IdUtil.mkQualifiedName(td.getSchemaName(),td.getName())]</InnerVar>
                <InnerVar>PreparedStatement [ps=lcc.prepareInternalStatement(maxStmt)]</InnerVar>
                <InnerVar>ResultSet [rs=ps.executeSubStatement(lcc,false,0L)]</InnerVar>
                <InnerVar>DataValueDescriptor[] [rowArray=rs.getNextRow().getRowArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rs;close;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rs;finish;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>openBulkFetchScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>heapConglomNumber</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>closeBulkFetchScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>compressHeapGSC;close;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateNotNullConstraint</MethodName>
            <MethodComment>/** 
 * Make sure that the columns are non null If any column is nullable, check that the data is null.
 * @param columnNames	names of columns to be checked
 * @param nullCols	true if corresponding column is nullable
 * @param numRows		number of rows in the table
 * @param lcc		language context
 * @param errorMsg	error message to use for exception
 * @return true if any nullable columns found (nullable columns must haveall non null data or exception is thrown
 * @exception StandardException on error 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>nullCols</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>numRows</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>errorMsg</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [foundNullable=false]</InnerVar>
                <InnerVar>StringBuilder [constraintText=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compressIndexArrays</MethodName>
            <MethodComment>/** 
 * Get rid of duplicates from a set of index conglomerate numbers and index descriptors.
 * @param indexCIDS	array of index conglomerate numbers
 * @param irgs		array of index row generaters
 * @return value:		If no duplicates, returns NULL; otherwise,a size-3 array of objects, first element is an array of duplicates' indexes in the input arrays; second element is the compact indexCIDs; third element is the compact irgs.
 */
</MethodComment>
            <ReturnType>Object[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>indexCIDS</ParamName>
                    <ParamType>long[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>irgs</ParamName>
                    <ParamType>IndexRowGenerator[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long[] [workSpace=new long[indexCIDS.length]]</InnerVar>
                <InnerVar>int [j=0, k=indexCIDS.length - 1]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>offendingRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containdId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>