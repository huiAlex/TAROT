<Class>
    <Id>107</Id>
    <Package>org.apache.derby.iapi.sql.depend</Package>
    <ClassName>DependencyManager</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>DependencyManager  /** 
 * Dependency Manager Interface &lt;p&gt; The dependency manager tracks needs that dependents have of providers. This is a general purpose interface which is associated with a DataDictinary object; infact the dependencymanager is really the datadictionary keeping track of dependencies between objects that it handles (descriptors) as well as prepared statements. &lt;p&gt; The primary example of this is a prepared statement's needs of  schema objects such as tables. &lt;p&gt; Dependencies are used so that we can determine when we need to recompile a statement; compiled statements depend on schema objects like tables and constraints, and may no longer be executable when those tables or constraints are altered. For example, consider an insert statement. &lt;p&gt; An insert statement is likely to have dependencies on the table it inserts into, any tables it selects from (including subqueries), the authorities it uses to do this, and any constraints or triggers it needs to check. &lt;p&gt; A prepared insert statement has a dependency on the target table  of the insert. When it is compiled, that dependency is registered  from the prepared statement on the data dictionary entry for the table. This dependency is added to the prepared statement's dependency list, which is also accessible from an overall dependency pool. &lt;p&gt; A DDL statement will mark invalid any prepared statement that depends on the schema object the DDL statement is altering or dropping.  We tend to want to track at the table level rather than the column or constraint level, so that we are not overburdened with dependencies.  This does mean that we may invalidate when in fact we do not need to; for example, adding a column to a table may not actually cause an insert statement compiled for that table to stop working; but our level of granularity may force us to invalidate the insert because it has to invalidate all statements that depend on the table due to some of them actually no longer being valid. It is up to the user of the dependency system at what granularity to track dependencies, where to hang them, and how to identify when objects become invalid.  The dependency system is basically supplying the ability to find out who is interested in knowing about other, distinct operations.  The primary user is the language system, and its primary use is for invalidating prepared statements when DDL occurs. &lt;p&gt; The insert will recompile itself when its next execution is requested (not when it is invalidated). We don't want it to recompile when the DDL is issued, as that would increase the time of execution of the DDL command unacceptably.  Note that the DDL  command is also allowed to proceed even if it would make the  statement no longer compilable.  It can be useful to have a way to recompile invalid statements during idle time in the system, but our first implementation will simply recompile at the next execution. &lt;p&gt; The start of a recompile will release the connection to all dependencies when it releases the activation class and  generates a new one. &lt;p&gt; The Dependency Manager is capable of storing dependencies to ensure that other D.M.s can see them and invalidate them appropriately. The dependencies in memory only the current D.M. can see; the stored dependencies are visible to other D.M.s once the transaction in which they were stored is committed. &lt;p&gt; REVISIT: Given that statements are compiled in a separate top-transaction from their execution, we may need/want some intermediate memory storage that makes the dependencies visible to all D.M.s in the system, without requiring that they be stored. &lt;p&gt; To ensure that dependencies are cleaned up when a statement is undone, the compiler context needs to keep track of what dependent it was creating dependencies for, and if it is informed of a statement exception that causes it to throw out the statement it was compiling, it should also call the dependency manager to have the dependencies removed. &lt;p&gt; Several expansions of the basic interface may be desirable: &lt;ul&gt; &lt;li&gt; to note a type of dependency, and to invalidate or perform an invalidation action based on dependency type &lt;li&gt; to note a type of invalidation, so the revalidation could  actually take some action other than recompilation, such as  simply ensuring the provider objects still existed. &lt;li&gt; to control the order of invalidation, so that if (for example) the invalidation action actually includes the revalidation attempt, revalidation is not attempted until all invalidations have occurred. &lt;li&gt; to get a list of dependencies that a Dependent or  a Provider has (this is included in the above, although the basic system does not need to expose the list). &lt;li&gt; to find out which of the dependencies for a dependent were marked  invalid. &lt;/ul&gt; &lt;p&gt; To provide a simple interface that satisfies the basic need, and yet supply more advanced functionality as well, we will present the simple functionality as defaults and provide ways to specify the more advanced functionality. &lt;pre&gt; interface Dependent { boolean isValid(); InvalidType getInvalidType(); // returns what it sees // as the "most important" // of its invalid types. void makeInvalid( ); void makeInvalid( DependencyType dt, InvalidType it ); void makeValid(); } interface Provider() { } interface Dependency() { Provider getProvider(); Dependent getDependent(); DependencyType getDependencyType(); boolean isValid(); InvalidType getInvalidType(); // returns what it sees // as the "most important" // of its invalid types. } interface DependencyManager() { void addDependency(Dependent d, Provider p, ContextManager cm); void invalidateFor(Provider p); void invalidateFor(Provider p, DependencyType dt, InvalidType it); void clearDependencies(Dependent d); void clearDependencies(Dependent d, DependencyType dt); Enumeration getProviders (Dependent d); Enumeration getProviders (Dependent d, DependencyType dt); Enumeration getInvalidDependencies (Dependent d,  DependencyType dt, InvalidType it); Enumeration getDependents (Provider p); Enumeration getDependents (Provider p, DependencyType dt); Enumeration getInvalidDependencies (Provider p,  DependencyType dt, InvalidType it); } &lt;/pre&gt; &lt;p&gt; The simplest things for DependencyType and InvalidType to be are  integer id's or strings, rather than complex objects. &lt;p&gt; In terms of ensuring that no makeInvalid calls are made until we have  identified all objects that could be, so that the calls will be made  from "leaf" invalid objects (those not in turn relied on by other  dependents) to dependent objects upon which others depend, the  dependency manager will need to maintain an internal queue of  dependencies and make the calls once it has completes its analysis  of the dependencies of which it is aware.  Since it is much simpler  and potentially faster for makeInvalid calls to be made as soon as the dependents are identified, separate implementations may be called for, or separate interfaces to trigger the different styles of invalidation. &lt;p&gt; In terms of separate interfaces, the DependencyManager might have two methods, &lt;pre&gt; void makeInvalidImmediate(); void makeInvalidOrdered(); &lt;/pre&gt; or a flag on the makeInvalid method to choose the style to use. &lt;p&gt; In terms of separate implementations, the ImmediateInvalidate manager might have simpler internal structures for  tracking dependencies than the OrderedInvalidate manager. &lt;p&gt; The language system doesn't tend to suffer from this ordering problem, as it tends to handle the impact of invalidation by simply deferring recompilation until the next execution.  So, a prepared statement might be invalidated several times by a transaction that contains several DDL operations, and only recompiled once, at its next  execution.  This is sufficient for the common use of a system, where DDL changes tend to be infrequent and clustered. &lt;p&gt; There could be ways to push this "ordering problem" out of the  dependency system, but since it knows when it starts and when it finished finding all of the invalidating actions, it is likely the best home for this. &lt;p&gt; One other problem that could arise is multiple invalidations occurring one after another.  The above design of the dependency system can  really only react to each invalidation request as a unit, not  to multiple invalidation requests. &lt;p&gt; Another extension that might be desired is for the dependency manager to provide for cascading invalidations -- that is, if it finds and marks one Dependent object as invalid, if that object can also be a provider, to look for its dependent objects and cascade the dependency on to them.  This can be a way to address the  multiple-invalidation request need, if it should arise.  The simplest way to do this is to always cascade the same invalidation type; otherwise, dependents need to be able to say what a certain type of invalidation type gets changed to when it is handed on. &lt;p&gt; The basic language system does not need support for cascaded  dependencies -- statements do not depend on other statements in a way that involves the dependency system. &lt;p&gt; I do not know if it would be worthwhile to consider using the  dependency manager to aid in the implementation of the SQL DROP statements or not. Past implementations of database systems have not used the dependency system to implement this functionality, but have instead hard-coded the lookups like so: &lt;pre&gt; in DropTable: scan the TableAuthority table looking for authorities on this table; drop any that are found. scan the ColumnAuthority table looking for authorities on this table; drop any that are found. scan the View table looking for views on this table; drop any that are found. scan the Column table looking for rows for columns of this table; drop any that are found. scan the Constraint table looking for rows for constraints of this table; drop any that are found. scan the Index table looking for rows for indexes of this table; drop the indexes, and any rows that are found. drop the table's conglomerate drop the table's row in the Table table. &lt;/pre&gt; &lt;p&gt; The direct approach such as that outlined in the example will probably be quicker and is definitely "known technology" over the use of a dependency system in this area.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>COMPILE_FAILED</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_TABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ROLLBACK</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CHANGED_CURSOR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_METHOD_ALIAS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_VIEW</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_VIEW</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PREPARED_STATEMENT_RELEASE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>ALTER_TABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_SPS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>USER_RECOMPILE_REQUEST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>BULK_INSERT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_JAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REPLACE_JAR</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SET_CONSTRAINTS_ENABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SET_CONSTRAINTS_DISABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_CONSTRAINT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>INTERNAL_RECOMPILE_REQUEST</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_TRIGGER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>CREATE_TRIGGER</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SET_TRIGGERS_ENABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>SET_TRIGGERS_DISABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MODIFY_COLUMN_DEFAULT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_SCHEMA</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>COMPRESS_TABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RENAME</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_COLUMN</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_STATISTICS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>UPDATE_STATISTICS</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RENAME_INDEX</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>TRUNCATE_TABLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_SYNONYM</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REVOKE_PRIVILEGE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REVOKE_PRIVILEGE_RESTRICT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_COLUMN_RESTRICT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>REVOKE_ROLE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>RECHECK_PRIVILEGES</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_SEQUENCE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_UDT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>DROP_AGGREGATE</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>MAX_ACTION_CODE</FieldName>
            <FieldType>int</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>addDependency</MethodName>
            <MethodComment>/** 
 * adds a dependency from the dependent on the provider. This will be considered to be the default type of dependency, when dependency types show up. &lt;p&gt; Implementations of addDependency should be fast -- performing alot of extra actions to add a dependency would be a detriment.
 * @param d	the dependent
 * @param p	the provider
 * @param cm	Current ContextManager
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invalidateFor</MethodName>
            <MethodComment>/** 
 * mark all dependencies on the named provider as invalid. When invalidation types show up, this will use the default invalidation type. The dependencies will still exist once they are marked invalid; clearDependencies should be used to remove dependencies that a dependent has or provider gives. &lt;p&gt; Implementations of this can take a little time, but are not really expected to recompile things against any changes made to the provider that caused the invalidation. The dependency system makes no guarantees about the state of the provider -- implementations can call this before or after actually changing the provider to its new state. &lt;p&gt; Implementations should throw DependencyStatementException if the invalidation should be disallowed.
 * @param p the provider
 * @param action	The action causing the invalidate
 * @param lcc		The LanguageConnectionContext
 * @exception StandardException thrown if unable to make it invalid
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Provider</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDependencies</MethodName>
            <MethodComment>/** 
 * Erases all of the dependencies the dependent has, be they valid or invalid, of any dependency type.  This action is usually performed as the first step in revalidating a dependent; it first erases all the old dependencies, then revalidates itself generating a list of new dependencies, and then marks itself valid if all its new dependencies are valid. &lt;p&gt; There might be a future want to clear all dependencies for a particular provider, e.g. when destroying the provider. However, at present, they are assumed to stick around and it is the responsibility of the dependent to erase them when revalidating against the new version of the provider. &lt;p&gt; clearDependencies will delete dependencies if they are stored; the delete is finalized at the next commit.
 * @param lcc	Compiler state
 * @param d the dependent
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearInMemoryDependency</MethodName>
            <MethodComment>/** 
 * Clear the specified in memory dependency. This is useful for clean-up when an exception occurs. (We clear all in-memory dependencies added in the current StatementContext.) This method will handle Dependency's that have already been removed from the DependencyManager.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dy</ParamName>
                    <ParamType>Dependency</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPersistentProviderInfos</MethodName>
            <MethodComment>/** 
 * Get a new array of ProviderInfos representing all the persistent providers for the given dependent.
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>ProviderInfo[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dependent</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getPersistentProviderInfos</MethodName>
            <MethodComment>/** 
 * Get a new array of ProviderInfos representing all the persistent providers from the given list of providers.
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>ProviderInfo[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pl</ParamName>
                    <ParamType>ProviderList</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearColumnInfoInProviders</MethodName>
            <MethodComment>/** 
 * Clear the in memory column bit map information in any table descriptor provider in a provider list.  This function needs to be called before the table descriptor is reused as provider in column dependency.  For example, this happens in "create publication" statement with target-only DDL where more than one views are defined and they all reference one table.
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pl</ParamName>
                    <ParamType>ProviderList</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyDependencies</MethodName>
            <MethodComment>/** 
 * Copy dependencies from one dependent to another.
 * @param copy_From the dependent to copy from	
 * @param copyTo the dependent to copy to
 * @param persistentOnly only copy persistent dependencies
 * @param cm			Current ContextManager
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>copy_From</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copyTo</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>persistentOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getActionString</MethodName>
            <MethodComment>/** 
 * Returns a string representation of the SQL action, hence no need to internationalize, which is causing the invokation of the Dependency Manager.
 * @param action		The action
 * @return String	The String representation
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>action</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countDependencies</MethodName>
            <MethodComment>/** 
 * Count the number of active dependencies, both stored and in memory, in the system.
 * @return int		The number of active dependencies in the system.
 * @exception StandardException thrown if something goes wrong
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clearDependencies</MethodName>
            <MethodComment>/** 
 * Erases all of the dependencies the dependent has, be they valid or invalid, of any dependency type.  This action is usually performed as the first step in revalidating a dependent; it first erases all the old dependencies, then revalidates itself generating a list of new dependencies, and then marks itself valid if all its new dependencies are valid. &lt;p&gt; There might be a future want to clear all dependencies for a particular provider, e.g. when destroying the provider. However, at present, they are assumed to stick around and it is the responsibility of the dependent to erase them when revalidating against the new version of the provider. &lt;p&gt; clearDependencies will delete dependencies if they are stored; the delete is finalized at the next commit.
 * @param lcc	Compiler state
 * @param d the dependent
 * @param tc transaction controller
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lcc</ParamName>
                    <ParamType>LanguageConnectionContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>d</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>copyDependencies</MethodName>
            <MethodComment>/** 
 * Copy dependencies from one dependent to another.
 * @param copy_From the dependent to copy from	
 * @param copyTo the dependent to copy to
 * @param persistentOnly only copy persistent dependencies
 * @param cm			Current ContextManager
 * @param tc            Transaction Controller
 * @exception StandardException		Thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>copy_From</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>copyTo</ParamName>
                    <ParamType>Dependent</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>persistentOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>