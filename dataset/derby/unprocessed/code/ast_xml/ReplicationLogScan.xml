<Class>
    <Id>1567</Id>
    <Package>org.apache.derby.impl.store.replication.slave</Package>
    <ClassName>ReplicationLogScan</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ReplicationLogScan  /** 
 * &lt;p&gt; Scan a chunk of log received from the master. The log chunk (byte[] logToScan) is assumed to always contain (an unknown) number of complete log records. If the last log record is incomplete, something is wrong. This will raise a StandardException, and will probably mean that replication has to be aborted. That decision is not made here, though. &lt;/p&gt; &lt;p&gt; When a new chunk of log records is to be scanned, ReplicationLogScan is initialized by calling init(...). Every time next() is called after that, ReplicationLogScan reads a new log record from logToScan. If next() returns true, the next log record was successfully read. The information in this last read log record either indicates that a log file switch has taken place on the master (isLogSwitch() = true) or it is a normal log record which information can be retrieved by using the get-methods (if isLogRecord() = true). &lt;/p&gt; &lt;p&gt; Threads: The class does not provide thread synchronization since it is assumed that only one thread will be receiving and applying log per replicated database when in slave mode. Since a ReplicationLogScan object belongs to only one slave database, this means that only one thread will access the object. &lt;/p&gt; &lt;p&gt; The format of the log chunk byte[] is defined in  org.apache.derby.impl.store.raw.log.LogAccessFile &lt;/p&gt;
 * @see org.apache.derby.impl.store.raw.log.LogAccessFile
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>logToScan</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>currentPosition</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentInstant</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>currentDataOffset</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>currentData</FieldName>
            <FieldType>byte[]</FieldType>
        </Field>
        <Field>
            <FieldName>hasInfo</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isLogSwitch</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ReplicationLogScan</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * Set all variables to default values, and makes logToScan the byte[] that will be scanned for log records.
 * @param logToScan A chunk of log records received from themaster
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>logToScan</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>next</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Read the next log record in logToScan. The information in this log record can be read by using the getXXX methods. &lt;/p&gt; &lt;p&gt; Side effects: &lt;br&gt; &lt;br&gt; On a successful read (return true): either...&lt;br&gt; &lt;br&gt; ... the scan read a log record indicating that a log file switch has taken place on the master, in which case isLogFileSwitch() returns true. In this case, getXXX will not contain valid data. Asserts handle calls to these methods when in sane mode. currentPosition is updated to point to the byte immediately following this log file switch log record.&lt;br&gt; &lt;br&gt; ... or the scan read a normal log record, in which case isLogRecord() returns true. Also sets currentInstant and currentData, and updates currentPosition to point to the byte immediatly following the log record. In this case, getXXX will return meaningful information about the log record. &lt;/p&gt; &lt;p&gt; If there are no more log records in logToScan (returns false) or a problem occurs (throws StandardException): setting hasInfo = false &lt;/p&gt;
 * @return true if a log record was successfully read, false if endof logToScan has been reached.
 * @throws StandardException if logToScan is found to be corrupted.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getInstant</MethodName>
            <MethodComment>/** 
 * @return The instant of the log record read by the last call tonext(). Only returns meaningful information if isLogRecord() returns true.
 * @throws NoSuchElementException if next() has not been called orif there are no more log records in this chunk of log. Should never be thrown unless ReplicationLogScan is used in a wrong way.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDataLength</MethodName>
            <MethodComment>/** 
 * @return The number of bytes in the byte[] returned by getData()for the log record read by the last call to next(). Only returns meaningful information if isLogRecord() returns true.
 * @throws NoSuchElementException if next() has not been called orif there are no more log records in this chunk of log. Should never be thrown unless ReplicationLogScan is used in a wrong way.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getData</MethodName>
            <MethodComment>/** 
 * Method to get the data byte[] read by the last call to next(). Note that this byte[] contains both byte[] data and byte[] optional_data from LogAccessFile. To split this byte[] into data and optional_data, we would need to create a Loggable object from it because the log does not provide information on where to split. There is no need to split since this byte[] will only be written to the slave log anyway. If it was split, LogAccessFile would simply merge them when writing to file.
 * @return The byte[] containing data+optional_data of the logrecord read by the last call to next(). Only returns meaningful information if isLogRecord() returns true.
 * @throws NoSuchElementException if next() has not been called orif there are no more log records in this chunk of log. Should never be thrown unless ReplicationLogScan is used in a wrong way.
 */
</MethodComment>
            <ReturnType>byte[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasValidInformation</MethodName>
            <MethodComment>/** 
 * Used to determine whether or not the last call to next() was successful.
 * @return true if next() has been called and the end of the logchunk has not yet been reached. Returns the same answer as the last call to next() did. Use isLogFileSwitch() and isLogRecord() to find out if the current log record indicates a log file switch or is a normal log record.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLogRecord</MethodName>
            <MethodComment>/** 
 * Used to determine whether the last call to next() read a log record
 * @return true if the last call to next() found a normal logrecord.
 * @throws NoSuchElementException if next() has not been called orif there are no more log records in this chunk of log. Should never be thrown unless ReplicationLogScan is used in a wrong way.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isLogFileSwitch</MethodName>
            <MethodComment>/** 
 * Used to determine whether the last call to next() found a log file switch
 * @return true if the last call to next() found a log recordindicating a log file switch has taken place on the master.
 * @throws NoSuchElementException if next() has not been called orif there are no more log records in this chunk of log. Should never be thrown unless ReplicationLogScan is used in a wrong way.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>NoSuchElementException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>retrieveBytes</MethodName>
            <MethodComment>/** 
 * Copy length number of bytes from logToScan into readInto. Starts to copy from currentPosition. Also increments currentPosition by length.
 * @param readInto The byte[] copied to
 * @param length The number of bytes copied from logToScan to readInto
 * @throws StandardException if there are less then length bytesleft to read in logToScan, meaning that the chunk of log is corrupt.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>readInto</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>length</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>retrieveInt</MethodName>
            <MethodComment>/** 
 * Read an int from logToScan. Also increments currentPosition by 4 (the number of bytes in an int).
 * @return an int read from logToScan
 * @throws StandardException if there are less then 4 bytes leftto read in logToScan, meaning that the chunk of log is corrupt.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>retrieveLong</MethodName>
            <MethodComment>/** 
 * Read a long from logToScan. Also increments currentPosition by 8 (the number of bytes in a long).
 * @return a long read from logToScan
 * @throws StandardException if there are less then 8 bytes leftto read in logToScan, meaning that the chunk of log is corrupt.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>