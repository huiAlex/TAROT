<Class>
    <Id>873</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>ResultSetNode</ClassName>
    <SuperClass>QueryTreeNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ResultSetNode  /** 
 * A ResultSetNode represents a result set, that is, a set of rows.  It is analogous to a ResultSet in the LanguageModuleExternalInterface.  In fact, code generation for a a ResultSetNode will create a "new" call to a constructor for a ResultSet.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>resultSetNumber</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>referencedTableMap</FieldName>
            <FieldType>JBitSet</FieldType>
        </Field>
        <Field>
            <FieldName>resultColumns</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>statementResultSet</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>cursorTargetTable</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>insertSource</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>costEstimate</FieldName>
            <FieldType>CostEstimate</FieldType>
        </Field>
        <Field>
            <FieldName>scratchCostEstimate</FieldName>
            <FieldType>CostEstimate</FieldType>
        </Field>
        <Field>
            <FieldName>optimizer</FieldName>
            <FieldType>Optimizer</FieldType>
        </Field>
        <Field>
            <FieldName>candidateFinalCostEstimate</FieldName>
            <FieldType>CostEstimate</FieldType>
        </Field>
        <Field>
            <FieldName>obl</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>obl</FieldName>
            <FieldType>OrderByList</FieldType>
        </Field>
        <Field>
            <FieldName>offset</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>offset</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>fetchFirst</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>fetchFirst</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>hasJDBCLimitClause</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>hasJDBCLimitClause</FieldName>
            <FieldType>Boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ResultSetNode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return  This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isStatementResultSet</MethodName>
            <MethodComment>/** 
 * Return true if this is a statement result set 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isCursorTargetTable</MethodName>
            <MethodComment>/** 
 * Return true if this is a cursor target table 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCursorTargetTable</MethodName>
            <MethodComment>/** 
 * Set whether this is a cursor target table 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>yesOrNo</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getScratchCostEstimate</MethodName>
            <MethodComment>/** 
 * Get the scratch estimate 
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setScratchCostEstimate</MethodName>
            <MethodComment>/** 
 * Set the scratch estimate 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultSetNumber</MethodName>
            <MethodComment>/** 
 * Get the resultSetNumber in this ResultSetNode. Expected to be set during generate(). Must be public in order to satisfy the Optimizable contract.
 * @return int 	The resultSetNumber.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultSetNumber</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rsn</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCostEstimate</MethodName>
            <MethodComment>/** 
 * Get the CostEstimate for this ResultSetNode.
 * @return	The CostEstimate for this ResultSetNode.
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCostEstimate</MethodName>
            <MethodComment>/** 
 * Set the CostEstimate for this ResultSetNode 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFinalCostEstimate</MethodName>
            <MethodComment>/** 
 * Get the final CostEstimate for this ResultSetNode.
 * @return	The final CostEstimate for this ResultSetNode.
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCandidateFinalCostEstimate</MethodName>
            <MethodComment>/** 
 * Get the final cost estimate which we've set so far 
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setCandidateFinalCostEstimate</MethodName>
            <MethodComment>/** 
 * Set the final cost estimate 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>CostEstimate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>assignResultSetNumber</MethodName>
            <MethodComment>/** 
 * Assign the next resultSetNumber to the resultSetNumber in this ResultSetNode.  Expected to be done during generate().
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resultColumns;setResultSetNumber;[resultSetNumber]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindNonVTITables</MethodName>
            <MethodComment>/** 
 * Bind the non VTI tables in this ResultSetNode.  This includes getting their descriptors from the data dictionary and numbering them.
 * @param dataDictionary	The DataDictionary to use for binding
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindVTITables</MethodName>
            <MethodComment>/** 
 * Bind the VTI tables in this ResultSetNode.  This includes getting their descriptors from the data dictionary and numbering them.
 * @param fromListParam		FromList to use/append to.
 * @return	ResultSetNode
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressions</MethodName>
            <MethodComment>/** 
 * Bind the expressions in this ResultSetNode.  This means binding the sub-expressions, as well as figuring out what the return type is for each expression.
 * @param fromListParam		FromList to use/append to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindExpressionsWithTables</MethodName>
            <MethodComment>/** 
 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the sub-expressions, as well as figuring out what the return type is for each expression.
 * @param fromListParam		FromList to use/append to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindTargetExpressions</MethodName>
            <MethodComment>/** 
 * Bind the expressions in the target list.  This means binding the sub-expressions, as well as figuring out what the return type is for each expression.  This is useful for EXISTS subqueries, where we need to validate the target list before blowing it away and replacing it with a SELECT true.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setTableConstructorTypes</MethodName>
            <MethodComment>/** 
 * Set the type of each parameter in the result column list for this table constructor.
 * @param typeColumns	The ResultColumnList containing the desired resulttypes.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeColumns</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setInsertSource</MethodName>
            <MethodComment>/** 
 * Remember that this node is the source result set for an INSERT.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isInsertSource</MethodName>
            <MethodComment>/** 
 * Return true if this is the source result set for an INSERT 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>verifySelectStarSubquery</MethodName>
            <MethodComment>/** 
 * Verify that a SELECT * is valid for this type of subquery.
 * @param outerFromList	The FromList from the outer query block(s)
 * @param subqueryType	The subquery type
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerFromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>subqueryType</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAllResultColumns</MethodName>
            <MethodComment>/** 
 * Expand "*" into a ResultColumnList with all of the columns in the table's result list.
 * @param allTableName		The qualifier on the "*"
 * @return ResultColumnList The expanded list, or {@code null} if{@code allTableName} is non-null and doesn't match a table name inthis result set
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>allTableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMatchingColumn</MethodName>
            <MethodComment>/** 
 * Try to find a ResultColumn in the table represented by this FromTable that matches the name in the given ColumnReference.
 * @param columnReference	The columnReference whose name we're lookingfor in the given table.
 * @return	A ResultColumn whose expression is the ColumnNodethat matches the ColumnReference. Returns null if there is no match.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnReference</ParamName>
                    <ParamType>ColumnReference</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultToBooleanTrueNode</MethodName>
            <MethodComment>/** 
 * Set the result column for the subquery to a boolean true, Useful for transformations such as changing: where exists (select ... from ...)  to: where (select true from ...) NOTE: No transformation is performed if the ResultColumn.expression is already the correct boolean constant.
 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
 * @return ResultSetNode whose resultColumn was transformed; defaultsto "this" here, but can be overridden by subclasses.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>onlyConvertAlls</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [resultColumn]</InnerVar>
                <InnerVar>BooleanConstantNode [booleanNode=new BooleanConstantNode(true,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resultColumn;setExpression;[booleanNode]</InnerMethodInvoke>
                <InnerMethodInvoke>resultColumn;setType;[booleanNode.getTypeServices()]</InnerMethodInvoke>
                <InnerMethodInvoke>resultColumn;setVirtualColumnId;[1]</InnerMethodInvoke>
                <InnerMethodInvoke>resultColumns;setElementAt;[resultColumn, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromList</MethodName>
            <MethodComment>/** 
 * Get the FromList.  Create and return an empty FromList.  (Subclasses which actuall have FromLists will override this.)  This is useful because there is a FromList parameter to bindExpressions() which is used as the common FromList to bind against, allowing us to support correlation columns under unions in subqueries.
 * @return FromList
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumns</MethodName>
            <MethodComment>/** 
 * Bind the result columns of this ResultSetNode when there is no base table to bind them to.  This is useful for SELECT statements, where the result columns get their types from the expressions that live under them.
 * @param fromListParam		FromList to use/append to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>resultColumns;bindResultColumnsToExpressions;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindResultColumns</MethodName>
            <MethodComment>/** 
 * Bind the result columns for this ResultSetNode to a base table. This is useful for INSERT and UPDATE statements, where the result columns get their types from the table being updated or inserted into. If a result column list is specified, then the verification that the  result column list does not contain any duplicates will be done when binding them by name.
 * @param targetTableDescriptor	The TableDescriptor for the table beingupdated or inserted into
 * @param targetColumnList	For INSERT statements, the userdoes not have to supply column names (for example, "insert into t values (1,2,3)".  When this parameter is null, it means that the user did not supply column names, and so the binding should be done based on order.  When it is not null, it means do the binding by name, not position.
 * @param statement			Calling DMLStatementNode (Insert or Update)
 * @param fromListParam		FromList to use/append to.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTableDescriptor</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetVTI</ParamName>
                    <ParamType>FromVTI</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetColumnList</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>DMLStatementNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromListParam</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindUntypedNullsToResultColumns</MethodName>
            <MethodComment>/** 
 * Bind untyped nulls to the types in the given ResultColumnList. This is used for binding the nulls in row constructors and table constructors.  In all other cases (as of the time of this writing), we do nothing.
 * @param rcl	The ResultColumnList with the types to bind nulls to
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>preprocess</MethodName>
            <MethodComment>/** 
 * Preprocess a ResultSetNode - this currently means: o  Generating a referenced table map for each ResultSetNode. o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF). o  Converting the WHERE and HAVING clauses into PredicateLists and classifying them. o  Ensuring that a ProjectRestrictNode is generated on top of every  FromBaseTable and generated in place of every FromSubquery.   o  Pushing single table predicates down to the new ProjectRestrictNodes.
 * @param numTables			The number of tables in the DML Statement
 * @param gbl				The group by list, if any
 * @param fromList			The from list, if any
 * @return ResultSetNode at top of preprocessed tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>gbl</ParamName>
                    <ParamType>GroupByList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>projectResultColumns</MethodName>
            <MethodComment>/** 
 * Find the unreferenced result columns and project them out.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ensurePredicateList</MethodName>
            <MethodComment>/** 
 * Ensure that the top of the RSN tree has a PredicateList.
 * @param numTables			The number of tables in the query.
 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addNewPredicate</MethodName>
            <MethodComment>/** 
 * Add a new predicate to the list.  This is useful when doing subquery transformations, when we build a new predicate with the left side of the subquery operator and the subquery's result column.
 * @param predicate		The predicate to add
 * @return ResultSetNode	The new top of the tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predicate</ParamName>
                    <ParamType>Predicate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>flattenableInFromSubquery</MethodName>
            <MethodComment>/** 
 * Evaluate whether or not the subquery in a FromSubquery is flattenable.   Currently, a FSqry is flattenable if all of the following are true: o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode) o  It contains no top level subqueries.  (RESOLVE - we can relax this) o  It does not contain a group by or having clause o  It does not contain aggregates.
 * @param fromList	The outer from list
 * @return boolean	Whether or not the FromSubquery is flattenable.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fromList</ParamName>
                    <ParamType>FromList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genProjectRestrictForReordering</MethodName>
            <MethodComment>/** 
 * Get a parent ProjectRestrictNode above us. This is useful when we need to preserve the user specified column order when reordering the columns in the distinct when we combine an order by with a distinct.
 * @return A parent ProjectRestrictNode to do column reordering
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumnList [prRCList=resultColumns]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>prRCList;genVirtualColumnNodes;[this, resultColumns, false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>optimize</MethodName>
            <MethodComment>/** 
 * Optimize a ResultSetNode. This means choosing the best access path for each table under the ResultSetNode, among other things. The only RSNs that need to implement their own optimize() are a  SelectNode and those RSNs that can appear above a SelectNode in the  query tree.  Currently, a ProjectRestrictNode is the only RSN that  can appear above a SelectNode.
 * @param dataDictionary	The DataDictionary to use for optimization
 * @param predicates		The PredicateList to apply.
 * @param outerRows			The number of outer joining rows
 * @return	ResultSetNode	The top of the optimized query tree
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>predicates</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outerRows</ParamName>
                    <ParamType>double</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyAccessPaths</MethodName>
            <MethodComment>/** 
 * Modify the access paths according to the decisions the optimizer made.  This can include adding project/restrict nodes, index-to-base-row nodes, etc.
 * @return	The modified query tree
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>modifyAccessPaths</MethodName>
            <MethodComment>/** 
 * Modify the access paths according to the decisions the optimizer made.  This can include adding project/restrict nodes, index-to-base-row nodes, etc.
 * @param predList A list of optimizable predicates that shouldbe pushed to this ResultSetNode, as determined by optimizer.
 * @return The modified query tree
 * @exception StandardException        Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>predList</ParamName>
                    <ParamType>PredicateList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeResultDescriptors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ResultColumnDescriptor[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>columnTypesAndLengthsMatch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setResultColumns</MethodName>
            <MethodComment>/** 
 * Set the resultColumns in this ResultSetNode
 * @param newRCL		The new ResultColumnList for this ResultSetNode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newRCL</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getResultColumns</MethodName>
            <MethodComment>/** 
 * Get the resultColumns for this ResultSetNode
 * @return ResultColumnList for this ResultSetNode
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setReferencedTableMap</MethodName>
            <MethodComment>/** 
 * Set the referencedTableMap in this ResultSetNode
 * @param newRTM	The new referencedTableMap for this ResultSetNode
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>newRTM</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getReferencedTableMap</MethodName>
            <MethodComment>/** 
 * Get the referencedTableMap for this ResultSetNode. Must be public in order to satisfy the Optimizable contract.
 * @return JBitSet	Referenced table map for this ResultSetNode
 */
</MethodComment>
            <ReturnType>JBitSet</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fillInReferencedTableMap</MethodName>
            <MethodComment>/** 
 * Fill the referencedTableMap with this ResultSetNode.
 * @param passedMap	The table map to fill in.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>passedMap</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rejectParameters</MethodName>
            <MethodComment>/** 
 * Check for (and reject) ? parameters directly under the ResultColumns. This is done for SELECT statements.
 * @exception StandardException		Thrown if a ? parameter founddirectly under a ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rejectXMLValues</MethodName>
            <MethodComment>/** 
 * Check for (and reject) XML values directly under the ResultColumns. This is done for SELECT/VALUES statements.  We reject values in this case because JDBC does not define an XML type/binding and thus there's no standard way to pass such a type back to a JDBC application.
 * @exception StandardException		Thrown if an XML value founddirectly under a ResultColumn
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>renameGeneratedResultNames</MethodName>
            <MethodComment>/** 
 * Rename generated result column names as '1', '2' etc... These will be the result column names seen by JDBC clients.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markStatementResultSet</MethodName>
            <MethodComment>/** 
 * This method is overridden to allow a resultset node to know if it is the one controlling the statement -- i.e., it is the outermost result set node for the statement.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>enhanceRCLForInsert</MethodName>
            <MethodComment>/** 
 * This ResultSet is the source for an Insert.  The target RCL is in a different order and/or a superset of this RCL.  In most cases we will add a ProjectRestrictNode on top of the source with an RCL that matches the target RCL. NOTE - The new or enhanced RCL will be fully bound.
 * @param target            the target node for the insert
 * @param inOrder           are source cols in same order as target cols?
 * @param colMap			int array representation of correspondence betweenRCLs - colmap[i] = -1 -&amp;gt; missing in current RCL colmap[i] = j -&amp;gt; targetRCL(i) &amp;lt;-&amp;gt; thisRCL(j+1)
 * @return a node that replaces this node and whose RCL matches the targetRCL. May return this node if no changes to the RCL are needed, or if the RCL is modified in-place.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>InsertNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inOrder</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colMap</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRCLForInsert</MethodName>
            <MethodComment>/** 
 * Generate an RCL that can replace the original RCL of this node to match the RCL of the target for the insert.
 * @param target the target node for the insert
 * @param colMap int array representation of correspondence betweenRCLs - colmap[i] = -1 -&amp;gt; missing in current RCL colmap[i] = j -&amp;gt; targetRCL(i) &amp;lt;-&amp;gt; thisRCL(j+1)
 * @return an RCL that matches the target RCL
 */
</MethodComment>
            <ReturnType>ResultColumnList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>InsertNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colMap</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [newResultCols=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>int [numTargetColumns=target.resultColumnList.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genNewRCForInsert</MethodName>
            <MethodComment>/** 
 * Generate the RC/expression for an unspecified column in an insert. Use the default if one exists.
 * @param targetTD			Target TableDescriptor if the target is not a VTI, null if a VTI.
 * @param targetVTI         Target description if it is a VTI, null if not a VTI
 * @param columnNumber		The column number
 * @param dataDictionary	The DataDictionary
 * @return	The RC/expression for the unspecified column.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTD</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>targetVTI</ParamName>
                    <ParamType>FromVTI</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>columnNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dataDictionary</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumn [newResultColumn]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newResultColumn;markGeneratedForUnmatchedColumnInInsert;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateProjectRestrictForInsert</MethodName>
            <MethodComment>/** 
 * Generate a ProjectRestrictNode to put on top of this node if it's the source for an insert, and the RCL needs reordering and/or addition of columns in order to match the target RCL.
 * @param target the target node for the insert
 * @param colMap int array representation of correspondence betweenRCLs - colmap[i] = -1 -&amp;gt; missing in current RCL colmap[i] = j -&amp;gt; targetRCL(i) &amp;lt;-&amp;gt; thisRCL(j+1)
 * @return a ProjectRestrictNode whos RCL matches the target RCL
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>target</ParamName>
                    <ParamType>InsertNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colMap</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ResultColumnList [newResultCols=new ResultColumnList(getContextManager())]</InnerVar>
                <InnerVar>int [numTargetColumns=target.resultColumnList.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createGeneratedColumn</MethodName>
            <MethodComment>/** 
 * Create a ResultColumn for a column with a generation clause.
 */
</MethodComment>
            <ReturnType>ResultColumn</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>targetTD</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>colDesc</ParamName>
                    <ParamType>ColumnDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ValueNode [dummy=new UntypedNullConstantNode(getContextManager())]</InnerVar>
                <InnerVar>ResultColumn [newResultColumn=new ResultColumn(colDesc.getType(),dummy,getContextManager())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newResultColumn;setColumnDescriptor;[targetTD, colDesc]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseDefault</MethodName>
            <MethodComment>/** 
 * Parse a default and turn it into a query tree.
 * @param defaultText			Text of Default.
 * @return	The parsed default as a query tree.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>defaultText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Parser [p]</InnerVar>
                <InnerVar>ValueNode [defaultTree]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>String [values="VALUES " + defaultText]</InnerVar>
                <InnerVar>CompilerContext [newCC=lcc.pushCompilerContext()]</InnerVar>
                <InnerVar>Visitable [qt=p.parseStatement(values)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;popCompilerContext;[newCC]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeResultDescription</MethodName>
            <MethodComment>/** 
 * Make a ResultDescription for use in a ResultSet. This is useful when generating/executing a NormalizeResultSet, since it can appear anywhere in the tree.
 * @return	A ResultDescription for this ResultSetNode.
 */
</MethodComment>
            <ReturnType>ResultDescription</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumnDescriptor[] [colDescs=makeResultDescriptors()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isUpdatableCursor</MethodName>
            <MethodComment>/** 
 * Determine if this result set is updatable or not, for a cursor (i.e., is it a cursor-updatable select).  This returns false and we expect selectnode to refine it for further checking.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCursorTargetTable</MethodName>
            <MethodComment>/** 
 * return the target table of an updatable cursor result set. since this is not updatable, just return null.
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markAsCursorTargetTable</MethodName>
            <MethodComment>/** 
 * Mark this ResultSetNode as the target table of an updatable cursor.  Most types of ResultSetNode can't be target tables.
 * @return true if the target table supports positioned updates.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notCursorTargetTable</MethodName>
            <MethodComment>/** 
 * Mark this ResultSetNode as *not* the target table of an updatable cursor.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genProjectRestrict</MethodName>
            <MethodComment>/** 
 * Put a ProjectRestrictNode on top of this ResultSetNode. ColumnReferences must continue to point to the same ResultColumn, so that ResultColumn must percolate up to the new PRN.  However, that ResultColumn will point to a new expression, a VirtualColumnNode,  which points to the FromTable and the ResultColumn that is the source for the ColumnReference.   (The new PRN will have the original of the ResultColumnList and the ResultColumns from that list.  The FromTable will get shallow copies of the ResultColumnList and its ResultColumns.  ResultColumn.expression will remain at the FromTable, with the PRN getting a new  VirtualColumnNode for each ResultColumn.expression.) This is useful for UNIONs, where we want to generate a DistinctNode above the UnionNode to eliminate the duplicates, because DistinctNodes expect their immediate child to be a PRN.
 * @return The generated ProjectRestrictNode atop the original ResultSetNode.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ResultColumnList [prRCList=resultColumns]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>prRCList;genVirtualColumnNodes;[this, resultColumns]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>genProjectRestrict</MethodName>
            <MethodComment>/** 
 * Put a ProjectRestrictNode on top of each FromTable in the FromList. ColumnReferences must continue to point to the same ResultColumn, so that ResultColumn must percolate up to the new PRN.  However, that ResultColumn will point to a new expression, a VirtualColumnNode,  which points to the FromTable and the ResultColumn that is the source for the ColumnReference.   (The new PRN will have the original of the ResultColumnList and the ResultColumns from that list.  The FromTable will get shallow copies of the ResultColumnList and its ResultColumns.  ResultColumn.expression will remain at the FromTable, with the PRN getting a new  VirtualColumnNode for each ResultColumn.expression.) We then project out the non-referenced columns.  If there are no referenced columns, then the PRN's ResultColumnList will consist of a single ResultColumn whose expression is 1.
 * @param numTables			Number of tables in the DML Statement
 * @return The generated ProjectRestrictNode atop the original FromTable.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateNormalizationResultSet</MethodName>
            <MethodComment>/** 
 * Generate the code for a NormalizeResultSet. The call must push two items before calling this method &lt;OL&gt; &lt;LI&gt; pushGetResultSetFactoryExpression &lt;LI&gt; the expression to normalize &lt;/OL&gt;
 * @param acb				The ActivationClassBuilder
 * @param mb				The method to put the generated code in
 * @param resultSetNumber	The result set number for the NRS
 * @param resultDescription	The ERD for the ResultSet
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ActivationClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultSetNumber</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resultDescription</ParamName>
                    <ParamType>ResultDescription</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [erdNumber=acb.addItem(resultDescription)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>mb;push;[resultSetNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[erdNumber]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().rowCount()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[getCostEstimate().getEstimatedCost()]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;push;[false]</InnerMethodInvoke>
                <InnerMethodInvoke>mb;callMethod;[VMOpcode.INVOKEINTERFACE, (String)null, "getNormalizeResultSet", ClassName.NoPutResultSet, 6]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>changeAccessPath</MethodName>
            <MethodComment>/** 
 * The optimizer's decision on the access path for a result set may require the generation of extra result sets.  For example, if it chooses an index for a FromBaseTable, we need an IndexToBaseRowNode above the FromBaseTable (and the FromBaseTable has to change its column list to match the index. This method in the parent class does not generate any extra result sets. It may be overridden in child classes.
 * @return	A ResultSetNode tree modified to do any extra processing forthe chosen access path
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesTarget</MethodName>
            <MethodComment>/** 
 * Search to see if a query references the specifed table name.
 * @param name		Table name (String) to search for.
 * @param baseTable	Whether or not name is for a base table
 * @return	true if found, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>subqueryReferencesTarget</MethodName>
            <MethodComment>/** 
 * Return whether or not this ResultSetNode contains a subquery with a reference to the specified target.
 * @param name	The table name.
 * @return boolean	Whether or not a reference to the table was found.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>baseTable</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOneRowResultSet</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying ResultSet tree will return a single row, at most. This is important for join nodes where we can save the extra next on the right side if we know that it will return at most 1 row.
 * @return Whether or not the underlying ResultSet tree will return a single row.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNotExists</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying ResultSet tree is for a NOT EXISTS join.
 * @return Whether or not the underlying ResultSet tree if for NOT EXISTS.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizerImpl</MethodName>
            <MethodComment>/** 
 * Get the optimizer for this result set.
 * @return If this.optimizer has has already been created by thegetOptimizer() method above, then return it; otherwise, return null.
 */
</MethodComment>
            <ReturnType>OptimizerImpl</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOptimizer</MethodName>
            <MethodComment>/** 
 * Get the optimizer being used on this result set 
 */
</MethodComment>
            <ReturnType>Optimizer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOptimizer</MethodName>
            <MethodComment>/** 
 * Set the optimizer for use on this result set 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>opt</ParamName>
                    <ParamType>Optimizer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNewCostEstimate</MethodName>
            <MethodComment>/** 
 * Get a cost estimate to use for this ResultSetNode.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>CostEstimate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>OptimizerFactory [optimizerFactory=getLanguageConnectionContext().getOptimizerFactory()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment>/** 
 * Accept the visitor for all visitable children of this node.
 * @param v the visitor
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>considerMaterialization</MethodName>
            <MethodComment>/** 
 * Consider materialization for this ResultSet tree if it is valid and cost effective (It is not valid if incorrect results would be returned.)
 * @return Top of the new/same ResultSet tree.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>ResultSetNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>performMaterialization</MethodName>
            <MethodComment>/** 
 * Return whether or not to materialize this ResultSet tree.
 * @return Whether or not to materialize this ResultSet tree.would return valid results.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>outerTables</ParamName>
                    <ParamType>JBitSet</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFromTableByName</MethodName>
            <MethodComment>/** 
 * Determine whether or not the specified name is an exposed name in the current query block.
 * @param name	The specified name to search for as an exposed name.
 * @param schemaName	Schema name, if non-null.
 * @param exactMatch	Whether or not we need an exact match on specified schema and tablenames or match on table id.
 * @return The FromTable, if any, with the exposed name.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>FromTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>schemaName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>exactMatch</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>decrementLevel</MethodName>
            <MethodComment>/** 
 * Decrement (query block) level (0-based) for  all of the tables in this ResultSet tree. This is useful when flattening a subquery.
 * @param decrement	The amount to decrement by.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>decrement</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushOrderByList</MethodName>
            <MethodComment>/** 
 * Push the order by list down from the cursor node into its child result set so that the optimizer has all of the information that it needs to  consider sort avoidance. Presumes a new level has been initialized by  {@link #pushQueryExpressionSuffix()}.
 * @param orderByList	The order by list
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>orderByList</ParamName>
                    <ParamType>OrderByList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushOffsetFetchFirst</MethodName>
            <MethodComment>/** 
 * Push down the offset and fetch first parameters, if any. This method should be overridden by the result sets that need this. Presumes a new level has been initialized by  {@link #pushQueryExpressionSuffix()}.
 * @param offset    the OFFSET, if any
 * @param fetchFirst the OFFSET FIRST, if any
 * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>offset</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fetchFirst</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hasJDBClimitClause</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateResultSet</MethodName>
            <MethodComment>/** 
 * General logic shared by Core compilation and by the Replication Filter compiler. A couple ResultSets (the ones used by PREPARE SELECT FILTER) implement this method.
 * @param acb	The ExpressionClassBuilder for the class being built
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>acb</ParamName>
                    <ParamType>ExpressionClassBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>mb</ParamName>
                    <ParamType>MethodBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>updateTargetLockMode</MethodName>
            <MethodComment>/** 
 * Get the lock mode for the target of an update statement (a delete or update).  The update mode will always be row for CurrentOfNodes.  It will be table if there is no where clause.
 * @see TransactionController
 * @return	The lock mode
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>notFlattenableJoin</MethodName>
            <MethodComment>/** 
 * Mark this node and its children as not being a flattenable join.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isOrderedOn</MethodName>
            <MethodComment>/** 
 * Return whether or not the underlying ResultSet tree is ordered on the specified columns. RESOLVE - This method currently only considers the outermost table  of the query block.
 * @param crs					The specified ColumnReference[]
 * @param permuteOrdering		Whether or not the order of the CRs in the array can be permuted
 * @param fbtHolder           List that is to be filled with the FromBaseTable
 * @return	Whether the underlying ResultSet treeis ordered on the specified column.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>crs</ParamName>
                    <ParamType>ColumnReference[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>permuteOrdering</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fbtHolder</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>returnsAtMostOneRow</MethodName>
            <MethodComment>/** 
 * Return whether or not this ResultSet tree is guaranteed to return at most 1 row based on heuristics.  (A RowResultSetNode and a SELECT with a non-grouped aggregate will return at most 1 row.)
 * @return Whether or not this ResultSet tree is guaranteed to returnat most 1 row based on heuristics.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceOrForbidDefaults</MethodName>
            <MethodComment>/** 
 * Replace any DEFAULTs with the associated tree for the default if allowed, or flag (when inside top level set operator nodes). Subqueries are checked for illegal DEFAULTs elsewhere.
 * @param ttd   The TableDescriptor for the target table.
 * @param tcl   The RCL for the target table.
 * @param allowDefaults true if allowed
 * @exception StandardException         Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ttd</ParamName>
                    <ParamType>TableDescriptor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tcl</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowDefaults</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isPossibleDistinctScan</MethodName>
            <MethodComment>/** 
 * Is it possible to do a distinct scan on this ResultSet tree. (See SelectNode for the criteria.)
 * @param distinctColumns the set of distinct columns
 * @return Whether or not it is possible to do a distinct scan on this ResultSet tree.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>distinctColumns</ParamName>
                    <ParamType>BaseColumnNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>markForDistinctScan</MethodName>
            <MethodComment>/** 
 * Mark the underlying scan as a distinct scan.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * Notify the underlying result set tree that the optimizer has chosen to "eliminate" a sort.  Sort elimination can happen as part of preprocessing (see esp. SelectNode.preprocess(...)) or it can happen if the optimizer chooses an access path that inherently returns the rows in the correct order (also known as a "sort avoidance" plan). In either case we drop the sort and rely on the underlying result set tree to return its rows in the correct order. For most types of ResultSetNodes we automatically get the rows in the correct order if the sort was eliminated. One exception to this rule, though, is the case of an IndexRowToBaseRowNode, for which we have to disable bulk fetching on the underlying base table.  Otherwise the index scan could return rows out of order if the base table is updated while the scan is "in progress" (i.e. while the result set is open). In order to account for this (and potentially other, similar issues in the future) this method exists to notify the result set node that it is expected to return rows in the correct order.  The result set can then take necessary action to satsify this requirement--such as disabling bulk fetch in the case of IndexRowToBaseRowNode. All of that said, any ResultSetNodes for which we could potentially eliminate sorts should override this method accordingly.  So we don't ever expect to get here.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>adjustForSortElimination</MethodName>
            <MethodComment>/** 
 * Same goal as adjustForSortElimination above, but this version takes a RequiredRowOrdering to allow nodes to adjust based on the ORDER BY clause, if needed.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rowOrdering</ParamName>
                    <ParamType>RequiredRowOrdering</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;adjustForSortElimination;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>numDistinctAggregates</MethodName>
            <MethodComment>/** 
 * Count the number of distinct aggregates in the list. By 'distinct' we mean aggregates of the form: &lt;I&gt;SELECT MAX(DISTINCT x) FROM T&lt;/I&gt;
 * @return number of aggregates
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>aggregates</ParamName>
                    <ParamType>AggregateNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=0]</InnerVar>
                <InnerVar>int [size=aggregates.size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LOJgetReferencedTables</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>JBitSet</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>numTables</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>QueryExpressionClauses</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;push;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>size</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>push</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [s=size()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOrderByList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>obl</ParamName>
                    <ParamType>OrderByList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.obl;set;[size() - 1, obl]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOffset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.offset;set;[size() - 1, v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFetchFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.fetchFirst;set;[size() - 1, v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setHasJDBCLimitClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>b</ParamName>
                    <ParamType>Boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.hasJDBCLimitClause;set;[size() - 1, b]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOrderByList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OrderByList</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOrderByList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>obl</ParamName>
                    <ParamType>OrderByList</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.obl;set;[i, obl]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOffset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setOffset</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.offset;set;[i, v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFetchFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ValueNode</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setFetchFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>i</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.fetchFirst;set;[i, v]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHasJDBCLimitClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Boolean[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasOffsetFetchFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>pushQueryExpressionSuffix</MethodName>
            <MethodComment>/** 
 * Set up a new level for order by and fetch/offset clauses. See Javadoc for  {@link ResultSetNode.QueryExpressionClauses}. Overridden by implementors of pushOrderByNode, pushOffsetFetchFirst.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printQueryExpressionSuffixClauses</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>qec</ParamName>
                    <ParamType>QueryExpressionClauses</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>