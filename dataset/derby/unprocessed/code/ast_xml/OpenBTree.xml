<Class>
    <Id>644</Id>
    <Package>org.apache.derby.impl.store.access.btree</Package>
    <ClassName>OpenBTree</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>OpenBTree  /** 
 * An open b-tree contains fields and methods common to scans and controllers. &lt;P&gt; &lt;B&gt;Concurrency Notes&lt;/B&gt; &lt;P&gt; An instance of an open b-tree is owned by a single context.  The b-tree code assumes that the context ensures that only one thread at a time is using the open b-tree.  The open b-tree itself does not enforce or check this.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>init_conglomerate</FieldName>
            <FieldType>BTree</FieldType>
        </Field>
        <Field>
            <FieldName>init_xact_manager</FieldName>
            <FieldType>TransactionManager</FieldType>
        </Field>
        <Field>
            <FieldName>init_rawtran</FieldName>
            <FieldType>Transaction</FieldType>
        </Field>
        <Field>
            <FieldName>init_openmode</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_lock_level</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>init_hold</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>init_btree_locking_policy</FieldName>
            <FieldType>BTreeLockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>container</FieldName>
            <FieldType>ContainerHandle</FieldType>
        </Field>
        <Field>
            <FieldName>err_containerid</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>init_open_user_scans</FieldName>
            <FieldType>TransactionManager</FieldType>
        </Field>
        <Field>
            <FieldName>btree_undo</FieldName>
            <FieldType>LogicalUndo</FieldType>
        </Field>
        <Field>
            <FieldName>runtime_mem</FieldName>
            <FieldType>OpenConglomerateScratchSpace</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getXactMgr</MethodName>
            <MethodComment>/** 
 * Public Accessors of This class:
 */
</MethodComment>
            <ReturnType>TransactionManager</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawTran</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Transaction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockLevel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOpenMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConglomerate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BTree</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHold</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockingPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>BTreeLockingPolicy</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setLockingPolicy</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>policy</ParamName>
                    <ParamType>BTreeLockingPolicy</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isClosed</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRuntimeMem</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>OpenConglomerateScratchSpace</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * Get the total estimated number of rows in the container. &lt;p&gt; The number is a rough estimate and may be grossly off.  In general the server will cache the row count and then occasionally write the count unlogged to a backing store.  If the system happens to  shutdown before the store gets a chance to update the row count it may wander from reality. &lt;p&gt; This call is currently only supported on Heap conglomerates, it will throw an exception if called on btree conglomerates.
 * @return The total estimated number of rows in the conglomerate.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>long [row_count=this.container.getEstimatedRowCount(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setEstimatedRowCount</MethodName>
            <MethodComment>/** 
 * Set the total estimated number of rows in the container. &lt;p&gt; Often, after a scan, the client of RawStore has a much better estimate of the number of rows in the container than what store has.  For  instance if we implement some sort of update statistics command, or just after a create index a complete scan will have been done of the table.  In this case this interface allows the client to set the estimated row count for the container, and store will use that number for all future references. &lt;p&gt; This call is currently only supported on Heap conglomerates, it will throw an exception if called on btree conglomerates.
 * @param count the estimated number of rows in the container.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>count</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.container;setEstimatedRowCount;[count, 0]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkConsistency</MethodName>
            <MethodComment>/** 
 * Check consistency of a btree. &lt;p&gt; Read in root and check consistency of entire tree.  Currently raises sanity check errors. &lt;p&gt; RESOLVE (mikem) if this is to be supported in non-sanity servers what  should it do?
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ControlRow [root=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTableLocked</MethodName>
            <MethodComment>/** 
 * is the open btree table locked?
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment>/** 
 * Initialize the open conglomerate. &lt;p&gt; If container is null, open the container, otherwise use the container passed in.  The container is always opened with no locking, it is up to the caller to make the appropriate container locking call. &lt;p&gt;
 * @param open_user_scans The user transaction which opened this btree.
 * @param xact_manager    The current transaction, usually the same as"open_user_scans", but in the case of split it is the internal xact nested below the user xact.
 * @param input_container The open container holding the index, if it isalready open, else null which will mean this routine will open it.
 * @param rawtran         The current raw store transaction.
 * @param open_mode       The opening mode for the ContainerHandle.
 * @param conglomerate    Readonly description of the conglomerate.
 * @param undo            Logical undo object to associate with all updatesdone on this open btree.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>open_user_scans</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>xact_manager</ParamName>
                    <ParamType>TransactionManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_container</ParamName>
                    <ParamType>ContainerHandle</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rawtran</ParamName>
                    <ParamType>Transaction</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hold</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>open_mode</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>lock_level</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>btree_locking_policy</ParamName>
                    <ParamType>BTreeLockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglomerate</ParamName>
                    <ParamType>BTree</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>undo</ParamName>
                    <ParamType>LogicalUndo</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>dynamic_info</ParamName>
                    <ParamType>DynamicCompiledOpenConglomInfo</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>reopen</MethodName>
            <MethodComment>/** 
 * Open the container after it has been closed previously. &lt;p&gt; Open the container, obtaining necessary locks.  Most work is actually done by RawStore.openContainer().  Will only reopen() if the container is not already open.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>close</MethodName>
            <MethodComment>/** 
 * Close the open conglomerate.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIndexableRowConsistent</MethodName>
            <MethodComment>/** 
 * Check if all the  columns are Indexable and Storable.  Eventually this routine could check whether all the types were right also.
 * @exception StandardException Standard Exception Policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>row</ParamName>
                    <ParamType>DataValueDescriptor[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContainerHandle</MethodName>
            <MethodComment>/** 
 * Return the container handle. &lt;p&gt;
 * @return The open container handle of the btree.
 */
</MethodComment>
            <ReturnType>ContainerHandle</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getHeight</MethodName>
            <MethodComment>/** 
 * get height of the tree. &lt;p&gt; Read in root and return the height (number of levels) of the tree. The level of a tree is 0 in the leaf and increases by 1 for each level of the tree as you go up the tree.  
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ControlRow [root=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>debugConglomerate</MethodName>
            <MethodComment>/** 
 * Dump information about tree into the log. &lt;p&gt; Traverse the tree dumping info about tree into the log.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ControlRow [root=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>test_errors</MethodName>
            <MethodComment>/** 
 * Testing infrastructure to cause unusual paths through the code. &lt;p&gt; Through the use of debug flags allow test code to cause otherwise hard to cause paths through the code.   &lt;p&gt;
 * @param pos the current scan position if the condition simulated bythis call would have resulted in the position being saved
 * @return whether the latch has been released by this routine.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>open_btree</ParamName>
                    <ParamType>OpenBTree</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>debug_string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pos</ParamName>
                    <ParamType>BTreeRowPosition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>btree_locking_policy</ParamName>
                    <ParamType>BTreeLockingPolicy</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>leaf</ParamName>
                    <ParamType>LeafControlRow</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>input_latch_released</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [latch_released=input_latch_released]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSpaceInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>SpaceInfo</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getColumnSortOrderInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>