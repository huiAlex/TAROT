<Class>
    <Id>1202</Id>
    <Package>org.apache.derby.iapi.store.access</Package>
    <ClassName>RowLocationRetRowSource</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>RowSource</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>RowLocationRetRowSource  /** 
 * A RowLocationRetRowSource is the mechanism for iterating over a set of rows, loading those rows into a conglomerate, and returning the RowLocation of the inserted rows. 
 * @see RowSource
 */
</ClassComment>
    <FieldList/>
    <MethodList>
        <Method>
            <MethodName>needsRowLocation</MethodName>
            <MethodComment>/** 
 * needsRowLocation returns true iff this the row source expects the drainer of the row source to call rowLocation after getting a row from getNextRowFromRowSource.
 * @return true iff this row source expects some row location to bereturned 
 * @see #rowLocation
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>needsRowLocationForDeferredCheckConstraints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rowLocation</MethodName>
            <MethodComment>/** 
 * rowLocation is a callback for the drainer of the row source to return the rowLocation of the current row, i.e, the row that is being returned by getNextRowFromRowSource.  This interface is for the purpose of loading a base table with index.  In that case, the indices can be built at the same time the base table is laid down once the row location of the base row is known.  This is an example pseudo code on how this call is expected to be used: &lt;BR&gt;&lt;pre&gt; boolean needsRL = rowSource.needsRowLocation(); DataValueDescriptor[] row; while((row = rowSource.getNextRowFromRowSource()) != null) { RowLocation rl = heapConglomerate.insertRow(row); if (needsRL) rowSource.rowLocation(rl); } &lt;/pre&gt;&lt;BR&gt; NeedsRowLocation and rowLocation will ONLY be called by a drainer of the row source which CAN return a row location.  Drainer of row source which cannot return rowLocation will guarantee to not call either callbacks. Conversely, if NeedsRowLocation is called and it returns true, then for every row return by getNextRowFromRowSource, a rowLocation callback must also be issued with the row location of the row.  Implementor of both the source and the drain of the row source must be aware of this protocol. &lt;BR&gt; The RowLocation object is own by the caller of rowLocation, in other words, the drainer of the RowSource.  This is so that we don't need to new a row location for every row.  If the Row Source wants to keep the row location, it needs to clone it (RowLocation is a ClonableObject).
 * @exception StandardException on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>offendingRowLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rl</ParamName>
                    <ParamType>RowLocation</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>containdId</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>