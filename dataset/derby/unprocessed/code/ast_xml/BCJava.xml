<Class>
    <Id>1963</Id>
    <Package>org.apache.derby.impl.services.bytecode</Package>
    <ClassName>BCJava</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>JavaFactory</SuperInterface>
        <SuperInterface>CacheableFactory</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>BCJava  /** 
 * &lt;p&gt; &lt;b&gt;Debugging problems with generated classes&lt;/b&gt; &lt;p&gt; When the code has been generated incorrectly, all sorts of odd things can go wrong.  This is one recommended approach to finding the problem. &lt;p&gt; First, turn on ByteCodeGenInstr and DumpClassFile. Look for missing files (right now they are consecutively numbered by the activation class builder; later on they won't be, but BytCodeGenInstr dumps messages about the classes it has). Look at the log to make sure that all "GEN starting class/method" messages are paired with a "GEN ending class/method" message. If a file is missing or the pairing is missing, then something went wrong when the system tried to generate the bytecodes. Resort to your favorite debugging tool to step through the faulty statement. &lt;p&gt; If you get class files but the system crashes on you (I had an OS segmentation fault once) or you get funny messages like JDBC Excpetion: ac5 where ac5 is just the name of a generated class, then one of the following is likely: &lt;ul&gt; &lt;li&gt; you are calling INVOKEVIRTUAL when you are supposed to call INVOKEINTERFACE &lt;li&gt; you have an inexact match on a method argument or return type. &lt;li&gt; you are trying to get to a superclass's field using a subclass. &lt;/ul&gt; The best way to locate the problem here is to do this (replace ac5.class with the name of your class file): &lt;ol&gt; &lt;li&gt; javap -c -v ac5 &amp;gt; ac5.gp&lt;br&gt; if javap reports "Class not found", and the file ac5.class does exist in the current directory, then the .class file is probably corrupt.  Try running mocha on it to see if that works. The problem will be in the code that generates the entries for the class file -- most likely the ConstantPool is bad, an attribute got created incorrectly, or perhaps the instruction streams are goofed up. &lt;li&gt; java mocha.Decompiler ac5.class&lt;br&gt; if mocha cannot create good java source, then you really need to go back and examine the calls creating the java  constructs; a parameter might have been null when it should have, a call to turn an expression into a statement may be missing, or something else may be wrong. &lt;li&gt; mv ac5.mocha ac5.java &lt;li&gt; vi ac5.java ; you will have to fix any new SQLBoolean(1, ...) calls to be new SQLBoolean(true, ...).  Also mocha  occasionally messes up other stuff too.  Just iterate on it until it builds or you figure out what is wrong with the generated code. &lt;li&gt; javac ac5.java &lt;li&gt; javap -v -c ac5 &amp;gt; ac5.jp &lt;li&gt; sed '1,$s/#[0-9]* &amp;lt;/# &amp;lt;/' ac5.gp &amp;gt; ac5.gn &lt;li&gt; sed '1,$s/#[0-9]* &amp;lt;/# &amp;lt;/' ac5.jp &amp;gt; ac5.jn&lt;br&gt; These seds are to get rid of constant pool entry numbers, which will be wildly different on the two files. &lt;li&gt; vdiff32 ac5.gn ac5.jn&lt;br&gt; this tool shows you side-by-side diffs.  If you change to the window that interleaves the diffs, you can see the  length of the line.  Look for places where there are invokevirtual vs. invokeinterface differences, differences in the class name of a field, differences in the class name of a method parameter or return type.  The generated code will* have some unavoidable differences from the compiled code, such as: &lt;ul&gt; &lt;li&gt; it will have goto's at the end of try blocks rather than return's. &lt;li&gt; it will do a getstatic on a static final field rather than inlining the static final field's value &lt;li&gt; it will have more checkcast's in it, since it doesn't see if the checkcast will always succeed and thus remove it. &lt;/ul&gt; Once you find a diff, you need to track down where the call was generated and modify it appropriately: change newMethodCall to newInterfaceMethodCall; add newCastExpression to get a argument into the right type for the parameter; ensure the return type given for the method is its declared return type. &lt;/ol&gt;
 * @see org.apache.derby.iapi.services.compiler.JavaFactory
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>vmTypeIdCache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>BCJava</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment>/** 
 * Start this module. We need a read/write version of the class utilities
 * @exception StandardException standard Derby policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheFactory [cf=(CacheFactory)startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment>/** 
 * Stop this module.  In this case, nothing needs to be done.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newClassBuilder</MethodName>
            <MethodComment>/** 
 * a class.  Once it is created, fields, methods, interfaces, static initialization code,  and constructors can be added to it. &lt;verbatim&gt; Java: package #packageName; #modifiers #className extends #superClass { } // modifiers is the | of the JVM constants for // the modifiers such as static, public, etc. &lt;/verbatim&gt; See java.lang.reflect.Modifiers
 * @param packageName the name of the package the class is in.null if it is in the default package.
 * @param modifiers the | of the Modifiersconstants representing the visibility and control of this method.
 * @param className the name of the class or interface
 * @param superClass the name of the superclass or superinterface
 * @return the class builder.
 */
</MethodComment>
            <ReturnType>ClassBuilder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cf</ParamName>
                    <ParamType>ClassFactory</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>packageName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>modifiers</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>superClass</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newCacheable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>CacheManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>type</MethodName>
            <MethodComment>/** 
 * Get the VM Type ID that corresponds with the given java type name. This uses the cache of VM type ids.
 * @param javaType	The java type name to translate to a java VM type id
 * @return		The java VM type ID
 */
</MethodComment>
            <ReturnType>Type</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>javaType</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Type [retval]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>vmType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>md</ParamName>
                    <ParamType>BCMethodDescriptor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [retval]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>vmTypeId</MethodName>
            <MethodComment>/** 
 * Map vm types as strings to vm types as the VM handles, with int ids. Used in mapping opcodes based on type of operand/stack entry available.
 */
</MethodComment>
            <ReturnType>short</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>vmTypeS</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char [vmTypeC=vmTypeS.charAt(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startSystemModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>