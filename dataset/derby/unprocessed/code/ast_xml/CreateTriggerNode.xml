<Class>
    <Id>996</Id>
    <Package>org.apache.derby.impl.sql.compile</Package>
    <ClassName>CreateTriggerNode</ClassName>
    <SuperClass>DDLStatementNode</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>CreateTriggerNode  /** 
 * A CreateTriggerNode is the root of a QueryTree  that represents a CREATE TRIGGER statement.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>triggerName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>tableName</FieldName>
            <FieldType>TableName</FieldType>
        </Field>
        <Field>
            <FieldName>triggerEventMask</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>triggerCols</FieldName>
            <FieldType>ResultColumnList</FieldType>
        </Field>
        <Field>
            <FieldName>isBefore</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isRow</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>isEnabled</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>refClause</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>refClause</FieldName>
            <FieldType>TriggerReferencingStruct</FieldType>
        </Field>
        <Field>
            <FieldName>whenClause</FieldName>
            <FieldType>ValueNode</FieldType>
        </Field>
        <Field>
            <FieldName>whenText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>actionNode</FieldName>
            <FieldType>StatementNode</FieldType>
        </Field>
        <Field>
            <FieldName>actionText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>originalWhenText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>originalActionText</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>providerInfo</FieldName>
            <FieldType>ProviderInfo[]</FieldType>
        </Field>
        <Field>
            <FieldName>triggerSchemaDescriptor</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>compSchemaDescriptor</FieldName>
            <FieldType>SchemaDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>referencedColInts</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>referencedColsInTriggerAction</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>triggerTableDescriptor</FieldName>
            <FieldType>TableDescriptor</FieldType>
        </Field>
        <Field>
            <FieldName>oldTableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>newTableName</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>oldTableInReferencingClause</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>newTableInReferencingClause</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
        <Field>
            <FieldName>actionTransformations</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>actionTransformations</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>whenClauseTransformations</FieldName>
            <FieldType>ArrayList</FieldType>
        </Field>
        <Field>
            <FieldName>whenClauseTransformations</FieldName>
            <FieldType>int[]</FieldType>
        </Field>
        <Field>
            <FieldName>OFFSET_COMPARATOR</FieldName>
            <FieldType>Comparator</FieldType>
        </Field>
        <Field>
            <FieldName>OFFSET_COMPARATOR</FieldName>
            <FieldType>FromBaseTable</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>CreateTriggerNode</MethodName>
            <MethodComment>/** 
 * Constructor for a CreateTriggerNode
 * @param triggerName			name of the trigger	
 * @param tableName				name of the table which the trigger is declared upon	
 * @param triggerEventMask		TriggerDescriptor.TRIGGER_EVENT_XXX
 * @param triggerCols			columns trigger is to fire upon.  Validfor UPDATE case only.
 * @param isBefore				is before trigger (false for after)
 * @param isRow					true for row trigger, false for statement
 * @param isEnabled				true if enabled
 * @param refClause				the referencing clause
 * @param whenClause			the WHEN clause tree
 * @param whenText				the text of the WHEN clause
 * @param actionNode			the trigger action tree
 * @param actionText			the text of the trigger action
 * @param cm                    context manager
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>triggerName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerEventMask</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>triggerCols</ParamName>
                    <ParamType>ResultColumnList</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isBefore</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isRow</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isEnabled</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>refClause</ParamName>
                    <ParamType>TriggerReferencingStruct</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whenClause</ParamName>
                    <ParamType>ValueNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whenText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionNode</ParamName>
                    <ParamType>StatementNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statementToString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>printSubNodes</MethodName>
            <MethodComment>/** 
 * Prints the sub-nodes of this object.  See QueryTreeNode.java for how tree printing is supposed to work.
 * @param depth		The depth of this node in the tree
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>depth</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindStatement</MethodName>
            <MethodComment>/** 
 * Bind this CreateTriggerNode.  This means doing any static error checking that can be done before actually creating the table.
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CompilerContext [compilerContext=getCompilerContext()]</InnerVar>
                <InnerVar>DataDictionary [dd=getDataDictionary()]</InnerVar>
                <InnerVar>LanguageConnectionContext [lcc=getLanguageConnectionContext()]</InnerVar>
                <InnerVar>boolean [needInternalSQL=bindReferencesClause(dd)]</InnerVar>
                <InnerVar>SortedSet&lt;TableName&gt; [actionNames=actionNode.getOffsetOrderedNodes(TableName.class)]</InnerVar>
                <InnerVar>SortedSet&lt;TableName&gt; [whenNames=(whenClause != null) ? whenClause.getOffsetOrderedNodes(TableName.class) : null]</InnerVar>
                <InnerVar>ProviderList [prevAPL=compilerContext.getCurrentAuxiliaryProviderList()]</InnerVar>
                <InnerVar>ProviderList [apl=new ProviderList()]</InnerVar>
                <InnerVar>DependencyManager [dm=dd.getDependencyManager()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lcc;pushTriggerTable;[triggerTableDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>null;qualifyNames;[actionNames, whenNames]</InnerMethodInvoke>
                <InnerMethodInvoke>compilerContext;createDependency;[triggerTableDescriptor]</InnerMethodInvoke>
                <InnerMethodInvoke>dm;clearColumnInfoInProviders;[apl]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>referencesSessionSchema</MethodName>
            <MethodComment>/** 
 * Return true if the node references SESSION schema tables (temporary or permanent)
 * @return	true if references SESSION schema tables, else false
 * @exception StandardException		Thrown on error
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compare</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>o1</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o2</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bindReferencesClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [transformedActionText]</InnerVar>
                <InnerVar>String [transformedWhenText=null]</InnerVar>
                <InnerVar>boolean [regenNode=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;validateReferencesClause;[dd]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>qualifyNames</MethodName>
            <MethodComment>/** 
 * Make sure all references to SQL schema objects (such as tables and functions) in the SQL fragments that will be stored in the SPS and in the trigger descriptor, are fully qualified with a schema name.
 * @param actionNames all the TableName nodes found in the triggeredSQL statement
 * @param whenNames   all the Table Name nodes found in the WHEN clause
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>actionNames</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>whenNames</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [original=new StringBuilder()]</InnerVar>
                <InnerVar>StringBuilder [transformed=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;qualifyNames;[actionNode, actionNames, originalActionText, actionText, actionTransformations, original, transformed]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>qualifyNames</MethodName>
            <MethodComment>/** 
 * Qualify all names SQL object names in original and transformed SQL text for an action or a WHEN clause.
 * @param node the query tree node for the transformed version of theSQL text, in a bound state
 * @param tableNames all the TableName nodes in the transformed text,in the order in which they appear in the SQL text
 * @param originalText the original SQL text
 * @param transformedText the transformed SQL text (with VTI calls fortransition tables or transition variables)
 * @param replacements a data structure that describes how {@code originalText} was transformed into {@code transformedText}
 * @param newOriginal where to store the normalized version of theoriginal text
 * @param newTransformed where to store the normalized version of thetransformed text
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tableNames</ParamName>
                    <ParamType>TableName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>originalText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transformedText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newOriginal</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newTransformed</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [originalPos=0]</InnerVar>
                <InnerVar>int [transformedPos=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newTransformed;append;[transformedText, transformedPos, transformedText.length()]</InnerMethodInvoke>
                <InnerMethodInvoke>newOriginal;append;[originalText, originalPos, originalText.length()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getOriginalPosition</MethodName>
            <MethodComment>/** 
 * Translate a position from the transformed trigger text ( {@link #actionText} or {@link #whenText}) to the corresponding position in the original trigger text ( {@link #originalActionText}or  {@link #originalWhenText}).
 * @param replacements a data structure that describes the relationshipbetween positions in the original and the transformed text
 * @param transformedPosition the position to translate
 * @return the position in the original text, or {@code null} if thereis no corresponding position in the original text (for example if it points to a token that was added to the transformed text and does not exist in the original text)
 */
</MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transformedPosition</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>justTheRequiredColumns</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>columnsArrary</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [countOfColsRefedInArray=0]</InnerVar>
                <InnerVar>int [numberOfColsInTriggerTable=triggerTableDescriptor.getNumberOfColumns()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transformStatementTriggerText</MethodName>
            <MethodComment>/** 
 * Transform the WHEN clause or the triggered SQL statement of a statement trigger from its original shape to internal syntax where references to transition tables are replaced with VTIs that return the before or after image of the changed rows.
 * @param node the syntax tree of the WHEN clause or the triggeredSQL statement
 * @param originalText the original text of the WHEN clause or thetriggered SQL statement
 * @param replacements list that will be populated with int arrays thatdescribe how the original text was transformed. The int arrays contain the begin (inclusive) and end (exclusive) positions of the original text that got replaced and of the replacement text, so that positions in the transformed text can be mapped to positions in the original text.
 * @return internal syntax for accessing before or after image ofthe changed rows
 * @throws StandardException if an error happens while performing thetransformation
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>QueryTreeNode</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>originalText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replacements</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [offset=node.getBeginOffset()]</InnerVar>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>StringBuilder [newText=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>newText;append;[originalText, start, originalText.length()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransitionTables</MethodName>
            <MethodComment>/** 
 * Get all transition tables referenced by a given node, sorted in the order in which they appear in the SQL text.
 * @param node the node in which to search for transition tables
 * @return a sorted set of {@code FromBaseTable}s that represent transition tables
 * @throws StandardException if an error occurs
 */
</MethodComment>
            <ReturnType>FromBaseTable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>node</ParamName>
                    <ParamType>Visitable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectNodesVisitor&lt;FromBaseTable&gt; [visitor=new CollectNodesVisitor&lt;FromBaseTable&gt;(FromBaseTable.class)]</InnerVar>
                <InnerVar>TreeSet&lt;FromBaseTable&gt; [tables=new TreeSet&lt;FromBaseTable&gt;(OFFSET_COMPARATOR)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>node;accept;[visitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isTransitionTable</MethodName>
            <MethodComment>/** 
 * Check if a table represents one of the transition tables.
 * @param fbt the table to check
 * @return {@code true} if {@code fbt} represents either the old orthe new transition table,  {@code false} otherwise
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fbt</ParamName>
                    <ParamType>FromBaseTable</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>forbidActionsOnGenCols</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>ColumnDescriptorList [generatedColumns=triggerTableDescriptor.getGeneratedColumns()]</InnerVar>
                <InnerVar>int [genColCount=generatedColumns.size()]</InnerVar>
                <InnerVar>CollectNodesVisitor&lt;ColumnReference&gt; [visitor=new CollectNodesVisitor&lt;ColumnReference&gt;(ColumnReference.class)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>actionNode;accept;[visitor]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equals</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkInvalidTriggerReference</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validateReferencesClause</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dd</ParamName>
                    <ParamType>DataDictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>makeConstantAction</MethodName>
            <MethodComment>/** 
 * Create the Constant information that will drive the guts of Execution.
 * @exception StandardException		Thrown on failure
 */
</MethodComment>
            <ReturnType>ConstantAction</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [oldReferencingName=(oldTableInReferencingClause) ? oldTableName : null]</InnerVar>
                <InnerVar>String [newReferencingName=(newTableInReferencingClause) ? newTableName : null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment>/** 
 * Convert this object to a String.  See comments in QueryTreeNode.java for how this should be done for tree printing.
 * @return	This object as a String
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>acceptChildren</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>v</ParamName>
                    <ParamType>Visitor</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>