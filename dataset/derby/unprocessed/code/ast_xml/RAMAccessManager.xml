<Class>
    <Id>1998</Id>
    <Package>org.apache.derby.impl.store.access</Package>
    <ClassName>RAMAccessManager</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>AccessFactory</SuperInterface>
        <SuperInterface>CacheableFactory</SuperInterface>
        <SuperInterface>ModuleControl</SuperInterface>
        <SuperInterface>PropertySetCallback</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>rawstore</FieldName>
            <FieldType>RawStoreFactory</FieldType>
        </Field>
        <Field>
            <FieldName>implhash</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>implhash</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>formathash</FieldName>
            <FieldType>Hashtable</FieldType>
        </Field>
        <Field>
            <FieldName>formathash</FieldName>
            <FieldType>UUID</FieldType>
        </Field>
        <Field>
            <FieldName>serviceProperties</FieldName>
            <FieldType>Properties</FieldType>
        </Field>
        <Field>
            <FieldName>system_default_locking_policy</FieldName>
            <FieldType>LockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>xactProperties</FieldName>
            <FieldType>PropertyConglomerate</FieldType>
        </Field>
        <Field>
            <FieldName>pf</FieldName>
            <FieldType>PropertyFactory</FieldType>
        </Field>
        <Field>
            <FieldName>table_level_policy</FieldName>
            <FieldType>LockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>record_level_policy</FieldName>
            <FieldType>LockingPolicy</FieldType>
        </Field>
        <Field>
            <FieldName>conglom_map</FieldName>
            <FieldType>ConglomerateFactory</FieldType>
        </Field>
        <Field>
            <FieldName>conglom_cache</FieldName>
            <FieldType>CacheManager</FieldType>
        </Field>
        <Field>
            <FieldName>conglom_nextid</FieldName>
            <FieldType>long</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>RAMAccessManager</MethodName>
            <MethodComment>/** 
 * Constructors for This class:
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultLockingPolicy</MethodName>
            <MethodComment>/** 
 * Return the default locking policy for this access manager.
 * @return the default locking policy for this accessmanager.
 */
</MethodComment>
            <ReturnType>LockingPolicy</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRawStore</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>RawStoreFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionalProperties</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PropertyConglomerate</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot_load_conglom_map</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>MethodFactory [mfactory=findMethodFactoryByImpl("heap")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSystemLockLevel</MethodName>
            <MethodComment>/** 
 * Return the locking level of the system. &lt;p&gt; This routine controls the lowest level of locking enabled for all locks for all tables accessed through this accessmanager.  The concrete  implementation may set this value always to table level locking for a client configuration, or it may set it to row level locking for a server configuration. &lt;p&gt; If TransactionController.MODE_RECORD is returned table may either be locked at table or row locking depending on the type of access expected (ie. level 3 will require table locking for heap scans.)
 * @return TransactionController.MODE_TABLE if only table locking allowed,else returns TransactionController.MODE_RECORD.
 */
</MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootLookupSystemLockLevel</MethodName>
            <MethodComment>/** 
 * Query property system to get the System lock level. &lt;p&gt; This routine will be called during boot after access has booted far  enough, to allow access to the property conglomerate.  This routine will call the property system and set the value to be returned by getSystemLockLevel(). &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNextConglomId</MethodName>
            <MethodComment>/** 
 * Return next conglomid to try to add the container with. &lt;p&gt; The conglomerate number has 2 parts.  The low 4 bits are used to  encode the factory which "owns" the conglomerate.  The high 60 bits are used as a normal unique id mechanism. &lt;p&gt; So for example if the next id to assign is 0x54 the following will be the conglomid: if a HEAP  (factory 0) - 0x540 if a BTREE (factory 1) - 0x541 And the next id assigned will be: if a HEAP  (factory 0) - 0x550 if a BTREE (factory 1) - 0x551
 * @param factory_type factory id as gotten from getConglomerateFactoryId()
 * @return The identifier to be used to open the conglomerate later.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>long</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factory_type</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>long [conglomid]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getFactoryFromConglomId</MethodName>
            <MethodComment>/** 
 * Given a conglomid, return the factory which "owns" it. &lt;p&gt; A simple lookup on the boot time built table which maps the low order 4 bits into which factory owns the conglomerate. &lt;p&gt;
 * @param conglom_id The conglomerate id of the conglomerate to look up.
 * @return The ConglomerateFactory which "owns" this conglomerate.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>ConglomerateFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglom_id</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomCacheInit</MethodName>
            <MethodComment>/** 
 * Initialize the conglomerate cache. &lt;p&gt; Simply calls the cache manager to create the cache with some hard coded defaults for size. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>CacheFactory [cf=(CacheFactory)startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomCacheFind</MethodName>
            <MethodComment>/** 
 * Find a conglomerate by conglomid in the cache. &lt;p&gt; Look for a conglomerate given a conglomid.  If in cache return it, otherwise fault in an entry by asking the owning factory to produce an entry. &lt;p&gt;
 * @return The conglomerate object identified by "conglomid".
 * @param conglomid The conglomerate id of the conglomerate to look up.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>Conglomerate</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Conglomerate [conglom=null]</InnerVar>
                <InnerVar>Long [conglomid_obj=conglomid]</InnerVar>
                <InnerVar>CacheableConglomerate [cache_entry=(CacheableConglomerate)conglom_cache.find(conglomid_obj)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomCacheInvalidate</MethodName>
            <MethodComment>/** 
 * Invalide the current Conglomerate Cache. &lt;p&gt; Abort of certain operations will invalidate the contents of the  cache.  Longer term we could just invalidate those entries, but for now just invalidate the whole cache. &lt;p&gt;
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglom_cache;ageOut;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomCacheAddEntry</MethodName>
            <MethodComment>/** 
 * Add a newly created conglomerate to the cache. &lt;p&gt;
 * @param conglomid   The conglomid of conglomerate to replace.
 * @param conglom     The Conglom to add.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conglom</ParamName>
                    <ParamType>Conglomerate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheableConglomerate [conglom_entry=(CacheableConglomerate)conglom_cache.create(conglomid,conglom)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglom_cache;release;[conglom_entry]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conglomCacheRemoveEntry</MethodName>
            <MethodComment>/** 
 * Remove an entry from the cache. &lt;p&gt;
 * @param conglomid   The conglomid of conglomerate to replace.
 * @exception StandardException  Standard exception policy.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>conglomid</ParamName>
                    <ParamType>long</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CacheableConglomerate [conglom_entry=(CacheableConglomerate)conglom_cache.findCached(conglomid)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentTransactionContext</MethodName>
            <MethodComment>/** 
 * &lt;p&gt; Get the current transaction context. &lt;/p&gt; &lt;p&gt; If there is an internal transaction on the context stack, return the internal transaction. Otherwise, if there is a nested user transaction on the context stack, return the nested transaction. Otherwise, return the current user transaction. &lt;/p&gt;
 * @return a context object referencing the current transaction
 */
</MethodComment>
            <ReturnType>RAMTransactionContext</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>RAMTransactionContext [rtc=(RAMTransactionContext)getContext(AccessFactoryGlobals.RAMXACT_INTERNAL_CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createFinished</MethodName>
            <MethodComment>/** 
 * Database creation finished.  Tell RawStore.
 * @exception StandardException standard Derby error policy
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;createFinished;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMethodFactoryByFormat</MethodName>
            <MethodComment>/** 
 * Find an access method that implements a format type.
 * @see AccessFactory#findMethodFactoryByFormat
 */
</MethodComment>
            <ReturnType>MethodFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>format</ParamName>
                    <ParamType>UUID</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodFactory [factory]</InnerVar>
                <InnerVar>Enumeration&lt;MethodFactory&gt; [e=formathash.elements()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findMethodFactoryByImpl</MethodName>
            <MethodComment>/** 
 * Find an access method that implements an implementation type.
 * @see AccessFactory#findMethodFactoryByImpl
 */
</MethodComment>
            <ReturnType>MethodFactory</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>impltype</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodFactory [factory=implhash.get(impltype)]</InnerVar>
                <InnerVar>Enumeration&lt;MethodFactory&gt; [e=implhash.elements()]</InnerVar>
                <InnerVar>Properties [conglomProperties=new Properties(serviceProperties)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>conglomProperties;put;[AccessFactoryGlobals.CONGLOM_PROP, impltype]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLockFactory</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LockFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAndNameTransaction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TransactionController</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>transName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RAMTransactionContext [rtc=(RAMTransactionContext)cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startXATransaction</MethodName>
            <MethodComment>/** 
 * Start a global transaction. &lt;p&gt; Get a transaction controller with which to manipulate data within the access manager.  Implicitly creates an access context. &lt;p&gt; Must only be called if no other transaction context exists in the current context manager.  If another transaction exists in the context an exception will be thrown. &lt;p&gt; The (format_id, global_id, branch_id) triplet is meant to come exactly from a javax.transaction.xa.Xid.  We don't use Xid so that the system can be delivered on a non-1.2 vm system and not require the javax classes in the path.  
 * @param cm        The context manager for the current context.
 * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
 * @param global_id the global transaction identifier part of XID - ie.Xid.getGlobalTransactionId().
 * @param branch_id The branch qualifier of the Xid - ie. Xid.getBranchQaulifier()
 * @exception StandardException Standard exception policy.
 * @see TransactionController
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>ContextManager</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>format_id</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>global_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>branch_id</ParamName>
                    <ParamType>byte[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RAMTransaction [xa_tc=null]</InnerVar>
                <InnerVar>RAMTransactionContext [rtc=(RAMTransactionContext)cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getXAResourceManager</MethodName>
            <MethodComment>/** 
 * Return the XAResourceManager associated with this AccessFactory. &lt;p&gt; Returns an object which can be used to implement the "offline"  2 phase commit interaction between the accessfactory and outstanding transaction managers taking care of in-doubt transactions.
 * @return The XAResourceManager associated with this accessfactory.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>registerAccessMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factory</ParamName>
                    <ParamType>MethodFactory</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>implhash;put;[factory.primaryImplementationType(), factory]</InnerMethodInvoke>
                <InnerMethodInvoke>formathash;put;[factory.primaryFormat(), factory]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isReadOnly</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>createReadMeFiles</MethodName>
            <MethodComment>/** 
 * DERBY-5996(Create readme files (cautioning users against modifying  database files) at database hard upgrade time) This gets called during hard upgrade. It will create 3 readme files one in database directory, one in "seg0" directory and one in log directory. These readme files warn users against touching any of files associated with derby database 
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LogFactory [logFactory=(LogFactory)findServiceModule(this,rawstore.getLogFactoryModule())]</InnerVar>
                <InnerVar>DataFactory [dataFactory=(DataFactory)findServiceModule(this,rawstore.getDataFactoryModule())]</InnerVar>
                <InnerVar>PersistentService [ps=getMonitor().getServiceType(rawstore)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;createDataWarningFile;[]</InnerMethodInvoke>
                <InnerMethodInvoke>logFactory;createDataWarningFile;[]</InnerMethodInvoke>
                <InnerMethodInvoke>ps;createDataWarningFile;[dataFactory.getStorageFactory()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addPropertySetNotification</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>who</ParamName>
                    <ParamType>PropertySetCallback</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tc</ParamName>
                    <ParamType>TransactionController</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Dictionary&lt;Object,Object&gt; [d=new Hashtable&lt;Object,Object&gt;()]</InnerVar>
                <InnerVar>boolean [dbOnly=PropertyUtil.isDBOnly(d)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>pf;addPropertySetNotification;[who]</InnerMethodInvoke>
                <InnerMethodInvoke>who;init;[dbOnly, d]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getTransactionInfo</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TransactionInfo[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startReplicationMaster</MethodName>
            <MethodComment>/** 
 * Start the replication master role for this database.
 * @param dbmaster The master database that is being replicated.
 * @param host The hostname for the slave
 * @param port The port the slave is listening on
 * @param replicationMode The type of replication contract.Currently only asynchronous replication is supported, but 1-safe/2-safe/very-safe modes may be added later.
 * @exception StandardException Standard Derby exception policy,thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbmaster</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>host</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>port</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>replicationMode</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;startReplicationMaster;[dbmaster, host, port, replicationMode]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>failover</MethodName>
            <MethodComment>/** 
 * @see org.apache.derby.iapi.store.access.AccessFactory#failover(String dbname).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbname</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;failover;[dbname]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stopReplicationMaster</MethodName>
            <MethodComment>/** 
 * Stop the replication master role for this database.
 * @exception StandardException Standard Derby exception policy,thrown on error.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore;stopReplicationMaster;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>freeze</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[Securable.FREEZE_DATABASE]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;freeze;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unfreeze</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[Securable.UNFREEZE_DATABASE]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;unfreeze;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>backup</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[wait ? Securable.BACKUP_DATABASE : Securable.BACKUP_DATABASE_NOWAIT]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;backup;[backupDir, wait]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>backupAndEnableLogArchiveMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>backupDir</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>deleteOnlineArchivedLogFiles</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>wait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[wait ? Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE : Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;backupAndEnableLogArchiveMode;[backupDir, deleteOnlineArchivedLogFiles, wait]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>disableLogArchiveMode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>deleteOnlineArchivedLogFiles</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[Securable.DISABLE_LOG_ARCHIVE_MODE]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;disableLogArchiveMode;[deleteOnlineArchivedLogFiles]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>checkpoint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>SecurityUtil;authorize;[Securable.CHECKPOINT_DATABASE]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;checkpoint;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>waitForPostCommitToFinishWork</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>rawstore.getDaemon();waitUntilQueueIsEmpty;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>boot</MethodName>
            <MethodComment>/** 
 * Public Methods implementing ModuleControl Interface:
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startParams</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RAMTransaction [tc=(RAMTransaction)getAndNameTransaction(getContextService().getCurrentContextManager(),AccessFactoryGlobals.USER_TRANS_NAME)]</InnerVar>
                <InnerVar>int [lock_mode=LockingPolicy.MODE_CONTAINER]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;boot_load_conglom_map;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;setUndoInsertEventHandler;[new RAMAccessUndoHandler(this)]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bootServiceModule;[create, this, org.apache.derby.iapi.reference.Module.PropertyFactory, startParams]</InnerMethodInvoke>
                <InnerMethodInvoke>null;conglomCacheInit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>rawstore;getRawStoreProperties;[tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;bootLookupSystemLockLevel;[tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addPropertySetNotification;[getLockFactory(), tc]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addPropertySetNotification;[this, tc]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;commit;[]</InnerMethodInvoke>
                <InnerMethodInvoke>tc;destroy;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stop</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>init</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>dbOnly</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>validate</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>apply</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Serviceable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>map</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Serializable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>Serializable</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>p</ParamName>
                    <ParamType>Dictionary</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newCacheable</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Cacheable</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cm</ParamName>
                    <ParamType>CacheManager</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContextService</MethodName>
            <MethodComment>/** 
 * Privileged lookup of the ContextService. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ContextService</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getContext</MethodName>
            <MethodComment>/** 
 * Privileged lookup of a Context. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextID</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Context</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getMonitor</MethodName>
            <MethodComment>/** 
 * Privileged Monitor lookup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ModuleFactory</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>startSystemModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>bootServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>create</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>identifier</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>properties</ParamName>
                    <ParamType>Properties</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findServiceModule</MethodName>
            <MethodComment>/** 
 * Privileged startup. Must be private so that user code can't call this entry point.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>serviceModule</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>factoryInterface</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>run</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>StandardException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>