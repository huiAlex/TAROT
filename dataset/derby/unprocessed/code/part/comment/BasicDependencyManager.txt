/**
     * DataDictionary for this database.
     */

/**
     * Map of in-memory dependencies for Dependents.
     * In-memory means that one or both of the Dependent
     * or Provider are non-persistent (isPersistent() returns false).
     * 
     * Key is the UUID of the Dependent (from getObjectID()).
     * Value is a List containing Dependency objects, each
     * of whihc links the same Dependent to a Provider.
     * Dependency objects in the List are unique.
     * 
     */

/**
     * Map of in-memory dependencies for Providers.
     * In-memory means that one or both of the Dependent
     * or Provider are non-persistent (isPersistent() returns false).
     * 
     * Key is the UUID of the Provider (from getObjectID()).
     * Value is a List containing Dependency objects, each
     * of which links the same Provider to a Dependent.
     * Dependency objects in the List are unique.
     * 
     */

/**
		adds a dependency from the dependent on the provider.
		This will be considered to be the default type of
		dependency, when dependency types show up.
		
		Implementations of addDependency should be fast --
		performing alot of extra actions to add a dependency would
		be a detriment.

		@param d the dependent
		@param p the provider

		@exception StandardException thrown if something goes wrong
	 */

/**
     * Adds the dependency to the data dictionary or the in-memory dependency
     * map.
     * 
     * The action taken is detmermined by whether the dependent and/or the
     * provider are persistent.
     *
     * @param d the dependent
     * @param p the provider
     * @param cm context manager
     * @param tc transaction controller, used to determine if any transactional
     *      operations should be attempted carried out in a nested transaction.
     *      If {@code tc} is {@code null}, the user transaction is used.
     *      */

/**
     * Adds the dependency as an in-memory dependency.
     *
     * @param d the dependent
     * @param p the provider
     * @param cm context manager
     *      *      */

/**
     * Adds the dependency as a stored dependency.
     * 
     * We expect that transactional locking (in the data dictionary) is enough
     * to protect us from concurrent changes when adding stored dependencies.
     * Adding synchronization here and accessing the data dictionary (which is
     * transactional) may cause deadlocks.
     *
     * @param d the dependent
     * @param p the provider
     * @param cm context manager
     * @param tc transaction controller (may be {@code null})
     *      *      */

/**
		drops a single dependency

		@param d the dependent
		@param p the provider

		@exception StandardException thrown if something goes wrong
	 */

/**
		mark all dependencies on the named provider as invalid.
		When invalidation types show up, this will use the default
		invalidation type. The dependencies will still exist once
		they are marked invalid; clearDependencies should be used
		to remove dependencies that a dependent has or provider gives.
		
		Implementations of this can take a little time, but are not
		really expected to recompile things against any changes
		made to the provider that caused the invalidation. The
		dependency system makes no guarantees about the state of
		the provider -- implementations can call this before or
		after actually changing the provider to its new state.
		
		Implementations should throw StandardException
		if the invalidation should be disallowed.

		@param p the provider
		@param action	The action causing the invalidate

		@exception StandardException thrown if unable to make it invalid
	 */

/**
     * A version of invalidateFor that does not provide synchronization among
     * invalidators.
     *
     * @param p the provider
     * @param action the action causing the invalidation
     * @param lcc language connection context
     *
     *      */

/**
		Erases all of the dependencies the dependent has, be they
		valid or invalid, of any dependency type.  This action is
		usually performed as the first step in revalidating a
		dependent; it first erases all the old dependencies, then
		revalidates itself generating a list of new dependencies,
		and then marks itself valid if all its new dependencies are
		valid.
		
		There might be a future want to clear all dependencies for
		a particular provider, e.g. when destroying the provider.
		However, at present, they are assumed to stick around and
		it is the responsibility of the dependent to erase them when
		revalidating against the new version of the provider.
		
		clearDependencies will delete dependencies if they are
		stored; the delete is finalized at the next commit.

		@param d the dependent
	 *
	 * @exception StandardException		Thrown on failure
	 */

/**
	 * @inheritDoc
	 */

/**
	 * Clear the specified in memory dependency.
	 * This is useful for clean-up when an exception occurs.
	 * (We clear all in-memory dependencies added in the current
	 * StatementContext.)
	 */

/**
	 * 	 *
	 * @exception StandardException		Thrown on error
	 */

/**
	 * 	 *
	 * @exception StandardException		Thrown on error
	 */

/**
	 * 	 *
	 * @param pl		provider list
	 *
	 * @exception StandardException		Thrown on error
	 */

/**
 	 * Copy dependencies from one dependent to another.
	 *
	 * @param copy_From the dependent to copy from	
	 * @param copyTo the dependent to copy to
	 * @param persistentOnly only copy persistent dependencies
	 * @param cm		Current ContextManager
	 *
	 * @exception StandardException		Thrown on error.
	 */

/**
	 * @inheritDoc 
	 */

/**
	 * Returns a string representation of the SQL action, hence no
	 * need to internationalize, which is causing the invokation
	 * of the Dependency Manager.
	 *
	 * @param action		The action
	 *
	 * @return String	The String representation
	 */

/**
	 * Count the number of active dependencies, both stored and in memory,
	 * in the system.
	 *
	 * @return int		The number of active dependencies in the system.

		@exception StandardException thrown if something goes wrong
	 */

/**
	 * Add a new dependency to the specified table if it does not
	 * already exist in that table.
	 *
	 * @return boolean		Whether or not the dependency get added.
	 */

/**
	 * removes a dependency for a given provider. assumes
	 * that the dependent removal is being dealt with elsewhere.
	 * Won't assume that the dependent only appears once in the list.
	 */

/**
	 * Turn a list of DependencyDescriptors into a list of Dependencies.
	 *
	 * @param storedList	The List of DependencyDescriptors representing
	 *						stored dependencies.
	 * @param providerForList The provider if this list is being created
	 *                        for a list of dependents. Null otherwise.
	 * 
	 * @return List		The converted List
	 *
	 * @exception StandardException thrown if something goes wrong
	 */

/**
	 * Returns the LanguageConnectionContext to use.
	 *
	 * @param cm	Current ContextManager
	 *
	 * @return LanguageConnectionContext	The LanguageConnectionContext to use.
	 */

/**
     * Returns a list of all providers that this dependent has (even invalid
     * ones). Includes all dependency types.
     *
     * @param d the dependent
     * @return A list of providers (possibly empty).
     *      */

/**
     * Returns an enumeration of all dependencies that this
     * provider is supporting for any dependent at all (even
     * invalid ones). Includes all dependency types.
     *
     * @param p the provider
     * @return A list of dependents (possibly empty).
     * 	 */

