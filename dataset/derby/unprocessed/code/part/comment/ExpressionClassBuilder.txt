/**
 * ExpressionClassBuilder
 * provides an interface to satisfy generation's
 * common tasks in building classes that involve expressions.
 * This is the common superclass of ActivationClassBuilder and
 * FilterClassBuilder. See the documentation on ActivationClassBuilder.
 *
 */

/**
	 * By the time this is done, it has constructed the following class:
	 * 
	 *
	 * @exception StandardException thrown on failure
	 */

/**
	 * Get the name of the package that the generated class will live in.
	 *
	 *	@return	name of package that the generated class will live in.
	 */

/**
	 * Get the number of ExecRows that must be allocated
	 *
	 *	@return	number of ExecRows that must be allocated
	 *
	 * 	@exception StandardException thrown on failure
	 */

/**
	 * Sets the number of subqueries under this expression
	 *
	 *
	 * 	@exception StandardException thrown on failure
	 */

/**
		Return the base class of the activation's hierarchy
		(the subclass of Object).

		This class is expected to hold methods used by all
		compilation code, such as datatype compilation code,
		e.g. getDataValueFactory.
	 */

/**
     * Get a method builder for adding code to the execute() method.
     * The method builder does not actually build a method called execute.
     * Instead, it creates a method that overrides the reinit() method,
     * which is called from execute() on every execution in order to
     * reinitialize the data structures.
	 */

/**
	 * Finish the constructor by newing the array of Rows and putting a return 
	 * at the end of it.
	 *
	 * @exception StandardException thrown on failure
	 */

/**
	 * Generate the assignment for row = new ExecRow[numResultSets]
	 *
	 * @param numResultSets	The size of the array.
	 */

/**
	 * Add a field declaration to the generated class
	 * 
	 * @param modifiers	The | of the modifier values such as public, static, etc.
	 * @param type		The type of the field in java language.
	 * @param name		The name of the field.
	 *
	 * @return None.
	 */

/**
	 * Add an arbitrarily named field to the generated class.
	 *
	 * This is used to generate fields where the caller doesn't care what
	 * the field is named.  It is especially useful for generating arbitrary
	 * numbers of fields, where the caller doesn't know in advance how many
	 * fields will be used.  For example, it is used for generating fields
	 * to hold intermediate values from expressions.
	 *
	 * @param modifiers	The | of the modifier values such as public, static, etc.
	 * @param type		The type of the field in java language.
	 *
	 * @return	The name of the new field
	 */

/**
	 * Activations might have need of internal functions
	 * that are not used by the result sets, but by other
	 * activation functions. Thus, we make it possible
	 * for functions to be generated directly as well
	 * as through the newExprFun interface.  newExprFun
	 * should be used when a static field pointing to the
	 * expression function is needed.
	 * 
	 * The generated function will generally have a generated name
	 * that can be viewed through the MethodBuilder interface.
	 * This name is generated to ensure uniqueness from other
	 * function names in the activation class. If you pass in a function
	 * name, think carefully about whether it will collide with other names.
	 *
	 * @param returnType the return type of the function
	 * @param modifiers the modifiers on the function
	 *
	 * 	 */

/**
	 * "ExprFun"s are the "expression functions" that
	 * are specific to a given JSQL statement. For example,
	 * an ExprFun is generated to evaluate the where clause
	 * of a select statement and return a boolean result.
	 * 
	 *
	 * All methods return by this are expected to be called
	 * via the GeneratedMethod interface. Thus the methods
	 * are public and return java.lang.Object.
	 * 
	 * Once the exprfun has been created, the
	 * caller will need to add statements to it,
	 * minimally a return statement.
	 * 
	 * ExprFuns  return Object types, since they
	 * are invoked through reflection and thus their
	 * return type would get wrapped in an object anyway.
	 * For example: return java.lang.Boolean, not boolean.
	 */

/**
		Push an expression that is a GeneratedMethod reference to the
		passed in method. aka. a "function pointer".
	*/

/**
	 * Start a user expression.  The difference between a normal expression
	 * (returned by newExprFun)
	 * and a user expression is that a user expression catches all exceptions
	 * (because we don't want random exceptions thrown from user methods to
	 * propagate to the rest of the system.
	 *
	 * @return	A new MethodBuilder
	 */

/**
		This utility method returns an expression for CURRENT_DATE.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_DATE,
		that would otherwise be painful to create manually.
	 */

/**
		This utility method returns an expression for CURRENT_TIME.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_TIME,
		that would otherwise be painful to create manually.
	 */

/**
		This utility method generates an expression for CURRENT_TIMESTAMP.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_TIMESTAMP,
		that would otherwise be painful to create manually.
	 */

/**
		These utility methods buffers compilation from the IndexColumnOrder
		class.

		They create an ordering based on their parameter, stuff that into
		the prepared statement, and then return the entry # for
		use in the generated code.

		We could write another utility method to generate code to
		turn an entry # back into an object, but so far no-one needs it.
	
		WARNING: this is a crafty method that ASSUMES that 
		you want every column in the list ordered, and that every
		column in the list is the entire actual result colunm.
		It is only useful for DISTINCT in select.	
	 */

/**
	 * Add a column to the existing Ordering list.  Takes
	 * a column id and only adds it if it isn't in the list.
	 *
	 *
	 * @return the ColumnOrdering array
	 */

/**
	 * Get/reuse the Expression for getting the DataValueFactory
	 */

/**
		This is a utility method to get a common expression --
		"BaseActivation.getResultSetFactory()".
		
		BaseActivation gets the factory from the context and
		caches it for faster retrieval.
	 */

/**
		This is a utility method to get a common expression --
		"BaseActivation.getExecutionFactory()".
		REVISIT: could the same expression objects be reused within
		the tree and have the correct java generated each time?
		
		BaseActivation gets the factory from the context and
		caches it for faster retrieval. 
	 */

/**
	 * Generate a reference to the row array that
	 * all activations use.
	 * 
	 * @param eb the expression block
	 *
	 * @return expression
	 */

/**
	 * Generate a reference to a colunm in a result set.
	 * 
	 * @param rsNumber the result set number
	 * @param colId the column number
	 */

/**
	 * Generate a reference to the parameter value
	 * set that all activations use.
	 * 
	 */

/**
	 * generated the next field name available.
	 * these are of the form 'e#', where # is
	 * incremented each time.
	 * This shares the name space with the expression methods
	 * as Java allows names and fields to have the same name.
	 * This reduces the number of constant pool entries created
	 * for a generated class file.
	 */

/**
	 * Get the TypeCompiler associated with the given TypeId
	 *
	 * @param typeId	The TypeId to get a TypeCompiler for
	 *
	 * @return	The corresponding TypeCompiler
	 *
	 */

/**
	 * Take the generated class, and turn it into an
	 * actual class.
	 *  This method assumes, does not check, that
	 * the class and its parts are all complete.
 	 *
	 * @param savedBytes place to save generated bytes.
	 *	if null, it is ignored
	 * @exception StandardException thrown when exception occurs
	 */

/**
	 * Get a "this" expression declared as an Activation.
	 * This is the commonly used type of the this expression.
	 *
	 */

/**
		Generate a Null data value.
		Nothing is required on the stack, a SQL null data value
		is pushed.
	*/

/**
		Generate a Null data value.
		The express value is required on the stack and will be popped, a SQL null data value
		is pushed.
	*/

/**
		Generate a data value.
		The value is to be set in the SQL data value is required
		on the stack and will be popped, a SQL data value
		is pushed.
	*/

/**
	 *generates a variable name for the rowscanresultset.
	 *This can not be a fixed name because in cases like
	 *cascade delete same activation class will be dealing 
	 * more than one RowScanResultSets for dependent tables.
	*/

