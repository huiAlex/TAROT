/**
     * No arg constructor.
     * 
     * Public no arg constructor is for the monitor to call for format
     * id implemenation, it should not be called for any other reason.
     **/

/**
     * Constructs a leaf-page control row, for a newly allocated leaf page.  
     *
     * @param btree     The open btree to allocate this page from.
     * @param page      The newly allocated page where the control row will
     *                  be inserted.
     * @param parent    The parent of the leaf page.  Set to null for root.
     *                  RESOLVE (mikem) - set to null otherwise?
     * @param isRoot    Is this page the root of the tree?
     *
     * @exception StandardException Standard exception policy.
     */

/**
     * Allocate a new leaf page to the conglomerate.
     *
     * @param btree     The open conglomerate from which to get the leaf from
     * @param parent    The parent page of the newly allocated page, null if
     *                  allocating root page.
     * 
     * @exception StandardException Standard exception policy.
     */

/**
     * Return the number of non-deleted rows from slot 1 through "startslot"
     * 
     * Return the number of non-deleted rows that exist on the page starting
     * at slot one through "startslot".
     * 
     * RESOLVE (mikem) - is the expense of this routine worth it, it is only
     * used for costing.  Could an estimate from the nonDeletedRecordCount()
     * be used instead?
     *
	 * @return The requested non_deleted_row_count.
     *
     * @param startslot  Count non deleted row up to and including this slot.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
     * Perform page specific initialization.
     * 
     **/

/**
     * Initialize conglomerate with one page, to be a 1 page btree.
     *
     * Given a conglomerate which already has one page allocated to it, 
     * initialize the page to be a leaf-root page with no entries.  Allocate
     * the control row and store it on the page.
     *
     * @param open_btree The open btree to initialize (container is open).
     *
     * @exception StandardException Standard exception policy.
     */

/**
     * Get the number of columns in the control row.  
     * 
     * Control rows all share the first columns as defined by this class and
     * then add columns to the end of the control row.  For instance a branch
     * control row add a child page pointer field.
     * 
     *
	 * @return The total number of columns in the control row.
     **/

/**
     * Is the current page the leftmost leaf of tree?
     * 
     *
	 * @return true if the current page is the leftmost leaf of the tree,
     *              else return false.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
     * Is the current page the rightmost leaf of tree?
     * 
     *
	 * @return true if the current page is the rightmost leaf of the tree,
     *              else return false.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
	 ** Perform a search of this leaf page, ultimately returning the latched
	 ** leaf page and row slot after which the given key belongs.
	 ** The slot is returned in the result structure.  If the key
	 ** exists on the page, the result.exact will be true.  Otherwise,
	 ** result.exact will be false, and the row slot returned will be
	 ** the one immediately preceding the position at which the key
	 ** belongs.
     *
     * @exception StandardException Standard exception policy.
	 **/

/**
     * Search and return the left most leaf page.
     * 
	 * Perform a recursive search, ultimately returning the
     * leftmost leaf page which is the first leaf page in the
	 * leaf sibling chain.  (This method might better be called
	 * getFirstLeafPage()).
     *
	 * @return The leftmost leaf page.
     *
     * @param btree  The open btree to associate latches/locks with.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
     * Search and return the right most leaf page.
     * 
	 * Perform a recursive search, ultimately returning the
	 * rightmost leaf page which is the last leaf page in the
	 * leaf sibling chain.  (This method might better be called
	 * getLastLeafPage()).
     *
	 * @return The rightmost leaf page.
     *
     * @param btree  The open btree to associate latches/locks with.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
	 **	Perform a recursive shrink operation for the key.
	 ** If this method returns true, the caller should
	 ** remove the corresponding entry for the page.
	 ** This routine is not guaranteed to successfully
	 ** shrink anything.  The page lead to by the key might
	 ** turn out not to be empty by the time shrink gets
	 ** there, and shrinks will give up if there is a deadlock.
	 ** 
	 ** The receiver page must be latched on entry and is
	 ** returned unlatched.
     *
     * @exception StandardException Standard exception policy.
	 **/

/**
	 ** Grow a new root page from a leaf page.  Slightly
	 ** tricky because we want to retain page 0 as the root.
	 ** 
	 ** On entry, the current leaf root page is expected 
	 ** to be latched.  On exit, all latches will have been
	 ** released.
     ** 
     ** The caller cannot not assume success.  If we have to release latches
     ** this routine just returns and assumes the caller will retry the 
     ** grow root if necessary.
	 **/

/**
     * Return the left child pointer for the page.
     * 
     * Leaf pages don't have children, so they override this and return null.
     *
	 * @return The page which is the leftmost child of this page.
     *
     * @param btree  The open btree to associate latches/locks with.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
     * Return the right child pointer for the page.
     * 
     * Leaf pages don't have children, so they override this and return null.
     *
	 * @return The page which is the rightmost child of this page.
     *
     * @param btree  The open btree to associate latches/locks with.
     *
	 * @exception  StandardException  Standard exception policy.
     **/

/**
	 ** Perform consistency checks on a leaf page.
     ** 
	 ** Check consistency of the page and its children,
	 ** returning the number of pages seen, and throwing
	 ** errors if inconsistencies are found.
     ** The checks specific to a leaf page are:
	 ** 
	 **  Page is at level 0.
	 **  Version is a valid leaf page version.
	 **  Control row has right number of columns for leaf.
	 ** 
	 ** This method also performs the consistency checks that
	 ** are common to both leaf and branch pages.
     **      **
     ** @exception StandardException Standard exception policy.
	 **/

/**
	 ** Recursively print the tree starting at current node in tree.
     ** This is a leaf so return.

    @exception StandardException Standard exception policy.
	 **/

/**
		Return my format identifier.

			*/

