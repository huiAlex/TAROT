/**
 * This is the base implementation of TypeCompiler
 *
 */

/**
	 * Get the method name for getting out the corresponding primitive
	 * Java type.
	 *
	 * @return String		The method call name for getting the
	 *						corresponding primitive Java type.
	 */

/**
	 * 	 *
	 * @exception StandardException		Thrown on error
	 */

/**
     * The caller will have pushed a DataValueFactory and a null or a value
     * of the correct type (interfaceName()). Thus upon entry the
     * stack looks like on of:
     * ...,dvf,ref
     * ...,dvf,null
     * 
     * This method then sets up to call the required method
     * on DataValueFactory using the nullMethodName().
     * The value left on the stack will be a DataValueDescriptor
     * of the correct type:
     * 
     * ...,dvd
     * 
     *      */

/**
        Return the method name to get a Derby DataValueDescriptor
        object of the correct type set to SQL NULL. The method named will
        be called with one argument: a holder object if pushCollationForDataValue()
        returns false, otherwise two arguments, the second being the
        collationType.
    */

/**
		Return the method name to get a Derby DataValueDescriptor
		object of the correct type and set it to a specific value.
        The method named will be called with two arguments, a value to set the
        returned value to and a holder object if pushCollationForDataValue()
        returns false. Otherwise three arguments, the third being the
        collationType.
        This implementation returns "getDataValue" to map
        to the overloaded methods
        DataValueFactory.getDataValue(type, dvd type)
	*/

/**
     * Return true if the collationType is to be passed
     * to the methods generated by generateNull and
     * generateDataValue.
     * 
     * @param collationType Collation type of character values.
     * @return true collationType will be pushed, false collationType will be ignored.
     */

/**
	 * Determine whether thisType is storable in otherType due to otherType
	 * being a user type.
	 *
	 * @param thisType	The TypeId of the value to be stored
	 * @param otherType	The TypeId of the value to be stored in
	 *
	 * @return	true if thisType is storable in otherType
	 */

/**
	 * Tell whether this numeric type can be converted to the given type.
	 *
	 * @param otherType	The TypeId of the other type.
	 * @param forDataTypeFunction  was this called from a scalarFunction like
	 *                             CHAR() or DOUBLE()
	 */

/**
	 * Tell whether this numeric type can be stored into from the given type.
	 *
	 * @param thisType	The TypeId of this type
	 * @param otherType	The TypeId of the other type.
	 * @param cf		A ClassFactory
	 */

/**
	 * Get the TypeId that corresponds to this TypeCompiler.
	 */

/**
	 * Get the TypeCompiler that corresponds to the given TypeId.
	 */

/**
	 * Set the TypeCompiler that corresponds to the given TypeId.
	 */

/**
	 * Get the StoredFormatId from the corresponding
	 * TypeId.
	 *
	 * @return The StoredFormatId from the corresponding
	 * TypeId.
	 */

