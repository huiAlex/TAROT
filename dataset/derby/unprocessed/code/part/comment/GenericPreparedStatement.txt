/**
 * Basic implementation of prepared statement.
 * relies on implementation of ResultDescription and Statement that
 * are also in this package.
 * 
 * These are both dependents (of the schema objects and prepared statements
 * they depend on) and providers.  Prepared statements that are providers
 * are cursors that end up being used in positioned delete and update
 * statements (at present).
 * 
 * This is impl with the regular prepared statements; they will never
 * have the cursor info fields set.
 * 
 * Stored prepared statements extend this implementation
 *
 */

/** True if the statement was invalidated while it was being compiled. */

/**
		If non-null then this object is the cacheable
		that holds us in the cache.
	*/

/**
     * Incremented for each (re)compile.
     */

/**
     * Holder for row counts and execution count. Used for determining
     * whether the statement should be recompiled.
     */

/**
	 */

/**
     * Check whether this statement is up to date and its generated class is
     * identical to the supplied class object.
     *      */

/**
     * Unsynchronized helper method for {@link #upToDate()} and {@link
     * #upToDate(GeneratedClass)}. Checks whether this statement is up to date.
     *
     * @return {@code true} if this statement is up to date, {@code false}
     * otherwise
     */

/** Check if this statement is currently being compiled. */

/**
     * Signal that the statement is about to be compiled. This will block
     * others from attempting to compile it.
     */

/**
     * Signal that we're done compiling the statement and unblock others
     * that are waiting for the compilation to finish.
     */

/**
	 * Get a new activation instance.
	 *
	 * @exception StandardException thrown if finished.
	 */

/**
	 * 	 */

/**
	 * 	 */

/**
	 * 	 */

/**
	  *	The guts of execution.
	  *
	  *	@param	activation					the activation to run.
	  * @param rollbackParentContext True if 1) the statement context is
	  *  NOT a top-level context, AND 2) in the event of a statement-level
	  *	 exception, the parent context needs to be rolled back, too.
      * @param forMetaData true if this is a meta-data query
      * @param timeoutMillis timeout value in milliseconds.
	  *	@return	the result set to be pawed through
	  *
	  *	@exception	StandardException thrown on error
	  */

/** Return the type of the parameter (0-based indexing) */

/**
	 * Get the total compile time for the associated query in milliseconds.
	 * Compile time can be divided into parse, bind, optimize and generate times.
	 * 
	 * @return long		The total compile time for the associated query in milliseconds.
	 */

/**
	 * Get the parse time for the associated query in milliseconds.
	 * 
	 * @return long		The parse time for the associated query in milliseconds.
	 */

/**
	 * Get the bind time for the associated query in milliseconds.
	 * 
	 * @return long		The bind time for the associated query in milliseconds.
	 */

/**
	 * Get the optimize time for the associated query in milliseconds.
	 * 
	 * @return long		The optimize time for the associated query in milliseconds.
	 */

/**
	 * Get the generate time for the associated query in milliseconds.
	 * 
	 * @return long		The generate time for the associated query in milliseconds.
	 */

/**
	 * Get the timestamp for the beginning of compilation
	 *
	 * @return Timestamp	The timestamp for the beginning of compilation.
	 */

/**
	 * Get the timestamp for the end of compilation
	 *
	 * @return Timestamp	The timestamp for the end of compilation.
	 */

/**
	 * Set the compile time for this prepared statement.
	 *
	 * @param compileTime	The compile time
	 */

/**
		Finish marks a statement as totally unusable.
	 */

/**
	 *	Set the Execution constants. This routine is called as we Prepare the
	 *	statement.
	 *
	 *	@param constantAction The big structure enclosing the Execution constants.
	 */

/**
	 *	Get the Execution constants. This routine is called at Execution time.
	 *
	 *	@return	ConstantAction	The big structure enclosing the Execution constants.
	 */

/**
	 *	Set the saved objects. Called when compilation completes.
	 *
	 *	@param	objects	The objects to save from compilation
	 */

/**
	 *	Get the specified saved object.
	 *
	 *	@param	objectNum	The object to get.
	 *	@return	the requested saved object.
	 */

/**
	 *	Get the saved objects.
	 *
	 *	@return all the saved objects
	 */

/**
		Check that all of the dependent's dependencies are valid.

		@return true if the dependent is currently valid
	 */

/**
	 * set this prepared statement to be valid, currently used by
	 * GenericTriggerExecutor.
	 */

/**
	 * Indicate this prepared statement is an SPS action, currently used
	 * by GenericTriggerExecutor.
	 */

/**
		Prepare to mark the dependent as invalid (due to at least one of
		its dependencies being invalid).

		@param	action	The action causing the invalidation
		@param	p		the provider

		@exception StandardException thrown if unable to make it invalid
	 */

/**
		Mark the dependent as invalid (due to at least one of
		its dependencies being invalid).

		@param	action	The action causing the invalidation

	 	@exception StandardException Standard Derby error policy.
	 */

/**
	 * Is this dependent persistent?  A stored dependency will be required
	 * if both the dependent and provider are persistent.
	 *
	 * @return boolean		Whether or not this dependent is persistent.
	 */

/**		
		@return the stored form of this Dependable

			 */

/**
	 * Return the name of this Dependable.  (Useful for errors.)
	 *
	 * @return String	The name of this Dependable..
	 */

/**
	 * Get the Dependable's UUID String.
	 *
	 * @return String	The Dependable's UUID String.
	 */

/**
	 * Get the Dependable's class type.
	 *
	 * @return String		Classname that this Dependable belongs to.
	 */

/**
	 * Return true if the query node for this statement references SESSION schema
	 * tables/views.
	 * This method gets called at the very beginning of the compile phase of any statement.
	 * If the statement which needs to be compiled is already found in cache, then there is
	 * no need to compile it again except the case when the statement is referencing SESSION
	 * schema objects. There is a small window where such a statement might get cached 
	 * temporarily (a statement referencing SESSION schema object will be removed from the
	 * cache after the bind phase is over because that is when we know for sure that the 
	 * statement is referencing SESSION schema objects.)
	 *
	 * @return	true if references SESSION schema tables, else false
	 */

/**
	 * Return true if the QueryTreeNode references SESSION schema tables/views.
	 * The return value is also saved in the local field because it will be 
	 * used by referencesSessionSchema() method. 
	 * This method gets called when the statement is not found in cache and 
	 * hence it is getting compiled.
	 * At the beginning of compilation for any statement, first we check if
	 * the statement's plan already exist in the cache. If not, then we add
	 * the statement to the cache and continue with the parsing and binding.
	 * At the end of the binding, this method gets called to see if the 
	 * QueryTreeNode references a SESSION schema object. If it does, then
	 * we want to remove it from the cache, since any statements referencing
	 * SESSION schema objects should never get cached.  
	 *
	 * @return	true if references SESSION schema tables/views, else false
	 */

/**
		Makes the prepared statement valid, assigning
		values for its query tree, generated class,
		and associated information.

		@param qt the query tree for this statement

		@exception StandardException thrown on failure.
	 */

/**
	 * the update mode of the cursor
	 *
	 * @return	The update mode of the cursor
	 */

/**
	 * the target table of the cursor
	 *
	 * @return	target table of the cursor
	 */

/**
	 * Return the cursor info in a single chunk.  Used
	 * by StrorablePreparedStatement
	 */

/**
	 * Get the byte code saver for this statement.
	 * Overridden for StorablePreparedStatement.  We
	 * don't want to save anything
	 *
	 * @return a byte code saver (null for us)
	 */

/**
	 * Does this statement need a savepoint?  
	 * 
	 * @return true if this statement needs a savepoint.
	 */

/**
	 * Set the stmts 'needsSavepoint' state.  Used
	 * by an SPS to convey whether the underlying stmt
	 * needs a savepoint or not.
	 * 
	 * @param needsSavepoint true if this statement needs a savepoint.
	 */

/**
	 * Set the stmts 'isAtomic' state.  
	 * 
	 * @param isAtomic true if this statement must be atomic
	 * (i.e. it is not ok to do a commit/rollback in the middle)
	 */

/**
	 * Returns whether or not this Statement requires should
	 * behave atomically -- i.e. whether a user is permitted
	 * to do a commit/rollback during the execution of this
	 * statement.
	 *
	 * @return boolean	Whether or not this Statement is atomic
	 */

/**
	 * Set the name of the statement and schema for an "execute statement"
	 * command.
	 */

/**
	 * Get a new prepared statement that is a shallow copy
	 * of the current one.
	 *
	 * @return a new prepared statement
	 * 
	 * @exception StandardException on error
	 */

/**
     * This class holds information about stale plan check interval,
     * execution count and row count statistics for a GenericPreparedStatement.
     *
     * The fields and methods should ideally live in GenericPreparedStatement,
     * not in a separate class. However, triggers clone the GPS on each
     * execution, which means the statistics would be reset on each execution
     * if they lived directly inside GPS. Instead, keep the statistics in an
     * object that can be shared between multiple GPS instances when they
     * are cloned.
     */

/** @see ExecPreparedStatement#incrementExecutionCount() */

/** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */

/** @see ExecPreparedStatement#getStalePlanCheckInterval() */

/** @see ExecPreparedStatement#getInitialRowCount(int, long) */

/**
     * Privileged lookup of the ContextService. Must be private so that user code
     * can't call this entry point.
     */

/**
     * Privileged Monitor lookup. Must be private so that user code
     * can't call this entry point.
     */

/** @see ExecPreparedStatement#incrementExecutionCount() */

/** @see ExecPreparedStatement#getInitialRowCount(int, long) */

/** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */

/** @see ExecPreparedStatement#getStalePlanCheckInterval() */

/** Reset all the row count statistics. */

