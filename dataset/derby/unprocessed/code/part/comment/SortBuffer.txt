/**

  This class implements an in-memory ordered set
  based on the balanced binary tree algorithm from
  Knuth Vol. 3, Sec. 6.2.3, pp. 451-471.
  Nodes are always maintained in order,
  so that inserts and deletes can be intermixed.
  
  This algorithm will insert/delete N elements
  in O(N log(N)) time using O(N) space. 

**/

/**
	Returned from insert when the row was inserted
	without incident.
	**/

/**
	Returned from insert when the row which was
	inserted was a duplicate.  The set will have
	aggregated it in.
	**/

/**
	Returned from insert when the row was not able to be
	inserted because the set was full.
	**/

/**
	The sort this set is associated with.
	**/

/**
	Where to allocate nodes from.
	**/

/**
	Special head node for the tree.  Head.rightLink is the
	root of the tree.
	**/

/**
	The current height of the tree.
	**/

/**
	Set, as a side effect of deleteLeftMost (only), to the
	key from the node that was deleted from the tree.  This
	field is only valid after a call to deleteLeftMost.
	**/

/**
	Set, as a side effect of deleteLeftMost and rotateRight,
	if the subtree they're working on decreased in height.
	This field is only valid after a call to deleteLeftMost
	or rotateRight.
	**/

/**
	Set by the setNextAux() method.  This value is stuffed
	into the aux field of the next node that's allocated.
	**/

/**
	Read by the getLastAux() method.  This value is read out
	of the last node that was deallocated from the tree.
	**/

/**
	Arrange that the next node allocated in the tree have
	it's aux field set to the argument.
	**/

/**
	Retrieve the aux value from the last node deallocated
	from the tree.
	**/

/**
	Construct doesn't do anything, callers must call init
	and check its return code.
	**/

/**
	Initialize.  Returns false if the allocator
	couldn't be initialized.
	**/

/**
	Grow by a certain percent if we can
	*/

/**
	Return the number of elements this sorter can sort.
	It's the capacity of the node allocator minus one
	because the sorter uses one node for the head.
	**/

/**
	Insert a key k into the tree. Returns true if the
	key was inserted, false if the tree is full.  Silently
	ignores duplicate keys.
	
	See Knuth Vol. 3, Sec. 6.2.3, pp. 455-457 for the algorithm.
	**/

/**
	Return the lowest key and delete it from 
	the tree, preserving the balance of the tree.
	**/

/**
	Delete the node with the lowest key from the subtree defined
	by 'thisNode', maintaining balance in the subtree.  Returns
	the node that should be the new root of the subtree.  This
	method sets this.subtreeShrunk if the subtree of thisNode
	decreased in height. Saves the key that was in the deleted
	node in 'deletedKey'.
	**/

/**
	Perform either a single or double rotation, as appropriate, 
	to get the subtree 'thisNode' back in balance, assuming
	that the right subtree of 'thisNode' is higher than the
	left subtree.  Returns the node that should be the new
	root of the subtree.
	
	These are the cases depicted in diagrams (1) and (2) of
	Knuth (p. 454), and the node names reflect these diagrams.
	However, in deletion, the single rotation may encounter
	a case where the "beta" and "gamma" subtrees are the same
	height (b.balance == 0), so the resulting does not always
	shrink.
	
    Note: This code will not do the "mirror image" cases.
	It only works when the right subtree is the higher one
	(this is the only case encountered when deleting leftmost
	nodes from the tree).
	**/

