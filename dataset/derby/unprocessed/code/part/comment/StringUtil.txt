/**
	A set of public static methods for dealing with Strings
*/

/**
	 * Used to print out a string for error messages, 
	 * chops is off at 60 chars for historical reasons.
	 */

/**
	 * A method that receive an array of Objects and return a 
	 * String array representation of that array.
	 */

/**
     * Trim off trailing blanks but not leading blanks
     *
     * @param str
     *
     * @return The input with trailing blanks stipped off
     */

/**
		Truncate a String to the given length with no warnings
		or error raised if it is bigger.
	
		@param	value String to be truncated
		@param	length	Maximum length of string

		@return Returns value if value is null or value.length() is less or equal to than length, otherwise a String representing
			value truncated to length.
	*/

/**
	 * Return a slice (substring) of the passed in value, optionally trimmed.
	 * WARNING - endOffset is inclusive for historical reasons, unlike
	 * String.substring() which has an exclusive ending offset.
	 * @param value Value to slice, must be non-null.
	 * @param beginOffset Inclusive start character
	 * @param endOffset Inclusive end character
	 * @param trim To trim or not to trim
	 * @return Sliceed value.
	 */

/**
		Convert a byte array to a String with a hexidecimal format.
		The String may be converted back to a byte array using fromHexString.
		
		For each byte (b) two characaters are generated, the first character
		represents the high nibble (4 bits) in hexidecimal (b &amp; 0xf0), the second character
		represents the low nibble (b &ampxs; 0x0f).
		
		The byte at data[offset] is represented by the first two characters in the returned String.

		@param	data	byte array
		@param	offset	starting byte (zero based) to convert.
		@param	length	number of bytes to convert.

		@return the String (with hexidecimal format) form of the byte array
	*/

/**
		Convert a hexidecimal string generated by toHexString() back
		into a byte array.

		@param s String to convert
		@param offset starting character (zero based) to convert.
		@param length number of characters to convert.

		@return the converted byte array. Returns null if the length is
		not a multiple of 2.
	*/

/**
		Convert a byte array to a human-readable String for debugging purposes.
	*/

/** Convert string to uppercase
	 * Always use the java.util.ENGLISH locale
	 * @param s   string to uppercase
	 * @return uppercased string
	 */

/** Compares two strings 
	 * Strings will be uppercased in english and compared
	 * equivalent to s1.equalsIgnoreCase(s2)
	 * throws NPE if s1 is null
	 *
	 * @param s1  first string to compare
	 * @param s2  second string to compare
	 *
	 * @return   true if the two upppercased ENGLISH values are equal
	 *           return false if s2 is null
	 */

/**
	 * Normalize a SQL identifer, up-casing if ,
	 * and handling of  (SQL 2003, section 5.2).
	 * The normal form is used internally in Derby.
	 *
	 * @param id syntacically correct SQL identifier
	 */

/**
	 * Compress 2 adjacent (single or double) quotes into a single (s or d)
	 * quote when found in the middle of a String.
	 *
	 * NOTE:  """" or '''' will be compressed into "" or ''.
	 * This function assumes that the leading and trailing quote from a
	 * string or delimited identifier have already been removed.
	 * @param source string to be compressed
	 * @param quotes string containing two single or double quotes.
	 * @return String where quotes have been compressed
	 */

/**
     * Quote a string so that it can be used as an identifier or a string
     * literal in SQL statements. Identifiers are surrounded by double quotes
     * and string literals are surrounded by single quotes. If the string
     * contains quote characters, they are escaped.
     *
     * @param source the string to quote
     * @param quote the character to quote the string with (' or &quot;)
     * @return a string quoted with the specified quote character
     *      *      */

/**
     * Quote a string so that it can be used as a string literal in an
     * SQL statement.
     *
     * @param string the string to quote
     * @return the string surrounded by single quotes and with proper escaping
     * of any single quotes inside the string
     */

/**
	 * Utility for formatting which bends a multi-line string into shape for
	 * outputting it in a context where there is depth tabs. Trailing
	 * newlines are discarded as well.
	 * 
	 * Replace     "^[\t]*" with "depth" number of tabs.
	 * Replace     "\n+$" with "".
	 * Replace all "\n[\t]*" with "\n" + "depth" number of tabs.
	 * 
	 * @param formatted string to sanitize
	 * @param depth indentation level the string is to be printed at (0,1,2..)
	 */

/**
	 * Reg.exp substitute:
	 * 
	 * Pattern pat_a = Pattern.compile("\\A\\t*");
	 * Matcher m_a = pat_a.matcher(src);
	 * src = m_a.replaceFirst(indent.toString());
	 *
	 * @param src source string in which to substitute indent
	 * @param indent indentation to lead source
	 * @return new version of src after substitution
	 *
	 */

/**
	 * Reg.exp substitute:
	 * 
	 * Pattern pat_b = Pattern.compile("\\n+\\Z");
	 * Matcher m_b = pat_b.matcher(formatted);
	 * formatted = m_b.replaceFirst("");
	 *
	 * @param src source string in which to substitute
	 * @return new version of src after substitution
	 *
	 */

/**
	 * Reg.exp substitute:
	 * 
	 * Pattern pat_c = Pattern.compile("\\n\\t*");
	 * Matcher m_c = pat_c.matcher(formatted);
	 * formatted = m_c.replaceAll("\n" + indent.toString());
	 *
	 * @param src source string in which to substitute indent
	 * @param indent indentation to lead source
	 * @return new version of src after substitution
	 *
	 */

/**
     * Get the short database name from the canonical name.
     */

