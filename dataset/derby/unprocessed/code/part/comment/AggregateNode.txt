/**
 * An Aggregate Node is a node that represents a set function/aggregate.
 * It used for all system aggregates as well as user defined aggregates.
 */

/**
     * Constructed when binding a StaticMethodNode that we realize is
     * an aggregate.
     *
     * @param operand the value expression for the aggregate
     * @param uadClass the class of the user aggregate definition
     * @param alias the name by which the aggregate was called
     * @param distinct boolean indicating whether this is distinct
	 *					or not.
     * @param aggregateName the name of the aggregate from the user's
     *                  perspective, e.g. MAX
     * @param cm context manager
     *      */

/**
     * @param operand the value expression for the aggregate
     * @param uadClass the class name for user aggregate definition
     * for the aggregate
     * @param distinct boolean indicating whether this is distinct
     *                  or not.
     * @param aggregateName the name of the aggregate from the user's
     *                  perspective, e.g. MAX
     * @param cm context manager
     *      */

/**
     * @param operand the value expression for the aggregate
     * @param uadClass Class for the internal aggregate type
     * @param distinct boolean indicating whether this is distinct
     *                  or not.
     * @param aggregateName the name of the aggregate from the user's
     *                  perspective, e.g. MAX
     * @param cm context manager
     *      */

/** initialize fields for user defined aggregate */

/**
	 * Replace aggregates in the expression tree with a ColumnReference to
	 * that aggregate, append the aggregate to the supplied RCL (assumed to
	 * be from the child ResultSetNode) and return the ColumnReference.
	 * This is useful for pushing aggregates in the Having clause down to
	 * the user's select at parse time.  It is also used for moving around 
	 * Aggregates in the select list when creating the Group By node.  In 
	 * that case it is called  after  bind time, so we need to create
	 * the column differently.
	 *
	 * @param rcl	The RCL to append to.
	 * @param tableNumber	The tableNumber for the new ColumnReference
	 *
	 * @return ValueNode	The (potentially) modified tree.
	 *
	 * @exception StandardException			Thrown on error
	 */

/**
	 * Get the AggregateDefinition.
	 *
	 * @return The AggregateDefinition
	 */

/**
	 * Get the generated ResultColumn where this
	 * aggregate now resides after a call to 
	 * replaceAggregatesWithColumnReference().
	 *
	 * @return the result column
	 */

/**
	 * Get the generated ColumnReference to this
	 * aggregate after the parent called
	 * replaceAggregatesWithColumnReference().
	 *
	 * @return the column reference
	 */

/**
	 * Bind this operator.  Determine the type of the subexpression,
	 * and pass that into the UserAggregate.
	 *
	 * @param fromList			The query's FROM list
	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
     * @param aggregates        The aggregate list being built as we find AggregateNodes
	 *
	 * @return	The new top of the expression tree.
	 *
	 * @exception StandardException		Thrown on error
	 */

/**
	 * Resolve a user-defined aggregate.
	 */

/**
     * Construct an AliasDescriptor for a modern builtin aggregate.
     */

/**
	 * Indicate whether this aggregate is distinct or not.
	 *
	 * @return 	true/false
	 */

/**
	 * Get the class that implements that aggregator for this
	 * node.
	 *
	 * @return the class name
	 */

/**
	 * Get the class that implements that aggregator for this
	 * node.
	 *
	 * @return the class name
	 */

/**
	 * Get the result column that has a new aggregator.
	 * This aggregator will be fed into the sorter.
	 *
	 * @param dd	the data dictionary
	 *
	 * @return the result column.  WARNING: it still needs to be bound
	 *
	 * @exception StandardException on error
	 */

/**
	 * Get the aggregate expression in a new result
	 * column.
	 *
	 * @param dd the data dictionary
	 *
	 * @return the result column.  WARNING: it still needs to be bound
	 *
	 * @exception StandardException on error
	 */

/**
	 * Get the null aggregate result expression
	 * column.
	 *
	 * @return the value node
	 *
	 * @exception StandardException on error
	 */

/**
	 * Do code generation for this unary operator.  Should
	 * never be called for an aggregate -- it should be converted
	 * into something else by code generation time.
	 *
	 * @param acb	The ExpressionClassBuilder for the class we're generating
	 * @param mb	The method the code to place the code
	 *
	 * @exception StandardException		Thrown on error
	 */

/**
	 * Print a string ref of this node.
	 *
	 * @return a string representation of this node 
	 */

/** Get the SQL name of the aggregate */

/** Return true if this is a user-defined aggregate */

