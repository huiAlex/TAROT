<Class>
    <Id>2378</Id>
    <Package>org.drools.core.base.evaluators</Package>
    <ClassName>EvaluatorRegistry</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface>Externalizable</SuperInterface>
    </SuperInterfaceList>
    <ClassComment>EvaluatorRegistry  /** 
 * A registry class for all available evaluators
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>serialVersionUID</FieldName>
            <FieldType>long</FieldType>
        </Field>
        <Field>
            <FieldName>evaluators</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>evaluators</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>classloader</FieldName>
            <FieldType>ClassLoader</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>EvaluatorRegistry</MethodName>
            <MethodComment>/** 
 * Default constructor. The registry will use the context classloader (if available) to load the evaluator definition classes or this class classloader if it is not available.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>EvaluatorRegistry</MethodName>
            <MethodComment>/** 
 * Creates a new EvaluatorRegistry using the given classloader to load the evaluator definition classes.
 * @param classloader the classloader to use to load evaluator definitionclasses. If it is null, try to obtain the context classloader. If it is also null, uses the same classloader that loaded this class.
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>classloader</ParamName>
                    <ParamType>ClassLoader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>keySet</MethodName>
            <MethodComment>/** 
 * Return the set of registered keys.
 * @return a Set of Strings
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readExternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in</ParamName>
                    <ParamType>ObjectInput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
                <ExceptionType>ClassNotFoundException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeExternal</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>ObjectOutput</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>out;writeObject;[evaluators]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getDefaultClassLoader</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>ClassLoader</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addEvaluatorDefinition</MethodName>
            <MethodComment>/** 
 * Adds an evaluator definition class to the registry using the evaluator class name. The class will be loaded and the corresponting evaluator ID will be added to the registry. In case there exists an implementation for that ID already, the new implementation will replace the previous one.
 * @param className the name of the class for the implementation definition.The class must implement the EvaluatorDefinition interface.
 * @return true if the new class implementation is replacing an oldimplementation for the same evaluator ID. False otherwise.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>className</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addEvaluatorDefinition</MethodName>
            <MethodComment>/** 
 * Adds an evaluator definition class to the registry. In case there exists an implementation for that evaluator ID already, the new implementation will replace the previous one.
 * @param def the evaluator definition to be added.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>def</ParamName>
                    <ParamType>EvaluatorDefinition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvaluatorDefinition</MethodName>
            <MethodComment>/** 
 * Returns the evaluator definition for the given evaluator ID or null if no one was found
 * @param evaluatorId
 * @return
 */
</MethodComment>
            <ReturnType>EvaluatorDefinition</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>evaluatorId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvaluatorDefinition</MethodName>
            <MethodComment>/** 
 * Returns the evaluator definition for the given operator or null if no one was found
 * @param operator the operator implemented by the evaluator definition
 * @return
 */
</MethodComment>
            <ReturnType>EvaluatorDefinition</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvaluator</MethodName>
            <MethodComment>/** 
 * Returns the evaluator instance for the given type and the defined parameterText
 * @param type the type of the attributes this evaluator willoperate on. This is important because the evaluator may do optimizations and type coercion based on the types it is evaluating. It is also possible that this evaluator does not support a given type.
 * @param operatorId the string identifier of the evaluator
 * @param isNegated true if the evaluator instance to be returned isthe negated version of the evaluator.
 * @param parameterText some evaluators support parameters and theseparameters are defined as a String that is parsed by the evaluator itself.
 * @return an Evaluator instance capable of evaluating expressionsbetween values of the given type, or null in case the type is not supported.
 */
</MethodComment>
            <ReturnType>Evaluator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ValueType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operatorId</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isNegated</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvaluator</MethodName>
            <MethodComment>/** 
 * Returns the evaluator instance for the given type and the defined parameterText
 * @param type the type of the attributes this evaluator willoperate on. This is important because the evaluator may do optimizations and type coercion based on the types it is evaluating. It is also possible that this evaluator does not support a given type.
 * @param operator the operator that evaluator implements
 * @param parameterText some evaluators support parameters and theseparameters are defined as a String that is parsed by the evaluator itself.
 * @return an Evaluator instance capable of evaluating expressionsbetween values of the given type, or null in case the type is not supported.
 */
</MethodComment>
            <ReturnType>Evaluator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ValueType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>parameterText</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getEvaluator</MethodName>
            <MethodComment>/** 
 * Returns the evaluator instance for the given type and the defined parameterText
 * @param type the type of the attributes this evaluator willoperate on. This is important because the evaluator may do optimizations and type coercion based on the types it is evaluating. It is also possible that this evaluator does not support a given type.
 * @param operator the operator that evaluator implements
 * @return an Evaluator instance capable of evaluating expressionsbetween values of the given type, or null in case the type is not supported.
 */
</MethodComment>
            <ReturnType>Evaluator</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>ValueType</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>operator</ParamName>
                    <ParamType>Operator</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>