<Class>
    <Id>2254</Id>
    <Package>org.drools.compiler.builder.impl.errors</Package>
    <ClassName>ErrorHandler</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>ErrorHandler  /** 
 * This is the super of the error handlers. Each error handler knows how to report a compile error of its type, should it happen. This is needed, as the compiling is done as one hit at the end, and we need to be able to work out what rule/ast element caused the error. An error handler it created for each class task that is queued to be compiled. This doesn't mean an error has occurred, it just means it *may occur in the future and we need to be able to map it back to the AST element that originally spawned the code to be compiled.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>errors</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>message</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>inError</FieldName>
            <FieldType>boolean</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>isInError</MethodName>
            <MethodComment>/** 
 * This needes to be checked if there is infact an error 
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addError</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>err</ParamName>
                    <ParamType>CompilationProblem</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.errors;add;[err]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getError</MethodName>
            <MethodComment>/** 
 * @return A DroolsError object populated as appropriate, should theunthinkable happen and this need to be reported.
 */
</MethodComment>
            <ReturnType>DroolsError</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectCompilerProblems</MethodName>
            <MethodComment>/** 
 * We must use an error of JCI problem objects. If there are no problems, null is returned. These errors are placed in the DroolsError instances. Its not 1 to 1 with reported errors.
 */
</MethodComment>
            <ReturnType>CompilationProblem[]</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>