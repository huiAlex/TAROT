<Class>
    <Id>1678</Id>
    <Package>org.drools.compiler.builder.impl</Package>
    <ClassName>ClassHierarchyManager</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>kbuilder</FieldName>
            <FieldType>KnowledgeBuilderImpl</FieldType>
        </Field>
        <Field>
            <FieldName>sortedDescriptors</FieldName>
            <FieldType>List</FieldType>
        </Field>
        <Field>
            <FieldName>sortedDescriptors</FieldName>
            <FieldType>AbstractClassTypeDeclarationDescr</FieldType>
        </Field>
        <Field>
            <FieldName>taxonomy</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>taxonomy</FieldName>
            <FieldType>QualifiedName</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>ClassHierarchyManager</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>unsortedDescrs</ParamName>
                    <ParamType>AbstractClassTypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kbuilder</ParamName>
                    <ParamType>KnowledgeBuilderImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getSortedDescriptors</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AbstractClassTypeDeclarationDescr</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>sortByHierarchy</MethodName>
            <MethodComment>/** 
 * Utility method to sort declared beans. Linearizes the hierarchy, i.e.generates a sequence of declaration such that, if Sub is subclass of Sup, then the index of Sub will be &gt; than the index of Sup in the resulting collection. This ensures that superclasses are processed before their subclasses
 */
</MethodComment>
            <ReturnType>AbstractClassTypeDeclarationDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>unsortedDescrs</ParamName>
                    <ParamType>AbstractClassTypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>kbuilder</ParamName>
                    <ParamType>KnowledgeBuilderImpl</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;QualifiedName,AbstractClassTypeDeclarationDescr&gt; [cache=new HashMap&lt;QualifiedName,AbstractClassTypeDeclarationDescr&gt;()]</InnerVar>
                <InnerVar>List&lt;QualifiedName&gt; [sorted=new HierarchySorter&lt;QualifiedName&gt;().sort(taxonomy)]</InnerVar>
                <InnerVar>ArrayList [list=new ArrayList(sorted.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>hasCircularDependency</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>QualifiedName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeName</ParamName>
                    <ParamType>QualifiedName</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>taxonomy</ParamName>
                    <ParamType>QualifiedName</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection&lt;QualifiedName&gt; [parents=taxonomy.get(typeName)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>inheritFields</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkgRegistry</ParamName>
                    <ParamType>PackageRegistry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>AbstractClassTypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>sortedTypeDescriptors</ParamName>
                    <ParamType>AbstractClassTypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unresolvedTypes</ParamName>
                    <ParamType>TypeDefinition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unprocessableDescrs</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDeclarationDescr [tDescr=(TypeDeclarationDescr)typeDescr]</InnerVar>
                <InnerVar>boolean [isNovel=TypeDeclarationUtils.isNovelClass(typeDescr,pkgRegistry)]</InnerVar>
                <InnerVar>boolean [inferFields=!isNovel &amp;&amp; typeDescr.getFields().isEmpty()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildDescrsFromFields</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>klass</ParamName>
                    <ParamType>Class</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>TypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkgRegistry</ParamName>
                    <ParamType>PackageRegistry</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fieldMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ClassFieldInspector [inspector=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeInheritedFields</MethodName>
            <MethodComment>/** 
 * In order to build a declared class, the fields inherited from its superclass(es) are added to its declaration. Inherited descriptors are marked as such to distinguish them from native ones. Various scenarioes are possible. (i) The superclass has been declared in the DRL as well : the fields are cloned as inherited (ii) The superclass is imported (external), but some of its fields have been tagged with metadata (iii) The superclass is imported. &lt;p&gt; The search for field descriptors is carried out in the order. (i) and (ii+iii) are mutually exclusive. The search is as such: (i) The superclass' declared fields are used to build the base class additional fields (iii) The superclass is inspected to discover its (public) fields, from which descriptors are generated (ii) Both (i) and (iii) are applied, but the declared fields override the inspected ones
 * @param typeDescr The base class descriptor, to be completed with the inheritedfields descriptors
 * @return true if all went well
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>TypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unresolvedTypes</ParamName>
                    <ParamType>TypeDefinition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unprocessableDescrs</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeResolver</ParamName>
                    <ParamType>TypeResolver</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mergeFields</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>simpleSuperTypeName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>superTypePackageName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fullSuper</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>TypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unresolvedTypes</ParamName>
                    <ParamType>TypeDefinition</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unprocessableDescrs</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>TypeResolver</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Map&lt;String,TypeFieldDescr&gt; [fieldMap=new LinkedHashMap&lt;String,TypeFieldDescr&gt;()]</InnerVar>
                <InnerVar>boolean [isNovel=TypeDeclarationUtils.isNovelClass(typeDescr,kbuilder.getPackageRegistry(typeDescr.getNamespace()))]</InnerVar>
                <InnerVar>PackageRegistry [registry=kbuilder.getPackageRegistry(superTypePackageName)]</InnerVar>
                <InnerVar>InternalKnowledgePackage [pack=null]</InnerVar>
                <InnerVar>boolean [isSuperClassTagged=false]</InnerVar>
                <InnerVar>boolean [isSuperClassDeclared=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>typeDescr;setFields;[fieldMap]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildInheritedFieldDescrFromDefinition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TypeFieldDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>fld</ParamName>
                    <ParamType>org.kie.api.definition.type.FactField</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>TypeDeclarationDescr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeFieldDescr [inheritedFldDescr=new TypeFieldDescr()]</InnerVar>
                <InnerVar>PatternDescr [fldType=new PatternDescr()]</InnerVar>
                <InnerVar>String [initExprOverride=((FieldDefinition)fld).getInitExpr()]</InnerVar>
                <InnerVar>int [overrideCount=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>inheritedFldDescr;setFieldName;[fld.getName()]</InnerMethodInvoke>
                <InnerMethodInvoke>inheritedFldDescr;setResource;[typeDescr.getResource()]</InnerMethodInvoke>
                <InnerMethodInvoke>fldType;setObjectType;[((FieldDefinition)fld).getTypeName()]</InnerMethodInvoke>
                <InnerMethodInvoke>inheritedFldDescr;setPattern;[fldType]</InnerMethodInvoke>
                <InnerMethodInvoke>inheritedFldDescr;setIndex;[((FieldDefinition)fld).getDeclIndex()]</InnerMethodInvoke>
                <InnerMethodInvoke>inheritedFldDescr;setInherited;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>inheritedFldDescr;setInitExpr;[initExprOverride]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addDeclarationToPackagePreservingOrder</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>type</ParamName>
                    <ParamType>TypeDeclaration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>typeDescr</ParamName>
                    <ParamType>AbstractClassTypeDeclarationDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>tgtPackage</ParamName>
                    <ParamType>InternalKnowledgePackage</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pkgRegistryMap</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Collection&lt;QualifiedName&gt; [parents=taxonomy.get(new QualifiedName(type.getFullName()))]</InnerVar>
                <InnerVar>int [index=getSortedDescriptors().indexOf(typeDescr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>type;setOrder;[index + 1]</InnerMethodInvoke>
                <InnerMethodInvoke>tgtPackage;addTypeDeclaration;[type]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>