<Class>
    <Id>1813</Id>
    <Package>org.drools.compiler.lang</Package>
    <ClassName>DRL6StrictParser</ClassName>
    <SuperClass>AbstractDRLParser</SuperClass>
    <SuperInterfaceList>
        <SuperInterface>DRLParser</SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>exprParser</FieldName>
            <FieldType>DRL6Expressions</FieldType>
        </Field>
        <Field>
            <FieldName>annotationsCollector</FieldName>
            <FieldType>AnnotationsCollector</FieldType>
        </Field>
        <Field>
            <FieldName>descr</FieldName>
            <FieldType>AnnotatedBaseDescr</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DRL6StrictParser</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>TokenStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getLanguageLevel</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LanguageLevelOption</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>compilationUnit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>PackageDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>annotations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAnnotationsOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>AnnotatedDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>annotationsCollector;setAnnotationsOn;[builder]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAnnotationsOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>annotationsContainer</ParamName>
                    <ParamType>BaseDescr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>annotationsCollector;setAnnotationsOn;[annotationsContainer]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DroolsUnexpectedAnnotationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>newAnnotation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AnnotationDescrBuilder</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AnnotationDescrBuilder [annotation=new AnnotationDescrCreator(name)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>descr;addAnnotation;[(AnnotationDescr)annotation.getDescr()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>AnnotationDescrCreator</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>name</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>clear</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAnnotationsOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>AnnotatedDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>setAnnotationsOn</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>annotationsContainer</ParamName>
                    <ParamType>BaseDescr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DroolsUnexpectedAnnotationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>resyncToNextStatement</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>helper;reportError;[new DroolsMismatchedSetException(helper.getStatementKeywords(),input)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>packageStatement</MethodName>
            <MethodComment>/** 
 * Parses a package statement and returns the name of the package or null if none is defined. packageStatement := PACKAGE qualifiedIdentifier SEMICOLON?
 * @return the name of the package or null if none is defined
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [pkgName=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unitStatement</MethodName>
            <MethodComment>/** 
 * unitStatement := UNIT qualifiedIdentifier SEMICOLON?
 */
</MethodComment>
            <ReturnType>UnitDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>UnitDescrBuilder [imp=helper.start(pkg,UnitDescrBuilder.class,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>statement</MethodName>
            <MethodComment>/** 
 * statement := importStatement |  globalStatement |  declare |  rule |  ruleAttribute |  function |  query ;
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [descr=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>importStatement</MethodName>
            <MethodComment>/** 
 * importStatement := IMPORT ((FUNCTION|STATIC)? qualifiedIdentifier ((DOT STAR)? |(ACC|ACCUMULATE) qualifiedIdentifier ID)
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>ImportDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>globalStatement</MethodName>
            <MethodComment>/** 
 * globalStatement := GLOBAL type ID
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>GlobalDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GlobalDescrBuilder [global=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>declare</MethodName>
            <MethodComment>/** 
 * declare := DECLARE | (ENTRY-POINT) =&gt; entryPointDeclaration | (WINDOW) =&gt; windowDeclaration | (TRAIT) =&gt; typeDeclaration (trait) | (ENUM) =&gt; enumDeclaration | typeDeclaration (class) END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [declaration=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>entryPointDeclaration</MethodName>
            <MethodComment>/** 
 * entryPointDeclaration := annotation* ENTRY-POINT stringId END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>EntryPointDeclarationDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ddb</ParamName>
                    <ParamType>DeclareDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EntryPointDeclarationDescrBuilder [declare=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>windowDeclaration</MethodName>
            <MethodComment>/** 
 * windowDeclaration := annotation* WINDOW ID lhsPatternBind END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>WindowDeclarationDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ddb</ParamName>
                    <ParamType>DeclareDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>WindowDeclarationDescrBuilder [declare=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>enumDeclaration</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>EnumDeclarationDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ddb</ParamName>
                    <ParamType>DeclareDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EnumDeclarationDescrBuilder [declare=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeDeclaration</MethodName>
            <MethodComment>/** 
 * typeDeclaration := annotation* [TYPE] qualifiedIdentifier (EXTENDS qualifiedIdentifier)? field END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>TypeDeclarationDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ddb</ParamName>
                    <ParamType>DeclareDescrBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isTrait</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>TypeDeclarationDescrBuilder [declare=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>enumerative</MethodName>
            <MethodComment>/** 
 * enumerative := ID ( LEFT_PAREN expression (COMMA expression)* RIGHT_PAREN )?
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declare</ParamName>
                    <ParamType>EnumDeclarationDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EnumLiteralDescrBuilder [literal=null]</InnerVar>
                <InnerVar>String [lit=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>field</MethodName>
            <MethodComment>/** 
 * field := annotation* label fieldType (EQUALS_ASSIGN conditionalExpression)? SEMICOLON?
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>declare</ParamName>
                    <ParamType>AbstractClassTypeDeclarationBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FieldDescrBuilder [field=null]</InnerVar>
                <InnerVar>String [fname=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;annotations;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>function</MethodName>
            <MethodComment>/** 
 * function := FUNCTION type? ID parameters(typed) chunk_{_}
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>FunctionDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>FunctionDescrBuilder [function=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parameters</MethodName>
            <MethodComment>/** 
 * parameters := LEFT_PAREN ( parameter ( COMMA parameter )* )? RIGHT_PAREN
 * @param statement
 * @param requiresType
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requiresType</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parameter</MethodName>
            <MethodComment>/** 
 * parameter := ({requiresType}?=&gt;type)? ID (LEFT_SQUARE RIGHT_SQUARE)
 * @param statement
 * @param requiresType
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>statement</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>requiresType</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [type="Object"]</InnerVar>
                <InnerVar>int [start=input.index()]</InnerVar>
                <InnerVar>int [end=input.LT(-1).getTokenIndex()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, null, null, DroolsEditorType.IDENTIFIER]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>query</MethodName>
            <MethodComment>/** 
 * query := annotation* QUERY stringId parameters? lhsExpression END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>RuleDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>QueryDescrBuilder [query=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>speculateParameters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>requiresType</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [start=input.mark()]</InnerVar>
                <InnerVar>boolean [success=!state.failed]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>input;rewind;[start]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rule</MethodName>
            <MethodComment>/** 
 * rule := annotation* RULE stringId (EXTENDS stringId)? attributes? lhs? rhs END
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>RuleDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pkg</ParamName>
                    <ParamType>PackageDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RuleDescrBuilder [rule=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringId</MethodName>
            <MethodComment>/** 
 * stringId := ( ID | STRING )
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>attributes</MethodName>
            <MethodComment>/** 
 * attributes := (ATTRIBUTES COLON?)? [ attribute ( COMMA? attribute )* ]
 * @param rule
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>RuleDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>attribute</MethodName>
            <MethodComment>/** 
 * attribute := salience |   enabled |   ( NO-LOOP | AUTO-FOCUS | LOCK-ON-ACTIVE | REFRACT | DIRECT ) BOOLEAN? |   ( AGENDA-GROUP | ACTIVATION-GROUP | RULEFLOW-GROUP | DATE-EFFECTIVE | DATE-EXPIRES | DIALECT ) STRING |   CALENDARS STRING (COMMA STRING) |   TIMER ( DECIMAL | chunk_(_) ) |   DURATION ( DECIMAL | chunk_(_) ) The above syntax is not quite how this is parsed, because the soft keyword is determined by look-ahead and passed on to one of the x-Attribute methods (booleanAttribute, stringAttribute, stringListAttribute, intOrChunkAttribute) which will actually gobble the tokens.
 * @return
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescr [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>salience</MethodName>
            <MethodComment>/** 
 * salience := SALIENCE conditionalExpression
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>enabled</MethodName>
            <MethodComment>/** 
 * enabled := ENABLED conditionalExpression
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>booleanAttribute</MethodName>
            <MethodComment>/** 
 * booleanAttribute := attributeKey (BOOLEAN)?
 * @param key
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringAttribute</MethodName>
            <MethodComment>/** 
 * stringAttribute := attributeKey STRING
 * @param key
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringListAttribute</MethodName>
            <MethodComment>/** 
 * stringListAttribute := attributeKey STRING (COMMA STRING)
 * @param key
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>intOrChunkAttribute</MethodName>
            <MethodComment>/** 
 * intOrChunkAttribute := attributeKey ( DECIMAL | chunk_(_) )
 * @param key
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>AttributeDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>as</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>key</ParamName>
                    <ParamType>String[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AttributeDescrBuilder&lt;?&gt; [attribute=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhs</MethodName>
            <MethodComment>/** 
 * lhs := WHEN COLON? lhsExpression
 * @param rule
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>RuleDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.WHEN, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;lhsExpression;[rule != null ? rule.lhs() : null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsExpression</MethodName>
            <MethodComment>/** 
 * lhsExpression := lhsOr
 * @param lhs
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>lhs</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>helper;start;[lhs, CEDescrBuilder.class, null]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsOr</MethodName>
            <MethodComment>/** 
 * lhsOr := LEFT_PAREN OR lhsAnd+ RIGHT_PAREN | lhsAnd (OR lhsAnd)
 * @param ce
 * @param allowOr
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsAnd</MethodName>
            <MethodComment>/** 
 * lhsAnd := LEFT_PAREN AND lhsUnary+ RIGHT_PAREN | lhsUnary (AND lhsUnary)
 * @param ce
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsUnary</MethodName>
            <MethodComment>/** 
 * lhsUnary := annotation ( lhsExists namedConsequence? | lhsNot namedConsequence? | lhsEval consequenceInvocation | lhsForall | lhsAccumulate | LEFT_PAREN lhsOr RIGHT_PAREN namedConsequence? | lhsPatternBind consequenceInvocation ) SEMICOLON?
 * @param ce
 * @return
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;annotations;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;setAnnotationsOn;[result]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>consequenceInvocation</MethodName>
            <MethodComment>/** 
 * consequenceInvocation := conditionalBranch | namedConsequence
 * @param ce
 * @return
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conditionalBranch</MethodName>
            <MethodComment>/** 
 * conditionalBranch := IF LEFT_PAREN conditionalExpression RIGHT_PAREN ( namedConsequence | breakingNamedConsequence ) ( ELSE ( namedConsequence | breakingNamedConsequence | conditionalBranch ) )?
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>conditionalBranch</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>namedConsequence</MethodName>
            <MethodComment>/** 
 * namedConsequence := DO LEFT_SQUARE ID RIGHT_SQUARE BREAK?
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>namedConsequence</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>breakingNamedConsequence</MethodName>
            <MethodComment>/** 
 * breakingNamedConsequence := BREAK LEFT_SQUARE ID RIGHT_SQUARE
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>namedConsequence</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsExists</MethodName>
            <MethodComment>/** 
 * lhsExists := EXISTS ( (LEFT_PAREN (or_key|and_key))=&gt; lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind )
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CEDescrBuilder&lt;?,ExistsDescr&gt; [exists=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsNot</MethodName>
            <MethodComment>/** 
 * lhsNot := NOT ( (LEFT_PAREN (or_key|and_key))=&gt; lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind )
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CEDescrBuilder&lt;?,NotDescr&gt; [not=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsForall</MethodName>
            <MethodComment>/** 
 * lhsForall := FORALL LEFT_PAREN lhsPatternBind+ RIGHT_PAREN
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>ForallDescrBuilder&lt;?&gt; [forall=helper.start(ce,ForallDescrBuilder.class,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsEval</MethodName>
            <MethodComment>/** 
 * lhsEval := EVAL LEFT_PAREN conditionalExpression RIGHT_PAREN
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>EvalDescrBuilder&lt;?&gt; [eval=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseEvalExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>eval</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [idx=input.index()]</InnerVar>
                <InnerVar>String [expr]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>helper;emit;[Location.LOCATION_LHS_BEGIN_OF_CONDITION]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsParen</MethodName>
            <MethodComment>/** 
 * lhsParen := LEFT_PAREN lhsOr RIGHT_PAREN
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BaseDescr [descr=lhsOr(ce,allowOr)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsPatternBind</MethodName>
            <MethodComment>/** 
 * lhsPatternBind := label? ( LEFT_PAREN lhsPattern (OR lhsPattern)* RIGHT_PAREN | lhsPattern )
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>allowOr</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PatternDescrBuilder&lt;?&gt; [pattern=null]</InnerVar>
                <InnerVar>CEDescrBuilder&lt;?,OrDescr&gt; [or=null]</InnerVar>
                <InnerVar>BaseDescr [result=null]</InnerVar>
                <InnerVar>Token [first=input.LT(1)]</InnerVar>
                <InnerVar>String [label=null]</InnerVar>
                <InnerVar>boolean [isUnification=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsAccumulate</MethodName>
            <MethodComment>/** 
 * lhsAccumulate := (ACCUMULATE|ACC) LEFT_PAREN lhsAnd (COMMA|SEMICOLON) accumulateFunctionBinding (COMMA accumulateFunctionBinding) (SEMICOLON constraints)? RIGHT_PAREN SEMICOLON?
 * @param ce
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>BaseDescr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>PatternDescrBuilder&lt;?&gt; [pattern=null]</InnerVar>
                <InnerVar>BaseDescr [result=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>failMismatchedTokenException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DroolsMismatchedTokenException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>failMissingTokenException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>MissingTokenException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>failUnexpectedAnnotationException</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>annotationName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>DroolsUnexpectedAnnotationException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lhsPattern</MethodName>
            <MethodComment>/** 
 * lhsPattern := xpathPrimary | ( QUESTION? qualifiedIdentifier LEFT_PAREN positionalConstraints? constraints? RIGHT_PAREN (OVER patternFilter)? (FROM patternSource)? )
 * @param pattern
 * @param label
 * @param isUnification
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>label</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>isUnification</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [query=false]</InnerVar>
                <InnerVar>String [type=this.qualifiedIdentifier()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>label</MethodName>
            <MethodComment>/** 
 * label := ID COLON
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>edType</ParamName>
                    <ParamType>DroolsEditorType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Token [label=match(input,DRL6Lexer.ID,null,null,edType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.COLON, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unif</MethodName>
            <MethodComment>/** 
 * unif := ID UNIFY
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>edType</ParamName>
                    <ParamType>DroolsEditorType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Token [label=match(input,DRL6Lexer.ID,null,null,edType)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.UNIFY, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>speculatePositionalConstraints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [start=input.mark()]</InnerVar>
                <InnerVar>boolean [success=!state.failed]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>input;rewind;[start]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>positionalConstraints</MethodName>
            <MethodComment>/** 
 * positionalConstraints := constraint (COMMA constraint)* SEMICOLON
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constraint;[pattern, true, ""]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constraints</MethodName>
            <MethodComment>/** 
 * constraints := constraint (COMMA constraint)
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constraints;[pattern, ""]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constraints</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constraint;[pattern, false, prefix]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>constraint</MethodName>
            <MethodComment>/** 
 * constraint := nestedConstraint | conditionalOrExpression
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>positional</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [first=input.index()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exprParser.getHelper();setHasOperator;[false]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>last</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [expr=input.toString(first,last)]</InnerVar>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;toOrExpression;[sb, prefix, expr]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toOrExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sb</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>int [end=expr.indexOf("||")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toAndExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>sb</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [start=0]</InnerVar>
                <InnerVar>int [end=expr.indexOf("&amp;&amp;")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [colonPos=expr.indexOf(":")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>speculateNestedConstraint</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>nestedConstraint</MethodName>
            <MethodComment>/** 
 * nestedConstraint := ( ID ( DOT | HASH ) )* ID DOT LEFT_PAREN constraints RIGHT_PAREN
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [prefixLenght=getNestedConstraintPrefixLenght()]</InnerVar>
                <InnerVar>int [prefixStart=input.index()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;constraints;[pattern, prefix]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getNestedConstraintPrefixLenght</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [cursor=0]</InnerVar>
                <InnerVar>int [lastToken=input.LA(++cursor)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lastTokenWasWhiteSpace</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [index=input.index()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getCurrentLocation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>LinkedList&lt;DroolsSentence&gt; [ei=helper.getEditorInterface()]</InnerVar>
                <InnerVar>LinkedList&lt;?&gt; [content=ei.getLast().getContent()]</InnerVar>
                <InnerVar>ListIterator&lt;?&gt; [listIterator=content.listIterator(content.size())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>patternFilter</MethodName>
            <MethodComment>/** 
 * patternFilter :=   OVER filterDef DISALLOWED:        | ( PIPE filterDef )+
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.OVER, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;filterDef;[pattern]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>filterDef</MethodName>
            <MethodComment>/** 
 * filterDef := label ID LEFT_PAREN parameters RIGHT_PAREN
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>BehaviorDescrBuilder&lt;?&gt; [behavior=helper.start(pattern,BehaviorDescrBuilder.class,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>patternSource</MethodName>
            <MethodComment>/** 
 * patternSource := FROM ( fromAccumulate | fromCollect | fromEntryPoint | fromWindow | fromExpression )
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.FROM, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromExpression</MethodName>
            <MethodComment>/** 
 * fromExpression := conditionalOrExpression
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [expr=conditionalOrExpression()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromEntryPoint</MethodName>
            <MethodComment>/** 
 * fromEntryPoint := ENTRY-POINT stringId
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [ep=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.ENTRY, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.MINUS, null, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.POINT, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromWindow</MethodName>
            <MethodComment>/** 
 * fromWindow := WINDOW ID
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [window=""]</InnerVar>
                <InnerVar>Token [id=match(input,DRL6Lexer.ID,null,null,DroolsEditorType.IDENTIFIER)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.ID, DroolsSoftKeywords.WINDOW, null, DroolsEditorType.KEYWORD]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromCollect</MethodName>
            <MethodComment>/** 
 * fromCollect := COLLECT LEFT_PAREN lhsPatternBind RIGHT_PAREN
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>CollectDescrBuilder&lt;?&gt; [collect=helper.start(pattern,CollectDescrBuilder.class,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fromAccumulate</MethodName>
            <MethodComment>/** 
 * fromAccumulate := ACCUMULATE LEFT_PAREN lhsAnd (COMMA|SEMICOLON) ( INIT chunk_(_) COMMA ACTION chunk_(_) COMMA ( REVERSE chunk_(_) COMMA)? RESULT chunk_(_) | accumulateFunction ) RIGHT_PAREN
 * @param pattern
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AccumulateDescrBuilder&lt;?&gt; [accumulate=helper.start(pattern,AccumulateDescrBuilder.class,null)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>accumulateFunctionBinding</MethodName>
            <MethodComment>/** 
 * accumulateFunctionBinding := label accumulateFunction
 * @param accumulate
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>accumulate</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [label=null]</InnerVar>
                <InnerVar>boolean [unif=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;accumulateFunction;[accumulate, unif, label]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>accumulateFunction</MethodName>
            <MethodComment>/** 
 * accumulateFunction := label? ID parameters
 * @param accumulate
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>accumulate</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>unif</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>label</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Token [function=match(input,DRL6Lexer.ID,null,null,DroolsEditorType.KEYWORD)]</InnerVar>
                <InnerVar>List&lt;String&gt; [parameters=parameters()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parameters</MethodName>
            <MethodComment>/** 
 * parameters := LEFT_PAREN (conditionalExpression (COMMA conditionalExpression)* )? RIGHT_PAREN
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [parameters=new ArrayList&lt;String&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
                <InnerMethodInvoke>null;match;[input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>rhs</MethodName>
            <MethodComment>/** 
 * rhs := defaultConsequence namedConsequence* (~END)
 * @param rule
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>RuleDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;defaultConsequence;[rule]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>defaultConsequence</MethodName>
            <MethodComment>/** 
 * defaultConsequence := THEN chunk
 * @param rule
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>RuleDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>namedConsequence</MethodName>
            <MethodComment>/** 
 * namedConsequence := THEN LEFT_SQUARE ID RIGHT_SQUARE chunk
 * @param rule
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>RuleDescrBuilder</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getConsequenceCode</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>first</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [last=input.LT(1).getTokenIndex()]</InnerVar>
                <InnerVar>String [chunk=input.toString(first,last)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isNextTokenThenCompatible</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>next</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>annotation</MethodName>
            <MethodComment>/** 
 * annotation := fullAnnotation | AT ID chunk_(_)?
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>adb</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AnnotationDescrBuilder&lt;?&gt; [annotation=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>speculateFullAnnotation</MethodName>
            <MethodComment>/** 
 * Invokes the expression parser, trying to parse the annotation as a full java-style annotation
 * @return true if the sequence of tokens will match theelementValuePairs() syntax. false otherwise.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [start=input.mark()]</InnerVar>
                <InnerVar>boolean [success=!state.failed]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>input;rewind;[start]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>type</MethodName>
            <MethodComment>/** 
 * Matches a type name type := ID typeArguments? ( DOT ID typeArguments? )* (LEFT_SQUARE RIGHT_SQUARE)
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [type=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeArguments</MethodName>
            <MethodComment>/** 
 * Matches type arguments typeArguments := LESS typeArgument (COMMA typeArgument)* GREATER
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [typeArguments=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>typeArgument</MethodName>
            <MethodComment>/** 
 * Matches a type argument typeArguments := QUESTION (( EXTENDS | SUPER ) type )? |  type ;
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [typeArgument=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>qualifiedIdentifier</MethodName>
            <MethodComment>/** 
 * Matches a qualified identifier qualifiedIdentifier := ID ( DOT ID )
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>String [qi=""]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conditionalExpression</MethodName>
            <MethodComment>/** 
 * Matches a conditional expression
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [first=input.index()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exprParser;conditionalExpression;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>conditionalOrExpression</MethodName>
            <MethodComment>/** 
 * Matches a conditional || expression
 * @return
 * @throws org.antlr.runtime.RecognitionException
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>int [first=input.index()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>exprParser;conditionalOrExpression;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>chunk</MethodName>
            <MethodComment>/** 
 * Matches a chunk started by the leftDelimiter and ended by the rightDelimiter.
 * @param leftDelimiter
 * @param rightDelimiter
 * @param location
 * @return the matched chunk without the delimiters
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>leftDelimiter</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rightDelimiter</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [chunk=""]</InnerVar>
                <InnerVar>int [first=-1, last=first]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>match</MethodName>
            <MethodComment>/** 
 * Match current input symbol against ttype and optionally check the text of the token against text.  Attempt single token insertion or deletion error recovery.  If that fails, throw MismatchedTokenException.
 */
</MethodComment>
            <ReturnType>Token</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>TokenStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ttype</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>follow</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>etype</ParamName>
                    <ParamType>DroolsEditorType</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Token [matchedSymbol=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>helper;emit;[matchedSymbol, etype]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>recoverFromMismatchedToken</MethodName>
            <MethodComment>/** 
 * Attempt to recover from a single missing or extra token. EXTRA TOKEN LA(1) is not what we are looking for.  If LA(2) has the right token, however, then assume LA(1) is some extra spurious token.  Delete it and LA(2) as if we were doing a normal match(), which advances the input. MISSING TOKEN If current token is consistent with what could come after ttype then it is ok to "insert" the missing token, else throw exception For example, Input "i=(3;" is clearly missing the ')'.  When the parser returns from the nested call to expr, it will have call chain: stat -&gt; expr -&gt; atom and it will be trying to match the ')' at this point in the derivation: =&gt; ID '=' '(' INT ')' ('+' atom)* ';' ^ match() will see that ';' doesn't match ')' and report a mismatched token error.  To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom.  It can assume that you forgot the ')'.
 */
</MethodComment>
            <ReturnType>Token</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>TokenStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ttype</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>follow</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>RecognitionException [e=null]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>RecognitionException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mismatchIsUnwantedToken</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>TokenStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ttype</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>text</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>mismatchIsMissingToken</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>input</ParamName>
                    <ParamType>TokenStream</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>follow</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>safeStripDelimiters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>left</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>right</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>safeStripStringDelimiters</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>value</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>