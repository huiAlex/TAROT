<Class>
    <Id>236</Id>
    <Package>org.drools.core.util</Package>
    <ClassName>StringUtils</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>StringUtils  /** 
 * Ripped form commons StringUtil, unless specified: &lt;p&gt;Operations on  {@link java.lang.String} that are&lt;code&gt;null&lt;/code&gt; safe.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;IsEmpty/IsBlank&lt;/b&gt; - checks if a String contains text&lt;/li&gt; &lt;li&gt;&lt;b&gt;Trim/Strip&lt;/b&gt; - removes leading and trailing whitespace&lt;/li&gt; &lt;li&gt;&lt;b&gt;Equals&lt;/b&gt; - compares two strings null-safe&lt;/li&gt; &lt;li&gt;&lt;b&gt;IndexOf/LastIndexOf/Contains&lt;/b&gt; - null-safe index-of checks &lt;li&gt;&lt;b&gt;IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut&lt;/b&gt; - index-of any of a set of Strings&lt;/li&gt; &lt;li&gt;&lt;b&gt;ContainsOnly/ContainsNone&lt;/b&gt; - does String contains only/none of these characters&lt;/li&gt; &lt;li&gt;&lt;b&gt;Substring/Left/Right/Mid&lt;/b&gt; - null-safe substring extractions&lt;/li&gt; &lt;li&gt;&lt;b&gt;SubstringBefore/SubstringAfter/SubstringBetween&lt;/b&gt; - substring extraction relative to other strings&lt;/li&gt; &lt;li&gt;&lt;b&gt;Split/Join&lt;/b&gt; - splits a String into an array of substrings and vice versa&lt;/li&gt; &lt;li&gt;&lt;b&gt;Remove/Delete&lt;/b&gt; - removes part of a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;Replace/Overlay&lt;/b&gt; - Searches a String and replaces one String with another&lt;/li&gt; &lt;li&gt;&lt;b&gt;Chomp/Chop&lt;/b&gt; - removes the last part of a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;LeftPad/RightPad/Center/Repeat&lt;/b&gt; - pads a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize&lt;/b&gt; - changes the case of a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;CountMatches&lt;/b&gt; - counts the number of occurrences of one String in another&lt;/li&gt; &lt;li&gt;&lt;b&gt;IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable&lt;/b&gt; - checks the characters in a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;DefaultString&lt;/b&gt; - protects against a null input String&lt;/li&gt; &lt;li&gt;&lt;b&gt;Reverse/ReverseDelimited&lt;/b&gt; - reverses a String&lt;/li&gt; &lt;li&gt;&lt;b&gt;Abbreviate&lt;/b&gt; - abbreviates a string using ellipsis&lt;/li&gt; &lt;li&gt;&lt;b&gt;Difference&lt;/b&gt; - compares two Strings and reports on their differences&lt;/li&gt; &lt;li&gt;&lt;b&gt;LevensteinDistance&lt;/b&gt; - the number of changes needed to change one String into another&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The &lt;code&gt;StringUtils&lt;/code&gt; class defines certain words related to String handling.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;null - &lt;code&gt;null&lt;/code&gt;&lt;/li&gt; &lt;li&gt;empty - a zero-length string (&lt;code&gt;""&lt;/code&gt;)&lt;/li&gt; &lt;li&gt;space - the space character (&lt;code&gt;' '&lt;/code&gt;, char 32)&lt;/li&gt; &lt;li&gt;whitespace - the characters defined by  {@link Character#isWhitespace(char)}&lt;/li&gt; &lt;li&gt;trim - the characters &amp;lt;= 32 as in  {@link String#trim()}&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; input Strings quietly. That is to say that a &lt;code&gt;null&lt;/code&gt; input will return &lt;code&gt;null&lt;/code&gt;. Where a &lt;code&gt;boolean&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; is being returned details vary by method.&lt;/p&gt; &lt;p&gt;A side effect of the &lt;code&gt;null&lt;/code&gt; handling is that a &lt;code&gt;NullPointerException&lt;/code&gt; should be considered a bug in &lt;code&gt;StringUtils&lt;/code&gt; (except for deprecated methods).&lt;/p&gt; &lt;p&gt;Methods in this class give sample code to explain their operation. The symbol &lt;code&gt;*&lt;/code&gt; is used to indicate any input including &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
 * @see java.lang.String
 * @since 1.0
 * @version $Id$
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>EMPTY_STRING_ARRAY</FieldName>
            <FieldType>String[]</FieldType>
        </Field>
        <Field>
            <FieldName>EMPTY</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>INDEX_NOT_FOUND</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>PAD_LIMIT</FieldName>
            <FieldType>int</FieldType>
        </Field>
        <Field>
            <FieldName>FOLDER_SEPARATOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>WINDOWS_FOLDER_SEPARATOR</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>TOP_PATH</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>CURRENT_PATH</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>EXTENSION_SEPARATOR</FieldName>
            <FieldType>char</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>StringUtils</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; instances should NOT be constructed in standard programming. Instead, the class should be used as &lt;code&gt;StringUtils.trim(" foo ");&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance to operate.&lt;/p&gt;
 */
</MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>ucFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>lcFirst</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isEmpty</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Checks if a String is empty ("") or null.&lt;/p&gt; &lt;pre&gt; StringUtils.isEmpty(null)      = true StringUtils.isEmpty("")        = true StringUtils.isEmpty(" ")       = false StringUtils.isEmpty("bob")     = false StringUtils.isEmpty("  bob  ") = false &lt;/pre&gt; &lt;p&gt;NOTE: This method changed in Lang version 2.0. It no longer trims the String. That functionality is available in isBlank().&lt;/p&gt;
 * @param str  the String to check, may be null
 * @return &lt;code&gt;true&lt;/code&gt; if the String is empty or null
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>repeat</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a new String.&lt;/p&gt; &lt;pre&gt; StringUtils.repeat(null, 2) = null StringUtils.repeat("", 0)   = "" StringUtils.repeat("", 2)   = "" StringUtils.repeat("a", 3)  = "aaa" StringUtils.repeat("ab", 2) = "abab" StringUtils.repeat("a", -2) = "" &lt;/pre&gt;
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,&lt;code&gt;null&lt;/code&gt; if null String input
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>repeat</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [inputLength=str.length()]</InnerVar>
                <InnerVar>int [outputLength=inputLength * repeat]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitPreserveAllTokens</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Splits the provided text into an array, separators specified,  preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.&lt;/p&gt; &lt;p&gt;The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.&lt;/p&gt; &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt; &lt;pre&gt; StringUtils.splitPreserveAllTokens(null, *)           = null StringUtils.splitPreserveAllTokens("", *)             = [] StringUtils.splitPreserveAllTokens("abc def", null)   = ["abc", "def"] StringUtils.splitPreserveAllTokens("abc def", " ")    = ["abc", "def"] StringUtils.splitPreserveAllTokens("abc  def", " ")   = ["abc", "", def"] StringUtils.splitPreserveAllTokens("ab:cd:ef", ":")   = ["ab", "cd", "ef"] StringUtils.splitPreserveAllTokens("ab:cd:ef:", ":")  = ["ab", "cd", "ef", ""] StringUtils.splitPreserveAllTokens("ab:cd:ef::", ":") = ["ab", "cd", "ef", "", ""] StringUtils.splitPreserveAllTokens("ab::cd:ef", ":")  = ["ab", "", cd", "ef"] StringUtils.splitPreserveAllTokens(":cd:ef", ":")     = ["", cd", "ef"] StringUtils.splitPreserveAllTokens("::cd:ef", ":")    = ["", "", cd", "ef"] StringUtils.splitPreserveAllTokens(":cd:ef:", ":")    = ["", cd", "ef", ""] &lt;/pre&gt;
 * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
 * @param separatorChars  the characters used as the delimiters,&lt;code&gt;null&lt;/code&gt; splits on whitespace
 * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
 * @since 2.1
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>separatorChars</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitWorker</MethodName>
            <MethodComment>/** 
 * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and  &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that return a maximum array  length.
 * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
 * @param separatorChars the separate character
 * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit.
 * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators aretreated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent separators are treated as one separator.
 * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>separatorChars</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>max</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>preserveAllTokens</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [len=str.length()]</InnerVar>
                <InnerVar>List&lt;String&gt; [list=new ArrayList&lt;String&gt;()]</InnerVar>
                <InnerVar>int [sizePlus1=1]</InnerVar>
                <InnerVar>int [i=0, start=0]</InnerVar>
                <InnerVar>boolean [match=false]</InnerVar>
                <InnerVar>boolean [lastMatch=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>padding</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Returns padding using the specified delimiter repeated to a given length.&lt;/p&gt; &lt;pre&gt; StringUtils.padding(0, 'e')  = "" StringUtils.padding(3, 'e')  = "eee" StringUtils.padding(-2, 'e') = IndexOutOfBoundsException &lt;/pre&gt; &lt;p&gt;Note: this method doesn't not support padding with &lt;a href="http://www.unicode.org/glossary/#supplementary_character"&gt;Unicode Supplementary Characters&lt;/a&gt; as they require a pair of &lt;code&gt;char&lt;/code&gt;s to be represented. If you are needing to support full I18N of your applications consider using  {@link #repeat(String,int)} instead. &lt;/p&gt;
 * @param repeat  number of times to repeat delim
 * @param padChar  character to repeat
 * @return String with repeated character
 * @throws IndexOutOfBoundsException if &lt;code&gt;repeat &amp;lt; 0&lt;/code&gt;
 * @see #repeat(String,int)
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>repeat</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>padChar</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>char[] [buf=new char[repeat]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IndexOutOfBoundsException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>readFileAsString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unescapeJava</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Unescapes any Java literals found in the &lt;code&gt;String&lt;/code&gt;. For example, it will turn a sequence of &lt;code&gt;'\'&lt;/code&gt; and &lt;code&gt;'n'&lt;/code&gt; into a newline character, unless the &lt;code&gt;'\'&lt;/code&gt; is preceded by another &lt;code&gt;'\'&lt;/code&gt;.&lt;/p&gt;
 * @param str  the &lt;code&gt;String&lt;/code&gt; to unescape, may be null
 * @return a new unescaped &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; if null string input
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>unescapeJava</MethodName>
            <MethodComment>/** 
 * &lt;p&gt;Unescapes any Java literals found in the &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;For example, it will turn a sequence of &lt;code&gt;'\'&lt;/code&gt; and &lt;code&gt;'n'&lt;/code&gt; into a newline character, unless the &lt;code&gt;'\'&lt;/code&gt; is preceded by another &lt;code&gt;'\'&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input has no effect.&lt;/p&gt;
 * @param out  the &lt;code&gt;Writer&lt;/code&gt; used to output unescaped characters
 * @param str  the &lt;code&gt;String&lt;/code&gt; to unescape, may be null
 * @throws IllegalArgumentException if the Writer is &lt;code&gt;null&lt;/code&gt;
 * @throws IOException if error occurs on underlying Writer
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>out</ParamName>
                    <ParamType>Writer</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [sz=str.length()]</InnerVar>
                <InnerVar>StringBuilder [unicode=new StringBuilder(4)]</InnerVar>
                <InnerVar>boolean [hadSlash=false]</InnerVar>
                <InnerVar>boolean [inUnicode=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>cleanPath</MethodName>
            <MethodComment>/** 
 * Normalize the path by suppressing sequences like "path/.." and inner simple dots. &lt;p&gt;The result is convenient for path comparison. For other uses, notice that Windows separators ("\") are replaced by simple slashes.
 * @param path the original path
 * @return the normalized pathBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>path</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [pathToUse=replace(path,WINDOWS_FOLDER_SEPARATOR,FOLDER_SEPARATOR)]</InnerVar>
                <InnerVar>int [prefixIndex=pathToUse.indexOf(":")]</InnerVar>
                <InnerVar>String [prefix=""]</InnerVar>
                <InnerVar>String[] [pathArray=delimitedListToStringArray(pathToUse,FOLDER_SEPARATOR)]</InnerVar>
                <InnerVar>List [pathElements=new LinkedList()]</InnerVar>
                <InnerVar>int [tops=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectionToDelimitedString</MethodName>
            <MethodComment>/** 
 * Convenience method to return a Collection as a delimited (e.g. CSV) String. E.g. useful for &lt;code&gt;toString()&lt;/code&gt; implementations.
 * @param coll the Collection to display
 * @param delim the delimiter to use (probably a ",")
 * @param prefix the String to start each element with
 * @param suffix the String to end each element with
 * @return the delimited StringBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>coll</ParamName>
                    <ParamType>Collection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delim</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>prefix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>suffix</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
                <InnerVar>Iterator [it=coll.iterator()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectionToDelimitedString</MethodName>
            <MethodComment>/** 
 * Convenience method to return a Collection as a delimited (e.g. CSV) String. E.g. useful for &lt;code&gt;toString()&lt;/code&gt; implementations.
 * @param coll the Collection to display
 * @param delim the delimiter to use (probably a ",")
 * @return the delimited StringBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>coll</ParamName>
                    <ParamType>Collection</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delim</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replace</MethodName>
            <MethodComment>/** 
 * Replace all occurences of a substring within a string with another string.
 * @param inString String to examine
 * @param oldPattern String to replace
 * @param newPattern String to insert
 * @return a String with the replacementsBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>oldPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>newPattern</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sbuf=new StringBuilder()]</InnerVar>
                <InnerVar>int [pos=0]</InnerVar>
                <InnerVar>int [index=inString.indexOf(oldPattern)]</InnerVar>
                <InnerVar>int [patLen=oldPattern.length()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>sbuf;append;[inString.substring(pos)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toURI</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>URI</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>location</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>URISyntaxException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>escapeXmlString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder(string.length())]</InnerVar>
                <InnerVar>int [len=string.length()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delimitedListToStringArray</MethodName>
            <MethodComment>/** 
 * Take a String which is a delimited list and convert it to a String array. &lt;p&gt;A single delimiter can consists of more than one character: It will still be considered as single delimiter string, rather than as bunch of potential delimiter characters - in contrast to &lt;code&gt;tokenizeToStringArray&lt;/code&gt;.
 * @param str the input String
 * @param delimiter the delimiter between elements (this is a single delimiter,rather than a bunch individual delimiter characters)
 * @return an array of the tokens in the listBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>delimitedListToStringArray</MethodName>
            <MethodComment>/** 
 * Take a String which is a delimited list and convert it to a String array. &lt;p&gt;A single delimiter can consists of more than one character: It will still be considered as single delimiter string, rather than as bunch of potential delimiter characters - in contrast to &lt;code&gt;tokenizeToStringArray&lt;/code&gt;.
 * @param str the input String
 * @param delimiter the delimiter between elements (this is a single delimiter,rather than a bunch individual delimiter characters)
 * @param charsToDelete a set of characters to delete. Useful for deleting unwantedline breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String.
 * @return an array of the tokens in the listBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>delimiter</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charsToDelete</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List [result=new ArrayList()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toStringArray</MethodName>
            <MethodComment>/** 
 * Copy the given Collection into a String array. The Collection must contain String elements only.
 * @param collection the Collection to copy
 * @return the String array (&lt;code&gt;null&lt;/code&gt; if the passed-inCollection was &lt;code&gt;null&lt;/code&gt;) Borrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>collection</ParamName>
                    <ParamType>Collection</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>deleteAny</MethodName>
            <MethodComment>/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. "az\n" will delete 'a's, 'z's and new lines.
 * @return the resulting StringBorrowed from Spring, under the ASL2.0 license.
 */
</MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>inString</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>charsToDelete</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [out=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>Reader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>is</ParamName>
                    <ParamType>InputStream</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toString</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>reader</ParamName>
                    <ParamType>BufferedReader</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [sb=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>IOException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>generateUUID</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar>char[] [uuid=new char[32]]</InnerVar>
                <InnerVar>char[] [chars=UUID.randomUUID().toString().toCharArray()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractFirstIdentifier</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>StringBuilder [builder=new StringBuilder()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;extractFirstIdentifier;[string, builder, start]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>extractFirstIdentifier</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>builder</ParamName>
                    <ParamType>StringBuilder</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [started=false]</InnerVar>
                <InnerVar>int [i=start]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>skipBlanks</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [i=start]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitStatements</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitArgumentsList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>codeAwareSplitOnChar</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ch</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [args=new ArrayList&lt;String&gt;()]</InnerVar>
                <InnerVar>int [lastStart=0]</InnerVar>
                <InnerVar>int [nestedParam=0]</InnerVar>
                <InnerVar>boolean [isQuoted=false]</InnerVar>
                <InnerVar>String [lastArg=string.subSequence(lastStart,string.length()).toString().trim()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>codeAwareEqualsIgnoreSpaces</MethodName>
            <MethodComment>/** 
 * Compares two string being equals ignoring whitespaces, but preserving whitespace between double-quotes The two inputs MUST BE valid DRL/Java syntax (this validation is NOT performed by this method, this method assumes they are). Null check: if either of the input is null, this method will return true IFF both are null. Empty check: if either of the input is an empty string, it will be considered as a whitespace during code-aware comparison.
 */
</MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>in1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>in2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [idx1=0]</InnerVar>
                <InnerVar>Character [quoted1=null]</InnerVar>
                <InnerVar>int [idx2=0]</InnerVar>
                <InnerVar>Character [quoted2=null]</InnerVar>
                <InnerVar>boolean [equals=true]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>findEndOfMethodArgsIndex</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>string</ParamName>
                    <ParamType>CharSequence</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>startOfMethodArgsIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isDoubleQuoted=false]</InnerVar>
                <InnerVar>boolean [isSingleQuoted=false]</InnerVar>
                <InnerVar>int [nestingLevel=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>indexOfOutOfQuotes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>searched</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>indexOfOutOfQuotes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>searched</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>fromIndex</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>countQuoteOccurrences</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>start</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>end</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [count=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>indexOfOutOfQuotes</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>str</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>searched</ParamName>
                    <ParamType>char</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [isQuoted=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isIdentifier</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>isDereferencingIdentifier</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringSimilarity</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>SIMILARITY_STRATS</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>stringSimilarityDice</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>double</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [n1=s1.length() - 1]</InnerVar>
                <InnerVar>int [n2=s2.length() - 1]</InnerVar>
                <InnerVar>int [n]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>commonBigrams</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int [acc=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>equalsIgnoreSpaces</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>s1</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>s2</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>uuid</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>