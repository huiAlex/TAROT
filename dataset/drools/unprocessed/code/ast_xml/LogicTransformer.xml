<Class>
    <Id>2306</Id>
    <Package>org.drools.core.rule</Package>
    <ClassName>LogicTransformer</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment>LogicTransformer  /** 
 * LogicTransformation is reponsible for removing redundant nodes and move Or nodes upwards. This class does not turn Exists into two Nots at this stage, that role is delegated to the Builder.
 */
</ClassComment>
    <FieldList>
        <Field>
            <FieldName>orTransformations</FieldName>
            <FieldType>Map</FieldType>
        </Field>
        <Field>
            <FieldName>orTransformations</FieldName>
            <FieldType>GroupElement.Type</FieldType>
        </Field>
        <Field>
            <FieldName>INSTANCE</FieldName>
            <FieldType>LogicTransformer</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>getInstance</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>LogicTransformer</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>LogicTransformer</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;initialize;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>initialize</MethodName>
            <MethodComment>/** 
 * sets up the parent-&gt;child transformations map
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;addTransformationPair;[GroupElement.NOT, new NotOrTransformation()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addTransformationPair;[GroupElement.EXISTS, new ExistOrTransformation()]</InnerMethodInvoke>
                <InnerMethodInvoke>null;addTransformationPair;[GroupElement.AND, new AndOrTransformation()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>addTransformationPair</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>GroupElement.Type</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>method</ParamName>
                    <ParamType>Transformation</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>this.orTransformations;put;[parent, method]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transform</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroupElement[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cloned</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>globals</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [hasNamedConsequenceAndIsStream=processTree(cloned)]</InnerVar>
                <InnerVar>GroupElement[] [ands]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>cloned;pack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processNamedConsequences</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroupElement[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ands</ParamName>
                    <ParamType>GroupElement[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;GroupElement&gt; [result=new ArrayList&lt;GroupElement&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>splitOr</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>GroupElement[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>cloned</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroupElement[] [ands=new GroupElement[cloned.getChildren().size()]]</InnerVar>
                <InnerVar>int [i=0]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>fixClonedDeclarations</MethodName>
            <MethodComment>/** 
 * During the logic transformation, we eventually clone CEs,  specially patterns and corresponding declarations. So now we need to fix any references to cloned declarations.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>and</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>globals</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Stack&lt;RuleConditionElement&gt; [contextStack=new Stack&lt;RuleConditionElement&gt;()]</InnerVar>
                <InnerVar>DeclarationScopeResolver [resolver=new DeclarationScopeResolver(globals,contextStack)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>contextStack;push;[and]</InnerMethodInvoke>
                <InnerMethodInvoke>null;processElement;[resolver, contextStack, and]</InnerMethodInvoke>
                <InnerMethodInvoke>contextStack;pop;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processElement</MethodName>
            <MethodComment>/** 
 * recurse through the rule condition elements updating the declaration objecs
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>DeclarationScopeResolver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>contextStack</ParamName>
                    <ParamType>RuleConditionElement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>RuleConditionElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceDeclarations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>DeclarationScopeResolver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>pattern</ParamName>
                    <ParamType>Pattern</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>constraint</ParamName>
                    <ParamType>Constraint</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Declaration[] [decl=constraint.getRequiredDeclarations()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>replaceDeclarations</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>DeclarationScopeResolver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulate</ParamName>
                    <ParamType>Accumulate</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Declaration[] [decl=accumulate.getRequiredDeclarations()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>asList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Integer</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ints</ParamName>
                    <ParamType>int[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;Integer&gt; [list=new ArrayList&lt;Integer&gt;(ints.length)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toIntArray</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>int[]</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>list</ParamName>
                    <ParamType>Integer</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>int[] [ints=new int[list.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processEvalCondition</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>DeclarationScopeResolver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>EvalCondition</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Declaration[] [decl=element.getRequiredDeclarations()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processBranch</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>resolver</ParamName>
                    <ParamType>DeclarationScopeResolver</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>branch</ParamName>
                    <ParamType>ConditionalBranch</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;processEvalCondition;[resolver, branch.getEvalCondition()]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processTree</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>boolean</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean[] [hasNamedConsequenceAndIsStream=new boolean[2]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>null;processTree;[ce, hasNamedConsequenceAndIsStream]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processTree</MethodName>
            <MethodComment>/** 
 * Traverses a Tree, during the process it transforms Or nodes moving the upwards and it removes duplicate logic statement, this does not include Not nodes. Traversal involves three levels the graph for each iteration. The first level is the current node, this node will not be transformed, instead what we are interested in are the children of the current node (called the parent nodes) and the children of those parents (call the child nodes).
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ce</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>result</ParamName>
                    <ParamType>boolean[]</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>boolean [hasChildOr=false]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>ce;pack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>applyOrTransformation</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Transformation [transformation=this.orTransformations.get(parent.getType())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>transformation;transform;[parent]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transform</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>element</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transform</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;GroupElement&gt; [orsList=new ArrayList&lt;GroupElement&gt;()]</InnerVar>
                <InnerVar>RuleConditionElement[] [others=new RuleConditionElement[parent.getChildren().size()]]</InnerVar>
                <InnerVar>int [permutations=1]</InnerVar>
                <InnerVar>int [index=0]</InnerVar>
                <InnerVar>int[] [indexes=new int[orsList.size()]]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>parent;setType;[GroupElement.OR]</InnerMethodInvoke>
                <InnerMethodInvoke>parent.getChildren();clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>parent;pack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transform</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroupElement [or=(GroupElement)parent.getChildren().get(0)]</InnerVar>
                <InnerVar>GroupElement [and=GroupElementFactory.newAndInstance()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>parent;setType;[GroupElement.NOT]</InnerMethodInvoke>
                <InnerMethodInvoke>parent.getChildren();clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>parent;addChild;[and]</InnerMethodInvoke>
                <InnerMethodInvoke>parent;pack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>transform</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>parent</ParamName>
                    <ParamType>GroupElement</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>GroupElement [or=(GroupElement)parent.getChildren().get(0)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>parent;setType;[GroupElement.AND]</InnerMethodInvoke>
                <InnerMethodInvoke>parent.getChildren();clear;[]</InnerMethodInvoke>
                <InnerMethodInvoke>parent;pack;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType>InvalidPatternException</ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>