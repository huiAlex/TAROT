<Class>
    <Id>1290</Id>
    <Package>org.drools.modelcompiler.builder.generator.visitor.accumulate</Package>
    <ClassName>AccumulateVisitor</ClassName>
    <SuperClass></SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>context</FieldName>
            <FieldType>RuleContext</FieldType>
        </Field>
        <Field>
            <FieldName>packageModel</FieldName>
            <FieldType>PackageModel</FieldType>
        </Field>
        <Field>
            <FieldName>modelGeneratorVisitor</FieldName>
            <FieldType>ModelGeneratorVisitor</FieldType>
        </Field>
        <Field>
            <FieldName>expressionBuilder</FieldName>
            <FieldType>AbstractExpressionBuilder</FieldType>
        </Field>
        <Field>
            <FieldName>patternBinding</FieldName>
            <FieldType>Optional</FieldType>
        </Field>
        <Field>
            <FieldName>patternBinding</FieldName>
            <FieldType>String</FieldType>
        </Field>
        <Field>
            <FieldName>bindExpression</FieldName>
            <FieldType>MethodCallExpr</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>AccumulateVisitor</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>RuleContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>modelGeneratorVisitor</ParamName>
                    <ParamType>ModelGeneratorVisitor</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>packageModel</ParamName>
                    <ParamType>PackageModel</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>descr</ParamName>
                    <ParamType>AccumulateDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>basePattern</ParamName>
                    <ParamType>PatternDescr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodCallExpr [accumulateDSL=new MethodCallExpr(null,"accumulate")]</InnerVar>
                <InnerVar>MethodCallExpr [accumulateExprs=new MethodCallExpr(null,"and")]</InnerVar>
                <InnerVar>BaseDescr [input=descr.getInputPattern() == null ? descr.getInput() : descr.getInputPattern()]</InnerVar>
                <InnerVar>boolean [inputPatternHasConstraints=(input instanceof PatternDescr) &amp;&amp; (!((PatternDescr)input).getConstraint().getDescrs().isEmpty())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>context;addExpression;[accumulateDSL]</InnerMethodInvoke>
                <InnerMethodInvoke>accumulateDSL;addArgument;[accumulateExprs]</InnerMethodInvoke>
                <InnerMethodInvoke>context;pushExprPointer;[accumulateExprs::addArgument]</InnerMethodInvoke>
                <InnerMethodInvoke>input;accept;[modelGeneratorVisitor]</InnerMethodInvoke>
                <InnerMethodInvoke>context;popExprPointer;[]</InnerMethodInvoke>
                <InnerMethodInvoke>null;postVisit;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AccumulateVisitorPatternDSL.NewBinding</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>RuleContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>AccumulateDescr.AccumulateFunctionCallDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulateDSL</ParamName>
                    <ParamType>MethodCallExpr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>basePattern</ParamName>
                    <ParamType>PatternDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputPatternHasConstraints</ParamName>
                    <ParamType>boolean</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodCallExpr [functionDSL=new MethodCallExpr(null,"accFunction")]</InnerVar>
                <InnerVar>String [expression=function.getParams()[0]]</InnerVar>
                <InnerVar>Expression [expr=DrlxParseUtil.parseExpression(expression).getExpr()]</InnerVar>
                <InnerVar>String [bindingId=Optional.ofNullable(function.getBind()).orElse(basePattern.getIdentifier())]</InnerVar>
                <InnerVar>Optional&lt;AccumulateVisitorPatternDSL.NewBinding&gt; [newBinding=Optional.empty()]</InnerVar>
                <InnerVar>MethodCallExpr [asDSL=new MethodCallExpr(functionDSL,"as")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>context;pushExprPointer;[accumulateDSL::addArgument]</InnerMethodInvoke>
                <InnerMethodInvoke>asDSL;addArgument;[new NameExpr(toVar(bindingId))]</InnerMethodInvoke>
                <InnerMethodInvoke>accumulateDSL;addArgument;[asDSL]</InnerMethodInvoke>
                <InnerMethodInvoke>context;popExprPointer;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onSuccess</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AccumulateVisitorPatternDSL.NewBinding</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>drlxParseResult</ParamName>
                    <ParamType>DrlxParseSuccess</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>AccumulateFunction [accumulateFunction=AccumulateVisitor.this.getAccumulateFunction(function,drlxParseResult.getExprType())]</InnerVar>
                <InnerVar>String [bindExpressionVariable=context.getExprId(accumulateFunction.getResultType(),drlxParseResult.getLeft().toString())]</InnerVar>
                <InnerVar>MethodCallExpr [newBindingFromBinary=AccumulateVisitor.this.buildBinding(bindExpressionVariable,drlxParseResult.getUsedDeclarations(),drlxParseResult.getExpr())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>drlxParseResult;setExprBinding;[bindExpressionVariable]</InnerMethodInvoke>
                <InnerMethodInvoke>context;addDeclarationReplacing;[new DeclarationSpec(drlxParseResult.getPatternBinding(),drlxParseResult.getExprType())]</InnerMethodInvoke>
                <InnerMethodInvoke>functionDSL;addArgument;[new ClassExpr(toType(accumulateFunction.getClass()))]</InnerMethodInvoke>
                <InnerMethodInvoke>context;addDeclarationReplacing;[new DeclarationSpec(bindExpressionVariable,drlxParseResult.getExprType())]</InnerMethodInvoke>
                <InnerMethodInvoke>functionDSL;addArgument;[new NameExpr(toVar(bindExpressionVariable))]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>onFail</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AccumulateVisitorPatternDSL.NewBinding</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>failure</ParamName>
                    <ParamType>DrlxParseFail</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getAccumulateFunction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>AccumulateFunction</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>function</ParamName>
                    <ParamType>AccumulateDescr.AccumulateFunctionCallDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodCallExprType</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>String [accumulateFunctionName=AccumulateUtil.getFunctionName(() -&gt; methodCallExprType,function.getFunction())]</InnerVar>
                <InnerVar>Optional&lt;AccumulateFunction&gt; [bundledAccumulateFunction=Optional.ofNullable(packageModel.getConfiguration().getAccumulateFunction(accumulateFunctionName))]</InnerVar>
                <InnerVar>Optional&lt;AccumulateFunction&gt; [importedAccumulateFunction=Optional.ofNullable(packageModel.getAccumulateFunctions().get(accumulateFunctionName))]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>getRootNodeName</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>methodCallWithoutRootNode</ParamName>
                    <ParamType>DrlxParseUtil.RemoveRootNodeResult</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Expression [rootNode=methodCallWithoutRootNode.getRootNode().orElseThrow(UnsupportedOperationException::new)]</InnerVar>
                <InnerVar>String [rootNodeName]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>parseMethodCallType</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>TypedExpression</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context</ParamName>
                    <ParamType>RuleContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>variableName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>methodCallWithoutRoot</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>Class [clazz=context.getDeclarationById(variableName).map(DeclarationSpec::getDeclarationClass).orElseThrow(RuntimeException::new)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildConstraintExpression</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>Expression</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>expr</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>usedDeclarations</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>LambdaExpr [lambdaExpr=new LambdaExpr()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>lambdaExpr;setEnclosingParameters;[true]</InnerMethodInvoke>
                <InnerMethodInvoke>usedDeclarations.stream().map(s -&gt; new Parameter(new UnknownType(),s));forEach;[lambdaExpr::addParameter]</InnerMethodInvoke>
                <InnerMethodInvoke>lambdaExpr;setBody;[new ExpressionStmt(expr)]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>visitAccInlineCustomCode</MethodName>
            <MethodComment>/** 
 * By design this legacy accumulate (with inline custome code) visitor supports only with 1-and-only binding in the accumulate code/expressions.
 */
</MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context2</ParamName>
                    <ParamType>RuleContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>descr</ParamName>
                    <ParamType>AccumulateDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulateDSL</ParamName>
                    <ParamType>MethodCallExpr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>basePattern</ParamName>
                    <ParamType>PatternDescr</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputDescr</ParamName>
                    <ParamType>PatternDescr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>MethodCallExpr [functionDSL=new MethodCallExpr(null,"accFunction")]</InnerVar>
                <InnerVar>String [code=null]</InnerVar>
                <InnerVar>String [targetClassName=StringUtil.toId(context2.getRuleDescr().getName()) + "Accumulate" + descr.getLine()]</InnerVar>
                <InnerVar>CompilationUnit [templateCU=JavaParser.parse(code)]</InnerVar>
                <InnerVar>ClassOrInterfaceDeclaration [templateClass=templateCU.getClassByName(targetClassName).orElseThrow(() -&gt; new RuntimeException("Template did not contain expected type definition."))]</InnerVar>
                <InnerVar>ClassOrInterfaceDeclaration [templateContextClass=templateClass.getMembers().stream().filter(m -&gt; m instanceof ClassOrInterfaceDeclaration &amp;&amp; ((ClassOrInterfaceDeclaration)m).getNameAsString().equals("ContextData")).map(ClassOrInterfaceDeclaration.class::cast).findFirst().orElseThrow(() -&gt; new RuntimeException("Template did not contain expected type definition."))]</InnerVar>
                <InnerVar>List&lt;String&gt; [contextFieldNames=new ArrayList&lt;&gt;()]</InnerVar>
                <InnerVar>MethodDeclaration [initMethod=templateClass.getMethodsByName("init").get(0)]</InnerVar>
                <InnerVar>BlockStmt [initBlock=JavaParser.parseBlock("{" + descr.getInitCode() + "}")]</InnerVar>
                <InnerVar>Type [singleAccumulateType=JavaParser.parseType("java.lang.Object")]</InnerVar>
                <InnerVar>MethodDeclaration [accumulateMethod=templateClass.getMethodsByName("accumulate").get(0)]</InnerVar>
                <InnerVar>BlockStmt [actionBlock=JavaParser.parseBlock("{" + descr.getActionCode() + "}")]</InnerVar>
                <InnerVar>Collection&lt;String&gt; [allNamesInActionBlock=collectNamesInBlock(context2,actionBlock)]</InnerVar>
                <InnerVar>MethodDeclaration [resultMethod=templateClass.getMethodsByName("getResult").get(0)]</InnerVar>
                <InnerVar>Type [returnExpressionType=JavaParser.parseType("java.lang.Object")]</InnerVar>
                <InnerVar>Expression [returnExpression=JavaParser.parseExpression(descr.getResultCode())]</InnerVar>
                <InnerVar>MethodDeclaration [getResultTypeMethod=templateClass.getMethodsByName("getResultType").get(0)]</InnerVar>
                <InnerVar>String [bindingId=basePattern.getIdentifier()]</InnerVar>
                <InnerVar>MethodCallExpr [asDSL=new MethodCallExpr(functionDSL,"as")]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke>context;pushExprPointer;[accumulateDSL::addArgument]</InnerMethodInvoke>
                <InnerMethodInvoke>null;writeAccumulateMethod;[contextFieldNames, singleAccumulateType, accumulateMethod, actionBlock]</InnerMethodInvoke>
                <InnerMethodInvoke>null;rescopeNamesToNewScope;[new NameExpr("data"), contextFieldNames, returnExpression]</InnerMethodInvoke>
                <InnerMethodInvoke>resultMethod.getBody().get();addStatement;[new ReturnStmt(returnExpression)]</InnerMethodInvoke>
                <InnerMethodInvoke>getResultTypeMethod.getBody().get();addStatement;[new ReturnStmt(new ClassExpr(returnExpressionType))]</InnerMethodInvoke>
                <InnerMethodInvoke>this.packageModel;addGeneratedPOJO;[templateClass]</InnerMethodInvoke>
                <InnerMethodInvoke>functionDSL;addArgument;[new ClassExpr(JavaParser.parseType(targetClassName))]</InnerMethodInvoke>
                <InnerMethodInvoke>functionDSL;addArgument;[new NameExpr(toVar(inputDescr.getIdentifier()))]</InnerMethodInvoke>
                <InnerMethodInvoke>asDSL;addArgument;[new NameExpr(toVar(bindingId))]</InnerMethodInvoke>
                <InnerMethodInvoke>accumulateDSL;addArgument;[asDSL]</InnerMethodInvoke>
                <InnerMethodInvoke>context;popExprPointer;[]</InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>writeAccumulateMethod</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>contextFieldNames</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>singleAccumulateType</ParamName>
                    <ParamType>Type</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>accumulateMethod</ParamName>
                    <ParamType>MethodDeclaration</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>actionBlock</ParamName>
                    <ParamType>BlockStmt</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>collectNamesInBlock</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>String</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>context2</ParamName>
                    <ParamType>RuleContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>block</ParamName>
                    <ParamType>BlockStmt</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>buildBinding</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>MethodCallExpr</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>bindingName</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>usedDeclaration</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>expression</ParamName>
                    <ParamType>Expression</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>processNewBinding</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>optNewBinding</ParamName>
                    <ParamType>NewBinding</ParamType>
                </Parameter>
            </ParameterList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>postVisit</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>void</ReturnType>
            <ParameterList/>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>NewBinding</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>patternBinding</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>bindExpression</ParamName>
                    <ParamType>MethodCallExpr</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>