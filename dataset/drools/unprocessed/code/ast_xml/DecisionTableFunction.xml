<Class>
    <Id>1811</Id>
    <Package>org.kie.dmn.feel.runtime.functions</Package>
    <ClassName>DecisionTableFunction</ClassName>
    <SuperClass>BaseFEELFunction</SuperClass>
    <SuperInterfaceList>
        <SuperInterface></SuperInterface>
    </SuperInterfaceList>
    <ClassComment></ClassComment>
    <FieldList>
        <Field>
            <FieldName>LOG</FieldName>
            <FieldType>Logger</FieldType>
        </Field>
    </FieldList>
    <MethodList>
        <Method>
            <MethodName>DecisionTableFunction</MethodName>
            <MethodComment></MethodComment>
            <ReturnType></ReturnType>
            <ParameterList/>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>invoke</MethodName>
            <MethodComment>/** 
 * @param inputExpressionList a list of the N&gt;=0 input expressions in display order
 * @param inputValuesList * a list of N input values, corresponding to the input expressions. Eachlist element is a unary tests literal (see below).
 * @param outputs * a name (a string matching grammar rule 27) or a list of M&gt;0 names
 * @param outputValues * if outputs is a list, then output values is a list of lists of values, one listper output; else output values is a list of values for the one output. Each value is a string.
 * @param ruleList a list of R&gt;0 rules. A rule is a list of N input entries followed by Moutput entries. An input entry is a unary tests literal. An output entry is an expression represented as a string.
 * @param hitPolicy * one of: "U", "A", “P”, “F”, "R", "O", "C", "C+", "C#", "C&lt;", “C&gt;”(default is "U")
 * @param defaultOutputValue * if outputs is a list, then default output value is a context with entriescomposed of outputs and output values; else default output value is one of the output values.
 */
</MethodComment>
            <ReturnType>Object</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>EvaluationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outputs</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputExpressionList</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputValuesList</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>outputValues</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>ruleList</ParamName>
                    <ParamType>List</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>hitPolicy</ParamName>
                    <ParamType>String</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>defaultOutputValue</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;String&gt; [inputExpressions=inputExpressionList instanceof List ? (List)inputExpressionList : Collections.singletonList((String)inputExpressionList)]</InnerVar>
                <InnerVar>List&lt;DTInputClause&gt; [inputs]</InnerVar>
                <InnerVar>List&lt;String&gt; [parseOutputs=outputs instanceof List ? (List)outputs : Collections.singletonList((String)outputs)]</InnerVar>
                <InnerVar>List&lt;DTOutputClause&gt; [outputClauses]</InnerVar>
                <InnerVar>FEEL [feel=FEEL.newInstance()]</InnerVar>
                <InnerVar>List&lt;DTDecisionRule&gt; [decisionRules=IntStream.range(0,ruleList.size()).mapToObj(index -&gt; toDecisionRule(ctx,feel,index,ruleList.get(index),inputExpressions.size())).collect(Collectors.toList())]</InnerVar>
                <InnerVar>DecisionTableImpl [dti=new DecisionTableImpl(UUID.randomUUID().toString(),inputExpressions,inputs,outputClauses,decisionRules,HitPolicy.fromString(hitPolicy),FEEL.newInstance())]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>objectToUnaryTestList</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>List&lt;UnaryTest&gt;</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>EvaluationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>values</ParamName>
                    <ParamType>List&lt;Object&gt;</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>List&lt;List&lt;UnaryTest&gt;&gt; [tests=new ArrayList&lt;&gt;()]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toDecisionRule</MethodName>
            <MethodComment>/** 
 * Convert row to DTDecisionRule
 * @param mainCtx the main context is used to identify the hosted FEELEventManager
 * @param embeddedFEEL a possibly cached embedded FEEL to compile the output expression, error will be reported up to the mainCtx
 * @param index
 * @param rule
 * @param inputSize
 * @return
 */
</MethodComment>
            <ReturnType>DTDecisionRule</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>mainCtx</ParamName>
                    <ParamType>EvaluationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>embeddedFEEL</ParamName>
                    <ParamType>FEEL</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>index</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>rule</ParamName>
                    <ParamType>?</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>inputSize</ParamName>
                    <ParamType>int</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar>DTDecisionRule [dr=new DTDecisionRule(index)]</InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
        <Method>
            <MethodName>toUnaryTest</MethodName>
            <MethodComment></MethodComment>
            <ReturnType>UnaryTest</ReturnType>
            <ParameterList>
                <Parameter>
                    <ParamName>ctx</ParamName>
                    <ParamType>EvaluationContext</ParamType>
                </Parameter>
                <Parameter>
                    <ParamName>o</ParamName>
                    <ParamType>Object</ParamType>
                </Parameter>
            </ParameterList>
            <InnerVarList>
                <InnerVar></InnerVar>
            </InnerVarList>
            <InnerMethodInvokeList>
                <InnerMethodInvoke></InnerMethodInvoke>
            </InnerMethodInvokeList>
            <ThrowExceptionList>
                <ExceptionType></ExceptionType>
            </ThrowExceptionList>
        </Method>
    </MethodList>
</Class>